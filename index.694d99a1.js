function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire2d39"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire2d39"] = parcelRequire;
}
parcelRequire.register("82BEU", function(module, exports) {

$parcel$export(module.exports, "register", function () { return $5dabb8ddcfc20e78$export$6503ec6e8aabbaf; }, function (v) { return $5dabb8ddcfc20e78$export$6503ec6e8aabbaf = v; });
$parcel$export(module.exports, "resolve", function () { return $5dabb8ddcfc20e78$export$f7ad0328861e2f03; }, function (v) { return $5dabb8ddcfc20e78$export$f7ad0328861e2f03 = v; });
var $5dabb8ddcfc20e78$export$6503ec6e8aabbaf;
var $5dabb8ddcfc20e78$export$f7ad0328861e2f03;
"use strict";
var $5dabb8ddcfc20e78$var$mapping = {};
function $5dabb8ddcfc20e78$var$register(pairs) {
    var keys = Object.keys(pairs);
    for(var i = 0; i < keys.length; i++)$5dabb8ddcfc20e78$var$mapping[keys[i]] = pairs[keys[i]];
}
function $5dabb8ddcfc20e78$var$resolve(id) {
    var resolved = $5dabb8ddcfc20e78$var$mapping[id];
    if (resolved == null) throw new Error('Could not resolve bundle with id ' + id);
    return resolved;
}
$5dabb8ddcfc20e78$export$6503ec6e8aabbaf = $5dabb8ddcfc20e78$var$register;
$5dabb8ddcfc20e78$export$f7ad0328861e2f03 = $5dabb8ddcfc20e78$var$resolve;

});

parcelRequire.register("ltudh", function(module, exports) {
"use strict";

});

parcelRequire.register("7LzWx", function(module, exports) {
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
(function(global, module, define) {
    function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
            var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
        };
        // Apply the seeding algorithm from Baagoe.
        me.c = 1;
        me.s0 = mash(' ');
        me.s1 = mash(' ');
        me.s2 = mash(' ');
        me.s0 -= mash(seed);
        if (me.s0 < 0) me.s0 += 1;
        me.s1 -= mash(seed);
        if (me.s1 < 0) me.s1 += 1;
        me.s2 -= mash(seed);
        if (me.s2 < 0) me.s2 += 1;
        mash = null;
    }
    function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
    }
    function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
            return xg.next() * 0x100000000 | 0;
        };
        prng.double = function() {
            return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
        };
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    function Mash() {
        var n = 0xefc8249d;
        var mash = function(data) {
            data = data.toString();
            for(var i = 0; i < data.length; i++){
                n += data.charCodeAt(i);
                var h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        return mash;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.alea = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("2QjKb", function(module, exports) {
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module, define) {
    function XorGen(seed) {
        var me = this, strseed = '';
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) // Integer seed.
        me.x = seed;
        else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.xor128 = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("iLjOb", function(module, exports) {
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper
(function(global, module, define) {
    function XorGen(seed) {
        var me = this, strseed = '';
        // Set up generator function.
        me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) // Integer seed.
        me.x = seed;
        else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 64; k++){
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) me.d = me.x << 10 ^ me.x >>> 4;
            me.next();
        }
    }
    function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.xorwow = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("fIzdX", function(module, exports) {
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf
(function(global, module, define) {
    function XorGen(seed1) {
        var me1 = this;
        // Set up generator function.
        me1.next = function() {
            // Update xor generator.
            var X = me1.x, i = me1.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me1.i = i + 1 & 7;
            return v;
        };
        function init(me, seed) {
            var j, w, X = [];
            if (seed === (seed | 0)) // Seed state array using a 32-bit integer.
            w = X[0] = seed;
            else {
                // Seed state using a string.
                seed = '' + seed;
                for(j = 0; j < seed.length; ++j)X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
            // Enforce an array length of 8, not all zeroes.
            while(X.length < 8)X.push(0);
            for(j = 0; j < 8 && X[j] === 0; ++j);
            if (j == 8) w = X[7] = -1;
            else w = X[j];
            me.x = X;
            me.i = 0;
            // Discard an initial 256 values.
            for(j = 256; j > 0; --j)me.next();
        }
        init(me1, seed1);
    }
    function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
    }
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.x) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.xorshift7 = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("cMOEe", function(module, exports) {
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().
(function(global, module, define) {
    function XorGen(seed1) {
        var me1 = this;
        // Set up generator function.
        me1.next = function() {
            var w = me1.w, X = me1.X, i = me1.i, t, v;
            // Update Weyl generator.
            me1.w = w = w + 0x61c88647 | 0;
            // Update xor generator.
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            // Update Xor generator array state.
            v = X[i] = v ^ t;
            me1.i = i;
            // Result is the combination.
            return v + (w ^ w >>> 16) | 0;
        };
        function init(me, seed) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed === (seed | 0)) {
                // Numeric seeds initialize v, which is used to generates X.
                v = seed;
                seed = null;
            } else {
                // String seeds are mixed into v and X one character at a time.
                seed = seed + '\0';
                v = 0;
                limit = Math.max(limit, seed.length);
            }
            // Initialize circular array and weyl value.
            for(i = 0, j = -32; j < limit; ++j){
                // Put the unicode characters into the array, and shuffle them.
                if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
                // After 32 shuffles, take v as the starting w value.
                if (j === 0) w = v;
                v ^= v << 10;
                v ^= v >>> 15;
                v ^= v << 4;
                v ^= v >>> 13;
                if (j >= 0) {
                    w = w + 0x61c88647 | 0; // Weyl.
                    t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.
                    i = 0 == t ? i + 1 : 0; // Count zeroes.
                }
            }
            // We have detected all zeroes; make the key nonzero.
            if (i >= 128) X[(seed && seed.length || 0) & 127] = -1;
            // Run the generator 512 times to further mix the state before using it.
            // Factoring this as a function slows the main generator, so it is just
            // unrolled here.  The weyl generator is not advanced while warming up.
            i = 127;
            for(j = 512; j > 0; --j){
                v = X[i + 34 & 127];
                t = X[i = i + 1 & 127];
                v ^= v << 13;
                t ^= t << 17;
                v ^= v >>> 15;
                t ^= t >>> 12;
                X[i] = v ^ t;
            }
            // Storing state as object members is faster than using closure variables.
            me.w = w;
            me.X = X;
            me.i = i;
        }
        init(me1, seed1);
    }
    function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
    }
    function impl(seed, opts) {
        if (seed == null) seed = +new Date;
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (state.X) copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.xor4096 = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("9knOD", function(module, exports) {
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
(function(global, module, define) {
    function XorGen(seed) {
        var me = this, strseed = '';
        // Set up generator function.
        me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
        };
        /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */ me.a = 0;
        me.b = 0;
        me.c = -1640531527;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
            // Integer seed.
            me.a = seed / 0x100000000 | 0;
            me.b = seed | 0;
        } else // String seed.
        strseed += seed;
        // Mix in string seed, then discard an initial batch of 64 values.
        for(var k = 0; k < strseed.length + 20; k++){
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
        }
    }
    function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
    }
    function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 0x100000000;
        };
        prng.double = function() {
            do var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / 2097152;
            while (result === 0)
            return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
            if (typeof state == 'object') copy(state, xg);
            prng.state = function() {
                return copy(xg, {});
            };
        }
        return prng;
    }
    if (module && module.exports) module.exports = impl;
    else if (define && define.amd) define(function() {
        return impl;
    });
    else this.tychei = impl;
})(this, module, typeof define == 'function' && define // present with an AMD loader
);

});

parcelRequire.register("245vJ", function(module, exports) {

var $3tEm6 = parcelRequire("3tEm6");

/*!
* ONNX Runtime Web v1.11.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/ !function(e, t) {
    var n, r;
    module.exports = t((parcelRequire("kUnTQ")));
}(self, function(__WEBPACK_EXTERNAL_MODULE__2174__) {
    return (()=>{
        var __webpack_modules__ = {
            3474: (e1, t1, n1)=>{
                var _scriptDir, r1 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(e2) {
                    function t2() {
                        return k.buffer != R && Y(k.buffer), L;
                    }
                    function r2() {
                        return k.buffer != R && Y(k.buffer), M;
                    }
                    function i1() {
                        return k.buffer != R && Y(k.buffer), j;
                    }
                    function o1() {
                        return k.buffer != R && Y(k.buffer), U;
                    }
                    var s1;
                    e2 = e2 || {}, s1 || (s1 = void 0 !== e2 ? e2 : {});
                    var a1, u1, l1 = Object.assign;
                    s1.ready = new Promise(function(e, t) {
                        a1 = e, u1 = t;
                    });
                    var c1, p1, d1, f1, h1, g, m = l1({}, s1), b = "./this.program", y = (e, t)=>{
                        throw t;
                    }, _ = "object" == typeof window, v = "function" == typeof importScripts, w = "object" == typeof $3tEm6 && "object" == typeof $3tEm6.versions && "string" == typeof $3tEm6.versions.node, x = s1.ENVIRONMENT_IS_PTHREAD || !1, T = "";
                    function O(e) {
                        return s1.locateFile ? s1.locateFile(e, T) : T + e;
                    }
                    if (w) {
                        let t3;
                        T = v ? n1(908).dirname(T) + "/" : "//", g = ()=>{
                            h1 || (f1 = n1(1384), h1 = n1(908));
                        }, c1 = function(e, t) {
                            return g(), e = h1.normalize(e), f1.readFileSync(e, t ? null : "utf8");
                        }, d1 = (e)=>((e = c1(e, !0)).buffer || (e = new Uint8Array(e)), e)
                        , p1 = (e3, t, n)=>{
                            g(), e3 = h1.normalize(e3), f1.readFile(e3, function(e, r) {
                                e ? n(e) : t(r.buffer);
                            });
                        }, 1 < $3tEm6.argv.length && (b = $3tEm6.argv[1].replace(/\\/g, "/")), $3tEm6.argv.slice(2), $3tEm6.on("uncaughtException", function(e) {
                            if (!(e instanceof Pt)) throw e;
                        }), $3tEm6.on("unhandledRejection", function(e) {
                            throw e;
                        }), y = (e, t)=>{
                            if (te()) throw $3tEm6.exitCode = e, t;
                            t instanceof Pt || P("exiting due to exception: " + t), $3tEm6.exit(e);
                        }, s1.inspect = function() {
                            return "[Emscripten Module object]";
                        };
                        try {
                            t3 = n1(9925);
                        } catch (e) {
                            throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e;
                        }
                        n1.g.Worker = t3.Worker;
                    } else (_ || v) && (v ? T = self.location.href : "undefined" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf("blob:") ? T.substr(0, T.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w || (c1 = (e)=>{
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.send(null), t.responseText;
                    }, v && (d1 = (e)=>{
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
                    }), p1 = (e, t, n)=>{
                        var r = new XMLHttpRequest;
                        r.open("GET", e, !0), r.responseType = "arraybuffer", r.onload = ()=>{
                            200 == r.status || 0 == r.status && r.response ? t(r.response) : n();
                        }, r.onerror = n, r.send(null);
                    }));
                    w && "undefined" == typeof performance && (n1.g.performance = n1(6953).performance);
                    var S = console.log.bind(console), A = console.warn.bind(console);
                    w && (g(), S = (e)=>f1.writeSync(1, e + "\n")
                    , A = (e)=>f1.writeSync(2, e + "\n")
                    );
                    var E, I, D = s1.print || S, P = s1.printErr || A;
                    l1(s1, m), m = null, s1.thisProgram && (b = s1.thisProgram), s1.quit && (y = s1.quit), s1.wasmBinary && (I = s1.wasmBinary);
                    var $ = s1.noExitRuntime || !1;
                    "object" != typeof WebAssembly && ae("no native wasm support detected");
                    var k, N, F = !1;
                    function C(e4) {
                        var t = new TextDecoder(e4);
                        this.decode = (e)=>(e.buffer instanceof SharedArrayBuffer && (e = new Uint8Array(e)), t.decode.call(t, e))
                        ;
                    }
                    var R, L, M, j, U, V = "undefined" != typeof TextDecoder ? new C("utf8") : void 0;
                    function B(e, t, n) {
                        var r = t + n;
                        for(n = t; e[n] && !(n >= r);)++n;
                        if (16 < n - t && e.subarray && V) return V.decode(e.subarray(t, n));
                        for(r = ""; t < n;){
                            var i = e[t++];
                            if (128 & i) {
                                var o = 63 & e[t++];
                                if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);
                                else {
                                    var s = 63 & e[t++];
                                    65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | s : (7 & i) << 18 | o << 12 | s << 6 | 63 & e[t++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));
                                }
                            } else r += String.fromCharCode(i);
                        }
                        return r;
                    }
                    function G(e, t) {
                        return e ? B(r2(), e, t) : "";
                    }
                    function z(e, t, n, r) {
                        if (!(0 < r)) return 0;
                        var i = n;
                        r = n + r - 1;
                        for(var o = 0; o < e.length; ++o){
                            var s = e.charCodeAt(o);
                            if (55296 <= s && 57343 >= s && (s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++o)), 127 >= s) {
                                if (n >= r) break;
                                t[n++] = s;
                            } else {
                                if (2047 >= s) {
                                    if (n + 1 >= r) break;
                                    t[n++] = 192 | s >> 6;
                                } else {
                                    if (65535 >= s) {
                                        if (n + 2 >= r) break;
                                        t[n++] = 224 | s >> 12;
                                    } else {
                                        if (n + 3 >= r) break;
                                        t[n++] = 240 | s >> 18, t[n++] = 128 | s >> 12 & 63;
                                    }
                                    t[n++] = 128 | s >> 6 & 63;
                                }
                                t[n++] = 128 | 63 & s;
                            }
                        }
                        return t[n] = 0, n - i;
                    }
                    function H(e, t, n) {
                        return z(e, r2(), t, n);
                    }
                    function W(e) {
                        for(var t = 0, n = 0; n < e.length; ++n){
                            var r = e.charCodeAt(n);
                            55296 <= r && 57343 >= r && (r = 65536 + ((1023 & r) << 10) | 1023 & e.charCodeAt(++n)), 127 >= r ? ++t : t = 2047 >= r ? t + 2 : 65535 >= r ? t + 3 : t + 4;
                        }
                        return t;
                    }
                    function q(e) {
                        var n = W(e) + 1, r = ft(n);
                        return r && z(e, t2(), r, n), r;
                    }
                    function Y(e) {
                        R = e, s1.HEAP8 = L = new Int8Array(e), s1.HEAP16 = new Int16Array(e), s1.HEAP32 = j = new Int32Array(e), s1.HEAPU8 = M = new Uint8Array(e), s1.HEAPU16 = new Uint16Array(e), s1.HEAPU32 = new Uint32Array(e), s1.HEAPF32 = new Float32Array(e), s1.HEAPF64 = U = new Float64Array(e);
                    }
                    "undefined" != typeof TextDecoder && new C("utf-16le"), x && (R = s1.buffer);
                    var X = s1.INITIAL_MEMORY || 16777216;
                    if (x) k = s1.wasmMemory, R = s1.buffer;
                    else if (s1.wasmMemory) k = s1.wasmMemory;
                    else if (!((k = new WebAssembly.Memory({
                        initial: X / 65536,
                        maximum: 32768,
                        shared: !0
                    })).buffer instanceof SharedArrayBuffer)) throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
                    k && (R = k.buffer), X = R.byteLength, Y(R);
                    var K, Z = [], J = [], Q = [], ee = [];
                    function te() {
                        return $ || !1;
                    }
                    function ne() {
                        var e = s1.preRun.shift();
                        Z.unshift(e);
                    }
                    var re, ie = 0, oe = null, se = null;
                    function ae(e) {
                        throw x ? postMessage({
                            cmd: "onAbort",
                            arg: e
                        }) : s1.onAbort && s1.onAbort(e), P(e = "Aborted(" + e + ")"), F = !0, e = new WebAssembly.RuntimeError(e + ". Build with -s ASSERTIONS=1 for more info."), u1(e), e;
                    }
                    function ue() {
                        return re.startsWith("data:application/octet-stream;base64,");
                    }
                    function le() {
                        var e = re;
                        try {
                            if (e == re && I) return new Uint8Array(I);
                            if (d1) return d1(e);
                            throw "both async and sync fetching of the wasm failed";
                        } catch (e5) {
                            ae(e5);
                        }
                    }
                    s1.preloadedImages = {}, s1.preloadedAudios = {}, re = "ort-wasm-threaded.wasm", ue() || (re = O(re));
                    var ce = {};
                    function pe(e) {
                        for(; 0 < e.length;){
                            var t = e.shift();
                            if ("function" == typeof t) t(s1);
                            else {
                                var n = t.Tb;
                                "number" == typeof n ? void 0 === t.Sa ? ye(n)() : ye(n)(t.Sa) : n(void 0 === t.Sa ? null : t.Sa);
                            }
                        }
                    }
                    function de(e) {
                        var t = St();
                        return e = e(), At(t), e;
                    }
                    function fe(e) {
                        var t = he.Oa[e];
                        t && (i1()[e >> 2] = 0, he.jb(t.worker));
                    }
                    var he = {
                        Pa: [],
                        Va: [],
                        fb: [],
                        Wb: function() {},
                        ub: function() {
                            he.receiveObjectTransfer = he.zb, he.threadInit = he.lb, he.setExitStatus = he.Bb;
                        },
                        Oa: {},
                        Bb: function() {},
                        kb: function() {
                            for(var e in he.Oa){
                                var t = he.Oa[e];
                                t && t.worker && he.jb(t.worker);
                            }
                            for(e = 0; e < he.Pa.length; ++e)he.Pa[e].terminate();
                            he.Pa = [];
                        },
                        jb: function(e) {
                            he.Ab(function() {
                                delete he.Oa[e.Qa.eb], he.Pa.push(e), he.Va.splice(he.Va.indexOf(e), 1), wt(e.Qa.eb), e.Qa = void 0;
                            });
                        },
                        Ab: function(e) {
                            i1()[Dt >> 2] = 0;
                            try {
                                e();
                            } finally{
                                i1()[Dt >> 2] = 1;
                            }
                        },
                        zb: function() {},
                        lb: function() {
                            for(var e in he.fb)he.fb[e]();
                        },
                        wb: function(e6, t5) {
                            e6.onmessage = (n)=>{
                                var r = (n = n.data).cmd;
                                if (e6.Qa && (he.pb = e6.Qa.eb), n.targetThread && n.targetThread != dt()) {
                                    var o = he.Oa[n.bc];
                                    o ? o.worker.postMessage(n, n.transferList) : P('Internal error! Worker sent a message "' + r + '" to target pthread ' + n.targetThread + ", but that thread no longer exists!");
                                } else "processQueuedMainThreadWork" === r ? mt() : "spawnThread" === r ? ve(n) : "cleanupThread" === r ? fe(n.thread) : "killThread" === r ? (n = n.thread, i1()[n >> 2] = 0, r = he.Oa[n], delete he.Oa[n], r.worker.terminate(), wt(n), he.Va.splice(he.Va.indexOf(r.worker), 1), r.worker.Qa = void 0) : "cancelThread" === r ? he.Oa[n.thread].worker.postMessage({
                                    cmd: "cancel"
                                }) : "loaded" === r ? (e6.loaded = !0, t5 && t5(e6), e6.Ua && (e6.Ua(), delete e6.Ua)) : "print" === r ? D("Thread " + n.threadId + ": " + n.text) : "printErr" === r ? P("Thread " + n.threadId + ": " + n.text) : "alert" === r ? alert("Thread " + n.threadId + ": " + n.text) : "setimmediate" === n.target ? e6.postMessage(n) : "onAbort" === r ? s1.onAbort && s1.onAbort(n.arg) : P("worker sent an unknown command " + r);
                                he.pb = void 0;
                            }, e6.onerror = (e)=>{
                                throw P("worker sent an error! " + e.filename + ":" + e.lineno + ": " + e.message), e;
                            }, w && (e6.on("message", function(t) {
                                e6.onmessage({
                                    data: t
                                });
                            }), e6.on("error", function(t) {
                                e6.onerror(t);
                            }), e6.on("detachedExit", function() {})), e6.postMessage({
                                cmd: "load",
                                urlOrBlob: s1.mainScriptUrlOrBlob || _scriptDir,
                                wasmMemory: k,
                                wasmModule: N
                            });
                        },
                        mb: function() {
                            var e = O("ort-wasm-threaded.worker.js");
                            he.Pa.push(new Worker(e));
                        },
                        rb: function() {
                            return 0 == he.Pa.length && (he.mb(), he.wb(he.Pa[0])), he.Pa.pop();
                        }
                    };
                    function ge(e) {
                        if (x) return Ve(1, 0, e);
                        try {
                            kt(e);
                        } catch (e7) {
                            e7 instanceof Pt || "unwind" == e7 || y(1, e7);
                        }
                    }
                    s1.establishStackSpace = function() {
                        var e = dt(), t = i1()[e + 44 >> 2];
                        e = i1()[e + 48 >> 2], Ot(t, t - e), At(t);
                    };
                    var me, be = [];
                    function ye(e) {
                        var t = be[e];
                        return t || (e >= be.length && (be.length = e + 1), be[e] = t = K.get(e)), t;
                    }
                    function _e(e8) {
                        this.Ta = e8 - 16, this.Gb = function(e) {
                            i1()[this.Ta + 4 >> 2] = e;
                        }, this.Db = function(e) {
                            i1()[this.Ta + 8 >> 2] = e;
                        }, this.Eb = function() {
                            i1()[this.Ta >> 2] = 0;
                        }, this.Cb = function() {
                            t2()[this.Ta + 12 >> 0] = 0;
                        }, this.Fb = function() {
                            t2()[this.Ta + 13 >> 0] = 0;
                        }, this.sb = function(e, t) {
                            this.Gb(e), this.Db(t), this.Eb(), this.Cb(), this.Fb();
                        };
                    }
                    function ve(e) {
                        var t = he.rb();
                        if (!t) return 6;
                        he.Va.push(t);
                        var n = he.Oa[e.cb] = {
                            worker: t,
                            eb: e.cb
                        };
                        t.Qa = n;
                        var r = {
                            cmd: "run",
                            start_routine: e.Hb,
                            arg: e.Sa,
                            threadInfoStruct: e.cb
                        };
                        return t.Ua = ()=>{
                            r.time = performance.now(), t.postMessage(r, e.Mb);
                        }, t.loaded && (t.Ua(), delete t.Ua), 0;
                    }
                    s1.invokeEntryPoint = function(e, t) {
                        return ye(e)(t);
                    }, me = w ? ()=>{
                        var e = $3tEm6.hrtime();
                        return 1e3 * e[0] + e[1] / 1e6;
                    } : x ? ()=>performance.now() - s1.__performance_now_clock_drift
                     : ()=>performance.now()
                    ;
                    var we = {}, xe = [
                        null,
                        [],
                        []
                    ];
                    function Te(e, t) {
                        var n = xe[e];
                        0 === t || 10 === t ? ((1 === e ? D : P)(B(n, 0)), n.length = 0) : n.push(t);
                    }
                    var Oe = {};
                    function Se(e, t, n) {
                        return x ? Ve(2, 1, e, t, n) : 0;
                    }
                    function Ae(e, t) {
                        if (x) return Ve(3, 1, e, t);
                    }
                    function Ee(e, t, n, r) {
                        if (x) return Ve(4, 1, e, t, n, r);
                    }
                    function Ie(e, t) {
                        if (x) return Ve(5, 1, e, t);
                    }
                    function De(e, t, n) {
                        if (x) return Ve(6, 1, e, t, n);
                    }
                    function Pe(e, t, n) {
                        return x ? Ve(7, 1, e, t, n) : 0;
                    }
                    function $e(e, t) {
                        if (x) return Ve(8, 1, e, t);
                    }
                    function ke(e, t) {
                        return x ? Ve(9, 1, e, t) : (e = G(e), Oe.Qb(e, t));
                    }
                    function Ne(e, t, n, i, o, s) {
                        if (x) t = Ve(10, 1, e, t, n, i, o, s);
                        else if (s <<= 12, 0 != (16 & i) && 0 != e % 65536) t = -28;
                        else if (0 != (32 & i)) {
                            var a = 65536 * Math.ceil(t / 65536);
                            (e = Tt(65536, a)) ? r2().fill(0, e, e + a) : e = 0, e ? (we[e] = {
                                yb: e,
                                vb: t,
                                nb: !0,
                                fd: o,
                                Zb: n,
                                flags: i,
                                offset: s
                            }, t = e) : t = -48;
                        } else t = -52;
                        return t;
                    }
                    function Fe(e, t) {
                        if (x) e = Ve(11, 1, e, t);
                        else {
                            var n = we[e];
                            0 !== t && n ? (t === n.vb && (we[e] = null, n.nb && ht(n.yb)), e = 0) : e = -28;
                        }
                        return e;
                    }
                    function Ce(e, t, n) {
                        if (x) return Ve(12, 1, e, t, n);
                    }
                    function Re(e, t, n) {
                        return x ? Ve(13, 1, e, t, n) : (e = G(e), Oe.Rb(e, t, n));
                    }
                    function Le(e) {
                        if (x) return Ve(14, 1, e);
                    }
                    function Me(e, t) {
                        if (x) return Ve(15, 1, e, t);
                    }
                    function je(e) {
                        if (x) return Ve(16, 1, e);
                    }
                    function Ue(e9, t, n) {
                        function r(e) {
                            return (e = e.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e[1] : "GMT";
                        }
                        if (x) return Ve(17, 1, e9, t, n);
                        var o = (new Date).getFullYear(), s = new Date(o, 0, 1), a = new Date(o, 6, 1);
                        o = s.getTimezoneOffset();
                        var u = a.getTimezoneOffset(), l = Math.max(o, u);
                        i1()[e9 >> 2] = 60 * l, i1()[t >> 2] = Number(o != u), e9 = r(s), t = r(a), e9 = q(e9), t = q(t), u < o ? (i1()[n >> 2] = e9, i1()[n + 4 >> 2] = t) : (i1()[n >> 2] = t, i1()[n + 4 >> 2] = e9);
                    }
                    function Ve(e, t) {
                        var n = arguments.length - 2, r = arguments;
                        return de(function() {
                            for(var i = Et(8 * n), s = i >> 3, a = 0; a < n; a++){
                                var u = r[2 + a];
                                o1()[s + a] = u;
                            }
                            return _t(e, n, i, t);
                        });
                    }
                    var Be = [], Ge = [
                        0,
                        "undefined" != typeof document ? document : 0,
                        "undefined" != typeof window ? window : 0
                    ];
                    function ze(e) {
                        return e = 2 < e ? G(e) : e, Ge[e] || ("undefined" != typeof document ? document.querySelector(e) : void 0);
                    }
                    function He(e10, t6, n2) {
                        var r3 = ze(e10);
                        return r3 ? (r3.Za && (i1()[r3.Za >> 2] = t6, i1()[r3.Za + 4 >> 2] = n2), !r3.ib && r3.Ob ? r3.Za ? (function(e, t, n, r) {
                            de(function() {
                                var o = Et(12), s = 0;
                                if (t) {
                                    s = W(t) + 1;
                                    var a = ft(s);
                                    H(t, a, s), s = a;
                                }
                                i1()[o >> 2] = s, i1()[o + 4 >> 2] = n, i1()[o + 8 >> 2] = r, vt(e, 657457152, 0, s, o);
                            });
                        }(r3 = i1()[r3.Za + 8 >> 2], e10 = e10 ? G(e10) : "", t6, n2), 1) : -4 : (r3.ib && (r3 = r3.ib), e10 = !1, r3.Ya && r3.Ya.Xa && (e10 = 0 === (e10 = r3.Ya.Xa.getParameter(2978))[0] && 0 === e10[1] && e10[2] === r3.width && e10[3] === r3.height), r3.width = t6, r3.height = n2, e10 && r3.Ya.Xa.viewport(0, 0, t6, n2), 0)) : -4;
                    }
                    function We(e, t, n) {
                        return x ? Ve(18, 1, e, t, n) : He(e, t, n);
                    }
                    var qe, Ye = [
                        "default",
                        "low-power",
                        "high-performance"
                    ], Xe = {};
                    function Ke() {
                        if (!qe) {
                            var e, t = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                                _: b || "./this.program"
                            };
                            for(e in Xe)void 0 === Xe[e] ? delete t[e] : t[e] = Xe[e];
                            var n = [];
                            for(e in t)n.push(e + "=" + t[e]);
                            qe = n;
                        }
                        return qe;
                    }
                    function Ze(e, n) {
                        if (x) return Ve(19, 1, e, n);
                        var r = 0;
                        return Ke().forEach(function(o, s) {
                            var a = n + r;
                            for(s = i1()[e + 4 * s >> 2] = a, a = 0; a < o.length; ++a)t2()[(s++) >> 0] = o.charCodeAt(a);
                            t2()[s >> 0] = 0, r += o.length + 1;
                        }), 0;
                    }
                    function Je(e11, t) {
                        if (x) return Ve(20, 1, e11, t);
                        var n = Ke();
                        i1()[e11 >> 2] = n.length;
                        var r = 0;
                        return n.forEach(function(e) {
                            r += e.length + 1;
                        }), i1()[t >> 2] = r, 0;
                    }
                    function Qe(e) {
                        return x ? Ve(21, 1, e) : 0;
                    }
                    function et(e, t, n, r) {
                        return x ? Ve(22, 1, e, t, n, r) : (e = Oe.Ub(e), t = Oe.Sb(e, t, n), i1()[r >> 2] = t, 0);
                    }
                    function tt(e, t, n, r, i) {
                        if (x) return Ve(23, 1, e, t, n, r, i);
                    }
                    function nt(e, t, n, o) {
                        if (x) return Ve(24, 1, e, t, n, o);
                        for(var s = 0, a = 0; a < n; a++){
                            var u = i1()[t >> 2], l = i1()[t + 4 >> 2];
                            t += 8;
                            for(var c = 0; c < l; c++)Te(e, r2()[u + c]);
                            s += l;
                        }
                        return i1()[o >> 2] = s, 0;
                    }
                    function rt(e) {
                        return 0 == e % 4 && (0 != e % 100 || 0 == e % 400);
                    }
                    function it(e, t) {
                        for(var n = 0, r = 0; r <= t; n += e[r++]);
                        return n;
                    }
                    var ot = [
                        31,
                        29,
                        31,
                        30,
                        31,
                        30,
                        31,
                        31,
                        30,
                        31,
                        30,
                        31
                    ], st = [
                        31,
                        28,
                        31,
                        30,
                        31,
                        30,
                        31,
                        31,
                        30,
                        31,
                        30,
                        31
                    ];
                    function at(e, t) {
                        for(e = new Date(e.getTime()); 0 < t;){
                            var n = e.getMonth(), r = (rt(e.getFullYear()) ? ot : st)[n];
                            if (!(t > r - e.getDate())) {
                                e.setDate(e.getDate() + t);
                                break;
                            }
                            t -= r - e.getDate() + 1, e.setDate(1), 11 > n ? e.setMonth(n + 1) : (e.setMonth(0), e.setFullYear(e.getFullYear() + 1));
                        }
                        return e;
                    }
                    function ut(e12, n3, r4, o) {
                        function s(e, t, n) {
                            for(e = "number" == typeof e ? e.toString() : e || ""; e.length < t;)e = n[0] + e;
                            return e;
                        }
                        function a(e, t) {
                            return s(e, t, "0");
                        }
                        function u(e13, t) {
                            function n(e) {
                                return 0 > e ? -1 : 0 < e ? 1 : 0;
                            }
                            var r;
                            return 0 === (r = n(e13.getFullYear() - t.getFullYear())) && 0 === (r = n(e13.getMonth() - t.getMonth())) && (r = n(e13.getDate() - t.getDate())), r;
                        }
                        function l(e) {
                            switch(e.getDay()){
                                case 0:
                                    return new Date(e.getFullYear() - 1, 11, 29);
                                case 1:
                                    return e;
                                case 2:
                                    return new Date(e.getFullYear(), 0, 3);
                                case 3:
                                    return new Date(e.getFullYear(), 0, 2);
                                case 4:
                                    return new Date(e.getFullYear(), 0, 1);
                                case 5:
                                    return new Date(e.getFullYear() - 1, 11, 31);
                                case 6:
                                    return new Date(e.getFullYear() - 1, 11, 30);
                            }
                        }
                        function c(e) {
                            e = at(new Date(e.Na + 1900, 0, 1), e.bb);
                            var t = new Date(e.getFullYear() + 1, 0, 4), n = l(new Date(e.getFullYear(), 0, 4));
                            return t = l(t), 0 >= u(n, e) ? 0 >= u(t, e) ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1;
                        }
                        var p = i1()[o + 40 >> 2];
                        for(var d in o = {
                            Kb: i1()[o >> 2],
                            Jb: i1()[o + 4 >> 2],
                            $a: i1()[o + 8 >> 2],
                            Wa: i1()[o + 12 >> 2],
                            Ra: i1()[o + 16 >> 2],
                            Na: i1()[o + 20 >> 2],
                            ab: i1()[o + 24 >> 2],
                            bb: i1()[o + 28 >> 2],
                            cc: i1()[o + 32 >> 2],
                            Ib: i1()[o + 36 >> 2],
                            Lb: p ? G(p) : ""
                        }, r4 = G(r4), p = {
                            "%c": "%a %b %d %H:%M:%S %Y",
                            "%D": "%m/%d/%y",
                            "%F": "%Y-%m-%d",
                            "%h": "%b",
                            "%r": "%I:%M:%S %p",
                            "%R": "%H:%M",
                            "%T": "%H:%M:%S",
                            "%x": "%m/%d/%y",
                            "%X": "%H:%M:%S",
                            "%Ec": "%c",
                            "%EC": "%C",
                            "%Ex": "%m/%d/%y",
                            "%EX": "%H:%M:%S",
                            "%Ey": "%y",
                            "%EY": "%Y",
                            "%Od": "%d",
                            "%Oe": "%e",
                            "%OH": "%H",
                            "%OI": "%I",
                            "%Om": "%m",
                            "%OM": "%M",
                            "%OS": "%S",
                            "%Ou": "%u",
                            "%OU": "%U",
                            "%OV": "%V",
                            "%Ow": "%w",
                            "%OW": "%W",
                            "%Oy": "%y"
                        })r4 = r4.replace(new RegExp(d, "g"), p[d]);
                        var f = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h = "January February March April May June July August September October November December".split(" ");
                        for(d in p = {
                            "%a": function(e) {
                                return f[e.ab].substring(0, 3);
                            },
                            "%A": function(e) {
                                return f[e.ab];
                            },
                            "%b": function(e) {
                                return h[e.Ra].substring(0, 3);
                            },
                            "%B": function(e) {
                                return h[e.Ra];
                            },
                            "%C": function(e) {
                                return a((e.Na + 1900) / 100 | 0, 2);
                            },
                            "%d": function(e) {
                                return a(e.Wa, 2);
                            },
                            "%e": function(e) {
                                return s(e.Wa, 2, " ");
                            },
                            "%g": function(e) {
                                return c(e).toString().substring(2);
                            },
                            "%G": function(e) {
                                return c(e);
                            },
                            "%H": function(e) {
                                return a(e.$a, 2);
                            },
                            "%I": function(e) {
                                return 0 == (e = e.$a) ? e = 12 : 12 < e && (e -= 12), a(e, 2);
                            },
                            "%j": function(e) {
                                return a(e.Wa + it(rt(e.Na + 1900) ? ot : st, e.Ra - 1), 3);
                            },
                            "%m": function(e) {
                                return a(e.Ra + 1, 2);
                            },
                            "%M": function(e) {
                                return a(e.Jb, 2);
                            },
                            "%n": function() {
                                return "\n";
                            },
                            "%p": function(e) {
                                return 0 <= e.$a && 12 > e.$a ? "AM" : "PM";
                            },
                            "%S": function(e) {
                                return a(e.Kb, 2);
                            },
                            "%t": function() {
                                return "\t";
                            },
                            "%u": function(e) {
                                return e.ab || 7;
                            },
                            "%U": function(e) {
                                var t = new Date(e.Na + 1900, 0, 1), n = 0 === t.getDay() ? t : at(t, 7 - t.getDay());
                                return 0 > u(n, e = new Date(e.Na + 1900, e.Ra, e.Wa)) ? a(Math.ceil((31 - n.getDate() + (it(rt(e.getFullYear()) ? ot : st, e.getMonth() - 1) - 31) + e.getDate()) / 7), 2) : 0 === u(n, t) ? "01" : "00";
                            },
                            "%V": function(e) {
                                var t = new Date(e.Na + 1901, 0, 4), n = l(new Date(e.Na + 1900, 0, 4));
                                t = l(t);
                                var r = at(new Date(e.Na + 1900, 0, 1), e.bb);
                                return 0 > u(r, n) ? "53" : 0 >= u(t, r) ? "01" : a(Math.ceil((n.getFullYear() < e.Na + 1900 ? e.bb + 32 - n.getDate() : e.bb + 1 - n.getDate()) / 7), 2);
                            },
                            "%w": function(e) {
                                return e.ab;
                            },
                            "%W": function(e) {
                                var t = new Date(e.Na, 0, 1), n = 1 === t.getDay() ? t : at(t, 0 === t.getDay() ? 1 : 7 - t.getDay() + 1);
                                return 0 > u(n, e = new Date(e.Na + 1900, e.Ra, e.Wa)) ? a(Math.ceil((31 - n.getDate() + (it(rt(e.getFullYear()) ? ot : st, e.getMonth() - 1) - 31) + e.getDate()) / 7), 2) : 0 === u(n, t) ? "01" : "00";
                            },
                            "%y": function(e) {
                                return (e.Na + 1900).toString().substring(2);
                            },
                            "%Y": function(e) {
                                return e.Na + 1900;
                            },
                            "%z": function(e) {
                                var t = 0 <= (e = e.Ib);
                                return e = Math.abs(e) / 60, (t ? "+" : "-") + String("0000" + (e / 60 * 100 + e % 60)).slice(-4);
                            },
                            "%Z": function(e) {
                                return e.Lb;
                            },
                            "%%": function() {
                                return "%";
                            }
                        })r4.includes(d) && (r4 = r4.replace(new RegExp(d, "g"), p[d](o)));
                        return d = function(e) {
                            var t = Array(W(e) + 1);
                            return z(e, t, 0, t.length), t;
                        }(r4), d.length > n3 ? 0 : (function(e, n) {
                            t2().set(e, n);
                        }(d, e12), d.length - 1);
                    }
                    var lt = [
                        null,
                        ge,
                        Se,
                        Ae,
                        Ee,
                        Ie,
                        De,
                        Pe,
                        $e,
                        ke,
                        Ne,
                        Fe,
                        Ce,
                        Re,
                        Le,
                        Me,
                        je,
                        Ue,
                        We,
                        Ze,
                        Je,
                        Qe,
                        et,
                        tt,
                        nt
                    ], ct = {
                        b: function(e) {
                            return ft(e + 16) + 16;
                        },
                        c: function(e, t, n) {
                            throw new _e(e).sb(t, n), e;
                        },
                        M: function(e) {
                            bt(e, !v, 1, !_), he.lb();
                        },
                        n: function(e) {
                            x ? postMessage({
                                cmd: "cleanupThread",
                                thread: e
                            }) : fe(e);
                        },
                        p: function(e, t, n, r) {
                            if ("undefined" == typeof SharedArrayBuffer) return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
                            var i = [];
                            return x && 0 === i.length ? yt(687865856, e, t, n, r) : (e = {
                                Hb: n,
                                cb: e,
                                Sa: r,
                                Mb: i
                            }, x ? (e.Nb = "spawnThread", postMessage(e, i), 0) : ve(e));
                        },
                        i: Se,
                        U: Ae,
                        R: Ee,
                        y: Ie,
                        A: De,
                        t: Pe,
                        S: $e,
                        H: ke,
                        G: Ne,
                        F: Fe,
                        o: Ce,
                        z: Re,
                        w: Le,
                        T: Me,
                        x: je,
                        j: function() {
                            ae("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                        },
                        _: function() {
                            ae("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                        },
                        E: function() {
                            return 2097152;
                        },
                        Z: function(e, t, n) {
                            var r = performance.now();
                            for(n = r + n, Atomics.exchange(i1(), It >> 2, e);;){
                                if ((r = performance.now()) > n) return Atomics.exchange(i1(), It >> 2, 0), -73;
                                if (0 == (r = Atomics.exchange(i1(), It >> 2, 0))) break;
                                if (mt(), Atomics.load(i1(), e >> 2) != t) return -6;
                                Atomics.exchange(i1(), It >> 2, e);
                            }
                            return 0;
                        },
                        N: function(e, t) {
                            if (e == t) postMessage({
                                cmd: "processQueuedMainThreadWork"
                            });
                            else if (x) postMessage({
                                targetThread: e,
                                cmd: "processThreadQueue"
                            });
                            else {
                                if (!(e = (e = he.Oa[e]) && e.worker)) return;
                                e.postMessage({
                                    cmd: "processThreadQueue"
                                });
                            }
                            return 1;
                        },
                        V: function(e, t) {
                            e = new Date(1e3 * i1()[e >> 2]), i1()[t >> 2] = e.getUTCSeconds(), i1()[t + 4 >> 2] = e.getUTCMinutes(), i1()[t + 8 >> 2] = e.getUTCHours(), i1()[t + 12 >> 2] = e.getUTCDate(), i1()[t + 16 >> 2] = e.getUTCMonth(), i1()[t + 20 >> 2] = e.getUTCFullYear() - 1900, i1()[t + 24 >> 2] = e.getUTCDay(), e = (e.getTime() - Date.UTC(e.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i1()[t + 28 >> 2] = e;
                        },
                        W: function(e, t) {
                            e = new Date(1e3 * i1()[e >> 2]), i1()[t >> 2] = e.getSeconds(), i1()[t + 4 >> 2] = e.getMinutes(), i1()[t + 8 >> 2] = e.getHours(), i1()[t + 12 >> 2] = e.getDate(), i1()[t + 16 >> 2] = e.getMonth(), i1()[t + 20 >> 2] = e.getFullYear() - 1900, i1()[t + 24 >> 2] = e.getDay();
                            var n = new Date(e.getFullYear(), 0, 1), r = (e.getTime() - n.getTime()) / 864e5 | 0;
                            i1()[t + 28 >> 2] = r, i1()[t + 36 >> 2] = -60 * e.getTimezoneOffset(), r = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(), e = 0 | (r != (n = n.getTimezoneOffset()) && e.getTimezoneOffset() == Math.min(n, r)), i1()[t + 32 >> 2] = e;
                        },
                        X: function(e) {
                            var t = new Date(i1()[e + 20 >> 2] + 1900, i1()[e + 16 >> 2], i1()[e + 12 >> 2], i1()[e + 8 >> 2], i1()[e + 4 >> 2], i1()[e >> 2], 0), n = i1()[e + 32 >> 2], r = t.getTimezoneOffset(), o = new Date(t.getFullYear(), 0, 1), s = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(), a = o.getTimezoneOffset(), u = Math.min(a, s);
                            return 0 > n ? i1()[e + 32 >> 2] = Number(s != a && u == r) : 0 < n != (u == r) && (s = Math.max(a, s), t.setTime(t.getTime() + 6e4 * ((0 < n ? u : s) - r))), i1()[e + 24 >> 2] = t.getDay(), n = (t.getTime() - o.getTime()) / 864e5 | 0, i1()[e + 28 >> 2] = n, i1()[e >> 2] = t.getSeconds(), i1()[e + 4 >> 2] = t.getMinutes(), i1()[e + 8 >> 2] = t.getHours(), i1()[e + 12 >> 2] = t.getDate(), i1()[e + 16 >> 2] = t.getMonth(), t.getTime() / 1e3 | 0;
                        },
                        Y: function e(t, n, r) {
                            e.ob || (e.ob = !0, Ue(t, n, r));
                        },
                        d: function() {
                            ae("");
                        },
                        q: function(e, t) {
                            if (0 === e) e = Date.now();
                            else {
                                if (1 !== e && 4 !== e) return i1()[pt() >> 2] = 28, -1;
                                e = me();
                            }
                            return i1()[t >> 2] = e / 1e3 | 0, i1()[t + 4 >> 2] = e % 1e3 * 1e6 | 0, 0;
                        },
                        B: function(e, t) {
                            return e - t;
                        },
                        m: function() {
                            w || v || (E || (E = {}), E["Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread"] || (E["Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread"] = 1, P("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")));
                        },
                        v: function() {
                            return 2147483648;
                        },
                        f: me,
                        Q: function(e, t, n) {
                            r2().copyWithin(e, t, t + n);
                        },
                        g: function() {
                            return w ? n1(3993).cpus().length : navigator.hardwareConcurrency;
                        },
                        I: function(e, t, n) {
                            Be.length = t, n >>= 3;
                            for(var r = 0; r < t; r++)Be[r] = o1()[n + r];
                            return (0 > e ? ce[-e - 1] : lt[e]).apply(null, Be);
                        },
                        u: function(e) {
                            var t = r2().length;
                            if ((e >>>= 0) <= t || 2147483648 < e) return !1;
                            for(var n = 1; 4 >= n; n *= 2){
                                var i = t * (1 + .2 / n);
                                i = Math.min(i, e + 100663296), 0 < (i = Math.max(e, i)) % 65536 && (i += 65536 - i % 65536);
                                e: {
                                    try {
                                        k.grow(Math.min(2147483648, i) - R.byteLength + 65535 >>> 16), Y(k.buffer);
                                        var o = 1;
                                        break e;
                                    } catch (e) {}
                                    o = void 0;
                                }
                                if (o) return !0;
                            }
                            return !1;
                        },
                        K: function(e, t, n) {
                            return ze(e) ? He(e, t, n) : We(e, t, n);
                        },
                        C: function() {
                            throw "unwind";
                        },
                        L: function(e14, t7) {
                            t7 >>= 2;
                            var n4 = i1()[t7 + 6];
                            return t7 = {
                                alpha: !!i1()[t7],
                                depth: !!i1()[t7 + 1],
                                stencil: !!i1()[t7 + 2],
                                antialias: !!i1()[t7 + 3],
                                premultipliedAlpha: !!i1()[t7 + 4],
                                preserveDrawingBuffer: !!i1()[t7 + 5],
                                powerPreference: Ye[n4],
                                failIfMajorPerformanceCaveat: !!i1()[t7 + 7],
                                xb: i1()[t7 + 8],
                                Xb: i1()[t7 + 9],
                                gb: i1()[t7 + 10],
                                qb: i1()[t7 + 11],
                                $b: i1()[t7 + 12],
                                ac: i1()[t7 + 13]
                            }, !(e14 = ze(e14)) || t7.qb ? 0 : function(e15, t8) {
                                e15.hb || (e15.hb = e15.getContext, e15.getContext = function(t, n) {
                                    return "webgl" == t == (n = e15.hb(t, n)) instanceof WebGLRenderingContext ? n : null;
                                });
                                var n5 = e15.getContext("webgl", t8);
                                return n5 ? function(e16, t9) {
                                    var n6 = ft(8);
                                    i1()[n6 + 4 >> 2] = dt();
                                    var r5 = {
                                        Vb: n6,
                                        attributes: t9,
                                        version: t9.xb,
                                        Xa: e16
                                    };
                                    return e16.canvas && (e16.canvas.Ya = r5), (void 0 === t9.gb || t9.gb) && function(e17) {
                                        if (e17 || (e17 = void 0), !e17.tb) {
                                            e17.tb = !0;
                                            var t10 = e17.Xa;
                                            !function(e18) {
                                                var t = e18.getExtension("ANGLE_instanced_arrays");
                                                t && (e18.vertexAttribDivisor = function(e, n) {
                                                    t.vertexAttribDivisorANGLE(e, n);
                                                }, e18.drawArraysInstanced = function(e, n, r, i) {
                                                    t.drawArraysInstancedANGLE(e, n, r, i);
                                                }, e18.drawElementsInstanced = function(e, n, r, i, o) {
                                                    t.drawElementsInstancedANGLE(e, n, r, i, o);
                                                });
                                            }(t10), function(e19) {
                                                var t = e19.getExtension("OES_vertex_array_object");
                                                t && (e19.createVertexArray = function() {
                                                    return t.createVertexArrayOES();
                                                }, e19.deleteVertexArray = function(e) {
                                                    t.deleteVertexArrayOES(e);
                                                }, e19.bindVertexArray = function(e) {
                                                    t.bindVertexArrayOES(e);
                                                }, e19.isVertexArray = function(e) {
                                                    return t.isVertexArrayOES(e);
                                                });
                                            }(t10), function(e20) {
                                                var t = e20.getExtension("WEBGL_draw_buffers");
                                                t && (e20.drawBuffers = function(e, n) {
                                                    t.drawBuffersWEBGL(e, n);
                                                });
                                            }(t10), t10.Pb = t10.getExtension("EXT_disjoint_timer_query"), t10.Yb = t10.getExtension("WEBGL_multi_draw"), (t10.getSupportedExtensions() || []).forEach(function(e) {
                                                e.includes("lose_context") || e.includes("debug") || t10.getExtension(e);
                                            });
                                        }
                                    }(r5), n6;
                                }(n5, t8) : 0;
                            }(e14, t7);
                        },
                        O: Ze,
                        P: Je,
                        D: function(e) {
                            kt(e);
                        },
                        h: Qe,
                        l: et,
                        s: tt,
                        k: nt,
                        J: function(e) {
                            var t = Date.now();
                            return i1()[e >> 2] = t / 1e3 | 0, i1()[e + 4 >> 2] = t % 1e3 * 1e3 | 0, 0;
                        },
                        a: k || s1.wasmMemory,
                        r: ut,
                        e: function(e, t, n, r) {
                            return ut(e, t, n, r);
                        }
                    };
                    !function() {
                        function e21(e, t) {
                            s1.asm = e.exports, he.fb.push(s1.asm.xa), K = s1.asm.Ba, J.unshift(s1.asm.$), N = t, x || (ie--, s1.monitorRunDependencies && s1.monitorRunDependencies(ie), 0 == ie && (null !== oe && (clearInterval(oe), oe = null), se && (e = se, se = null, e())));
                        }
                        function t12(t) {
                            e21(t.instance, t.module);
                        }
                        function n(e22) {
                            return (function() {
                                if (!I && (_ || v)) {
                                    if ("function" == typeof fetch && !re.startsWith("file://")) return fetch(re, {
                                        credentials: "same-origin"
                                    }).then(function(e) {
                                        if (!e.ok) throw "failed to load wasm binary file at '" + re + "'";
                                        return e.arrayBuffer();
                                    }).catch(function() {
                                        return le();
                                    });
                                    if (p1) return new Promise(function(e, t13) {
                                        p1(re, function(t) {
                                            e(new Uint8Array(t));
                                        }, t13);
                                    });
                                }
                                return Promise.resolve().then(function() {
                                    return le();
                                });
                            })().then(function(e) {
                                return WebAssembly.instantiate(e, r);
                            }).then(function(e) {
                                return e;
                            }).then(e22, function(e) {
                                P("failed to asynchronously prepare wasm: " + e), ae(e);
                            });
                        }
                        var r = {
                            a: ct
                        };
                        if (x || (ie++, s1.monitorRunDependencies && s1.monitorRunDependencies(ie)), s1.instantiateWasm) try {
                            return s1.instantiateWasm(r, e21);
                        } catch (e23) {
                            return P("Module.instantiateWasm callback failed with error: " + e23), !1;
                        }
                        (I || "function" != typeof WebAssembly.instantiateStreaming || ue() || re.startsWith("file://") || "function" != typeof fetch ? n(t12) : fetch(re, {
                            credentials: "same-origin"
                        }).then(function(e24) {
                            return WebAssembly.instantiateStreaming(e24, r).then(t12, function(e) {
                                return P("wasm streaming compile failed: " + e), P("falling back to ArrayBuffer instantiation"), n(t12);
                            });
                        })).catch(u1);
                    }(), s1.___wasm_call_ctors = function() {
                        return (s1.___wasm_call_ctors = s1.asm.$).apply(null, arguments);
                    }, s1._OrtInit = function() {
                        return (s1._OrtInit = s1.asm.aa).apply(null, arguments);
                    }, s1._OrtCreateSessionOptions = function() {
                        return (s1._OrtCreateSessionOptions = s1.asm.ba).apply(null, arguments);
                    }, s1._OrtAddSessionConfigEntry = function() {
                        return (s1._OrtAddSessionConfigEntry = s1.asm.ca).apply(null, arguments);
                    }, s1._OrtReleaseSessionOptions = function() {
                        return (s1._OrtReleaseSessionOptions = s1.asm.da).apply(null, arguments);
                    }, s1._OrtCreateSession = function() {
                        return (s1._OrtCreateSession = s1.asm.ea).apply(null, arguments);
                    }, s1._OrtReleaseSession = function() {
                        return (s1._OrtReleaseSession = s1.asm.fa).apply(null, arguments);
                    }, s1._OrtGetInputCount = function() {
                        return (s1._OrtGetInputCount = s1.asm.ga).apply(null, arguments);
                    }, s1._OrtGetOutputCount = function() {
                        return (s1._OrtGetOutputCount = s1.asm.ha).apply(null, arguments);
                    }, s1._OrtGetInputName = function() {
                        return (s1._OrtGetInputName = s1.asm.ia).apply(null, arguments);
                    }, s1._OrtGetOutputName = function() {
                        return (s1._OrtGetOutputName = s1.asm.ja).apply(null, arguments);
                    }, s1._OrtFree = function() {
                        return (s1._OrtFree = s1.asm.ka).apply(null, arguments);
                    }, s1._OrtCreateTensor = function() {
                        return (s1._OrtCreateTensor = s1.asm.la).apply(null, arguments);
                    }, s1._OrtGetTensorData = function() {
                        return (s1._OrtGetTensorData = s1.asm.ma).apply(null, arguments);
                    }, s1._OrtReleaseTensor = function() {
                        return (s1._OrtReleaseTensor = s1.asm.na).apply(null, arguments);
                    }, s1._OrtCreateRunOptions = function() {
                        return (s1._OrtCreateRunOptions = s1.asm.oa).apply(null, arguments);
                    }, s1._OrtAddRunConfigEntry = function() {
                        return (s1._OrtAddRunConfigEntry = s1.asm.pa).apply(null, arguments);
                    }, s1._OrtReleaseRunOptions = function() {
                        return (s1._OrtReleaseRunOptions = s1.asm.qa).apply(null, arguments);
                    }, s1._OrtRun = function() {
                        return (s1._OrtRun = s1.asm.ra).apply(null, arguments);
                    }, s1._OrtEndProfiling = function() {
                        return (s1._OrtEndProfiling = s1.asm.sa).apply(null, arguments);
                    };
                    var pt = s1.___errno_location = function() {
                        return (pt = s1.___errno_location = s1.asm.ta).apply(null, arguments);
                    }, dt = s1._pthread_self = function() {
                        return (dt = s1._pthread_self = s1.asm.ua).apply(null, arguments);
                    }, ft = s1._malloc = function() {
                        return (ft = s1._malloc = s1.asm.va).apply(null, arguments);
                    }, ht = s1._free = function() {
                        return (ht = s1._free = s1.asm.wa).apply(null, arguments);
                    };
                    s1._emscripten_tls_init = function() {
                        return (s1._emscripten_tls_init = s1.asm.xa).apply(null, arguments);
                    };
                    var gt = s1.___funcs_on_exit = function() {
                        return (gt = s1.___funcs_on_exit = s1.asm.ya).apply(null, arguments);
                    }, mt = s1._emscripten_main_thread_process_queued_calls = function() {
                        return (mt = s1._emscripten_main_thread_process_queued_calls = s1.asm.za).apply(null, arguments);
                    }, bt = s1.__emscripten_thread_init = function() {
                        return (bt = s1.__emscripten_thread_init = s1.asm.Aa).apply(null, arguments);
                    };
                    s1._emscripten_current_thread_process_queued_calls = function() {
                        return (s1._emscripten_current_thread_process_queued_calls = s1.asm.Ca).apply(null, arguments);
                    };
                    var yt = s1._emscripten_sync_run_in_main_thread_4 = function() {
                        return (yt = s1._emscripten_sync_run_in_main_thread_4 = s1.asm.Da).apply(null, arguments);
                    }, _t = s1._emscripten_run_in_main_runtime_thread_js = function() {
                        return (_t = s1._emscripten_run_in_main_runtime_thread_js = s1.asm.Ea).apply(null, arguments);
                    }, vt = s1._emscripten_dispatch_to_thread_ = function() {
                        return (vt = s1._emscripten_dispatch_to_thread_ = s1.asm.Fa).apply(null, arguments);
                    }, wt = s1.__emscripten_thread_free_data = function() {
                        return (wt = s1.__emscripten_thread_free_data = s1.asm.Ga).apply(null, arguments);
                    };
                    s1.__emscripten_thread_exit = function() {
                        return (s1.__emscripten_thread_exit = s1.asm.Ha).apply(null, arguments);
                    };
                    var xt, Tt = s1._memalign = function() {
                        return (Tt = s1._memalign = s1.asm.Ia).apply(null, arguments);
                    }, Ot = s1._emscripten_stack_set_limits = function() {
                        return (Ot = s1._emscripten_stack_set_limits = s1.asm.Ja).apply(null, arguments);
                    }, St = s1.stackSave = function() {
                        return (St = s1.stackSave = s1.asm.Ka).apply(null, arguments);
                    }, At = s1.stackRestore = function() {
                        return (At = s1.stackRestore = s1.asm.La).apply(null, arguments);
                    }, Et = s1.stackAlloc = function() {
                        return (Et = s1.stackAlloc = s1.asm.Ma).apply(null, arguments);
                    }, It = s1.__emscripten_main_thread_futex = 687896, Dt = s1.__emscripten_allow_main_runtime_queued_calls = 683012;
                    function Pt(e) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + e + ")", this.status = e;
                    }
                    function $t() {
                        function e25() {
                            if (!xt && (xt = !0, s1.calledRun = !0, !F) && (x || pe(J), a1(s1), s1.onRuntimeInitialized && s1.onRuntimeInitialized(), !x)) {
                                if (s1.postRun) for("function" == typeof s1.postRun && (s1.postRun = [
                                    s1.postRun
                                ]); s1.postRun.length;){
                                    var e = s1.postRun.shift();
                                    ee.unshift(e);
                                }
                                pe(ee);
                            }
                        }
                        if (!(0 < ie)) {
                            if (x) a1(s1), x || pe(J), postMessage({
                                cmd: "loaded"
                            });
                            else {
                                if (s1.preRun) for("function" == typeof s1.preRun && (s1.preRun = [
                                    s1.preRun
                                ]); s1.preRun.length;)ne();
                                pe(Z), 0 < ie || (s1.setStatus ? (s1.setStatus("Running..."), setTimeout(function() {
                                    setTimeout(function() {
                                        s1.setStatus("");
                                    }, 1), e25();
                                }, 1)) : e25());
                            }
                        }
                    }
                    function kt(e) {
                        if (x) throw ge(e), "unwind";
                        te() || x || (gt(), pe(Q), xe[1].length && Te(1, 10), xe[2].length && Te(2, 10), he.kb()), te() || (he.kb(), s1.onExit && s1.onExit(e), F = !0), y(e, new Pt(e));
                    }
                    if (s1.UTF8ToString = G, s1.stringToUTF8 = H, s1.lengthBytesUTF8 = W, s1.keepRuntimeAlive = te, s1.PThread = he, s1.stackSave = St, s1.stackRestore = At, s1.stackAlloc = Et, s1.PThread = he, s1.wasmMemory = k, s1.ExitStatus = Pt, se = function e() {
                        xt || $t(), xt || (se = e);
                    }, s1.run = $t, s1.preInit) for("function" == typeof s1.preInit && (s1.preInit = [
                        s1.preInit
                    ]); 0 < s1.preInit.length;)s1.preInit.pop()();
                    return x && ($ = !1, he.ub()), $t(), e2.ready;
                });
                e1.exports = r1;
            },
            5118: (e)=>{
                "use strict";
                e.exports = '"use strict";var e={};if("object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node){var t=require("worker_threads"),r=t.parentPort;r.on("message",(function(e){onmessage({data:e})}));var a=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:t.Worker,importScripts:function(e){(0,eval)(a.readFileSync(e,"utf8"))},postMessage:function(e){r.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=function(){var e=Array.prototype.slice.call(arguments).join(" ");console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.threadInfoStruct,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInit();try{var a=e.invokeEntryPoint(t.data.start_routine,t.data.arg);e.keepRuntimeAlive()?e.PThread.setExitStatus(a):e.__emscripten_thread_exit(a)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processThreadQueue"===t.data.cmd?e._pthread_self()&&e._emscripten_current_thread_process_queued_calls():(s("worker.js received unknown command "+t.data.cmd),s(t.data)))}catch(e){throw s("worker.js onmessage() captured an uncaught exception: "+e),e&&e.stack&&s(e.stack),e}};\n';
            },
            932: (e26, t14, n7)=>{
                var _scriptDir, r6 = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(e27) {
                    var t15;
                    e27 = e27 || {}, t15 || (t15 = void 0 !== e27 ? e27 : {});
                    var r7, i2, o2 = Object.assign;
                    t15.ready = new Promise(function(e, t) {
                        r7 = e, i2 = t;
                    });
                    var s2, a2, u2, l2, c2, p2, d2 = o2({}, t15), f = "./this.program", h = "object" == typeof window, g = "function" == typeof importScripts, m = "object" == typeof $3tEm6 && "object" == typeof $3tEm6.versions && "string" == typeof $3tEm6.versions.node, b = "";
                    m ? (b = g ? n7(908).dirname(b) + "/" : "//", p2 = ()=>{
                        c2 || (l2 = n7(1384), c2 = n7(908));
                    }, s2 = function(e, t) {
                        return p2(), e = c2.normalize(e), l2.readFileSync(e, t ? null : "utf8");
                    }, u2 = (e)=>((e = s2(e, !0)).buffer || (e = new Uint8Array(e)), e)
                    , a2 = (e28, t, n)=>{
                        p2(), e28 = c2.normalize(e28), l2.readFile(e28, function(e, r) {
                            e ? n(e) : t(r.buffer);
                        });
                    }, 1 < $3tEm6.argv.length && (f = $3tEm6.argv[1].replace(/\\/g, "/")), $3tEm6.argv.slice(2), $3tEm6.on("uncaughtException", function(e) {
                        throw e;
                    }), $3tEm6.on("unhandledRejection", function(e) {
                        throw e;
                    }), t15.inspect = function() {
                        return "[Emscripten Module object]";
                    }) : (h || g) && (g ? b = self.location.href : "undefined" != typeof document && document.currentScript && (b = document.currentScript.src), _scriptDir && (b = _scriptDir), b = 0 !== b.indexOf("blob:") ? b.substr(0, b.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", s2 = (e)=>{
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.send(null), t.responseText;
                    }, g && (u2 = (e)=>{
                        var t = new XMLHttpRequest;
                        return t.open("GET", e, !1), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
                    }), a2 = (e, t, n)=>{
                        var r = new XMLHttpRequest;
                        r.open("GET", e, !0), r.responseType = "arraybuffer", r.onload = ()=>{
                            200 == r.status || 0 == r.status && r.response ? t(r.response) : n();
                        }, r.onerror = n, r.send(null);
                    });
                    var y, _ = t15.print || console.log.bind(console), v = t15.printErr || console.warn.bind(console);
                    o2(t15, d2), d2 = null, t15.thisProgram && (f = t15.thisProgram), t15.wasmBinary && (y = t15.wasmBinary), t15.noExitRuntime, "object" != typeof WebAssembly && G("no native wasm support detected");
                    var w, x, T, O, S, A = !1, E = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
                    function I(e, t, n) {
                        var r = t + n;
                        for(n = t; e[n] && !(n >= r);)++n;
                        if (16 < n - t && e.subarray && E) return E.decode(e.subarray(t, n));
                        for(r = ""; t < n;){
                            var i = e[t++];
                            if (128 & i) {
                                var o = 63 & e[t++];
                                if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);
                                else {
                                    var s = 63 & e[t++];
                                    65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | s : (7 & i) << 18 | o << 12 | s << 6 | 63 & e[t++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));
                                }
                            } else r += String.fromCharCode(i);
                        }
                        return r;
                    }
                    function D(e, t) {
                        return e ? I(O, e, t) : "";
                    }
                    function P(e, t, n, r) {
                        if (!(0 < r)) return 0;
                        var i = n;
                        r = n + r - 1;
                        for(var o = 0; o < e.length; ++o){
                            var s = e.charCodeAt(o);
                            if (55296 <= s && 57343 >= s && (s = 65536 + ((1023 & s) << 10) | 1023 & e.charCodeAt(++o)), 127 >= s) {
                                if (n >= r) break;
                                t[n++] = s;
                            } else {
                                if (2047 >= s) {
                                    if (n + 1 >= r) break;
                                    t[n++] = 192 | s >> 6;
                                } else {
                                    if (65535 >= s) {
                                        if (n + 2 >= r) break;
                                        t[n++] = 224 | s >> 12;
                                    } else {
                                        if (n + 3 >= r) break;
                                        t[n++] = 240 | s >> 18, t[n++] = 128 | s >> 12 & 63;
                                    }
                                    t[n++] = 128 | s >> 6 & 63;
                                }
                                t[n++] = 128 | 63 & s;
                            }
                        }
                        return t[n] = 0, n - i;
                    }
                    function $(e) {
                        for(var t = 0, n = 0; n < e.length; ++n){
                            var r = e.charCodeAt(n);
                            55296 <= r && 57343 >= r && (r = 65536 + ((1023 & r) << 10) | 1023 & e.charCodeAt(++n)), 127 >= r ? ++t : t = 2047 >= r ? t + 2 : 65535 >= r ? t + 3 : t + 4;
                        }
                        return t;
                    }
                    function k(e) {
                        var t = $(e) + 1, n = fe(t);
                        return n && P(e, T, n, t), n;
                    }
                    function N() {
                        var e = w.buffer;
                        x = e, t15.HEAP8 = T = new Int8Array(e), t15.HEAP16 = new Int16Array(e), t15.HEAP32 = S = new Int32Array(e), t15.HEAPU8 = O = new Uint8Array(e), t15.HEAPU16 = new Uint16Array(e), t15.HEAPU32 = new Uint32Array(e), t15.HEAPF32 = new Float32Array(e), t15.HEAPF64 = new Float64Array(e);
                    }
                    var F, C = [], R = [], L = [];
                    function M() {
                        var e = t15.preRun.shift();
                        C.unshift(e);
                    }
                    var j, U = 0, V = null, B = null;
                    function G(e) {
                        throw t15.onAbort && t15.onAbort(e), v(e = "Aborted(" + e + ")"), A = !0, e = new WebAssembly.RuntimeError(e + ". Build with -s ASSERTIONS=1 for more info."), i2(e), e;
                    }
                    function z() {
                        return j.startsWith("data:application/octet-stream;base64,");
                    }
                    if (t15.preloadedImages = {}, t15.preloadedAudios = {}, j = "ort-wasm.wasm", !z()) {
                        var H = j;
                        j = t15.locateFile ? t15.locateFile(H, b) : b + H;
                    }
                    function W() {
                        var e = j;
                        try {
                            if (e == j && y) return new Uint8Array(y);
                            if (u2) return u2(e);
                            throw "both async and sync fetching of the wasm failed";
                        } catch (e29) {
                            G(e29);
                        }
                    }
                    function q(e) {
                        for(; 0 < e.length;){
                            var n = e.shift();
                            if ("function" == typeof n) n(t15);
                            else {
                                var r = n.Na;
                                "number" == typeof r ? void 0 === n.va ? X(r)() : X(r)(n.va) : r(void 0 === n.va ? null : n.va);
                            }
                        }
                    }
                    var Y = [];
                    function X(e) {
                        var t = Y[e];
                        return t || (e >= Y.length && (Y.length = e + 1), Y[e] = t = F.get(e)), t;
                    }
                    function K(e30) {
                        this.qa = e30 - 16, this.Fa = function(e) {
                            S[this.qa + 4 >> 2] = e;
                        }, this.Ca = function(e) {
                            S[this.qa + 8 >> 2] = e;
                        }, this.Da = function() {
                            S[this.qa >> 2] = 0;
                        }, this.Ba = function() {
                            T[this.qa + 12 >> 0] = 0;
                        }, this.Ea = function() {
                            T[this.qa + 13 >> 0] = 0;
                        }, this.ya = function(e, t) {
                            this.Fa(e), this.Ca(t), this.Da(), this.Ba(), this.Ea();
                        };
                    }
                    var Z, J, Q = {}, ee = [
                        null,
                        [],
                        []
                    ], te = {}, ne = {};
                    function re() {
                        if (!J) {
                            var e, t = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                                _: f || "./this.program"
                            };
                            for(e in ne)void 0 === ne[e] ? delete t[e] : t[e] = ne[e];
                            var n = [];
                            for(e in t)n.push(e + "=" + t[e]);
                            J = n;
                        }
                        return J;
                    }
                    function ie(e) {
                        return 0 == e % 4 && (0 != e % 100 || 0 == e % 400);
                    }
                    function oe(e, t) {
                        for(var n = 0, r = 0; r <= t; n += e[r++]);
                        return n;
                    }
                    var se = [
                        31,
                        29,
                        31,
                        30,
                        31,
                        30,
                        31,
                        31,
                        30,
                        31,
                        30,
                        31
                    ], ae = [
                        31,
                        28,
                        31,
                        30,
                        31,
                        30,
                        31,
                        31,
                        30,
                        31,
                        30,
                        31
                    ];
                    function ue(e, t) {
                        for(e = new Date(e.getTime()); 0 < t;){
                            var n = e.getMonth(), r = (ie(e.getFullYear()) ? se : ae)[n];
                            if (!(t > r - e.getDate())) {
                                e.setDate(e.getDate() + t);
                                break;
                            }
                            t -= r - e.getDate() + 1, e.setDate(1), 11 > n ? e.setMonth(n + 1) : (e.setMonth(0), e.setFullYear(e.getFullYear() + 1));
                        }
                        return e;
                    }
                    function le(e31, t16, n8, r8) {
                        function i(e, t, n) {
                            for(e = "number" == typeof e ? e.toString() : e || ""; e.length < t;)e = n[0] + e;
                            return e;
                        }
                        function o(e, t) {
                            return i(e, t, "0");
                        }
                        function s(e32, t) {
                            function n(e) {
                                return 0 > e ? -1 : 0 < e ? 1 : 0;
                            }
                            var r;
                            return 0 === (r = n(e32.getFullYear() - t.getFullYear())) && 0 === (r = n(e32.getMonth() - t.getMonth())) && (r = n(e32.getDate() - t.getDate())), r;
                        }
                        function a(e) {
                            switch(e.getDay()){
                                case 0:
                                    return new Date(e.getFullYear() - 1, 11, 29);
                                case 1:
                                    return e;
                                case 2:
                                    return new Date(e.getFullYear(), 0, 3);
                                case 3:
                                    return new Date(e.getFullYear(), 0, 2);
                                case 4:
                                    return new Date(e.getFullYear(), 0, 1);
                                case 5:
                                    return new Date(e.getFullYear() - 1, 11, 31);
                                case 6:
                                    return new Date(e.getFullYear() - 1, 11, 30);
                            }
                        }
                        function u(e) {
                            e = ue(new Date(e.oa + 1900, 0, 1), e.ua);
                            var t = new Date(e.getFullYear() + 1, 0, 4), n = a(new Date(e.getFullYear(), 0, 4));
                            return t = a(t), 0 >= s(n, e) ? 0 >= s(t, e) ? e.getFullYear() + 1 : e.getFullYear() : e.getFullYear() - 1;
                        }
                        var l = S[r8 + 40 >> 2];
                        for(var c in r8 = {
                            Ia: S[r8 >> 2],
                            Ha: S[r8 + 4 >> 2],
                            sa: S[r8 + 8 >> 2],
                            ra: S[r8 + 12 >> 2],
                            pa: S[r8 + 16 >> 2],
                            oa: S[r8 + 20 >> 2],
                            ta: S[r8 + 24 >> 2],
                            ua: S[r8 + 28 >> 2],
                            Qa: S[r8 + 32 >> 2],
                            Ga: S[r8 + 36 >> 2],
                            Ja: l ? D(l) : ""
                        }, n8 = D(n8), l = {
                            "%c": "%a %b %d %H:%M:%S %Y",
                            "%D": "%m/%d/%y",
                            "%F": "%Y-%m-%d",
                            "%h": "%b",
                            "%r": "%I:%M:%S %p",
                            "%R": "%H:%M",
                            "%T": "%H:%M:%S",
                            "%x": "%m/%d/%y",
                            "%X": "%H:%M:%S",
                            "%Ec": "%c",
                            "%EC": "%C",
                            "%Ex": "%m/%d/%y",
                            "%EX": "%H:%M:%S",
                            "%Ey": "%y",
                            "%EY": "%Y",
                            "%Od": "%d",
                            "%Oe": "%e",
                            "%OH": "%H",
                            "%OI": "%I",
                            "%Om": "%m",
                            "%OM": "%M",
                            "%OS": "%S",
                            "%Ou": "%u",
                            "%OU": "%U",
                            "%OV": "%V",
                            "%Ow": "%w",
                            "%OW": "%W",
                            "%Oy": "%y"
                        })n8 = n8.replace(new RegExp(c, "g"), l[c]);
                        var p = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), d = "January February March April May June July August September October November December".split(" ");
                        for(c in l = {
                            "%a": function(e) {
                                return p[e.ta].substring(0, 3);
                            },
                            "%A": function(e) {
                                return p[e.ta];
                            },
                            "%b": function(e) {
                                return d[e.pa].substring(0, 3);
                            },
                            "%B": function(e) {
                                return d[e.pa];
                            },
                            "%C": function(e) {
                                return o((e.oa + 1900) / 100 | 0, 2);
                            },
                            "%d": function(e) {
                                return o(e.ra, 2);
                            },
                            "%e": function(e) {
                                return i(e.ra, 2, " ");
                            },
                            "%g": function(e) {
                                return u(e).toString().substring(2);
                            },
                            "%G": function(e) {
                                return u(e);
                            },
                            "%H": function(e) {
                                return o(e.sa, 2);
                            },
                            "%I": function(e) {
                                return 0 == (e = e.sa) ? e = 12 : 12 < e && (e -= 12), o(e, 2);
                            },
                            "%j": function(e) {
                                return o(e.ra + oe(ie(e.oa + 1900) ? se : ae, e.pa - 1), 3);
                            },
                            "%m": function(e) {
                                return o(e.pa + 1, 2);
                            },
                            "%M": function(e) {
                                return o(e.Ha, 2);
                            },
                            "%n": function() {
                                return "\n";
                            },
                            "%p": function(e) {
                                return 0 <= e.sa && 12 > e.sa ? "AM" : "PM";
                            },
                            "%S": function(e) {
                                return o(e.Ia, 2);
                            },
                            "%t": function() {
                                return "\t";
                            },
                            "%u": function(e) {
                                return e.ta || 7;
                            },
                            "%U": function(e) {
                                var t = new Date(e.oa + 1900, 0, 1), n = 0 === t.getDay() ? t : ue(t, 7 - t.getDay());
                                return 0 > s(n, e = new Date(e.oa + 1900, e.pa, e.ra)) ? o(Math.ceil((31 - n.getDate() + (oe(ie(e.getFullYear()) ? se : ae, e.getMonth() - 1) - 31) + e.getDate()) / 7), 2) : 0 === s(n, t) ? "01" : "00";
                            },
                            "%V": function(e) {
                                var t = new Date(e.oa + 1901, 0, 4), n = a(new Date(e.oa + 1900, 0, 4));
                                t = a(t);
                                var r = ue(new Date(e.oa + 1900, 0, 1), e.ua);
                                return 0 > s(r, n) ? "53" : 0 >= s(t, r) ? "01" : o(Math.ceil((n.getFullYear() < e.oa + 1900 ? e.ua + 32 - n.getDate() : e.ua + 1 - n.getDate()) / 7), 2);
                            },
                            "%w": function(e) {
                                return e.ta;
                            },
                            "%W": function(e) {
                                var t = new Date(e.oa, 0, 1), n = 1 === t.getDay() ? t : ue(t, 0 === t.getDay() ? 1 : 7 - t.getDay() + 1);
                                return 0 > s(n, e = new Date(e.oa + 1900, e.pa, e.ra)) ? o(Math.ceil((31 - n.getDate() + (oe(ie(e.getFullYear()) ? se : ae, e.getMonth() - 1) - 31) + e.getDate()) / 7), 2) : 0 === s(n, t) ? "01" : "00";
                            },
                            "%y": function(e) {
                                return (e.oa + 1900).toString().substring(2);
                            },
                            "%Y": function(e) {
                                return e.oa + 1900;
                            },
                            "%z": function(e) {
                                var t = 0 <= (e = e.Ga);
                                return e = Math.abs(e) / 60, (t ? "+" : "-") + String("0000" + (e / 60 * 100 + e % 60)).slice(-4);
                            },
                            "%Z": function(e) {
                                return e.Ja;
                            },
                            "%%": function() {
                                return "%";
                            }
                        })n8.includes(c) && (n8 = n8.replace(new RegExp(c, "g"), l[c](r8)));
                        return c = function(e) {
                            var t = Array($(e) + 1);
                            return P(e, t, 0, t.length), t;
                        }(n8), c.length > t16 ? 0 : (T.set(c, e31), c.length - 1);
                    }
                    var ce = {
                        a: function(e) {
                            return fe(e + 16) + 16;
                        },
                        b: function(e, t, n) {
                            throw new K(e).ya(t, n), e;
                        },
                        g: function() {
                            return 0;
                        },
                        I: function() {},
                        F: function() {},
                        v: function() {},
                        y: function() {},
                        r: function() {
                            return 0;
                        },
                        G: function() {},
                        B: function(e, t) {
                            return e = D(e), te.Ka(e, t);
                        },
                        A: function(e, t, n, r, i, o) {
                            if (o <<= 12, 0 != (16 & r) && 0 != e % 65536) t = -28;
                            else if (0 != (32 & r)) {
                                e = 65536 * Math.ceil(t / 65536);
                                var s = ge(65536, e);
                                s ? (O.fill(0, s, s + e), e = s) : e = 0, e ? (Q[e] = {
                                    Aa: e,
                                    za: t,
                                    wa: !0,
                                    fd: i,
                                    Pa: n,
                                    flags: r,
                                    offset: o
                                }, t = e) : t = -48;
                            } else t = -52;
                            return t;
                        },
                        z: function(e, t) {
                            var n = Q[e];
                            return 0 !== t && n ? (t === n.za && (Q[e] = null, n.wa && he(n.Aa)), e = 0) : e = -28, e;
                        },
                        k: function() {},
                        x: function(e, t, n) {
                            return e = D(e), te.La(e, t, n);
                        },
                        t: function() {},
                        H: function() {},
                        u: function() {},
                        h: function() {
                            G("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                        },
                        n: function() {
                            G("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking");
                        },
                        J: function(e, t) {
                            e = new Date(1e3 * S[e >> 2]), S[t >> 2] = e.getUTCSeconds(), S[t + 4 >> 2] = e.getUTCMinutes(), S[t + 8 >> 2] = e.getUTCHours(), S[t + 12 >> 2] = e.getUTCDate(), S[t + 16 >> 2] = e.getUTCMonth(), S[t + 20 >> 2] = e.getUTCFullYear() - 1900, S[t + 24 >> 2] = e.getUTCDay(), S[t + 28 >> 2] = (e.getTime() - Date.UTC(e.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
                        },
                        K: function(e, t) {
                            e = new Date(1e3 * S[e >> 2]), S[t >> 2] = e.getSeconds(), S[t + 4 >> 2] = e.getMinutes(), S[t + 8 >> 2] = e.getHours(), S[t + 12 >> 2] = e.getDate(), S[t + 16 >> 2] = e.getMonth(), S[t + 20 >> 2] = e.getFullYear() - 1900, S[t + 24 >> 2] = e.getDay();
                            var n = new Date(e.getFullYear(), 0, 1);
                            S[t + 28 >> 2] = (e.getTime() - n.getTime()) / 864e5 | 0, S[t + 36 >> 2] = -60 * e.getTimezoneOffset();
                            var r = new Date(e.getFullYear(), 6, 1).getTimezoneOffset();
                            n = n.getTimezoneOffset(), S[t + 32 >> 2] = 0 | (r != n && e.getTimezoneOffset() == Math.min(n, r));
                        },
                        L: function(e) {
                            var t = new Date(S[e + 20 >> 2] + 1900, S[e + 16 >> 2], S[e + 12 >> 2], S[e + 8 >> 2], S[e + 4 >> 2], S[e >> 2], 0), n = S[e + 32 >> 2], r = t.getTimezoneOffset(), i = new Date(t.getFullYear(), 0, 1), o = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(), s = i.getTimezoneOffset(), a = Math.min(s, o);
                            return 0 > n ? S[e + 32 >> 2] = Number(o != s && a == r) : 0 < n != (a == r) && (o = Math.max(s, o), t.setTime(t.getTime() + 6e4 * ((0 < n ? a : o) - r))), S[e + 24 >> 2] = t.getDay(), S[e + 28 >> 2] = (t.getTime() - i.getTime()) / 864e5 | 0, S[e >> 2] = t.getSeconds(), S[e + 4 >> 2] = t.getMinutes(), S[e + 8 >> 2] = t.getHours(), S[e + 12 >> 2] = t.getDate(), S[e + 16 >> 2] = t.getMonth(), t.getTime() / 1e3 | 0;
                        },
                        M: function e33(t17, n9, r9) {
                            e33.xa || (e33.xa = !0, function(e34, t, n) {
                                function r(e) {
                                    return (e = e.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e[1] : "GMT";
                                }
                                var i = (new Date).getFullYear(), o = new Date(i, 0, 1), s = new Date(i, 6, 1);
                                i = o.getTimezoneOffset();
                                var a = s.getTimezoneOffset();
                                S[e34 >> 2] = 60 * Math.max(i, a), S[t >> 2] = Number(i != a), e34 = r(o), t = r(s), e34 = k(e34), t = k(t), a < i ? (S[n >> 2] = e34, S[n + 4 >> 2] = t) : (S[n >> 2] = t, S[n + 4 >> 2] = e34);
                            }(t17, n9, r9));
                        },
                        d: function() {
                            G("");
                        },
                        m: function(e, t) {
                            if (0 === e) e = Date.now();
                            else {
                                if (1 !== e && 4 !== e) return S[de() >> 2] = 28, -1;
                                e = Z();
                            }
                            return S[t >> 2] = e / 1e3 | 0, S[t + 4 >> 2] = e % 1e3 * 1e6 | 0, 0;
                        },
                        p: function(e, t) {
                            return e - t;
                        },
                        s: function() {
                            return 2147483648;
                        },
                        l: Z = m ? ()=>{
                            var e = $3tEm6.hrtime();
                            return 1e3 * e[0] + e[1] / 1e6;
                        } : ()=>performance.now()
                        ,
                        E: function(e, t, n) {
                            O.copyWithin(e, t, t + n);
                        },
                        f: function(e) {
                            var t = O.length;
                            if (2147483648 < (e >>>= 0)) return !1;
                            for(var n = 1; 4 >= n; n *= 2){
                                var r = t * (1 + .2 / n);
                                r = Math.min(r, e + 100663296), 0 < (r = Math.max(e, r)) % 65536 && (r += 65536 - r % 65536);
                                e: {
                                    try {
                                        w.grow(Math.min(2147483648, r) - x.byteLength + 65535 >>> 16), N();
                                        var i = 1;
                                        break e;
                                    } catch (e) {}
                                    i = void 0;
                                }
                                if (i) return !0;
                            }
                            return !1;
                        },
                        C: function(e, t) {
                            var n = 0;
                            return re().forEach(function(r, i) {
                                var o = t + n;
                                for(i = S[e + 4 * i >> 2] = o, o = 0; o < r.length; ++o)T[(i++) >> 0] = r.charCodeAt(o);
                                T[i >> 0] = 0, n += r.length + 1;
                            }), 0;
                        },
                        D: function(e35, t) {
                            var n = re();
                            S[e35 >> 2] = n.length;
                            var r = 0;
                            return n.forEach(function(e) {
                                r += e.length + 1;
                            }), S[t >> 2] = r, 0;
                        },
                        e: function() {
                            return 0;
                        },
                        j: function(e, t, n, r) {
                            return e = te.Oa(e), t = te.Ma(e, t, n), S[r >> 2] = t, 0;
                        },
                        q: function() {},
                        i: function(e, t, n, r) {
                            for(var i = 0, o = 0; o < n; o++){
                                var s = S[t >> 2], a = S[t + 4 >> 2];
                                t += 8;
                                for(var u = 0; u < a; u++){
                                    var l = O[s + u], c = ee[e];
                                    0 === l || 10 === l ? ((1 === e ? _ : v)(I(c, 0)), c.length = 0) : c.push(l);
                                }
                                i += a;
                            }
                            return S[r >> 2] = i, 0;
                        },
                        w: function(e) {
                            var t = Date.now();
                            return S[e >> 2] = t / 1e3 | 0, S[e + 4 >> 2] = t % 1e3 * 1e3 | 0, 0;
                        },
                        o: le,
                        c: function(e, t, n, r) {
                            return le(e, t, n, r);
                        }
                    };
                    !function() {
                        function e36(e) {
                            t15.asm = e.exports, w = t15.asm.N, N(), F = t15.asm.ja, R.unshift(t15.asm.O), U--, t15.monitorRunDependencies && t15.monitorRunDependencies(U), 0 == U && (null !== V && (clearInterval(V), V = null), B && (e = B, B = null, e()));
                        }
                        function n(t) {
                            e36(t.instance);
                        }
                        function r(e37) {
                            return (function() {
                                if (!y && (h || g)) {
                                    if ("function" == typeof fetch && !j.startsWith("file://")) return fetch(j, {
                                        credentials: "same-origin"
                                    }).then(function(e) {
                                        if (!e.ok) throw "failed to load wasm binary file at '" + j + "'";
                                        return e.arrayBuffer();
                                    }).catch(function() {
                                        return W();
                                    });
                                    if (a2) return new Promise(function(e, t18) {
                                        a2(j, function(t) {
                                            e(new Uint8Array(t));
                                        }, t18);
                                    });
                                }
                                return Promise.resolve().then(function() {
                                    return W();
                                });
                            })().then(function(e) {
                                return WebAssembly.instantiate(e, o);
                            }).then(function(e) {
                                return e;
                            }).then(e37, function(e) {
                                v("failed to asynchronously prepare wasm: " + e), G(e);
                            });
                        }
                        var o = {
                            a: ce
                        };
                        if (U++, t15.monitorRunDependencies && t15.monitorRunDependencies(U), t15.instantiateWasm) try {
                            return t15.instantiateWasm(o, e36);
                        } catch (e38) {
                            return v("Module.instantiateWasm callback failed with error: " + e38), !1;
                        }
                        (y || "function" != typeof WebAssembly.instantiateStreaming || z() || j.startsWith("file://") || "function" != typeof fetch ? r(n) : fetch(j, {
                            credentials: "same-origin"
                        }).then(function(e39) {
                            return WebAssembly.instantiateStreaming(e39, o).then(n, function(e) {
                                return v("wasm streaming compile failed: " + e), v("falling back to ArrayBuffer instantiation"), r(n);
                            });
                        })).catch(i2);
                    }(), t15.___wasm_call_ctors = function() {
                        return (t15.___wasm_call_ctors = t15.asm.O).apply(null, arguments);
                    }, t15._OrtInit = function() {
                        return (t15._OrtInit = t15.asm.P).apply(null, arguments);
                    }, t15._OrtCreateSessionOptions = function() {
                        return (t15._OrtCreateSessionOptions = t15.asm.Q).apply(null, arguments);
                    }, t15._OrtAddSessionConfigEntry = function() {
                        return (t15._OrtAddSessionConfigEntry = t15.asm.R).apply(null, arguments);
                    }, t15._OrtReleaseSessionOptions = function() {
                        return (t15._OrtReleaseSessionOptions = t15.asm.S).apply(null, arguments);
                    }, t15._OrtCreateSession = function() {
                        return (t15._OrtCreateSession = t15.asm.T).apply(null, arguments);
                    }, t15._OrtReleaseSession = function() {
                        return (t15._OrtReleaseSession = t15.asm.U).apply(null, arguments);
                    }, t15._OrtGetInputCount = function() {
                        return (t15._OrtGetInputCount = t15.asm.V).apply(null, arguments);
                    }, t15._OrtGetOutputCount = function() {
                        return (t15._OrtGetOutputCount = t15.asm.W).apply(null, arguments);
                    }, t15._OrtGetInputName = function() {
                        return (t15._OrtGetInputName = t15.asm.X).apply(null, arguments);
                    }, t15._OrtGetOutputName = function() {
                        return (t15._OrtGetOutputName = t15.asm.Y).apply(null, arguments);
                    }, t15._OrtFree = function() {
                        return (t15._OrtFree = t15.asm.Z).apply(null, arguments);
                    }, t15._OrtCreateTensor = function() {
                        return (t15._OrtCreateTensor = t15.asm._).apply(null, arguments);
                    }, t15._OrtGetTensorData = function() {
                        return (t15._OrtGetTensorData = t15.asm.$).apply(null, arguments);
                    }, t15._OrtReleaseTensor = function() {
                        return (t15._OrtReleaseTensor = t15.asm.aa).apply(null, arguments);
                    }, t15._OrtCreateRunOptions = function() {
                        return (t15._OrtCreateRunOptions = t15.asm.ba).apply(null, arguments);
                    }, t15._OrtAddRunConfigEntry = function() {
                        return (t15._OrtAddRunConfigEntry = t15.asm.ca).apply(null, arguments);
                    }, t15._OrtReleaseRunOptions = function() {
                        return (t15._OrtReleaseRunOptions = t15.asm.da).apply(null, arguments);
                    }, t15._OrtRun = function() {
                        return (t15._OrtRun = t15.asm.ea).apply(null, arguments);
                    }, t15._OrtEndProfiling = function() {
                        return (t15._OrtEndProfiling = t15.asm.fa).apply(null, arguments);
                    };
                    var pe, de = t15.___errno_location = function() {
                        return (de = t15.___errno_location = t15.asm.ga).apply(null, arguments);
                    }, fe = t15._malloc = function() {
                        return (fe = t15._malloc = t15.asm.ha).apply(null, arguments);
                    }, he = t15._free = function() {
                        return (he = t15._free = t15.asm.ia).apply(null, arguments);
                    }, ge = t15._memalign = function() {
                        return (ge = t15._memalign = t15.asm.ka).apply(null, arguments);
                    }, me = t15.stackSave = function() {
                        return (me = t15.stackSave = t15.asm.la).apply(null, arguments);
                    }, be = t15.stackRestore = function() {
                        return (be = t15.stackRestore = t15.asm.ma).apply(null, arguments);
                    }, ye = t15.stackAlloc = function() {
                        return (ye = t15.stackAlloc = t15.asm.na).apply(null, arguments);
                    };
                    function _e() {
                        function e40() {
                            if (!pe && (pe = !0, t15.calledRun = !0, !A)) {
                                if (q(R), r7(t15), t15.onRuntimeInitialized && t15.onRuntimeInitialized(), t15.postRun) for("function" == typeof t15.postRun && (t15.postRun = [
                                    t15.postRun
                                ]); t15.postRun.length;){
                                    var e = t15.postRun.shift();
                                    L.unshift(e);
                                }
                                q(L);
                            }
                        }
                        if (!(0 < U)) {
                            if (t15.preRun) for("function" == typeof t15.preRun && (t15.preRun = [
                                t15.preRun
                            ]); t15.preRun.length;)M();
                            q(C), 0 < U || (t15.setStatus ? (t15.setStatus("Running..."), setTimeout(function() {
                                setTimeout(function() {
                                    t15.setStatus("");
                                }, 1), e40();
                            }, 1)) : e40());
                        }
                    }
                    if (t15.UTF8ToString = D, t15.stringToUTF8 = function(e, t, n) {
                        return P(e, O, t, n);
                    }, t15.lengthBytesUTF8 = $, t15.stackSave = me, t15.stackRestore = be, t15.stackAlloc = ye, B = function e() {
                        pe || _e(), pe || (B = e);
                    }, t15.run = _e, t15.preInit) for("function" == typeof t15.preInit && (t15.preInit = [
                        t15.preInit
                    ]); 0 < t15.preInit.length;)t15.preInit.pop()();
                    return _e(), e27.ready;
                });
                e26.exports = r6;
            },
            4537: (e41)=>{
                "use strict";
                e41.exports = function(e42, t19) {
                    for(var n10 = new Array(arguments.length - 1), r = 0, i3 = 2, o = !0; i3 < arguments.length;)n10[r++] = arguments[i3++];
                    return new Promise(function(i, s) {
                        n10[r] = function(e) {
                            if (o) {
                                if (o = !1, e) s(e);
                                else {
                                    for(var t = new Array(arguments.length - 1), n = 0; n < t.length;)t[n++] = arguments[n];
                                    i.apply(null, t);
                                }
                            }
                        };
                        try {
                            e42.apply(t19 || null, n10);
                        } catch (e) {
                            o && (o = !1, s(e));
                        }
                    });
                };
            },
            7419: (e43, t20)=>{
                "use strict";
                var n11 = t20;
                n11.length = function(e) {
                    var t = e.length;
                    if (!t) return 0;
                    for(var n = 0; --t % 4 > 1 && "=" === e.charAt(t);)++n;
                    return Math.ceil(3 * e.length) / 4 - n;
                };
                for(var r10 = new Array(64), i4 = new Array(123), o3 = 0; o3 < 64;)i4[r10[o3] = o3 < 26 ? o3 + 65 : o3 < 52 ? o3 + 71 : o3 < 62 ? o3 - 4 : o3 - 59 | 43] = o3++;
                n11.encode = function(e, t, n) {
                    for(var i, o = null, s = [], a = 0, u = 0; t < n;){
                        var l = e[t++];
                        switch(u){
                            case 0:
                                s[a++] = r10[l >> 2], i = (3 & l) << 4, u = 1;
                                break;
                            case 1:
                                s[a++] = r10[i | l >> 4], i = (15 & l) << 2, u = 2;
                                break;
                            case 2:
                                s[a++] = r10[i | l >> 6], s[a++] = r10[63 & l], u = 0;
                        }
                        a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, s)), a = 0);
                    }
                    return u && (s[a++] = r10[i], s[a++] = 61, 1 === u && (s[a++] = 61)), o ? (a && o.push(String.fromCharCode.apply(String, s.slice(0, a))), o.join("")) : String.fromCharCode.apply(String, s.slice(0, a));
                };
                var s3 = "invalid encoding";
                n11.decode = function(e, t, n) {
                    for(var r, o = n, a = 0, u = 0; u < e.length;){
                        var l = e.charCodeAt(u++);
                        if (61 === l && a > 1) break;
                        if (void 0 === (l = i4[l])) throw Error(s3);
                        switch(a){
                            case 0:
                                r = l, a = 1;
                                break;
                            case 1:
                                t[n++] = r << 2 | (48 & l) >> 4, r = l, a = 2;
                                break;
                            case 2:
                                t[n++] = (15 & r) << 4 | (60 & l) >> 2, r = l, a = 3;
                                break;
                            case 3:
                                t[n++] = (3 & r) << 6 | l, a = 0;
                        }
                    }
                    if (1 === a) throw Error(s3);
                    return n - o;
                }, n11.test = function(e) {
                    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);
                };
            },
            9211: (e44)=>{
                "use strict";
                function t21() {
                    this._listeners = {};
                }
                e44.exports = t21, t21.prototype.on = function(e, t, n) {
                    return (this._listeners[e] || (this._listeners[e] = [])).push({
                        fn: t,
                        ctx: n || this
                    }), this;
                }, t21.prototype.off = function(e, t) {
                    if (void 0 === e) this._listeners = {};
                    else if (void 0 === t) this._listeners[e] = [];
                    else for(var n = this._listeners[e], r = 0; r < n.length;)n[r].fn === t ? n.splice(r, 1) : ++r;
                    return this;
                }, t21.prototype.emit = function(e) {
                    var t = this._listeners[e];
                    if (t) {
                        for(var n = [], r = 1; r < arguments.length;)n.push(arguments[r++]);
                        for(r = 0; r < t.length;)t[r].fn.apply(t[r++].ctx, n);
                    }
                    return this;
                };
            },
            945: (e45)=>{
                "use strict";
                function t22(e46) {
                    return "undefined" != typeof Float32Array ? function() {
                        var t = new Float32Array([
                            -0
                        ]), n = new Uint8Array(t.buffer), r12 = 128 === n[3];
                        function i6(e, r, i) {
                            t[0] = e, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3];
                        }
                        function o(e, r, i) {
                            t[0] = e, r[i] = n[3], r[i + 1] = n[2], r[i + 2] = n[1], r[i + 3] = n[0];
                        }
                        function s(e, r) {
                            return n[0] = e[r], n[1] = e[r + 1], n[2] = e[r + 2], n[3] = e[r + 3], t[0];
                        }
                        function a(e, r) {
                            return n[3] = e[r], n[2] = e[r + 1], n[1] = e[r + 2], n[0] = e[r + 3], t[0];
                        }
                        e46.writeFloatLE = r12 ? i6 : o, e46.writeFloatBE = r12 ? o : i6, e46.readFloatLE = r12 ? s : a, e46.readFloatBE = r12 ? a : s;
                    }() : function() {
                        function t23(e, t, n, r) {
                            var i = t < 0 ? 1 : 0;
                            if (i && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, n, r);
                            else if (isNaN(t)) e(2143289344, n, r);
                            else if (t > 34028234663852886e22) e((i << 31 | 2139095040) >>> 0, n, r);
                            else if (t < 11754943508222875e-54) e((i << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, n, r);
                            else {
                                var o = Math.floor(Math.log(t) / Math.LN2);
                                e((i << 31 | o + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -o) * 8388608)) >>> 0, n, r);
                            }
                        }
                        function s4(e, t, n) {
                            var r = e(t, n), i = 2 * (r >> 31) + 1, o = r >>> 23 & 255, s = 8388607 & r;
                            return 255 === o ? s ? NaN : i * (1 / 0) : 0 === o ? 1401298464324817e-60 * i * s : i * Math.pow(2, o - 150) * (s + 8388608);
                        }
                        e46.writeFloatLE = t23.bind(null, n12), e46.writeFloatBE = t23.bind(null, r11), e46.readFloatLE = s4.bind(null, i5), e46.readFloatBE = s4.bind(null, o4);
                    }(), "undefined" != typeof Float64Array ? function() {
                        var t = new Float64Array([
                            -0
                        ]), n = new Uint8Array(t.buffer), r13 = 128 === n[7];
                        function i7(e, r, i) {
                            t[0] = e, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3], r[i + 4] = n[4], r[i + 5] = n[5], r[i + 6] = n[6], r[i + 7] = n[7];
                        }
                        function o(e, r, i) {
                            t[0] = e, r[i] = n[7], r[i + 1] = n[6], r[i + 2] = n[5], r[i + 3] = n[4], r[i + 4] = n[3], r[i + 5] = n[2], r[i + 6] = n[1], r[i + 7] = n[0];
                        }
                        function s(e, r) {
                            return n[0] = e[r], n[1] = e[r + 1], n[2] = e[r + 2], n[3] = e[r + 3], n[4] = e[r + 4], n[5] = e[r + 5], n[6] = e[r + 6], n[7] = e[r + 7], t[0];
                        }
                        function a(e, r) {
                            return n[7] = e[r], n[6] = e[r + 1], n[5] = e[r + 2], n[4] = e[r + 3], n[3] = e[r + 4], n[2] = e[r + 5], n[1] = e[r + 6], n[0] = e[r + 7], t[0];
                        }
                        e46.writeDoubleLE = r13 ? i7 : o, e46.writeDoubleBE = r13 ? o : i7, e46.readDoubleLE = r13 ? s : a, e46.readDoubleBE = r13 ? a : s;
                    }() : function() {
                        function t24(e, t, n, r, i, o) {
                            var s = r < 0 ? 1 : 0;
                            if (s && (r = -r), 0 === r) e(0, i, o + t), e(1 / r > 0 ? 0 : 2147483648, i, o + n);
                            else if (isNaN(r)) e(0, i, o + t), e(2146959360, i, o + n);
                            else if (r > 17976931348623157e292) e(0, i, o + t), e((s << 31 | 2146435072) >>> 0, i, o + n);
                            else {
                                var a;
                                if (r < 22250738585072014e-324) e((a = r / 5e-324) >>> 0, i, o + t), e((s << 31 | a / 4294967296) >>> 0, i, o + n);
                                else {
                                    var u = Math.floor(Math.log(r) / Math.LN2);
                                    1024 === u && (u = 1023), e(4503599627370496 * (a = r * Math.pow(2, -u)) >>> 0, i, o + t), e((s << 31 | u + 1023 << 20 | 1048576 * a & 1048575) >>> 0, i, o + n);
                                }
                            }
                        }
                        function s5(e, t, n, r, i) {
                            var o = e(r, i + t), s = e(r, i + n), a = 2 * (s >> 31) + 1, u = s >>> 20 & 2047, l = 4294967296 * (1048575 & s) + o;
                            return 2047 === u ? l ? NaN : a * (1 / 0) : 0 === u ? 5e-324 * a * l : a * Math.pow(2, u - 1075) * (l + 4503599627370496);
                        }
                        e46.writeDoubleLE = t24.bind(null, n12, 0, 4), e46.writeDoubleBE = t24.bind(null, r11, 4, 0), e46.readDoubleLE = s5.bind(null, i5, 0, 4), e46.readDoubleBE = s5.bind(null, o4, 4, 0);
                    }(), e46;
                }
                function n12(e, t, n) {
                    t[n] = 255 & e, t[n + 1] = e >>> 8 & 255, t[n + 2] = e >>> 16 & 255, t[n + 3] = e >>> 24;
                }
                function r11(e, t, n) {
                    t[n] = e >>> 24, t[n + 1] = e >>> 16 & 255, t[n + 2] = e >>> 8 & 255, t[n + 3] = 255 & e;
                }
                function i5(e, t) {
                    return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;
                }
                function o4(e, t) {
                    return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;
                }
                e45.exports = t22(t22);
            },
            7199: (module)=>{
                "use strict";
                function inquire(moduleName) {
                    try {
                        var mod = eval("quire".replace(/^/, "re"))(moduleName);
                        if (mod && (mod.length || Object.keys(mod).length)) return mod;
                    } catch (e) {}
                    return null;
                }
                module.exports = inquire;
            },
            6662: (e47)=>{
                "use strict";
                e47.exports = function(e, t, n13) {
                    var r = n13 || 8192, i = r >>> 1, o = null, s = r;
                    return function(n) {
                        if (n < 1 || n > i) return e(n);
                        s + n > r && (o = e(r), s = 0);
                        var a = t.call(o, s, s += n);
                        return 7 & s && (s = 1 + (7 | s)), a;
                    };
                };
            },
            4997: (e48, t25)=>{
                "use strict";
                var n14 = t25;
                n14.length = function(e) {
                    for(var t = 0, n = 0, r = 0; r < e.length; ++r)(n = e.charCodeAt(r)) < 128 ? t += 1 : n < 2048 ? t += 2 : 55296 == (64512 & n) && 56320 == (64512 & e.charCodeAt(r + 1)) ? (++r, t += 4) : t += 3;
                    return t;
                }, n14.read = function(e, t, n) {
                    if (n - t < 1) return "";
                    for(var r, i = null, o = [], s = 0; t < n;)(r = e[t++]) < 128 ? o[s++] = r : r > 191 && r < 224 ? o[s++] = (31 & r) << 6 | 63 & e[t++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, o[s++] = 55296 + (r >> 10), o[s++] = 56320 + (1023 & r)) : o[s++] = (15 & r) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), s = 0);
                    return i ? (s && i.push(String.fromCharCode.apply(String, o.slice(0, s))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, s));
                }, n14.write = function(e, t, n) {
                    for(var r, i, o = n, s = 0; s < e.length; ++s)(r = e.charCodeAt(s)) < 128 ? t[n++] = r : r < 2048 ? (t[n++] = r >> 6 | 192, t[n++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = e.charCodeAt(s + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++s, t[n++] = r >> 18 | 240, t[n++] = r >> 12 & 63 | 128, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128) : (t[n++] = r >> 12 | 224, t[n++] = r >> 6 & 63 | 128, t[n++] = 63 & r | 128);
                    return n - o;
                };
            },
            4819: (e49, t26, n15)=>{
                "use strict";
                n15.r(t26), n15.d(t26, {
                    flatbuffers: ()=>r14
                });
                var r14 = {};
                r14.Offset, r14.Table, r14.SIZEOF_SHORT = 2, r14.SIZEOF_INT = 4, r14.FILE_IDENTIFIER_LENGTH = 4, r14.SIZE_PREFIX_LENGTH = 4, r14.Encoding = {
                    UTF8_BYTES: 1,
                    UTF16_STRING: 2
                }, r14.int32 = new Int32Array(2), r14.float32 = new Float32Array(r14.int32.buffer), r14.float64 = new Float64Array(r14.int32.buffer), r14.isLittleEndian = 1 === new Uint16Array(new Uint8Array([
                    1,
                    0
                ]).buffer)[0], r14.Long = function(e, t) {
                    this.low = 0 | e, this.high = 0 | t;
                }, r14.Long.create = function(e, t) {
                    return 0 == e && 0 == t ? r14.Long.ZERO : new r14.Long(e, t);
                }, r14.Long.prototype.toFloat64 = function() {
                    return (this.low >>> 0) + 4294967296 * this.high;
                }, r14.Long.prototype.equals = function(e) {
                    return this.low == e.low && this.high == e.high;
                }, r14.Long.ZERO = new r14.Long(0, 0), r14.Builder = function(e) {
                    if (e) t = e;
                    else var t = 1024;
                    this.bb = r14.ByteBuffer.allocate(t), this.space = t, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;
                }, r14.Builder.prototype.clear = function() {
                    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;
                }, r14.Builder.prototype.forceDefaults = function(e) {
                    this.force_defaults = e;
                }, r14.Builder.prototype.dataBuffer = function() {
                    return this.bb;
                }, r14.Builder.prototype.asUint8Array = function() {
                    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
                }, r14.Builder.prototype.prep = function(e, t) {
                    e > this.minalign && (this.minalign = e);
                    for(var n = 1 + ~(this.bb.capacity() - this.space + t) & e - 1; this.space < n + e + t;){
                        var i = this.bb.capacity();
                        this.bb = r14.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
                    }
                    this.pad(n);
                }, r14.Builder.prototype.pad = function(e) {
                    for(var t = 0; t < e; t++)this.bb.writeInt8(--this.space, 0);
                }, r14.Builder.prototype.writeInt8 = function(e) {
                    this.bb.writeInt8(this.space -= 1, e);
                }, r14.Builder.prototype.writeInt16 = function(e) {
                    this.bb.writeInt16(this.space -= 2, e);
                }, r14.Builder.prototype.writeInt32 = function(e) {
                    this.bb.writeInt32(this.space -= 4, e);
                }, r14.Builder.prototype.writeInt64 = function(e) {
                    this.bb.writeInt64(this.space -= 8, e);
                }, r14.Builder.prototype.writeFloat32 = function(e) {
                    this.bb.writeFloat32(this.space -= 4, e);
                }, r14.Builder.prototype.writeFloat64 = function(e) {
                    this.bb.writeFloat64(this.space -= 8, e);
                }, r14.Builder.prototype.addInt8 = function(e) {
                    this.prep(1, 0), this.writeInt8(e);
                }, r14.Builder.prototype.addInt16 = function(e) {
                    this.prep(2, 0), this.writeInt16(e);
                }, r14.Builder.prototype.addInt32 = function(e) {
                    this.prep(4, 0), this.writeInt32(e);
                }, r14.Builder.prototype.addInt64 = function(e) {
                    this.prep(8, 0), this.writeInt64(e);
                }, r14.Builder.prototype.addFloat32 = function(e) {
                    this.prep(4, 0), this.writeFloat32(e);
                }, r14.Builder.prototype.addFloat64 = function(e) {
                    this.prep(8, 0), this.writeFloat64(e);
                }, r14.Builder.prototype.addFieldInt8 = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addInt8(t), this.slot(e));
                }, r14.Builder.prototype.addFieldInt16 = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addInt16(t), this.slot(e));
                }, r14.Builder.prototype.addFieldInt32 = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addInt32(t), this.slot(e));
                }, r14.Builder.prototype.addFieldInt64 = function(e, t, n) {
                    !this.force_defaults && t.equals(n) || (this.addInt64(t), this.slot(e));
                }, r14.Builder.prototype.addFieldFloat32 = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addFloat32(t), this.slot(e));
                }, r14.Builder.prototype.addFieldFloat64 = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addFloat64(t), this.slot(e));
                }, r14.Builder.prototype.addFieldOffset = function(e, t, n) {
                    (this.force_defaults || t != n) && (this.addOffset(t), this.slot(e));
                }, r14.Builder.prototype.addFieldStruct = function(e, t, n) {
                    t != n && (this.nested(t), this.slot(e));
                }, r14.Builder.prototype.nested = function(e) {
                    if (e != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.");
                }, r14.Builder.prototype.notNested = function() {
                    if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.");
                }, r14.Builder.prototype.slot = function(e) {
                    this.vtable[e] = this.offset();
                }, r14.Builder.prototype.offset = function() {
                    return this.bb.capacity() - this.space;
                }, r14.Builder.growByteBuffer = function(e) {
                    var t = e.capacity();
                    if (3221225472 & t) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
                    var n = t << 1, i = r14.ByteBuffer.allocate(n);
                    return i.setPosition(n - t), i.bytes().set(e.bytes(), n - t), i;
                }, r14.Builder.prototype.addOffset = function(e) {
                    this.prep(r14.SIZEOF_INT, 0), this.writeInt32(this.offset() - e + r14.SIZEOF_INT);
                }, r14.Builder.prototype.startObject = function(e) {
                    this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e;
                    for(var t = 0; t < e; t++)this.vtable[t] = 0;
                    this.isNested = !0, this.object_start = this.offset();
                }, r14.Builder.prototype.endObject = function() {
                    if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
                    this.addInt32(0);
                    for(var e = this.offset(), t = this.vtable_in_use - 1; t >= 0 && 0 == this.vtable[t]; t--);
                    for(var n = t + 1; t >= 0; t--)this.addInt16(0 != this.vtable[t] ? e - this.vtable[t] : 0);
                    this.addInt16(e - this.object_start);
                    var i = (n + 2) * r14.SIZEOF_SHORT;
                    this.addInt16(i);
                    var o = 0, s = this.space;
                    e: for(t = 0; t < this.vtables.length; t++){
                        var a = this.bb.capacity() - this.vtables[t];
                        if (i == this.bb.readInt16(a)) {
                            for(var u = r14.SIZEOF_SHORT; u < i; u += r14.SIZEOF_SHORT)if (this.bb.readInt16(s + u) != this.bb.readInt16(a + u)) continue e;
                            o = this.vtables[t];
                            break;
                        }
                    }
                    return o ? (this.space = this.bb.capacity() - e, this.bb.writeInt32(this.space, o - e)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e, this.offset() - e)), this.isNested = !1, e;
                }, r14.Builder.prototype.finish = function(e, t, n) {
                    var i = n ? r14.SIZE_PREFIX_LENGTH : 0;
                    if (t) {
                        var o = t;
                        if (this.prep(this.minalign, r14.SIZEOF_INT + r14.FILE_IDENTIFIER_LENGTH + i), o.length != r14.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r14.FILE_IDENTIFIER_LENGTH);
                        for(var s = r14.FILE_IDENTIFIER_LENGTH - 1; s >= 0; s--)this.writeInt8(o.charCodeAt(s));
                    }
                    this.prep(this.minalign, r14.SIZEOF_INT + i), this.addOffset(e), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
                }, r14.Builder.prototype.finishSizePrefixed = function(e, t) {
                    this.finish(e, t, !0);
                }, r14.Builder.prototype.requiredField = function(e, t) {
                    var n = this.bb.capacity() - e, r = n - this.bb.readInt32(n);
                    if (0 == this.bb.readInt16(r + t)) throw new Error("FlatBuffers: field " + t + " must be set");
                }, r14.Builder.prototype.startVector = function(e, t, n) {
                    this.notNested(), this.vector_num_elems = t, this.prep(r14.SIZEOF_INT, e * t), this.prep(n, e * t);
                }, r14.Builder.prototype.endVector = function() {
                    return this.writeInt32(this.vector_num_elems), this.offset();
                }, r14.Builder.prototype.createString = function(e) {
                    if (e instanceof Uint8Array) var t = e;
                    else {
                        t = [];
                        for(var n = 0; n < e.length;){
                            var r, i = e.charCodeAt(n++);
                            (r = i < 55296 || i >= 56320 ? i : (i << 10) + e.charCodeAt(n++) + -56613888) < 128 ? t.push(r) : (r < 2048 ? t.push(r >> 6 & 31 | 192) : (r < 65536 ? t.push(r >> 12 & 15 | 224) : t.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), t.push(r >> 6 & 63 | 128)), t.push(63 & r | 128));
                        }
                    }
                    this.addInt8(0), this.startVector(1, t.length, 1), this.bb.setPosition(this.space -= t.length), n = 0;
                    for(var o = this.space, s = this.bb.bytes(); n < t.length; n++)s[o++] = t[n];
                    return this.endVector();
                }, r14.Builder.prototype.createLong = function(e, t) {
                    return r14.Long.create(e, t);
                }, r14.ByteBuffer = function(e) {
                    this.bytes_ = e, this.position_ = 0;
                }, r14.ByteBuffer.allocate = function(e) {
                    return new r14.ByteBuffer(new Uint8Array(e));
                }, r14.ByteBuffer.prototype.clear = function() {
                    this.position_ = 0;
                }, r14.ByteBuffer.prototype.bytes = function() {
                    return this.bytes_;
                }, r14.ByteBuffer.prototype.position = function() {
                    return this.position_;
                }, r14.ByteBuffer.prototype.setPosition = function(e) {
                    this.position_ = e;
                }, r14.ByteBuffer.prototype.capacity = function() {
                    return this.bytes_.length;
                }, r14.ByteBuffer.prototype.readInt8 = function(e) {
                    return this.readUint8(e) << 24 >> 24;
                }, r14.ByteBuffer.prototype.readUint8 = function(e) {
                    return this.bytes_[e];
                }, r14.ByteBuffer.prototype.readInt16 = function(e) {
                    return this.readUint16(e) << 16 >> 16;
                }, r14.ByteBuffer.prototype.readUint16 = function(e) {
                    return this.bytes_[e] | this.bytes_[e + 1] << 8;
                }, r14.ByteBuffer.prototype.readInt32 = function(e) {
                    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
                }, r14.ByteBuffer.prototype.readUint32 = function(e) {
                    return this.readInt32(e) >>> 0;
                }, r14.ByteBuffer.prototype.readInt64 = function(e) {
                    return new r14.Long(this.readInt32(e), this.readInt32(e + 4));
                }, r14.ByteBuffer.prototype.readUint64 = function(e) {
                    return new r14.Long(this.readUint32(e), this.readUint32(e + 4));
                }, r14.ByteBuffer.prototype.readFloat32 = function(e) {
                    return r14.int32[0] = this.readInt32(e), r14.float32[0];
                }, r14.ByteBuffer.prototype.readFloat64 = function(e) {
                    return r14.int32[r14.isLittleEndian ? 0 : 1] = this.readInt32(e), r14.int32[r14.isLittleEndian ? 1 : 0] = this.readInt32(e + 4), r14.float64[0];
                }, r14.ByteBuffer.prototype.writeInt8 = function(e, t) {
                    this.bytes_[e] = t;
                }, r14.ByteBuffer.prototype.writeUint8 = function(e, t) {
                    this.bytes_[e] = t;
                }, r14.ByteBuffer.prototype.writeInt16 = function(e, t) {
                    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
                }, r14.ByteBuffer.prototype.writeUint16 = function(e, t) {
                    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
                }, r14.ByteBuffer.prototype.writeInt32 = function(e, t) {
                    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
                }, r14.ByteBuffer.prototype.writeUint32 = function(e, t) {
                    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
                }, r14.ByteBuffer.prototype.writeInt64 = function(e, t) {
                    this.writeInt32(e, t.low), this.writeInt32(e + 4, t.high);
                }, r14.ByteBuffer.prototype.writeUint64 = function(e, t) {
                    this.writeUint32(e, t.low), this.writeUint32(e + 4, t.high);
                }, r14.ByteBuffer.prototype.writeFloat32 = function(e, t) {
                    r14.float32[0] = t, this.writeInt32(e, r14.int32[0]);
                }, r14.ByteBuffer.prototype.writeFloat64 = function(e, t) {
                    r14.float64[0] = t, this.writeInt32(e, r14.int32[r14.isLittleEndian ? 0 : 1]), this.writeInt32(e + 4, r14.int32[r14.isLittleEndian ? 1 : 0]);
                }, r14.ByteBuffer.prototype.getBufferIdentifier = function() {
                    if (this.bytes_.length < this.position_ + r14.SIZEOF_INT + r14.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
                    for(var e = "", t = 0; t < r14.FILE_IDENTIFIER_LENGTH; t++)e += String.fromCharCode(this.readInt8(this.position_ + r14.SIZEOF_INT + t));
                    return e;
                }, r14.ByteBuffer.prototype.__offset = function(e, t) {
                    var n = e - this.readInt32(e);
                    return t < this.readInt16(n) ? this.readInt16(n + t) : 0;
                }, r14.ByteBuffer.prototype.__union = function(e, t) {
                    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
                }, r14.ByteBuffer.prototype.__string = function(e, t) {
                    e += this.readInt32(e);
                    var n = this.readInt32(e), i = "", o = 0;
                    if (e += r14.SIZEOF_INT, t === r14.Encoding.UTF8_BYTES) return this.bytes_.subarray(e, e + n);
                    for(; o < n;){
                        var s, a = this.readUint8(e + o++);
                        if (a < 192) s = a;
                        else {
                            var u = this.readUint8(e + o++);
                            if (a < 224) s = (31 & a) << 6 | 63 & u;
                            else {
                                var l = this.readUint8(e + o++);
                                s = a < 240 ? (15 & a) << 12 | (63 & u) << 6 | 63 & l : (7 & a) << 18 | (63 & u) << 12 | (63 & l) << 6 | 63 & this.readUint8(e + o++);
                            }
                        }
                        s < 65536 ? i += String.fromCharCode(s) : (s -= 65536, i += String.fromCharCode(55296 + (s >> 10), 56320 + (1023 & s)));
                    }
                    return i;
                }, r14.ByteBuffer.prototype.__indirect = function(e) {
                    return e + this.readInt32(e);
                }, r14.ByteBuffer.prototype.__vector = function(e) {
                    return e + this.readInt32(e) + r14.SIZEOF_INT;
                }, r14.ByteBuffer.prototype.__vector_len = function(e) {
                    return this.readInt32(e + this.readInt32(e));
                }, r14.ByteBuffer.prototype.__has_identifier = function(e) {
                    if (e.length != r14.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r14.FILE_IDENTIFIER_LENGTH);
                    for(var t = 0; t < r14.FILE_IDENTIFIER_LENGTH; t++)if (e.charCodeAt(t) != this.readInt8(this.position_ + r14.SIZEOF_INT + t)) return !1;
                    return !0;
                }, r14.ByteBuffer.prototype.createLong = function(e, t) {
                    return r14.Long.create(e, t);
                };
            },
            3442: (e50, t27)=>{
                "use strict";
                t27.__esModule = !0;
                var n16 = function() {
                    function e51(t) {
                        if (!t) throw new TypeError("Invalid argument; `value` has no value.");
                        this.value = e51.EMPTY, t && e51.isGuid(t) && (this.value = t);
                    }
                    return e51.isGuid = function(t) {
                        var n = t.toString();
                        return t && (t instanceof e51 || e51.validator.test(n));
                    }, e51.create = function() {
                        return new e51([
                            e51.gen(2),
                            e51.gen(1),
                            e51.gen(1),
                            e51.gen(1),
                            e51.gen(3)
                        ].join("-"));
                    }, e51.createEmpty = function() {
                        return new e51("emptyguid");
                    }, e51.parse = function(t) {
                        return new e51(t);
                    }, e51.raw = function() {
                        return [
                            e51.gen(2),
                            e51.gen(1),
                            e51.gen(1),
                            e51.gen(1),
                            e51.gen(3)
                        ].join("-");
                    }, e51.gen = function(e) {
                        for(var t = "", n = 0; n < e; n++)t += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
                        return t;
                    }, e51.prototype.equals = function(t) {
                        return e51.isGuid(t) && this.value === t.toString();
                    }, e51.prototype.isEmpty = function() {
                        return this.value === e51.EMPTY;
                    }, e51.prototype.toString = function() {
                        return this.value;
                    }, e51.prototype.toJSON = function() {
                        return {
                            value: this.value
                        };
                    }, e51.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), e51.EMPTY = "00000000-0000-0000-0000-000000000000", e51;
                }();
                t27.Guid = n16;
            },
            3720: (e53)=>{
                e53.exports = n17;
                var t28 = null;
                try {
                    t28 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
                        0,
                        97,
                        115,
                        109,
                        1,
                        0,
                        0,
                        0,
                        1,
                        13,
                        2,
                        96,
                        0,
                        1,
                        127,
                        96,
                        4,
                        127,
                        127,
                        127,
                        127,
                        1,
                        127,
                        3,
                        7,
                        6,
                        0,
                        1,
                        1,
                        1,
                        1,
                        1,
                        6,
                        6,
                        1,
                        127,
                        1,
                        65,
                        0,
                        11,
                        7,
                        50,
                        6,
                        3,
                        109,
                        117,
                        108,
                        0,
                        1,
                        5,
                        100,
                        105,
                        118,
                        95,
                        115,
                        0,
                        2,
                        5,
                        100,
                        105,
                        118,
                        95,
                        117,
                        0,
                        3,
                        5,
                        114,
                        101,
                        109,
                        95,
                        115,
                        0,
                        4,
                        5,
                        114,
                        101,
                        109,
                        95,
                        117,
                        0,
                        5,
                        8,
                        103,
                        101,
                        116,
                        95,
                        104,
                        105,
                        103,
                        104,
                        0,
                        0,
                        10,
                        191,
                        1,
                        6,
                        4,
                        0,
                        35,
                        0,
                        11,
                        36,
                        1,
                        1,
                        126,
                        32,
                        0,
                        173,
                        32,
                        1,
                        173,
                        66,
                        32,
                        134,
                        132,
                        32,
                        2,
                        173,
                        32,
                        3,
                        173,
                        66,
                        32,
                        134,
                        132,
                        126,
                        34,
                        4,
                        66,
                        32,
                        135,
                        167,
                        36,
                        0,
                        32,
                        4,
                        167,
                        11,
                        36,
                        1,
                        1,
                        126,
                        32,
                        0,
                        173,
                        32,
                        1,
                        173,
                        66,
                        32,
                        134,
                        132,
                        32,
                        2,
                        173,
                        32,
                        3,
                        173,
                        66,
                        32,
                        134,
                        132,
                        127,
                        34,
                        4,
                        66,
                        32,
                        135,
                        167,
                        36,
                        0,
                        32,
                        4,
                        167,
                        11,
                        36,
                        1,
                        1,
                        126,
                        32,
                        0,
                        173,
                        32,
                        1,
                        173,
                        66,
                        32,
                        134,
                        132,
                        32,
                        2,
                        173,
                        32,
                        3,
                        173,
                        66,
                        32,
                        134,
                        132,
                        128,
                        34,
                        4,
                        66,
                        32,
                        135,
                        167,
                        36,
                        0,
                        32,
                        4,
                        167,
                        11,
                        36,
                        1,
                        1,
                        126,
                        32,
                        0,
                        173,
                        32,
                        1,
                        173,
                        66,
                        32,
                        134,
                        132,
                        32,
                        2,
                        173,
                        32,
                        3,
                        173,
                        66,
                        32,
                        134,
                        132,
                        129,
                        34,
                        4,
                        66,
                        32,
                        135,
                        167,
                        36,
                        0,
                        32,
                        4,
                        167,
                        11,
                        36,
                        1,
                        1,
                        126,
                        32,
                        0,
                        173,
                        32,
                        1,
                        173,
                        66,
                        32,
                        134,
                        132,
                        32,
                        2,
                        173,
                        32,
                        3,
                        173,
                        66,
                        32,
                        134,
                        132,
                        130,
                        34,
                        4,
                        66,
                        32,
                        135,
                        167,
                        36,
                        0,
                        32,
                        4,
                        167,
                        11
                    ])), {}).exports;
                } catch (e52) {}
                function n17(e, t, n) {
                    this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n;
                }
                function r15(e) {
                    return !0 === (e && e.__isLong__);
                }
                n17.prototype.__isLong__, Object.defineProperty(n17.prototype, "__isLong__", {
                    value: !0
                }), n17.isLong = r15;
                var i8 = {}, o5 = {};
                function s6(e, t) {
                    var n, r, s;
                    return t ? (s = 0 <= (e >>>= 0) && e < 256) && (r = o5[e]) ? r : (n = u3(e, (0 | e) < 0 ? -1 : 0, !0), s && (o5[e] = n), n) : (s = -128 <= (e |= 0) && e < 128) && (r = i8[e]) ? r : (n = u3(e, e < 0 ? -1 : 0, !1), s && (i8[e] = n), n);
                }
                function a3(e, t) {
                    if (isNaN(e)) return t ? b1 : m;
                    if (t) {
                        if (e < 0) return b1;
                        if (e >= f2) return x;
                    } else {
                        if (e <= -h2) return T;
                        if (e + 1 >= h2) return w;
                    }
                    return e < 0 ? a3(-e, t).neg() : u3(e % d3 | 0, e / d3 | 0, t);
                }
                function u3(e, t, r) {
                    return new n17(e, t, r);
                }
                n17.fromInt = s6, n17.fromNumber = a3, n17.fromBits = u3;
                var l3 = Math.pow;
                function c3(e, t, n) {
                    if (0 === e.length) throw Error("empty string");
                    if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return m;
                    if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
                    var r;
                    if ((r = e.indexOf("-")) > 0) throw Error("interior hyphen");
                    if (0 === r) return c3(e.substring(1), t, n).neg();
                    for(var i = a3(l3(n, 8)), o = m, s = 0; s < e.length; s += 8){
                        var u = Math.min(8, e.length - s), p = parseInt(e.substring(s, s + u), n);
                        if (u < 8) {
                            var d = a3(l3(n, u));
                            o = o.mul(d).add(a3(p));
                        } else o = (o = o.mul(i)).add(a3(p));
                    }
                    return o.unsigned = t, o;
                }
                function p3(e, t) {
                    return "number" == typeof e ? a3(e, t) : "string" == typeof e ? c3(e, t) : u3(e.low, e.high, "boolean" == typeof t ? t : e.unsigned);
                }
                n17.fromString = c3, n17.fromValue = p3;
                var d3 = 4294967296, f2 = d3 * d3, h2 = f2 / 2, g = s6(16777216), m = s6(0);
                n17.ZERO = m;
                var b1 = s6(0, !0);
                n17.UZERO = b1;
                var y1 = s6(1);
                n17.ONE = y1;
                var _1 = s6(1, !0);
                n17.UONE = _1;
                var v = s6(-1);
                n17.NEG_ONE = v;
                var w = u3(-1, 2147483647, !1);
                n17.MAX_VALUE = w;
                var x = u3(-1, -1, !0);
                n17.MAX_UNSIGNED_VALUE = x;
                var T = u3(0, -2147483648, !1);
                n17.MIN_VALUE = T;
                var O = n17.prototype;
                O.toInt = function() {
                    return this.unsigned ? this.low >>> 0 : this.low;
                }, O.toNumber = function() {
                    return this.unsigned ? (this.high >>> 0) * d3 + (this.low >>> 0) : this.high * d3 + (this.low >>> 0);
                }, O.toString = function(e) {
                    if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
                    if (this.isZero()) return "0";
                    if (this.isNegative()) {
                        if (this.eq(T)) {
                            var t = a3(e), n = this.div(t), r = n.mul(t).sub(this);
                            return n.toString(e) + r.toInt().toString(e);
                        }
                        return "-" + this.neg().toString(e);
                    }
                    for(var i = a3(l3(e, 6), this.unsigned), o = this, s = "";;){
                        var u = o.div(i), c = (o.sub(u.mul(i)).toInt() >>> 0).toString(e);
                        if ((o = u).isZero()) return c + s;
                        for(; c.length < 6;)c = "0" + c;
                        s = "" + c + s;
                    }
                }, O.getHighBits = function() {
                    return this.high;
                }, O.getHighBitsUnsigned = function() {
                    return this.high >>> 0;
                }, O.getLowBits = function() {
                    return this.low;
                }, O.getLowBitsUnsigned = function() {
                    return this.low >>> 0;
                }, O.getNumBitsAbs = function() {
                    if (this.isNegative()) return this.eq(T) ? 64 : this.neg().getNumBitsAbs();
                    for(var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--);
                    return 0 != this.high ? t + 33 : t + 1;
                }, O.isZero = function() {
                    return 0 === this.high && 0 === this.low;
                }, O.eqz = O.isZero, O.isNegative = function() {
                    return !this.unsigned && this.high < 0;
                }, O.isPositive = function() {
                    return this.unsigned || this.high >= 0;
                }, O.isOdd = function() {
                    return 1 == (1 & this.low);
                }, O.isEven = function() {
                    return 0 == (1 & this.low);
                }, O.equals = function(e) {
                    return r15(e) || (e = p3(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && this.high === e.high && this.low === e.low;
                }, O.eq = O.equals, O.notEquals = function(e) {
                    return !this.eq(e);
                }, O.neq = O.notEquals, O.ne = O.notEquals, O.lessThan = function(e) {
                    return this.comp(e) < 0;
                }, O.lt = O.lessThan, O.lessThanOrEqual = function(e) {
                    return this.comp(e) <= 0;
                }, O.lte = O.lessThanOrEqual, O.le = O.lessThanOrEqual, O.greaterThan = function(e) {
                    return this.comp(e) > 0;
                }, O.gt = O.greaterThan, O.greaterThanOrEqual = function(e) {
                    return this.comp(e) >= 0;
                }, O.gte = O.greaterThanOrEqual, O.ge = O.greaterThanOrEqual, O.compare = function(e) {
                    if (r15(e) || (e = p3(e)), this.eq(e)) return 0;
                    var t = this.isNegative(), n = e.isNegative();
                    return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
                }, O.comp = O.compare, O.negate = function() {
                    return !this.unsigned && this.eq(T) ? T : this.not().add(y1);
                }, O.neg = O.negate, O.add = function(e) {
                    r15(e) || (e = p3(e));
                    var t = this.high >>> 16, n = 65535 & this.high, i = this.low >>> 16, o = 65535 & this.low, s = e.high >>> 16, a = 65535 & e.high, l = e.low >>> 16, c = 0, d = 0, f = 0, h = 0;
                    return f += (h += o + (65535 & e.low)) >>> 16, d += (f += i + l) >>> 16, c += (d += n + a) >>> 16, c += t + s, u3((f &= 65535) << 16 | (h &= 65535), (c &= 65535) << 16 | (d &= 65535), this.unsigned);
                }, O.subtract = function(e) {
                    return r15(e) || (e = p3(e)), this.add(e.neg());
                }, O.sub = O.subtract, O.multiply = function(e) {
                    if (this.isZero()) return m;
                    if (r15(e) || (e = p3(e)), t28) return u3(t28.mul(this.low, this.high, e.low, e.high), t28.get_high(), this.unsigned);
                    if (e.isZero()) return m;
                    if (this.eq(T)) return e.isOdd() ? T : m;
                    if (e.eq(T)) return this.isOdd() ? T : m;
                    if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
                    if (e.isNegative()) return this.mul(e.neg()).neg();
                    if (this.lt(g) && e.lt(g)) return a3(this.toNumber() * e.toNumber(), this.unsigned);
                    var n = this.high >>> 16, i = 65535 & this.high, o = this.low >>> 16, s = 65535 & this.low, l = e.high >>> 16, c = 65535 & e.high, d = e.low >>> 16, f = 65535 & e.low, h = 0, b = 0, y = 0, _ = 0;
                    return y += (_ += s * f) >>> 16, b += (y += o * f) >>> 16, y &= 65535, b += (y += s * d) >>> 16, h += (b += i * f) >>> 16, b &= 65535, h += (b += o * d) >>> 16, b &= 65535, h += (b += s * c) >>> 16, h += n * f + i * d + o * c + s * l, u3((y &= 65535) << 16 | (_ &= 65535), (h &= 65535) << 16 | (b &= 65535), this.unsigned);
                }, O.mul = O.multiply, O.divide = function(e) {
                    if (r15(e) || (e = p3(e)), e.isZero()) throw Error("division by zero");
                    var n, i, o;
                    if (t28) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? u3((this.unsigned ? t28.div_u : t28.div_s)(this.low, this.high, e.low, e.high), t28.get_high(), this.unsigned) : this;
                    if (this.isZero()) return this.unsigned ? b1 : m;
                    if (this.unsigned) {
                        if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return b1;
                        if (e.gt(this.shru(1))) return _1;
                        o = b1;
                    } else {
                        if (this.eq(T)) return e.eq(y1) || e.eq(v) ? T : e.eq(T) ? y1 : (n = this.shr(1).div(e).shl(1)).eq(m) ? e.isNegative() ? y1 : v : (i = this.sub(e.mul(n)), o = n.add(i.div(e)));
                        if (e.eq(T)) return this.unsigned ? b1 : m;
                        if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
                        if (e.isNegative()) return this.div(e.neg()).neg();
                        o = m;
                    }
                    for(i = this; i.gte(e);){
                        n = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
                        for(var s = Math.ceil(Math.log(n) / Math.LN2), c = s <= 48 ? 1 : l3(2, s - 48), d = a3(n), f = d.mul(e); f.isNegative() || f.gt(i);)f = (d = a3(n -= c, this.unsigned)).mul(e);
                        d.isZero() && (d = y1), o = o.add(d), i = i.sub(f);
                    }
                    return o;
                }, O.div = O.divide, O.modulo = function(e) {
                    return r15(e) || (e = p3(e)), t28 ? u3((this.unsigned ? t28.rem_u : t28.rem_s)(this.low, this.high, e.low, e.high), t28.get_high(), this.unsigned) : this.sub(this.div(e).mul(e));
                }, O.mod = O.modulo, O.rem = O.modulo, O.not = function() {
                    return u3(~this.low, ~this.high, this.unsigned);
                }, O.and = function(e) {
                    return r15(e) || (e = p3(e)), u3(this.low & e.low, this.high & e.high, this.unsigned);
                }, O.or = function(e) {
                    return r15(e) || (e = p3(e)), u3(this.low | e.low, this.high | e.high, this.unsigned);
                }, O.xor = function(e) {
                    return r15(e) || (e = p3(e)), u3(this.low ^ e.low, this.high ^ e.high, this.unsigned);
                }, O.shiftLeft = function(e) {
                    return r15(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? u3(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : u3(0, this.low << e - 32, this.unsigned);
                }, O.shl = O.shiftLeft, O.shiftRight = function(e) {
                    return r15(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? u3(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : u3(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
                }, O.shr = O.shiftRight, O.shiftRightUnsigned = function(e) {
                    if (r15(e) && (e = e.toInt()), 0 == (e &= 63)) return this;
                    var t = this.high;
                    return e < 32 ? u3(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : u3(32 === e ? t : t >>> e - 32, 0, this.unsigned);
                }, O.shru = O.shiftRightUnsigned, O.shr_u = O.shiftRightUnsigned, O.toSigned = function() {
                    return this.unsigned ? u3(this.low, this.high, !1) : this;
                }, O.toUnsigned = function() {
                    return this.unsigned ? this : u3(this.low, this.high, !0);
                }, O.toBytes = function(e) {
                    return e ? this.toBytesLE() : this.toBytesBE();
                }, O.toBytesLE = function() {
                    var e = this.high, t = this.low;
                    return [
                        255 & t,
                        t >>> 8 & 255,
                        t >>> 16 & 255,
                        t >>> 24,
                        255 & e,
                        e >>> 8 & 255,
                        e >>> 16 & 255,
                        e >>> 24
                    ];
                }, O.toBytesBE = function() {
                    var e = this.high, t = this.low;
                    return [
                        e >>> 24,
                        e >>> 16 & 255,
                        e >>> 8 & 255,
                        255 & e,
                        t >>> 24,
                        t >>> 16 & 255,
                        t >>> 8 & 255,
                        255 & t
                    ];
                }, n17.fromBytes = function(e, t, r) {
                    return r ? n17.fromBytesLE(e, t) : n17.fromBytesBE(e, t);
                }, n17.fromBytesLE = function(e, t) {
                    return new n17(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
                }, n17.fromBytesBE = function(e, t) {
                    return new n17(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
                };
            },
            1446: (e54, t29, n18)=>{
                "use strict";
                var r16, i9, o6, s = n18(2100), a = s.Reader, u = s.Writer, l = s.util, c = s.roots.default || (s.roots.default = {});
                c.onnx = ((o6 = {}).Version = (r16 = {}, (i9 = Object.create(r16))[r16[0] = "_START_VERSION"] = 0, i9[r16[1] = "IR_VERSION_2017_10_10"] = 1, i9[r16[2] = "IR_VERSION_2017_10_30"] = 2, i9[r16[3] = "IR_VERSION_2017_11_3"] = 3, i9[r16[4] = "IR_VERSION_2019_1_22"] = 4, i9[r16[5] = "IR_VERSION"] = 5, i9), o6.AttributeProto = function() {
                    function e55(e) {
                        if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e55.prototype.name = "", e55.prototype.refAttrName = "", e55.prototype.docString = "", e55.prototype.type = 0, e55.prototype.f = 0, e55.prototype.i = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e55.prototype.s = l.newBuffer([]), e55.prototype.t = null, e55.prototype.g = null, e55.prototype.floats = l.emptyArray, e55.prototype.ints = l.emptyArray, e55.prototype.strings = l.emptyArray, e55.prototype.tensors = l.emptyArray, e55.prototype.graphs = l.emptyArray, e55.create = function(t) {
                        return new e55(t);
                    }, e55.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.name && e.hasOwnProperty("name") && t.uint32(10).string(e.name), null != e.f && e.hasOwnProperty("f") && t.uint32(21).float(e.f), null != e.i && e.hasOwnProperty("i") && t.uint32(24).int64(e.i), null != e.s && e.hasOwnProperty("s") && t.uint32(34).bytes(e.s), null != e.t && e.hasOwnProperty("t") && c.onnx.TensorProto.encode(e.t, t.uint32(42).fork()).ldelim(), null != e.g && e.hasOwnProperty("g") && c.onnx.GraphProto.encode(e.g, t.uint32(50).fork()).ldelim(), null != e.floats && e.floats.length) {
                            t.uint32(58).fork();
                            for(var n = 0; n < e.floats.length; ++n)t.float(e.floats[n]);
                            t.ldelim();
                        }
                        if (null != e.ints && e.ints.length) {
                            for(t.uint32(66).fork(), n = 0; n < e.ints.length; ++n)t.int64(e.ints[n]);
                            t.ldelim();
                        }
                        if (null != e.strings && e.strings.length) for(n = 0; n < e.strings.length; ++n)t.uint32(74).bytes(e.strings[n]);
                        if (null != e.tensors && e.tensors.length) for(n = 0; n < e.tensors.length; ++n)c.onnx.TensorProto.encode(e.tensors[n], t.uint32(82).fork()).ldelim();
                        if (null != e.graphs && e.graphs.length) for(n = 0; n < e.graphs.length; ++n)c.onnx.GraphProto.encode(e.graphs[n], t.uint32(90).fork()).ldelim();
                        return null != e.docString && e.hasOwnProperty("docString") && t.uint32(106).string(e.docString), null != e.type && e.hasOwnProperty("type") && t.uint32(160).int32(e.type), null != e.refAttrName && e.hasOwnProperty("refAttrName") && t.uint32(170).string(e.refAttrName), t;
                    }, e55.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e55.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.AttributeProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.name = e.string();
                                    break;
                                case 21:
                                    r.refAttrName = e.string();
                                    break;
                                case 13:
                                    r.docString = e.string();
                                    break;
                                case 20:
                                    r.type = e.int32();
                                    break;
                                case 2:
                                    r.f = e.float();
                                    break;
                                case 3:
                                    r.i = e.int64();
                                    break;
                                case 4:
                                    r.s = e.bytes();
                                    break;
                                case 5:
                                    r.t = c.onnx.TensorProto.decode(e, e.uint32());
                                    break;
                                case 6:
                                    r.g = c.onnx.GraphProto.decode(e, e.uint32());
                                    break;
                                case 7:
                                    if (r.floats && r.floats.length || (r.floats = []), 2 == (7 & i)) for(var o = e.uint32() + e.pos; e.pos < o;)r.floats.push(e.float());
                                    else r.floats.push(e.float());
                                    break;
                                case 8:
                                    if (r.ints && r.ints.length || (r.ints = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.ints.push(e.int64());
                                    else r.ints.push(e.int64());
                                    break;
                                case 9:
                                    r.strings && r.strings.length || (r.strings = []), r.strings.push(e.bytes());
                                    break;
                                case 10:
                                    r.tensors && r.tensors.length || (r.tensors = []), r.tensors.push(c.onnx.TensorProto.decode(e, e.uint32()));
                                    break;
                                case 11:
                                    r.graphs && r.graphs.length || (r.graphs = []), r.graphs.push(c.onnx.GraphProto.decode(e, e.uint32()));
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e55.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e55.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.name && e.hasOwnProperty("name") && !l.isString(e.name)) return "name: string expected";
                        if (null != e.refAttrName && e.hasOwnProperty("refAttrName") && !l.isString(e.refAttrName)) return "refAttrName: string expected";
                        if (null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString)) return "docString: string expected";
                        if (null != e.type && e.hasOwnProperty("type")) switch(e.type){
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                        }
                        if (null != e.f && e.hasOwnProperty("f") && "number" != typeof e.f) return "f: number expected";
                        if (null != e.i && e.hasOwnProperty("i") && !(l.isInteger(e.i) || e.i && l.isInteger(e.i.low) && l.isInteger(e.i.high))) return "i: integer|Long expected";
                        if (null != e.s && e.hasOwnProperty("s") && !(e.s && "number" == typeof e.s.length || l.isString(e.s))) return "s: buffer expected";
                        if (null != e.t && e.hasOwnProperty("t") && (n = c.onnx.TensorProto.verify(e.t))) return "t." + n;
                        if (null != e.g && e.hasOwnProperty("g") && (n = c.onnx.GraphProto.verify(e.g))) return "g." + n;
                        if (null != e.floats && e.hasOwnProperty("floats")) {
                            if (!Array.isArray(e.floats)) return "floats: array expected";
                            for(var t = 0; t < e.floats.length; ++t)if ("number" != typeof e.floats[t]) return "floats: number[] expected";
                        }
                        if (null != e.ints && e.hasOwnProperty("ints")) {
                            if (!Array.isArray(e.ints)) return "ints: array expected";
                            for(t = 0; t < e.ints.length; ++t)if (!(l.isInteger(e.ints[t]) || e.ints[t] && l.isInteger(e.ints[t].low) && l.isInteger(e.ints[t].high))) return "ints: integer|Long[] expected";
                        }
                        if (null != e.strings && e.hasOwnProperty("strings")) {
                            if (!Array.isArray(e.strings)) return "strings: array expected";
                            for(t = 0; t < e.strings.length; ++t)if (!(e.strings[t] && "number" == typeof e.strings[t].length || l.isString(e.strings[t]))) return "strings: buffer[] expected";
                        }
                        if (null != e.tensors && e.hasOwnProperty("tensors")) {
                            if (!Array.isArray(e.tensors)) return "tensors: array expected";
                            for(t = 0; t < e.tensors.length; ++t)if (n = c.onnx.TensorProto.verify(e.tensors[t])) return "tensors." + n;
                        }
                        if (null != e.graphs && e.hasOwnProperty("graphs")) {
                            if (!Array.isArray(e.graphs)) return "graphs: array expected";
                            for(t = 0; t < e.graphs.length; ++t){
                                var n;
                                if (n = c.onnx.GraphProto.verify(e.graphs[t])) return "graphs." + n;
                            }
                        }
                        return null;
                    }, e55.fromObject = function(e) {
                        if (e instanceof c.onnx.AttributeProto) return e;
                        var t = new c.onnx.AttributeProto;
                        switch(null != e.name && (t.name = String(e.name)), null != e.refAttrName && (t.refAttrName = String(e.refAttrName)), null != e.docString && (t.docString = String(e.docString)), e.type){
                            case "UNDEFINED":
                            case 0:
                                t.type = 0;
                                break;
                            case "FLOAT":
                            case 1:
                                t.type = 1;
                                break;
                            case "INT":
                            case 2:
                                t.type = 2;
                                break;
                            case "STRING":
                            case 3:
                                t.type = 3;
                                break;
                            case "TENSOR":
                            case 4:
                                t.type = 4;
                                break;
                            case "GRAPH":
                            case 5:
                                t.type = 5;
                                break;
                            case "FLOATS":
                            case 6:
                                t.type = 6;
                                break;
                            case "INTS":
                            case 7:
                                t.type = 7;
                                break;
                            case "STRINGS":
                            case 8:
                                t.type = 8;
                                break;
                            case "TENSORS":
                            case 9:
                                t.type = 9;
                                break;
                            case "GRAPHS":
                            case 10:
                                t.type = 10;
                        }
                        if (null != e.f && (t.f = Number(e.f)), null != e.i && (l.Long ? (t.i = l.Long.fromValue(e.i)).unsigned = !1 : "string" == typeof e.i ? t.i = parseInt(e.i, 10) : "number" == typeof e.i ? t.i = e.i : "object" == typeof e.i && (t.i = new l.LongBits(e.i.low >>> 0, e.i.high >>> 0).toNumber())), null != e.s && ("string" == typeof e.s ? l.base64.decode(e.s, t.s = l.newBuffer(l.base64.length(e.s)), 0) : e.s.length && (t.s = e.s)), null != e.t) {
                            if ("object" != typeof e.t) throw TypeError(".onnx.AttributeProto.t: object expected");
                            t.t = c.onnx.TensorProto.fromObject(e.t);
                        }
                        if (null != e.g) {
                            if ("object" != typeof e.g) throw TypeError(".onnx.AttributeProto.g: object expected");
                            t.g = c.onnx.GraphProto.fromObject(e.g);
                        }
                        if (e.floats) {
                            if (!Array.isArray(e.floats)) throw TypeError(".onnx.AttributeProto.floats: array expected");
                            t.floats = [];
                            for(var n = 0; n < e.floats.length; ++n)t.floats[n] = Number(e.floats[n]);
                        }
                        if (e.ints) {
                            if (!Array.isArray(e.ints)) throw TypeError(".onnx.AttributeProto.ints: array expected");
                            for(t.ints = [], n = 0; n < e.ints.length; ++n)l.Long ? (t.ints[n] = l.Long.fromValue(e.ints[n])).unsigned = !1 : "string" == typeof e.ints[n] ? t.ints[n] = parseInt(e.ints[n], 10) : "number" == typeof e.ints[n] ? t.ints[n] = e.ints[n] : "object" == typeof e.ints[n] && (t.ints[n] = new l.LongBits(e.ints[n].low >>> 0, e.ints[n].high >>> 0).toNumber());
                        }
                        if (e.strings) {
                            if (!Array.isArray(e.strings)) throw TypeError(".onnx.AttributeProto.strings: array expected");
                            for(t.strings = [], n = 0; n < e.strings.length; ++n)"string" == typeof e.strings[n] ? l.base64.decode(e.strings[n], t.strings[n] = l.newBuffer(l.base64.length(e.strings[n])), 0) : e.strings[n].length && (t.strings[n] = e.strings[n]);
                        }
                        if (e.tensors) {
                            if (!Array.isArray(e.tensors)) throw TypeError(".onnx.AttributeProto.tensors: array expected");
                            for(t.tensors = [], n = 0; n < e.tensors.length; ++n){
                                if ("object" != typeof e.tensors[n]) throw TypeError(".onnx.AttributeProto.tensors: object expected");
                                t.tensors[n] = c.onnx.TensorProto.fromObject(e.tensors[n]);
                            }
                        }
                        if (e.graphs) {
                            if (!Array.isArray(e.graphs)) throw TypeError(".onnx.AttributeProto.graphs: array expected");
                            for(t.graphs = [], n = 0; n < e.graphs.length; ++n){
                                if ("object" != typeof e.graphs[n]) throw TypeError(".onnx.AttributeProto.graphs: object expected");
                                t.graphs[n] = c.onnx.GraphProto.fromObject(e.graphs[n]);
                            }
                        }
                        return t;
                    }, e55.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = []), t.defaults) {
                            if (n.name = "", n.f = 0, l.Long) {
                                var r = new l.Long(0, 0, !1);
                                n.i = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;
                            } else n.i = t.longs === String ? "0" : 0;
                            t.bytes === String ? n.s = "" : (n.s = [], t.bytes !== Array && (n.s = l.newBuffer(n.s))), n.t = null, n.g = null, n.docString = "", n.type = t.enums === String ? "UNDEFINED" : 0, n.refAttrName = "";
                        }
                        if (null != e.name && e.hasOwnProperty("name") && (n.name = e.name), null != e.f && e.hasOwnProperty("f") && (n.f = t.json && !isFinite(e.f) ? String(e.f) : e.f), null != e.i && e.hasOwnProperty("i") && ("number" == typeof e.i ? n.i = t.longs === String ? String(e.i) : e.i : n.i = t.longs === String ? l.Long.prototype.toString.call(e.i) : t.longs === Number ? new l.LongBits(e.i.low >>> 0, e.i.high >>> 0).toNumber() : e.i), null != e.s && e.hasOwnProperty("s") && (n.s = t.bytes === String ? l.base64.encode(e.s, 0, e.s.length) : t.bytes === Array ? Array.prototype.slice.call(e.s) : e.s), null != e.t && e.hasOwnProperty("t") && (n.t = c.onnx.TensorProto.toObject(e.t, t)), null != e.g && e.hasOwnProperty("g") && (n.g = c.onnx.GraphProto.toObject(e.g, t)), e.floats && e.floats.length) {
                            n.floats = [];
                            for(var i = 0; i < e.floats.length; ++i)n.floats[i] = t.json && !isFinite(e.floats[i]) ? String(e.floats[i]) : e.floats[i];
                        }
                        if (e.ints && e.ints.length) for(n.ints = [], i = 0; i < e.ints.length; ++i)"number" == typeof e.ints[i] ? n.ints[i] = t.longs === String ? String(e.ints[i]) : e.ints[i] : n.ints[i] = t.longs === String ? l.Long.prototype.toString.call(e.ints[i]) : t.longs === Number ? new l.LongBits(e.ints[i].low >>> 0, e.ints[i].high >>> 0).toNumber() : e.ints[i];
                        if (e.strings && e.strings.length) for(n.strings = [], i = 0; i < e.strings.length; ++i)n.strings[i] = t.bytes === String ? l.base64.encode(e.strings[i], 0, e.strings[i].length) : t.bytes === Array ? Array.prototype.slice.call(e.strings[i]) : e.strings[i];
                        if (e.tensors && e.tensors.length) for(n.tensors = [], i = 0; i < e.tensors.length; ++i)n.tensors[i] = c.onnx.TensorProto.toObject(e.tensors[i], t);
                        if (e.graphs && e.graphs.length) for(n.graphs = [], i = 0; i < e.graphs.length; ++i)n.graphs[i] = c.onnx.GraphProto.toObject(e.graphs[i], t);
                        return null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), null != e.type && e.hasOwnProperty("type") && (n.type = t.enums === String ? c.onnx.AttributeProto.AttributeType[e.type] : e.type), null != e.refAttrName && e.hasOwnProperty("refAttrName") && (n.refAttrName = e.refAttrName), n;
                    }, e55.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e55.AttributeType = function() {
                        var e = {}, t = Object.create(e);
                        return t[e[0] = "UNDEFINED"] = 0, t[e[1] = "FLOAT"] = 1, t[e[2] = "INT"] = 2, t[e[3] = "STRING"] = 3, t[e[4] = "TENSOR"] = 4, t[e[5] = "GRAPH"] = 5, t[e[6] = "FLOATS"] = 6, t[e[7] = "INTS"] = 7, t[e[8] = "STRINGS"] = 8, t[e[9] = "TENSORS"] = 9, t[e[10] = "GRAPHS"] = 10, t;
                    }(), e55;
                }(), o6.ValueInfoProto = function() {
                    function e56(e) {
                        if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e56.prototype.name = "", e56.prototype.type = null, e56.prototype.docString = "", e56.create = function(t) {
                        return new e56(t);
                    }, e56.encode = function(e, t) {
                        return t || (t = u.create()), null != e.name && e.hasOwnProperty("name") && t.uint32(10).string(e.name), null != e.type && e.hasOwnProperty("type") && c.onnx.TypeProto.encode(e.type, t.uint32(18).fork()).ldelim(), null != e.docString && e.hasOwnProperty("docString") && t.uint32(26).string(e.docString), t;
                    }, e56.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e56.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.ValueInfoProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.name = e.string();
                                    break;
                                case 2:
                                    r.type = c.onnx.TypeProto.decode(e, e.uint32());
                                    break;
                                case 3:
                                    r.docString = e.string();
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e56.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e56.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.name && e.hasOwnProperty("name") && !l.isString(e.name)) return "name: string expected";
                        if (null != e.type && e.hasOwnProperty("type")) {
                            var t = c.onnx.TypeProto.verify(e.type);
                            if (t) return "type." + t;
                        }
                        return null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString) ? "docString: string expected" : null;
                    }, e56.fromObject = function(e) {
                        if (e instanceof c.onnx.ValueInfoProto) return e;
                        var t = new c.onnx.ValueInfoProto;
                        if (null != e.name && (t.name = String(e.name)), null != e.type) {
                            if ("object" != typeof e.type) throw TypeError(".onnx.ValueInfoProto.type: object expected");
                            t.type = c.onnx.TypeProto.fromObject(e.type);
                        }
                        return null != e.docString && (t.docString = String(e.docString)), t;
                    }, e56.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        return t.defaults && (n.name = "", n.type = null, n.docString = ""), null != e.name && e.hasOwnProperty("name") && (n.name = e.name), null != e.type && e.hasOwnProperty("type") && (n.type = c.onnx.TypeProto.toObject(e.type, t)), null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), n;
                    }, e56.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e56;
                }(), o6.NodeProto = function() {
                    function e57(e) {
                        if (this.input = [], this.output = [], this.attribute = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e57.prototype.input = l.emptyArray, e57.prototype.output = l.emptyArray, e57.prototype.name = "", e57.prototype.opType = "", e57.prototype.domain = "", e57.prototype.attribute = l.emptyArray, e57.prototype.docString = "", e57.create = function(t) {
                        return new e57(t);
                    }, e57.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.input && e.input.length) for(var n = 0; n < e.input.length; ++n)t.uint32(10).string(e.input[n]);
                        if (null != e.output && e.output.length) for(n = 0; n < e.output.length; ++n)t.uint32(18).string(e.output[n]);
                        if (null != e.name && e.hasOwnProperty("name") && t.uint32(26).string(e.name), null != e.opType && e.hasOwnProperty("opType") && t.uint32(34).string(e.opType), null != e.attribute && e.attribute.length) for(n = 0; n < e.attribute.length; ++n)c.onnx.AttributeProto.encode(e.attribute[n], t.uint32(42).fork()).ldelim();
                        return null != e.docString && e.hasOwnProperty("docString") && t.uint32(50).string(e.docString), null != e.domain && e.hasOwnProperty("domain") && t.uint32(58).string(e.domain), t;
                    }, e57.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e57.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.NodeProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.input && r.input.length || (r.input = []), r.input.push(e.string());
                                    break;
                                case 2:
                                    r.output && r.output.length || (r.output = []), r.output.push(e.string());
                                    break;
                                case 3:
                                    r.name = e.string();
                                    break;
                                case 4:
                                    r.opType = e.string();
                                    break;
                                case 7:
                                    r.domain = e.string();
                                    break;
                                case 5:
                                    r.attribute && r.attribute.length || (r.attribute = []), r.attribute.push(c.onnx.AttributeProto.decode(e, e.uint32()));
                                    break;
                                case 6:
                                    r.docString = e.string();
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e57.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e57.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.input && e.hasOwnProperty("input")) {
                            if (!Array.isArray(e.input)) return "input: array expected";
                            for(var t = 0; t < e.input.length; ++t)if (!l.isString(e.input[t])) return "input: string[] expected";
                        }
                        if (null != e.output && e.hasOwnProperty("output")) {
                            if (!Array.isArray(e.output)) return "output: array expected";
                            for(t = 0; t < e.output.length; ++t)if (!l.isString(e.output[t])) return "output: string[] expected";
                        }
                        if (null != e.name && e.hasOwnProperty("name") && !l.isString(e.name)) return "name: string expected";
                        if (null != e.opType && e.hasOwnProperty("opType") && !l.isString(e.opType)) return "opType: string expected";
                        if (null != e.domain && e.hasOwnProperty("domain") && !l.isString(e.domain)) return "domain: string expected";
                        if (null != e.attribute && e.hasOwnProperty("attribute")) {
                            if (!Array.isArray(e.attribute)) return "attribute: array expected";
                            for(t = 0; t < e.attribute.length; ++t){
                                var n = c.onnx.AttributeProto.verify(e.attribute[t]);
                                if (n) return "attribute." + n;
                            }
                        }
                        return null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString) ? "docString: string expected" : null;
                    }, e57.fromObject = function(e) {
                        if (e instanceof c.onnx.NodeProto) return e;
                        var t = new c.onnx.NodeProto;
                        if (e.input) {
                            if (!Array.isArray(e.input)) throw TypeError(".onnx.NodeProto.input: array expected");
                            t.input = [];
                            for(var n = 0; n < e.input.length; ++n)t.input[n] = String(e.input[n]);
                        }
                        if (e.output) {
                            if (!Array.isArray(e.output)) throw TypeError(".onnx.NodeProto.output: array expected");
                            for(t.output = [], n = 0; n < e.output.length; ++n)t.output[n] = String(e.output[n]);
                        }
                        if (null != e.name && (t.name = String(e.name)), null != e.opType && (t.opType = String(e.opType)), null != e.domain && (t.domain = String(e.domain)), e.attribute) {
                            if (!Array.isArray(e.attribute)) throw TypeError(".onnx.NodeProto.attribute: array expected");
                            for(t.attribute = [], n = 0; n < e.attribute.length; ++n){
                                if ("object" != typeof e.attribute[n]) throw TypeError(".onnx.NodeProto.attribute: object expected");
                                t.attribute[n] = c.onnx.AttributeProto.fromObject(e.attribute[n]);
                            }
                        }
                        return null != e.docString && (t.docString = String(e.docString)), t;
                    }, e57.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.input = [], n.output = [], n.attribute = []), t.defaults && (n.name = "", n.opType = "", n.docString = "", n.domain = ""), e.input && e.input.length) {
                            n.input = [];
                            for(var r = 0; r < e.input.length; ++r)n.input[r] = e.input[r];
                        }
                        if (e.output && e.output.length) for(n.output = [], r = 0; r < e.output.length; ++r)n.output[r] = e.output[r];
                        if (null != e.name && e.hasOwnProperty("name") && (n.name = e.name), null != e.opType && e.hasOwnProperty("opType") && (n.opType = e.opType), e.attribute && e.attribute.length) for(n.attribute = [], r = 0; r < e.attribute.length; ++r)n.attribute[r] = c.onnx.AttributeProto.toObject(e.attribute[r], t);
                        return null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), null != e.domain && e.hasOwnProperty("domain") && (n.domain = e.domain), n;
                    }, e57.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e57;
                }(), o6.ModelProto = function() {
                    function e58(e) {
                        if (this.opsetImport = [], this.metadataProps = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e58.prototype.irVersion = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e58.prototype.opsetImport = l.emptyArray, e58.prototype.producerName = "", e58.prototype.producerVersion = "", e58.prototype.domain = "", e58.prototype.modelVersion = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e58.prototype.docString = "", e58.prototype.graph = null, e58.prototype.metadataProps = l.emptyArray, e58.create = function(t) {
                        return new e58(t);
                    }, e58.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.irVersion && e.hasOwnProperty("irVersion") && t.uint32(8).int64(e.irVersion), null != e.producerName && e.hasOwnProperty("producerName") && t.uint32(18).string(e.producerName), null != e.producerVersion && e.hasOwnProperty("producerVersion") && t.uint32(26).string(e.producerVersion), null != e.domain && e.hasOwnProperty("domain") && t.uint32(34).string(e.domain), null != e.modelVersion && e.hasOwnProperty("modelVersion") && t.uint32(40).int64(e.modelVersion), null != e.docString && e.hasOwnProperty("docString") && t.uint32(50).string(e.docString), null != e.graph && e.hasOwnProperty("graph") && c.onnx.GraphProto.encode(e.graph, t.uint32(58).fork()).ldelim(), null != e.opsetImport && e.opsetImport.length) for(var n = 0; n < e.opsetImport.length; ++n)c.onnx.OperatorSetIdProto.encode(e.opsetImport[n], t.uint32(66).fork()).ldelim();
                        if (null != e.metadataProps && e.metadataProps.length) for(n = 0; n < e.metadataProps.length; ++n)c.onnx.StringStringEntryProto.encode(e.metadataProps[n], t.uint32(114).fork()).ldelim();
                        return t;
                    }, e58.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e58.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.ModelProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.irVersion = e.int64();
                                    break;
                                case 8:
                                    r.opsetImport && r.opsetImport.length || (r.opsetImport = []), r.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e, e.uint32()));
                                    break;
                                case 2:
                                    r.producerName = e.string();
                                    break;
                                case 3:
                                    r.producerVersion = e.string();
                                    break;
                                case 4:
                                    r.domain = e.string();
                                    break;
                                case 5:
                                    r.modelVersion = e.int64();
                                    break;
                                case 6:
                                    r.docString = e.string();
                                    break;
                                case 7:
                                    r.graph = c.onnx.GraphProto.decode(e, e.uint32());
                                    break;
                                case 14:
                                    r.metadataProps && r.metadataProps.length || (r.metadataProps = []), r.metadataProps.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e58.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e58.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.irVersion && e.hasOwnProperty("irVersion") && !(l.isInteger(e.irVersion) || e.irVersion && l.isInteger(e.irVersion.low) && l.isInteger(e.irVersion.high))) return "irVersion: integer|Long expected";
                        if (null != e.opsetImport && e.hasOwnProperty("opsetImport")) {
                            if (!Array.isArray(e.opsetImport)) return "opsetImport: array expected";
                            for(var t = 0; t < e.opsetImport.length; ++t)if (n = c.onnx.OperatorSetIdProto.verify(e.opsetImport[t])) return "opsetImport." + n;
                        }
                        if (null != e.producerName && e.hasOwnProperty("producerName") && !l.isString(e.producerName)) return "producerName: string expected";
                        if (null != e.producerVersion && e.hasOwnProperty("producerVersion") && !l.isString(e.producerVersion)) return "producerVersion: string expected";
                        if (null != e.domain && e.hasOwnProperty("domain") && !l.isString(e.domain)) return "domain: string expected";
                        if (null != e.modelVersion && e.hasOwnProperty("modelVersion") && !(l.isInteger(e.modelVersion) || e.modelVersion && l.isInteger(e.modelVersion.low) && l.isInteger(e.modelVersion.high))) return "modelVersion: integer|Long expected";
                        if (null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString)) return "docString: string expected";
                        if (null != e.graph && e.hasOwnProperty("graph") && (n = c.onnx.GraphProto.verify(e.graph))) return "graph." + n;
                        if (null != e.metadataProps && e.hasOwnProperty("metadataProps")) {
                            if (!Array.isArray(e.metadataProps)) return "metadataProps: array expected";
                            for(t = 0; t < e.metadataProps.length; ++t){
                                var n;
                                if (n = c.onnx.StringStringEntryProto.verify(e.metadataProps[t])) return "metadataProps." + n;
                            }
                        }
                        return null;
                    }, e58.fromObject = function(e) {
                        if (e instanceof c.onnx.ModelProto) return e;
                        var t = new c.onnx.ModelProto;
                        if (null != e.irVersion && (l.Long ? (t.irVersion = l.Long.fromValue(e.irVersion)).unsigned = !1 : "string" == typeof e.irVersion ? t.irVersion = parseInt(e.irVersion, 10) : "number" == typeof e.irVersion ? t.irVersion = e.irVersion : "object" == typeof e.irVersion && (t.irVersion = new l.LongBits(e.irVersion.low >>> 0, e.irVersion.high >>> 0).toNumber())), e.opsetImport) {
                            if (!Array.isArray(e.opsetImport)) throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                            t.opsetImport = [];
                            for(var n = 0; n < e.opsetImport.length; ++n){
                                if ("object" != typeof e.opsetImport[n]) throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                                t.opsetImport[n] = c.onnx.OperatorSetIdProto.fromObject(e.opsetImport[n]);
                            }
                        }
                        if (null != e.producerName && (t.producerName = String(e.producerName)), null != e.producerVersion && (t.producerVersion = String(e.producerVersion)), null != e.domain && (t.domain = String(e.domain)), null != e.modelVersion && (l.Long ? (t.modelVersion = l.Long.fromValue(e.modelVersion)).unsigned = !1 : "string" == typeof e.modelVersion ? t.modelVersion = parseInt(e.modelVersion, 10) : "number" == typeof e.modelVersion ? t.modelVersion = e.modelVersion : "object" == typeof e.modelVersion && (t.modelVersion = new l.LongBits(e.modelVersion.low >>> 0, e.modelVersion.high >>> 0).toNumber())), null != e.docString && (t.docString = String(e.docString)), null != e.graph) {
                            if ("object" != typeof e.graph) throw TypeError(".onnx.ModelProto.graph: object expected");
                            t.graph = c.onnx.GraphProto.fromObject(e.graph);
                        }
                        if (e.metadataProps) {
                            if (!Array.isArray(e.metadataProps)) throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                            for(t.metadataProps = [], n = 0; n < e.metadataProps.length; ++n){
                                if ("object" != typeof e.metadataProps[n]) throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                                t.metadataProps[n] = c.onnx.StringStringEntryProto.fromObject(e.metadataProps[n]);
                            }
                        }
                        return t;
                    }, e58.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.opsetImport = [], n.metadataProps = []), t.defaults) {
                            if (l.Long) {
                                var r = new l.Long(0, 0, !1);
                                n.irVersion = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;
                            } else n.irVersion = t.longs === String ? "0" : 0;
                            n.producerName = "", n.producerVersion = "", n.domain = "", l.Long ? (r = new l.Long(0, 0, !1), n.modelVersion = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.modelVersion = t.longs === String ? "0" : 0, n.docString = "", n.graph = null;
                        }
                        if (null != e.irVersion && e.hasOwnProperty("irVersion") && ("number" == typeof e.irVersion ? n.irVersion = t.longs === String ? String(e.irVersion) : e.irVersion : n.irVersion = t.longs === String ? l.Long.prototype.toString.call(e.irVersion) : t.longs === Number ? new l.LongBits(e.irVersion.low >>> 0, e.irVersion.high >>> 0).toNumber() : e.irVersion), null != e.producerName && e.hasOwnProperty("producerName") && (n.producerName = e.producerName), null != e.producerVersion && e.hasOwnProperty("producerVersion") && (n.producerVersion = e.producerVersion), null != e.domain && e.hasOwnProperty("domain") && (n.domain = e.domain), null != e.modelVersion && e.hasOwnProperty("modelVersion") && ("number" == typeof e.modelVersion ? n.modelVersion = t.longs === String ? String(e.modelVersion) : e.modelVersion : n.modelVersion = t.longs === String ? l.Long.prototype.toString.call(e.modelVersion) : t.longs === Number ? new l.LongBits(e.modelVersion.low >>> 0, e.modelVersion.high >>> 0).toNumber() : e.modelVersion), null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), null != e.graph && e.hasOwnProperty("graph") && (n.graph = c.onnx.GraphProto.toObject(e.graph, t)), e.opsetImport && e.opsetImport.length) {
                            n.opsetImport = [];
                            for(var i = 0; i < e.opsetImport.length; ++i)n.opsetImport[i] = c.onnx.OperatorSetIdProto.toObject(e.opsetImport[i], t);
                        }
                        if (e.metadataProps && e.metadataProps.length) for(n.metadataProps = [], i = 0; i < e.metadataProps.length; ++i)n.metadataProps[i] = c.onnx.StringStringEntryProto.toObject(e.metadataProps[i], t);
                        return n;
                    }, e58.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e58;
                }(), o6.StringStringEntryProto = function() {
                    function e59(e) {
                        if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e59.prototype.key = "", e59.prototype.value = "", e59.create = function(t) {
                        return new e59(t);
                    }, e59.encode = function(e, t) {
                        return t || (t = u.create()), null != e.key && e.hasOwnProperty("key") && t.uint32(10).string(e.key), null != e.value && e.hasOwnProperty("value") && t.uint32(18).string(e.value), t;
                    }, e59.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e59.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.StringStringEntryProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.key = e.string();
                                    break;
                                case 2:
                                    r.value = e.string();
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e59.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e59.verify = function(e) {
                        return "object" != typeof e || null === e ? "object expected" : null != e.key && e.hasOwnProperty("key") && !l.isString(e.key) ? "key: string expected" : null != e.value && e.hasOwnProperty("value") && !l.isString(e.value) ? "value: string expected" : null;
                    }, e59.fromObject = function(e) {
                        if (e instanceof c.onnx.StringStringEntryProto) return e;
                        var t = new c.onnx.StringStringEntryProto;
                        return null != e.key && (t.key = String(e.key)), null != e.value && (t.value = String(e.value)), t;
                    }, e59.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        return t.defaults && (n.key = "", n.value = ""), null != e.key && e.hasOwnProperty("key") && (n.key = e.key), null != e.value && e.hasOwnProperty("value") && (n.value = e.value), n;
                    }, e59.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e59;
                }(), o6.TensorAnnotation = function() {
                    function e60(e) {
                        if (this.quantParameterTensorNames = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e60.prototype.tensorName = "", e60.prototype.quantParameterTensorNames = l.emptyArray, e60.create = function(t) {
                        return new e60(t);
                    }, e60.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.tensorName && e.hasOwnProperty("tensorName") && t.uint32(10).string(e.tensorName), null != e.quantParameterTensorNames && e.quantParameterTensorNames.length) for(var n = 0; n < e.quantParameterTensorNames.length; ++n)c.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[n], t.uint32(18).fork()).ldelim();
                        return t;
                    }, e60.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e60.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorAnnotation; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.tensorName = e.string();
                                    break;
                                case 2:
                                    r.quantParameterTensorNames && r.quantParameterTensorNames.length || (r.quantParameterTensorNames = []), r.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e60.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e60.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.tensorName && e.hasOwnProperty("tensorName") && !l.isString(e.tensorName)) return "tensorName: string expected";
                        if (null != e.quantParameterTensorNames && e.hasOwnProperty("quantParameterTensorNames")) {
                            if (!Array.isArray(e.quantParameterTensorNames)) return "quantParameterTensorNames: array expected";
                            for(var t = 0; t < e.quantParameterTensorNames.length; ++t){
                                var n = c.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);
                                if (n) return "quantParameterTensorNames." + n;
                            }
                        }
                        return null;
                    }, e60.fromObject = function(e) {
                        if (e instanceof c.onnx.TensorAnnotation) return e;
                        var t = new c.onnx.TensorAnnotation;
                        if (null != e.tensorName && (t.tensorName = String(e.tensorName)), e.quantParameterTensorNames) {
                            if (!Array.isArray(e.quantParameterTensorNames)) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                            t.quantParameterTensorNames = [];
                            for(var n = 0; n < e.quantParameterTensorNames.length; ++n){
                                if ("object" != typeof e.quantParameterTensorNames[n]) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                                t.quantParameterTensorNames[n] = c.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[n]);
                            }
                        }
                        return t;
                    }, e60.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.quantParameterTensorNames = []), t.defaults && (n.tensorName = ""), null != e.tensorName && e.hasOwnProperty("tensorName") && (n.tensorName = e.tensorName), e.quantParameterTensorNames && e.quantParameterTensorNames.length) {
                            n.quantParameterTensorNames = [];
                            for(var r = 0; r < e.quantParameterTensorNames.length; ++r)n.quantParameterTensorNames[r] = c.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[r], t);
                        }
                        return n;
                    }, e60.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e60;
                }(), o6.GraphProto = function() {
                    function e61(e) {
                        if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e61.prototype.node = l.emptyArray, e61.prototype.name = "", e61.prototype.initializer = l.emptyArray, e61.prototype.docString = "", e61.prototype.input = l.emptyArray, e61.prototype.output = l.emptyArray, e61.prototype.valueInfo = l.emptyArray, e61.prototype.quantizationAnnotation = l.emptyArray, e61.create = function(t) {
                        return new e61(t);
                    }, e61.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.node && e.node.length) for(var n = 0; n < e.node.length; ++n)c.onnx.NodeProto.encode(e.node[n], t.uint32(10).fork()).ldelim();
                        if (null != e.name && e.hasOwnProperty("name") && t.uint32(18).string(e.name), null != e.initializer && e.initializer.length) for(n = 0; n < e.initializer.length; ++n)c.onnx.TensorProto.encode(e.initializer[n], t.uint32(42).fork()).ldelim();
                        if (null != e.docString && e.hasOwnProperty("docString") && t.uint32(82).string(e.docString), null != e.input && e.input.length) for(n = 0; n < e.input.length; ++n)c.onnx.ValueInfoProto.encode(e.input[n], t.uint32(90).fork()).ldelim();
                        if (null != e.output && e.output.length) for(n = 0; n < e.output.length; ++n)c.onnx.ValueInfoProto.encode(e.output[n], t.uint32(98).fork()).ldelim();
                        if (null != e.valueInfo && e.valueInfo.length) for(n = 0; n < e.valueInfo.length; ++n)c.onnx.ValueInfoProto.encode(e.valueInfo[n], t.uint32(106).fork()).ldelim();
                        if (null != e.quantizationAnnotation && e.quantizationAnnotation.length) for(n = 0; n < e.quantizationAnnotation.length; ++n)c.onnx.TensorAnnotation.encode(e.quantizationAnnotation[n], t.uint32(114).fork()).ldelim();
                        return t;
                    }, e61.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e61.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.GraphProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.node && r.node.length || (r.node = []), r.node.push(c.onnx.NodeProto.decode(e, e.uint32()));
                                    break;
                                case 2:
                                    r.name = e.string();
                                    break;
                                case 5:
                                    r.initializer && r.initializer.length || (r.initializer = []), r.initializer.push(c.onnx.TensorProto.decode(e, e.uint32()));
                                    break;
                                case 10:
                                    r.docString = e.string();
                                    break;
                                case 11:
                                    r.input && r.input.length || (r.input = []), r.input.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));
                                    break;
                                case 12:
                                    r.output && r.output.length || (r.output = []), r.output.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));
                                    break;
                                case 13:
                                    r.valueInfo && r.valueInfo.length || (r.valueInfo = []), r.valueInfo.push(c.onnx.ValueInfoProto.decode(e, e.uint32()));
                                    break;
                                case 14:
                                    r.quantizationAnnotation && r.quantizationAnnotation.length || (r.quantizationAnnotation = []), r.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e, e.uint32()));
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e61.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e61.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.node && e.hasOwnProperty("node")) {
                            if (!Array.isArray(e.node)) return "node: array expected";
                            for(var t = 0; t < e.node.length; ++t)if (n = c.onnx.NodeProto.verify(e.node[t])) return "node." + n;
                        }
                        if (null != e.name && e.hasOwnProperty("name") && !l.isString(e.name)) return "name: string expected";
                        if (null != e.initializer && e.hasOwnProperty("initializer")) {
                            if (!Array.isArray(e.initializer)) return "initializer: array expected";
                            for(t = 0; t < e.initializer.length; ++t)if (n = c.onnx.TensorProto.verify(e.initializer[t])) return "initializer." + n;
                        }
                        if (null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString)) return "docString: string expected";
                        if (null != e.input && e.hasOwnProperty("input")) {
                            if (!Array.isArray(e.input)) return "input: array expected";
                            for(t = 0; t < e.input.length; ++t)if (n = c.onnx.ValueInfoProto.verify(e.input[t])) return "input." + n;
                        }
                        if (null != e.output && e.hasOwnProperty("output")) {
                            if (!Array.isArray(e.output)) return "output: array expected";
                            for(t = 0; t < e.output.length; ++t)if (n = c.onnx.ValueInfoProto.verify(e.output[t])) return "output." + n;
                        }
                        if (null != e.valueInfo && e.hasOwnProperty("valueInfo")) {
                            if (!Array.isArray(e.valueInfo)) return "valueInfo: array expected";
                            for(t = 0; t < e.valueInfo.length; ++t)if (n = c.onnx.ValueInfoProto.verify(e.valueInfo[t])) return "valueInfo." + n;
                        }
                        if (null != e.quantizationAnnotation && e.hasOwnProperty("quantizationAnnotation")) {
                            if (!Array.isArray(e.quantizationAnnotation)) return "quantizationAnnotation: array expected";
                            for(t = 0; t < e.quantizationAnnotation.length; ++t){
                                var n;
                                if (n = c.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t])) return "quantizationAnnotation." + n;
                            }
                        }
                        return null;
                    }, e61.fromObject = function(e) {
                        if (e instanceof c.onnx.GraphProto) return e;
                        var t = new c.onnx.GraphProto;
                        if (e.node) {
                            if (!Array.isArray(e.node)) throw TypeError(".onnx.GraphProto.node: array expected");
                            t.node = [];
                            for(var n = 0; n < e.node.length; ++n){
                                if ("object" != typeof e.node[n]) throw TypeError(".onnx.GraphProto.node: object expected");
                                t.node[n] = c.onnx.NodeProto.fromObject(e.node[n]);
                            }
                        }
                        if (null != e.name && (t.name = String(e.name)), e.initializer) {
                            if (!Array.isArray(e.initializer)) throw TypeError(".onnx.GraphProto.initializer: array expected");
                            for(t.initializer = [], n = 0; n < e.initializer.length; ++n){
                                if ("object" != typeof e.initializer[n]) throw TypeError(".onnx.GraphProto.initializer: object expected");
                                t.initializer[n] = c.onnx.TensorProto.fromObject(e.initializer[n]);
                            }
                        }
                        if (null != e.docString && (t.docString = String(e.docString)), e.input) {
                            if (!Array.isArray(e.input)) throw TypeError(".onnx.GraphProto.input: array expected");
                            for(t.input = [], n = 0; n < e.input.length; ++n){
                                if ("object" != typeof e.input[n]) throw TypeError(".onnx.GraphProto.input: object expected");
                                t.input[n] = c.onnx.ValueInfoProto.fromObject(e.input[n]);
                            }
                        }
                        if (e.output) {
                            if (!Array.isArray(e.output)) throw TypeError(".onnx.GraphProto.output: array expected");
                            for(t.output = [], n = 0; n < e.output.length; ++n){
                                if ("object" != typeof e.output[n]) throw TypeError(".onnx.GraphProto.output: object expected");
                                t.output[n] = c.onnx.ValueInfoProto.fromObject(e.output[n]);
                            }
                        }
                        if (e.valueInfo) {
                            if (!Array.isArray(e.valueInfo)) throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                            for(t.valueInfo = [], n = 0; n < e.valueInfo.length; ++n){
                                if ("object" != typeof e.valueInfo[n]) throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                                t.valueInfo[n] = c.onnx.ValueInfoProto.fromObject(e.valueInfo[n]);
                            }
                        }
                        if (e.quantizationAnnotation) {
                            if (!Array.isArray(e.quantizationAnnotation)) throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                            for(t.quantizationAnnotation = [], n = 0; n < e.quantizationAnnotation.length; ++n){
                                if ("object" != typeof e.quantizationAnnotation[n]) throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                                t.quantizationAnnotation[n] = c.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[n]);
                            }
                        }
                        return t;
                    }, e61.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = []), t.defaults && (n.name = "", n.docString = ""), e.node && e.node.length) {
                            n.node = [];
                            for(var r = 0; r < e.node.length; ++r)n.node[r] = c.onnx.NodeProto.toObject(e.node[r], t);
                        }
                        if (null != e.name && e.hasOwnProperty("name") && (n.name = e.name), e.initializer && e.initializer.length) for(n.initializer = [], r = 0; r < e.initializer.length; ++r)n.initializer[r] = c.onnx.TensorProto.toObject(e.initializer[r], t);
                        if (null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), e.input && e.input.length) for(n.input = [], r = 0; r < e.input.length; ++r)n.input[r] = c.onnx.ValueInfoProto.toObject(e.input[r], t);
                        if (e.output && e.output.length) for(n.output = [], r = 0; r < e.output.length; ++r)n.output[r] = c.onnx.ValueInfoProto.toObject(e.output[r], t);
                        if (e.valueInfo && e.valueInfo.length) for(n.valueInfo = [], r = 0; r < e.valueInfo.length; ++r)n.valueInfo[r] = c.onnx.ValueInfoProto.toObject(e.valueInfo[r], t);
                        if (e.quantizationAnnotation && e.quantizationAnnotation.length) for(n.quantizationAnnotation = [], r = 0; r < e.quantizationAnnotation.length; ++r)n.quantizationAnnotation[r] = c.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[r], t);
                        return n;
                    }, e61.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e61;
                }(), o6.TensorProto = function() {
                    function e62(e) {
                        if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e62.prototype.dims = l.emptyArray, e62.prototype.dataType = 0, e62.prototype.segment = null, e62.prototype.floatData = l.emptyArray, e62.prototype.int32Data = l.emptyArray, e62.prototype.stringData = l.emptyArray, e62.prototype.int64Data = l.emptyArray, e62.prototype.name = "", e62.prototype.docString = "", e62.prototype.rawData = l.newBuffer([]), e62.prototype.externalData = l.emptyArray, e62.prototype.dataLocation = 0, e62.prototype.doubleData = l.emptyArray, e62.prototype.uint64Data = l.emptyArray, e62.create = function(t) {
                        return new e62(t);
                    }, e62.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.dims && e.dims.length) {
                            t.uint32(10).fork();
                            for(var n = 0; n < e.dims.length; ++n)t.int64(e.dims[n]);
                            t.ldelim();
                        }
                        if (null != e.dataType && e.hasOwnProperty("dataType") && t.uint32(16).int32(e.dataType), null != e.segment && e.hasOwnProperty("segment") && c.onnx.TensorProto.Segment.encode(e.segment, t.uint32(26).fork()).ldelim(), null != e.floatData && e.floatData.length) {
                            for(t.uint32(34).fork(), n = 0; n < e.floatData.length; ++n)t.float(e.floatData[n]);
                            t.ldelim();
                        }
                        if (null != e.int32Data && e.int32Data.length) {
                            for(t.uint32(42).fork(), n = 0; n < e.int32Data.length; ++n)t.int32(e.int32Data[n]);
                            t.ldelim();
                        }
                        if (null != e.stringData && e.stringData.length) for(n = 0; n < e.stringData.length; ++n)t.uint32(50).bytes(e.stringData[n]);
                        if (null != e.int64Data && e.int64Data.length) {
                            for(t.uint32(58).fork(), n = 0; n < e.int64Data.length; ++n)t.int64(e.int64Data[n]);
                            t.ldelim();
                        }
                        if (null != e.name && e.hasOwnProperty("name") && t.uint32(66).string(e.name), null != e.rawData && e.hasOwnProperty("rawData") && t.uint32(74).bytes(e.rawData), null != e.doubleData && e.doubleData.length) {
                            for(t.uint32(82).fork(), n = 0; n < e.doubleData.length; ++n)t.double(e.doubleData[n]);
                            t.ldelim();
                        }
                        if (null != e.uint64Data && e.uint64Data.length) {
                            for(t.uint32(90).fork(), n = 0; n < e.uint64Data.length; ++n)t.uint64(e.uint64Data[n]);
                            t.ldelim();
                        }
                        if (null != e.docString && e.hasOwnProperty("docString") && t.uint32(98).string(e.docString), null != e.externalData && e.externalData.length) for(n = 0; n < e.externalData.length; ++n)c.onnx.StringStringEntryProto.encode(e.externalData[n], t.uint32(106).fork()).ldelim();
                        return null != e.dataLocation && e.hasOwnProperty("dataLocation") && t.uint32(112).int32(e.dataLocation), t;
                    }, e62.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e62.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    if (r.dims && r.dims.length || (r.dims = []), 2 == (7 & i)) for(var o = e.uint32() + e.pos; e.pos < o;)r.dims.push(e.int64());
                                    else r.dims.push(e.int64());
                                    break;
                                case 2:
                                    r.dataType = e.int32();
                                    break;
                                case 3:
                                    r.segment = c.onnx.TensorProto.Segment.decode(e, e.uint32());
                                    break;
                                case 4:
                                    if (r.floatData && r.floatData.length || (r.floatData = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.floatData.push(e.float());
                                    else r.floatData.push(e.float());
                                    break;
                                case 5:
                                    if (r.int32Data && r.int32Data.length || (r.int32Data = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.int32Data.push(e.int32());
                                    else r.int32Data.push(e.int32());
                                    break;
                                case 6:
                                    r.stringData && r.stringData.length || (r.stringData = []), r.stringData.push(e.bytes());
                                    break;
                                case 7:
                                    if (r.int64Data && r.int64Data.length || (r.int64Data = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.int64Data.push(e.int64());
                                    else r.int64Data.push(e.int64());
                                    break;
                                case 8:
                                    r.name = e.string();
                                    break;
                                case 12:
                                    r.docString = e.string();
                                    break;
                                case 9:
                                    r.rawData = e.bytes();
                                    break;
                                case 13:
                                    r.externalData && r.externalData.length || (r.externalData = []), r.externalData.push(c.onnx.StringStringEntryProto.decode(e, e.uint32()));
                                    break;
                                case 14:
                                    r.dataLocation = e.int32();
                                    break;
                                case 10:
                                    if (r.doubleData && r.doubleData.length || (r.doubleData = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.doubleData.push(e.double());
                                    else r.doubleData.push(e.double());
                                    break;
                                case 11:
                                    if (r.uint64Data && r.uint64Data.length || (r.uint64Data = []), 2 == (7 & i)) for(o = e.uint32() + e.pos; e.pos < o;)r.uint64Data.push(e.uint64());
                                    else r.uint64Data.push(e.uint64());
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e62.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e62.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.dims && e.hasOwnProperty("dims")) {
                            if (!Array.isArray(e.dims)) return "dims: array expected";
                            for(var t = 0; t < e.dims.length; ++t)if (!(l.isInteger(e.dims[t]) || e.dims[t] && l.isInteger(e.dims[t].low) && l.isInteger(e.dims[t].high))) return "dims: integer|Long[] expected";
                        }
                        if (null != e.dataType && e.hasOwnProperty("dataType") && !l.isInteger(e.dataType)) return "dataType: integer expected";
                        if (null != e.segment && e.hasOwnProperty("segment") && (n = c.onnx.TensorProto.Segment.verify(e.segment))) return "segment." + n;
                        if (null != e.floatData && e.hasOwnProperty("floatData")) {
                            if (!Array.isArray(e.floatData)) return "floatData: array expected";
                            for(t = 0; t < e.floatData.length; ++t)if ("number" != typeof e.floatData[t]) return "floatData: number[] expected";
                        }
                        if (null != e.int32Data && e.hasOwnProperty("int32Data")) {
                            if (!Array.isArray(e.int32Data)) return "int32Data: array expected";
                            for(t = 0; t < e.int32Data.length; ++t)if (!l.isInteger(e.int32Data[t])) return "int32Data: integer[] expected";
                        }
                        if (null != e.stringData && e.hasOwnProperty("stringData")) {
                            if (!Array.isArray(e.stringData)) return "stringData: array expected";
                            for(t = 0; t < e.stringData.length; ++t)if (!(e.stringData[t] && "number" == typeof e.stringData[t].length || l.isString(e.stringData[t]))) return "stringData: buffer[] expected";
                        }
                        if (null != e.int64Data && e.hasOwnProperty("int64Data")) {
                            if (!Array.isArray(e.int64Data)) return "int64Data: array expected";
                            for(t = 0; t < e.int64Data.length; ++t)if (!(l.isInteger(e.int64Data[t]) || e.int64Data[t] && l.isInteger(e.int64Data[t].low) && l.isInteger(e.int64Data[t].high))) return "int64Data: integer|Long[] expected";
                        }
                        if (null != e.name && e.hasOwnProperty("name") && !l.isString(e.name)) return "name: string expected";
                        if (null != e.docString && e.hasOwnProperty("docString") && !l.isString(e.docString)) return "docString: string expected";
                        if (null != e.rawData && e.hasOwnProperty("rawData") && !(e.rawData && "number" == typeof e.rawData.length || l.isString(e.rawData))) return "rawData: buffer expected";
                        if (null != e.externalData && e.hasOwnProperty("externalData")) {
                            if (!Array.isArray(e.externalData)) return "externalData: array expected";
                            for(t = 0; t < e.externalData.length; ++t){
                                var n;
                                if (n = c.onnx.StringStringEntryProto.verify(e.externalData[t])) return "externalData." + n;
                            }
                        }
                        if (null != e.dataLocation && e.hasOwnProperty("dataLocation")) switch(e.dataLocation){
                            default:
                                return "dataLocation: enum value expected";
                            case 0:
                            case 1:
                        }
                        if (null != e.doubleData && e.hasOwnProperty("doubleData")) {
                            if (!Array.isArray(e.doubleData)) return "doubleData: array expected";
                            for(t = 0; t < e.doubleData.length; ++t)if ("number" != typeof e.doubleData[t]) return "doubleData: number[] expected";
                        }
                        if (null != e.uint64Data && e.hasOwnProperty("uint64Data")) {
                            if (!Array.isArray(e.uint64Data)) return "uint64Data: array expected";
                            for(t = 0; t < e.uint64Data.length; ++t)if (!(l.isInteger(e.uint64Data[t]) || e.uint64Data[t] && l.isInteger(e.uint64Data[t].low) && l.isInteger(e.uint64Data[t].high))) return "uint64Data: integer|Long[] expected";
                        }
                        return null;
                    }, e62.fromObject = function(e) {
                        if (e instanceof c.onnx.TensorProto) return e;
                        var t = new c.onnx.TensorProto;
                        if (e.dims) {
                            if (!Array.isArray(e.dims)) throw TypeError(".onnx.TensorProto.dims: array expected");
                            t.dims = [];
                            for(var n = 0; n < e.dims.length; ++n)l.Long ? (t.dims[n] = l.Long.fromValue(e.dims[n])).unsigned = !1 : "string" == typeof e.dims[n] ? t.dims[n] = parseInt(e.dims[n], 10) : "number" == typeof e.dims[n] ? t.dims[n] = e.dims[n] : "object" == typeof e.dims[n] && (t.dims[n] = new l.LongBits(e.dims[n].low >>> 0, e.dims[n].high >>> 0).toNumber());
                        }
                        if (null != e.dataType && (t.dataType = 0 | e.dataType), null != e.segment) {
                            if ("object" != typeof e.segment) throw TypeError(".onnx.TensorProto.segment: object expected");
                            t.segment = c.onnx.TensorProto.Segment.fromObject(e.segment);
                        }
                        if (e.floatData) {
                            if (!Array.isArray(e.floatData)) throw TypeError(".onnx.TensorProto.floatData: array expected");
                            for(t.floatData = [], n = 0; n < e.floatData.length; ++n)t.floatData[n] = Number(e.floatData[n]);
                        }
                        if (e.int32Data) {
                            if (!Array.isArray(e.int32Data)) throw TypeError(".onnx.TensorProto.int32Data: array expected");
                            for(t.int32Data = [], n = 0; n < e.int32Data.length; ++n)t.int32Data[n] = 0 | e.int32Data[n];
                        }
                        if (e.stringData) {
                            if (!Array.isArray(e.stringData)) throw TypeError(".onnx.TensorProto.stringData: array expected");
                            for(t.stringData = [], n = 0; n < e.stringData.length; ++n)"string" == typeof e.stringData[n] ? l.base64.decode(e.stringData[n], t.stringData[n] = l.newBuffer(l.base64.length(e.stringData[n])), 0) : e.stringData[n].length && (t.stringData[n] = e.stringData[n]);
                        }
                        if (e.int64Data) {
                            if (!Array.isArray(e.int64Data)) throw TypeError(".onnx.TensorProto.int64Data: array expected");
                            for(t.int64Data = [], n = 0; n < e.int64Data.length; ++n)l.Long ? (t.int64Data[n] = l.Long.fromValue(e.int64Data[n])).unsigned = !1 : "string" == typeof e.int64Data[n] ? t.int64Data[n] = parseInt(e.int64Data[n], 10) : "number" == typeof e.int64Data[n] ? t.int64Data[n] = e.int64Data[n] : "object" == typeof e.int64Data[n] && (t.int64Data[n] = new l.LongBits(e.int64Data[n].low >>> 0, e.int64Data[n].high >>> 0).toNumber());
                        }
                        if (null != e.name && (t.name = String(e.name)), null != e.docString && (t.docString = String(e.docString)), null != e.rawData && ("string" == typeof e.rawData ? l.base64.decode(e.rawData, t.rawData = l.newBuffer(l.base64.length(e.rawData)), 0) : e.rawData.length && (t.rawData = e.rawData)), e.externalData) {
                            if (!Array.isArray(e.externalData)) throw TypeError(".onnx.TensorProto.externalData: array expected");
                            for(t.externalData = [], n = 0; n < e.externalData.length; ++n){
                                if ("object" != typeof e.externalData[n]) throw TypeError(".onnx.TensorProto.externalData: object expected");
                                t.externalData[n] = c.onnx.StringStringEntryProto.fromObject(e.externalData[n]);
                            }
                        }
                        switch(e.dataLocation){
                            case "DEFAULT":
                            case 0:
                                t.dataLocation = 0;
                                break;
                            case "EXTERNAL":
                            case 1:
                                t.dataLocation = 1;
                        }
                        if (e.doubleData) {
                            if (!Array.isArray(e.doubleData)) throw TypeError(".onnx.TensorProto.doubleData: array expected");
                            for(t.doubleData = [], n = 0; n < e.doubleData.length; ++n)t.doubleData[n] = Number(e.doubleData[n]);
                        }
                        if (e.uint64Data) {
                            if (!Array.isArray(e.uint64Data)) throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                            for(t.uint64Data = [], n = 0; n < e.uint64Data.length; ++n)l.Long ? (t.uint64Data[n] = l.Long.fromValue(e.uint64Data[n])).unsigned = !0 : "string" == typeof e.uint64Data[n] ? t.uint64Data[n] = parseInt(e.uint64Data[n], 10) : "number" == typeof e.uint64Data[n] ? t.uint64Data[n] = e.uint64Data[n] : "object" == typeof e.uint64Data[n] && (t.uint64Data[n] = new l.LongBits(e.uint64Data[n].low >>> 0, e.uint64Data[n].high >>> 0).toNumber(!0));
                        }
                        return t;
                    }, e62.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), t.defaults && (n.dataType = 0, n.segment = null, n.name = "", t.bytes === String ? n.rawData = "" : (n.rawData = [], t.bytes !== Array && (n.rawData = l.newBuffer(n.rawData))), n.docString = "", n.dataLocation = t.enums === String ? "DEFAULT" : 0), e.dims && e.dims.length) {
                            n.dims = [];
                            for(var r = 0; r < e.dims.length; ++r)"number" == typeof e.dims[r] ? n.dims[r] = t.longs === String ? String(e.dims[r]) : e.dims[r] : n.dims[r] = t.longs === String ? l.Long.prototype.toString.call(e.dims[r]) : t.longs === Number ? new l.LongBits(e.dims[r].low >>> 0, e.dims[r].high >>> 0).toNumber() : e.dims[r];
                        }
                        if (null != e.dataType && e.hasOwnProperty("dataType") && (n.dataType = e.dataType), null != e.segment && e.hasOwnProperty("segment") && (n.segment = c.onnx.TensorProto.Segment.toObject(e.segment, t)), e.floatData && e.floatData.length) for(n.floatData = [], r = 0; r < e.floatData.length; ++r)n.floatData[r] = t.json && !isFinite(e.floatData[r]) ? String(e.floatData[r]) : e.floatData[r];
                        if (e.int32Data && e.int32Data.length) for(n.int32Data = [], r = 0; r < e.int32Data.length; ++r)n.int32Data[r] = e.int32Data[r];
                        if (e.stringData && e.stringData.length) for(n.stringData = [], r = 0; r < e.stringData.length; ++r)n.stringData[r] = t.bytes === String ? l.base64.encode(e.stringData[r], 0, e.stringData[r].length) : t.bytes === Array ? Array.prototype.slice.call(e.stringData[r]) : e.stringData[r];
                        if (e.int64Data && e.int64Data.length) for(n.int64Data = [], r = 0; r < e.int64Data.length; ++r)"number" == typeof e.int64Data[r] ? n.int64Data[r] = t.longs === String ? String(e.int64Data[r]) : e.int64Data[r] : n.int64Data[r] = t.longs === String ? l.Long.prototype.toString.call(e.int64Data[r]) : t.longs === Number ? new l.LongBits(e.int64Data[r].low >>> 0, e.int64Data[r].high >>> 0).toNumber() : e.int64Data[r];
                        if (null != e.name && e.hasOwnProperty("name") && (n.name = e.name), null != e.rawData && e.hasOwnProperty("rawData") && (n.rawData = t.bytes === String ? l.base64.encode(e.rawData, 0, e.rawData.length) : t.bytes === Array ? Array.prototype.slice.call(e.rawData) : e.rawData), e.doubleData && e.doubleData.length) for(n.doubleData = [], r = 0; r < e.doubleData.length; ++r)n.doubleData[r] = t.json && !isFinite(e.doubleData[r]) ? String(e.doubleData[r]) : e.doubleData[r];
                        if (e.uint64Data && e.uint64Data.length) for(n.uint64Data = [], r = 0; r < e.uint64Data.length; ++r)"number" == typeof e.uint64Data[r] ? n.uint64Data[r] = t.longs === String ? String(e.uint64Data[r]) : e.uint64Data[r] : n.uint64Data[r] = t.longs === String ? l.Long.prototype.toString.call(e.uint64Data[r]) : t.longs === Number ? new l.LongBits(e.uint64Data[r].low >>> 0, e.uint64Data[r].high >>> 0).toNumber(!0) : e.uint64Data[r];
                        if (null != e.docString && e.hasOwnProperty("docString") && (n.docString = e.docString), e.externalData && e.externalData.length) for(n.externalData = [], r = 0; r < e.externalData.length; ++r)n.externalData[r] = c.onnx.StringStringEntryProto.toObject(e.externalData[r], t);
                        return null != e.dataLocation && e.hasOwnProperty("dataLocation") && (n.dataLocation = t.enums === String ? c.onnx.TensorProto.DataLocation[e.dataLocation] : e.dataLocation), n;
                    }, e62.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e62.DataType = function() {
                        var e = {}, t = Object.create(e);
                        return t[e[0] = "UNDEFINED"] = 0, t[e[1] = "FLOAT"] = 1, t[e[2] = "UINT8"] = 2, t[e[3] = "INT8"] = 3, t[e[4] = "UINT16"] = 4, t[e[5] = "INT16"] = 5, t[e[6] = "INT32"] = 6, t[e[7] = "INT64"] = 7, t[e[8] = "STRING"] = 8, t[e[9] = "BOOL"] = 9, t[e[10] = "FLOAT16"] = 10, t[e[11] = "DOUBLE"] = 11, t[e[12] = "UINT32"] = 12, t[e[13] = "UINT64"] = 13, t[e[14] = "COMPLEX64"] = 14, t[e[15] = "COMPLEX128"] = 15, t[e[16] = "BFLOAT16"] = 16, t;
                    }(), e62.Segment = function() {
                        function e63(e) {
                            if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                        }
                        return e63.prototype.begin = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e63.prototype.end = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e63.create = function(t) {
                            return new e63(t);
                        }, e63.encode = function(e, t) {
                            return t || (t = u.create()), null != e.begin && e.hasOwnProperty("begin") && t.uint32(8).int64(e.begin), null != e.end && e.hasOwnProperty("end") && t.uint32(16).int64(e.end), t;
                        }, e63.encodeDelimited = function(e, t) {
                            return this.encode(e, t).ldelim();
                        }, e63.decode = function(e, t) {
                            e instanceof a || (e = a.create(e));
                            for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorProto.Segment; e.pos < n;){
                                var i = e.uint32();
                                switch(i >>> 3){
                                    case 1:
                                        r.begin = e.int64();
                                        break;
                                    case 2:
                                        r.end = e.int64();
                                        break;
                                    default:
                                        e.skipType(7 & i);
                                }
                            }
                            return r;
                        }, e63.decodeDelimited = function(e) {
                            return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                        }, e63.verify = function(e) {
                            return "object" != typeof e || null === e ? "object expected" : null != e.begin && e.hasOwnProperty("begin") && !(l.isInteger(e.begin) || e.begin && l.isInteger(e.begin.low) && l.isInteger(e.begin.high)) ? "begin: integer|Long expected" : null != e.end && e.hasOwnProperty("end") && !(l.isInteger(e.end) || e.end && l.isInteger(e.end.low) && l.isInteger(e.end.high)) ? "end: integer|Long expected" : null;
                        }, e63.fromObject = function(e) {
                            if (e instanceof c.onnx.TensorProto.Segment) return e;
                            var t = new c.onnx.TensorProto.Segment;
                            return null != e.begin && (l.Long ? (t.begin = l.Long.fromValue(e.begin)).unsigned = !1 : "string" == typeof e.begin ? t.begin = parseInt(e.begin, 10) : "number" == typeof e.begin ? t.begin = e.begin : "object" == typeof e.begin && (t.begin = new l.LongBits(e.begin.low >>> 0, e.begin.high >>> 0).toNumber())), null != e.end && (l.Long ? (t.end = l.Long.fromValue(e.end)).unsigned = !1 : "string" == typeof e.end ? t.end = parseInt(e.end, 10) : "number" == typeof e.end ? t.end = e.end : "object" == typeof e.end && (t.end = new l.LongBits(e.end.low >>> 0, e.end.high >>> 0).toNumber())), t;
                        }, e63.toObject = function(e, t) {
                            t || (t = {});
                            var n = {};
                            if (t.defaults) {
                                if (l.Long) {
                                    var r = new l.Long(0, 0, !1);
                                    n.begin = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;
                                } else n.begin = t.longs === String ? "0" : 0;
                                l.Long ? (r = new l.Long(0, 0, !1), n.end = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.end = t.longs === String ? "0" : 0;
                            }
                            return null != e.begin && e.hasOwnProperty("begin") && ("number" == typeof e.begin ? n.begin = t.longs === String ? String(e.begin) : e.begin : n.begin = t.longs === String ? l.Long.prototype.toString.call(e.begin) : t.longs === Number ? new l.LongBits(e.begin.low >>> 0, e.begin.high >>> 0).toNumber() : e.begin), null != e.end && e.hasOwnProperty("end") && ("number" == typeof e.end ? n.end = t.longs === String ? String(e.end) : e.end : n.end = t.longs === String ? l.Long.prototype.toString.call(e.end) : t.longs === Number ? new l.LongBits(e.end.low >>> 0, e.end.high >>> 0).toNumber() : e.end), n;
                        }, e63.prototype.toJSON = function() {
                            return this.constructor.toObject(this, s.util.toJSONOptions);
                        }, e63;
                    }(), e62.DataLocation = function() {
                        var e = {}, t = Object.create(e);
                        return t[e[0] = "DEFAULT"] = 0, t[e[1] = "EXTERNAL"] = 1, t;
                    }(), e62;
                }(), o6.TensorShapeProto = function() {
                    function e64(e) {
                        if (this.dim = [], e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e64.prototype.dim = l.emptyArray, e64.create = function(t) {
                        return new e64(t);
                    }, e64.encode = function(e, t) {
                        if (t || (t = u.create()), null != e.dim && e.dim.length) for(var n = 0; n < e.dim.length; ++n)c.onnx.TensorShapeProto.Dimension.encode(e.dim[n], t.uint32(10).fork()).ldelim();
                        return t;
                    }, e64.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e64.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorShapeProto; e.pos < n;){
                            var i = e.uint32();
                            i >>> 3 == 1 ? (r.dim && r.dim.length || (r.dim = []), r.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e, e.uint32()))) : e.skipType(7 & i);
                        }
                        return r;
                    }, e64.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e64.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.dim && e.hasOwnProperty("dim")) {
                            if (!Array.isArray(e.dim)) return "dim: array expected";
                            for(var t = 0; t < e.dim.length; ++t){
                                var n = c.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);
                                if (n) return "dim." + n;
                            }
                        }
                        return null;
                    }, e64.fromObject = function(e) {
                        if (e instanceof c.onnx.TensorShapeProto) return e;
                        var t = new c.onnx.TensorShapeProto;
                        if (e.dim) {
                            if (!Array.isArray(e.dim)) throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                            t.dim = [];
                            for(var n = 0; n < e.dim.length; ++n){
                                if ("object" != typeof e.dim[n]) throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                                t.dim[n] = c.onnx.TensorShapeProto.Dimension.fromObject(e.dim[n]);
                            }
                        }
                        return t;
                    }, e64.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if ((t.arrays || t.defaults) && (n.dim = []), e.dim && e.dim.length) {
                            n.dim = [];
                            for(var r = 0; r < e.dim.length; ++r)n.dim[r] = c.onnx.TensorShapeProto.Dimension.toObject(e.dim[r], t);
                        }
                        return n;
                    }, e64.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e64.Dimension = function() {
                        function e65(e) {
                            if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                        }
                        var t30;
                        return e65.prototype.dimValue = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e65.prototype.dimParam = "", e65.prototype.denotation = "", Object.defineProperty(e65.prototype, "value", {
                            get: l.oneOfGetter(t30 = [
                                "dimValue",
                                "dimParam"
                            ]),
                            set: l.oneOfSetter(t30)
                        }), e65.create = function(t) {
                            return new e65(t);
                        }, e65.encode = function(e, t) {
                            return t || (t = u.create()), null != e.dimValue && e.hasOwnProperty("dimValue") && t.uint32(8).int64(e.dimValue), null != e.dimParam && e.hasOwnProperty("dimParam") && t.uint32(18).string(e.dimParam), null != e.denotation && e.hasOwnProperty("denotation") && t.uint32(26).string(e.denotation), t;
                        }, e65.encodeDelimited = function(e, t) {
                            return this.encode(e, t).ldelim();
                        }, e65.decode = function(e, t) {
                            e instanceof a || (e = a.create(e));
                            for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TensorShapeProto.Dimension; e.pos < n;){
                                var i = e.uint32();
                                switch(i >>> 3){
                                    case 1:
                                        r.dimValue = e.int64();
                                        break;
                                    case 2:
                                        r.dimParam = e.string();
                                        break;
                                    case 3:
                                        r.denotation = e.string();
                                        break;
                                    default:
                                        e.skipType(7 & i);
                                }
                            }
                            return r;
                        }, e65.decodeDelimited = function(e) {
                            return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                        }, e65.verify = function(e) {
                            if ("object" != typeof e || null === e) return "object expected";
                            var t = {};
                            if (null != e.dimValue && e.hasOwnProperty("dimValue") && (t.value = 1, !(l.isInteger(e.dimValue) || e.dimValue && l.isInteger(e.dimValue.low) && l.isInteger(e.dimValue.high)))) return "dimValue: integer|Long expected";
                            if (null != e.dimParam && e.hasOwnProperty("dimParam")) {
                                if (1 === t.value) return "value: multiple values";
                                if (t.value = 1, !l.isString(e.dimParam)) return "dimParam: string expected";
                            }
                            return null != e.denotation && e.hasOwnProperty("denotation") && !l.isString(e.denotation) ? "denotation: string expected" : null;
                        }, e65.fromObject = function(e) {
                            if (e instanceof c.onnx.TensorShapeProto.Dimension) return e;
                            var t = new c.onnx.TensorShapeProto.Dimension;
                            return null != e.dimValue && (l.Long ? (t.dimValue = l.Long.fromValue(e.dimValue)).unsigned = !1 : "string" == typeof e.dimValue ? t.dimValue = parseInt(e.dimValue, 10) : "number" == typeof e.dimValue ? t.dimValue = e.dimValue : "object" == typeof e.dimValue && (t.dimValue = new l.LongBits(e.dimValue.low >>> 0, e.dimValue.high >>> 0).toNumber())), null != e.dimParam && (t.dimParam = String(e.dimParam)), null != e.denotation && (t.denotation = String(e.denotation)), t;
                        }, e65.toObject = function(e, t) {
                            t || (t = {});
                            var n = {};
                            return t.defaults && (n.denotation = ""), null != e.dimValue && e.hasOwnProperty("dimValue") && ("number" == typeof e.dimValue ? n.dimValue = t.longs === String ? String(e.dimValue) : e.dimValue : n.dimValue = t.longs === String ? l.Long.prototype.toString.call(e.dimValue) : t.longs === Number ? new l.LongBits(e.dimValue.low >>> 0, e.dimValue.high >>> 0).toNumber() : e.dimValue, t.oneofs && (n.value = "dimValue")), null != e.dimParam && e.hasOwnProperty("dimParam") && (n.dimParam = e.dimParam, t.oneofs && (n.value = "dimParam")), null != e.denotation && e.hasOwnProperty("denotation") && (n.denotation = e.denotation), n;
                        }, e65.prototype.toJSON = function() {
                            return this.constructor.toObject(this, s.util.toJSONOptions);
                        }, e65;
                    }(), e64;
                }(), o6.TypeProto = function() {
                    function e66(e) {
                        if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    var t31;
                    return e66.prototype.tensorType = null, e66.prototype.denotation = "", Object.defineProperty(e66.prototype, "value", {
                        get: l.oneOfGetter(t31 = [
                            "tensorType"
                        ]),
                        set: l.oneOfSetter(t31)
                    }), e66.create = function(t) {
                        return new e66(t);
                    }, e66.encode = function(e, t) {
                        return t || (t = u.create()), null != e.tensorType && e.hasOwnProperty("tensorType") && c.onnx.TypeProto.Tensor.encode(e.tensorType, t.uint32(10).fork()).ldelim(), null != e.denotation && e.hasOwnProperty("denotation") && t.uint32(50).string(e.denotation), t;
                    }, e66.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e66.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.tensorType = c.onnx.TypeProto.Tensor.decode(e, e.uint32());
                                    break;
                                case 6:
                                    r.denotation = e.string();
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e66.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e66.verify = function(e) {
                        if ("object" != typeof e || null === e) return "object expected";
                        if (null != e.tensorType && e.hasOwnProperty("tensorType")) {
                            var t = c.onnx.TypeProto.Tensor.verify(e.tensorType);
                            if (t) return "tensorType." + t;
                        }
                        return null != e.denotation && e.hasOwnProperty("denotation") && !l.isString(e.denotation) ? "denotation: string expected" : null;
                    }, e66.fromObject = function(e) {
                        if (e instanceof c.onnx.TypeProto) return e;
                        var t = new c.onnx.TypeProto;
                        if (null != e.tensorType) {
                            if ("object" != typeof e.tensorType) throw TypeError(".onnx.TypeProto.tensorType: object expected");
                            t.tensorType = c.onnx.TypeProto.Tensor.fromObject(e.tensorType);
                        }
                        return null != e.denotation && (t.denotation = String(e.denotation)), t;
                    }, e66.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        return t.defaults && (n.denotation = ""), null != e.tensorType && e.hasOwnProperty("tensorType") && (n.tensorType = c.onnx.TypeProto.Tensor.toObject(e.tensorType, t), t.oneofs && (n.value = "tensorType")), null != e.denotation && e.hasOwnProperty("denotation") && (n.denotation = e.denotation), n;
                    }, e66.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e66.Tensor = function() {
                        function e67(e) {
                            if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                        }
                        return e67.prototype.elemType = 0, e67.prototype.shape = null, e67.create = function(t) {
                            return new e67(t);
                        }, e67.encode = function(e, t) {
                            return t || (t = u.create()), null != e.elemType && e.hasOwnProperty("elemType") && t.uint32(8).int32(e.elemType), null != e.shape && e.hasOwnProperty("shape") && c.onnx.TensorShapeProto.encode(e.shape, t.uint32(18).fork()).ldelim(), t;
                        }, e67.encodeDelimited = function(e, t) {
                            return this.encode(e, t).ldelim();
                        }, e67.decode = function(e, t) {
                            e instanceof a || (e = a.create(e));
                            for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.TypeProto.Tensor; e.pos < n;){
                                var i = e.uint32();
                                switch(i >>> 3){
                                    case 1:
                                        r.elemType = e.int32();
                                        break;
                                    case 2:
                                        r.shape = c.onnx.TensorShapeProto.decode(e, e.uint32());
                                        break;
                                    default:
                                        e.skipType(7 & i);
                                }
                            }
                            return r;
                        }, e67.decodeDelimited = function(e) {
                            return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                        }, e67.verify = function(e) {
                            if ("object" != typeof e || null === e) return "object expected";
                            if (null != e.elemType && e.hasOwnProperty("elemType") && !l.isInteger(e.elemType)) return "elemType: integer expected";
                            if (null != e.shape && e.hasOwnProperty("shape")) {
                                var t = c.onnx.TensorShapeProto.verify(e.shape);
                                if (t) return "shape." + t;
                            }
                            return null;
                        }, e67.fromObject = function(e) {
                            if (e instanceof c.onnx.TypeProto.Tensor) return e;
                            var t = new c.onnx.TypeProto.Tensor;
                            if (null != e.elemType && (t.elemType = 0 | e.elemType), null != e.shape) {
                                if ("object" != typeof e.shape) throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                                t.shape = c.onnx.TensorShapeProto.fromObject(e.shape);
                            }
                            return t;
                        }, e67.toObject = function(e, t) {
                            t || (t = {});
                            var n = {};
                            return t.defaults && (n.elemType = 0, n.shape = null), null != e.elemType && e.hasOwnProperty("elemType") && (n.elemType = e.elemType), null != e.shape && e.hasOwnProperty("shape") && (n.shape = c.onnx.TensorShapeProto.toObject(e.shape, t)), n;
                        }, e67.prototype.toJSON = function() {
                            return this.constructor.toObject(this, s.util.toJSONOptions);
                        }, e67;
                    }(), e66;
                }(), o6.OperatorSetIdProto = function() {
                    function e68(e) {
                        if (e) for(var t = Object.keys(e), n = 0; n < t.length; ++n)null != e[t[n]] && (this[t[n]] = e[t[n]]);
                    }
                    return e68.prototype.domain = "", e68.prototype.version = l.Long ? l.Long.fromBits(0, 0, !1) : 0, e68.create = function(t) {
                        return new e68(t);
                    }, e68.encode = function(e, t) {
                        return t || (t = u.create()), null != e.domain && e.hasOwnProperty("domain") && t.uint32(10).string(e.domain), null != e.version && e.hasOwnProperty("version") && t.uint32(16).int64(e.version), t;
                    }, e68.encodeDelimited = function(e, t) {
                        return this.encode(e, t).ldelim();
                    }, e68.decode = function(e, t) {
                        e instanceof a || (e = a.create(e));
                        for(var n = void 0 === t ? e.len : e.pos + t, r = new c.onnx.OperatorSetIdProto; e.pos < n;){
                            var i = e.uint32();
                            switch(i >>> 3){
                                case 1:
                                    r.domain = e.string();
                                    break;
                                case 2:
                                    r.version = e.int64();
                                    break;
                                default:
                                    e.skipType(7 & i);
                            }
                        }
                        return r;
                    }, e68.decodeDelimited = function(e) {
                        return e instanceof a || (e = new a(e)), this.decode(e, e.uint32());
                    }, e68.verify = function(e) {
                        return "object" != typeof e || null === e ? "object expected" : null != e.domain && e.hasOwnProperty("domain") && !l.isString(e.domain) ? "domain: string expected" : null != e.version && e.hasOwnProperty("version") && !(l.isInteger(e.version) || e.version && l.isInteger(e.version.low) && l.isInteger(e.version.high)) ? "version: integer|Long expected" : null;
                    }, e68.fromObject = function(e) {
                        if (e instanceof c.onnx.OperatorSetIdProto) return e;
                        var t = new c.onnx.OperatorSetIdProto;
                        return null != e.domain && (t.domain = String(e.domain)), null != e.version && (l.Long ? (t.version = l.Long.fromValue(e.version)).unsigned = !1 : "string" == typeof e.version ? t.version = parseInt(e.version, 10) : "number" == typeof e.version ? t.version = e.version : "object" == typeof e.version && (t.version = new l.LongBits(e.version.low >>> 0, e.version.high >>> 0).toNumber())), t;
                    }, e68.toObject = function(e, t) {
                        t || (t = {});
                        var n = {};
                        if (t.defaults) {
                            if (n.domain = "", l.Long) {
                                var r = new l.Long(0, 0, !1);
                                n.version = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;
                            } else n.version = t.longs === String ? "0" : 0;
                        }
                        return null != e.domain && e.hasOwnProperty("domain") && (n.domain = e.domain), null != e.version && e.hasOwnProperty("version") && ("number" == typeof e.version ? n.version = t.longs === String ? String(e.version) : e.version : n.version = t.longs === String ? l.Long.prototype.toString.call(e.version) : t.longs === Number ? new l.LongBits(e.version.low >>> 0, e.version.high >>> 0).toNumber() : e.version), n;
                    }, e68.prototype.toJSON = function() {
                        return this.constructor.toObject(this, s.util.toJSONOptions);
                    }, e68;
                }(), o6), e54.exports = c;
            },
            2100: (e, t, n)=>{
                "use strict";
                e.exports = n(9482);
            },
            9482: (e, t, n)=>{
                "use strict";
                var r = t;
                function i() {
                    r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
                }
                r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();
            },
            1408: (e69, t32, n19)=>{
                "use strict";
                e69.exports = u;
                var r, i = n19(9693), o = i.LongBits, s = i.utf8;
                function a(e, t) {
                    return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len);
                }
                function u(e) {
                    this.buf = e, this.pos = 0, this.len = e.length;
                }
                var l, c = "undefined" != typeof Uint8Array ? function(e) {
                    if (e instanceof Uint8Array || Array.isArray(e)) return new u(e);
                    throw Error("illegal buffer");
                } : function(e) {
                    if (Array.isArray(e)) return new u(e);
                    throw Error("illegal buffer");
                }, p = function() {
                    return i.Buffer ? function(e70) {
                        return (u.create = function(e) {
                            return i.Buffer.isBuffer(e) ? new r(e) : c(e);
                        })(e70);
                    } : c;
                };
                function d() {
                    var e = new o(0, 0), t = 0;
                    if (!(this.len - this.pos > 4)) {
                        for(; t < 3; ++t){
                            if (this.pos >= this.len) throw a(this);
                            if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;
                        }
                        return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;
                    }
                    for(; t < 4; ++t)if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;
                    if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;
                    if (t = 0, this.len - this.pos > 4) {
                        for(; t < 5; ++t)if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;
                    } else for(; t < 5; ++t){
                        if (this.pos >= this.len) throw a(this);
                        if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;
                    }
                    throw Error("invalid varint encoding");
                }
                function f(e, t) {
                    return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;
                }
                function h() {
                    if (this.pos + 8 > this.len) throw a(this, 8);
                    return new o(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));
                }
                u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (l = 4294967295, function() {
                    if (l = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return l;
                    if (l = (l | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return l;
                    if (l = (l | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return l;
                    if (l = (l | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return l;
                    if (l = (l | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return l;
                    if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);
                    return l;
                }), u.prototype.int32 = function() {
                    return 0 | this.uint32();
                }, u.prototype.sint32 = function() {
                    var e = this.uint32();
                    return e >>> 1 ^ -(1 & e) | 0;
                }, u.prototype.bool = function() {
                    return 0 !== this.uint32();
                }, u.prototype.fixed32 = function() {
                    if (this.pos + 4 > this.len) throw a(this, 4);
                    return f(this.buf, this.pos += 4);
                }, u.prototype.sfixed32 = function() {
                    if (this.pos + 4 > this.len) throw a(this, 4);
                    return 0 | f(this.buf, this.pos += 4);
                }, u.prototype.float = function() {
                    if (this.pos + 4 > this.len) throw a(this, 4);
                    var e = i.float.readFloatLE(this.buf, this.pos);
                    return this.pos += 4, e;
                }, u.prototype.double = function() {
                    if (this.pos + 8 > this.len) throw a(this, 4);
                    var e = i.float.readDoubleLE(this.buf, this.pos);
                    return this.pos += 8, e;
                }, u.prototype.bytes = function() {
                    var e = this.uint32(), t = this.pos, n = this.pos + e;
                    if (n > this.len) throw a(this, e);
                    return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, n) : t === n ? new this.buf.constructor(0) : this._slice.call(this.buf, t, n);
                }, u.prototype.string = function() {
                    var e = this.bytes();
                    return s.read(e, 0, e.length);
                }, u.prototype.skip = function(e) {
                    if ("number" == typeof e) {
                        if (this.pos + e > this.len) throw a(this, e);
                        this.pos += e;
                    } else do {
                        if (this.pos >= this.len) throw a(this);
                    }while (128 & this.buf[this.pos++])
                    return this;
                }, u.prototype.skipType = function(e) {
                    switch(e){
                        case 0:
                            this.skip();
                            break;
                        case 1:
                            this.skip(8);
                            break;
                        case 2:
                            this.skip(this.uint32());
                            break;
                        case 3:
                            for(; 4 != (e = 7 & this.uint32());)this.skipType(e);
                            break;
                        case 5:
                            this.skip(4);
                            break;
                        default:
                            throw Error("invalid wire type " + e + " at offset " + this.pos);
                    }
                    return this;
                }, u._configure = function(e) {
                    r = e, u.create = p(), r._configure();
                    var t = i.Long ? "toLong" : "toNumber";
                    i.merge(u.prototype, {
                        int64: function() {
                            return d.call(this)[t](!1);
                        },
                        uint64: function() {
                            return d.call(this)[t](!0);
                        },
                        sint64: function() {
                            return d.call(this).zzDecode()[t](!1);
                        },
                        fixed64: function() {
                            return h.call(this)[t](!0);
                        },
                        sfixed64: function() {
                            return h.call(this)[t](!1);
                        }
                    });
                };
            },
            593: (e71, t, n)=>{
                "use strict";
                e71.exports = o;
                var r = n(1408);
                (o.prototype = Object.create(r.prototype)).constructor = o;
                var i = n(9693);
                function o(e) {
                    r.call(this, e);
                }
                o._configure = function() {
                    i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
                }, o.prototype.string = function() {
                    var e = this.uint32();
                    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
                }, o._configure();
            },
            5054: (e)=>{
                "use strict";
                e.exports = {};
            },
            5994: (e, t, n)=>{
                "use strict";
                t.Service = n(7948);
            },
            7948: (e72, t33, n20)=>{
                "use strict";
                e72.exports = i10;
                var r = n20(9693);
                function i10(e, t, n) {
                    if ("function" != typeof e) throw TypeError("rpcImpl must be a function");
                    r.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(n);
                }
                (i10.prototype = Object.create(r.EventEmitter.prototype)).constructor = i10, i10.prototype.rpcCall = function e73(t, n21, i, o, s) {
                    if (!o) throw TypeError("request must be specified");
                    var a = this;
                    if (!s) return r.asPromise(e73, a, t, n21, i, o);
                    if (a.rpcImpl) try {
                        return a.rpcImpl(t, n21[a.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(e, n) {
                            if (e) return a.emit("error", e, t), s(e);
                            if (null !== n) {
                                if (!(n instanceof i)) try {
                                    n = i[a.responseDelimited ? "decodeDelimited" : "decode"](n);
                                } catch (e) {
                                    return a.emit("error", e, t), s(e);
                                }
                                return a.emit("data", n, t), s(null, n);
                            }
                            a.end(!0);
                        });
                    } catch (e) {
                        return a.emit("error", e, t), void setTimeout(function() {
                            s(e);
                        }, 0);
                    }
                    else setTimeout(function() {
                        s(Error("already ended"));
                    }, 0);
                }, i10.prototype.end = function(e) {
                    return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
                };
            },
            1945: (e74, t34, n22)=>{
                "use strict";
                e74.exports = i;
                var r17 = n22(9693);
                function i(e, t) {
                    this.lo = e >>> 0, this.hi = t >>> 0;
                }
                var o = i.zero = new i(0, 0);
                o.toNumber = function() {
                    return 0;
                }, o.zzEncode = o.zzDecode = function() {
                    return this;
                }, o.length = function() {
                    return 1;
                };
                var s = i.zeroHash = "\0\0\0\0\0\0\0\0";
                i.fromNumber = function(e) {
                    if (0 === e) return o;
                    var t = e < 0;
                    t && (e = -e);
                    var n = e >>> 0, r = (e - n) / 4294967296 >>> 0;
                    return t && (r = ~r >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++r > 4294967295 && (r = 0))), new i(n, r);
                }, i.from = function(e) {
                    if ("number" == typeof e) return i.fromNumber(e);
                    if (r17.isString(e)) {
                        if (!r17.Long) return i.fromNumber(parseInt(e, 10));
                        e = r17.Long.fromString(e);
                    }
                    return e.low || e.high ? new i(e.low >>> 0, e.high >>> 0) : o;
                }, i.prototype.toNumber = function(e) {
                    if (!e && this.hi >>> 31) {
                        var t = 1 + ~this.lo >>> 0, n = ~this.hi >>> 0;
                        return t || (n = n + 1 >>> 0), -(t + 4294967296 * n);
                    }
                    return this.lo + 4294967296 * this.hi;
                }, i.prototype.toLong = function(e) {
                    return r17.Long ? new r17.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : {
                        low: 0 | this.lo,
                        high: 0 | this.hi,
                        unsigned: Boolean(e)
                    };
                };
                var a = String.prototype.charCodeAt;
                i.fromHash = function(e) {
                    return e === s ? o : new i((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);
                }, i.prototype.toHash = function() {
                    return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
                }, i.prototype.zzEncode = function() {
                    var e = this.hi >> 31;
                    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;
                }, i.prototype.zzDecode = function() {
                    var e = -(1 & this.lo);
                    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;
                }, i.prototype.length = function() {
                    var e = this.lo, t = (this.lo >>> 28 | this.hi << 4) >>> 0, n = this.hi >>> 24;
                    return 0 === n ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;
                };
            },
            9693: function(e75, t35, n23) {
                "use strict";
                var r18 = t35;
                function i11(e, t, n) {
                    for(var r = Object.keys(t), i = 0; i < r.length; ++i)void 0 !== e[r[i]] && n || (e[r[i]] = t[r[i]]);
                    return e;
                }
                function o(e76) {
                    function t(e, n) {
                        if (!(this instanceof t)) return new t(e, n);
                        Object.defineProperty(this, "message", {
                            get: function() {
                                return e;
                            }
                        }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", {
                            value: (new Error).stack || ""
                        }), n && i11(this, n);
                    }
                    return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", {
                        get: function() {
                            return e76;
                        }
                    }), t.prototype.toString = function() {
                        return this.name + ": " + this.message;
                    }, t;
                }
                r18.asPromise = n23(4537), r18.base64 = n23(7419), r18.EventEmitter = n23(9211), r18.float = n23(945), r18.inquire = n23(7199), r18.utf8 = n23(4997), r18.pool = n23(6662), r18.LongBits = n23(1945), r18.isNode = Boolean(void 0 !== n23.g && n23.g && n23.g.process && n23.g.process.versions && n23.g.process.versions.node), r18.global = r18.isNode && n23.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r18.emptyArray = Object.freeze ? Object.freeze([]) : [], r18.emptyObject = Object.freeze ? Object.freeze({}) : {}, r18.isInteger = Number.isInteger || function(e) {
                    return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
                }, r18.isString = function(e) {
                    return "string" == typeof e || e instanceof String;
                }, r18.isObject = function(e) {
                    return e && "object" == typeof e;
                }, r18.isset = r18.isSet = function(e, t) {
                    var n = e[t];
                    return !(null == n || !e.hasOwnProperty(t)) && ("object" != typeof n || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0);
                }, r18.Buffer = function() {
                    try {
                        var e = r18.inquire("buffer").Buffer;
                        return e.prototype.utf8Write ? e : null;
                    } catch (e) {
                        return null;
                    }
                }(), r18._Buffer_from = null, r18._Buffer_allocUnsafe = null, r18.newBuffer = function(e) {
                    return "number" == typeof e ? r18.Buffer ? r18._Buffer_allocUnsafe(e) : new r18.Array(e) : r18.Buffer ? r18._Buffer_from(e) : "undefined" == typeof Uint8Array ? e : new Uint8Array(e);
                }, r18.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r18.Long = r18.global.dcodeIO && r18.global.dcodeIO.Long || r18.global.Long || r18.inquire("long"), r18.key2Re = /^true|false|0|1$/, r18.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r18.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r18.longToHash = function(e) {
                    return e ? r18.LongBits.from(e).toHash() : r18.LongBits.zeroHash;
                }, r18.longFromHash = function(e, t) {
                    var n = r18.LongBits.fromHash(e);
                    return r18.Long ? r18.Long.fromBits(n.lo, n.hi, t) : n.toNumber(Boolean(t));
                }, r18.merge = i11, r18.lcFirst = function(e) {
                    return e.charAt(0).toLowerCase() + e.substring(1);
                }, r18.newError = o, r18.ProtocolError = o("ProtocolError"), r18.oneOfGetter = function(e77) {
                    for(var t = {}, n24 = 0; n24 < e77.length; ++n24)t[e77[n24]] = 1;
                    return function() {
                        for(var e = Object.keys(this), n = e.length - 1; n > -1; --n)if (1 === t[e[n]] && void 0 !== this[e[n]] && null !== this[e[n]]) return e[n];
                    };
                }, r18.oneOfSetter = function(e) {
                    return function(t) {
                        for(var n = 0; n < e.length; ++n)e[n] !== t && delete this[e[n]];
                    };
                }, r18.toJSONOptions = {
                    longs: String,
                    enums: String,
                    bytes: String,
                    json: !0
                }, r18._configure = function() {
                    var e = r18.Buffer;
                    e ? (r18._Buffer_from = e.from !== Uint8Array.from && e.from || function(t, n) {
                        return new e(t, n);
                    }, r18._Buffer_allocUnsafe = e.allocUnsafe || function(t) {
                        return new e(t);
                    }) : r18._Buffer_from = r18._Buffer_allocUnsafe = null;
                };
            },
            1173: (e78, t36, n25)=>{
                "use strict";
                e78.exports = p;
                var r19, i = n25(9693), o = i.LongBits, s = i.base64, a = i.utf8;
                function u(e, t, n) {
                    this.fn = e, this.len = t, this.next = void 0, this.val = n;
                }
                function l() {}
                function c(e) {
                    this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
                }
                function p() {
                    this.len = 0, this.head = new u(l, 0, 0), this.tail = this.head, this.states = null;
                }
                var d = function() {
                    return i.Buffer ? function() {
                        return (p.create = function() {
                            return new r19;
                        })();
                    } : function() {
                        return new p;
                    };
                };
                function f(e, t, n) {
                    t[n] = 255 & e;
                }
                function h(e, t) {
                    this.len = e, this.next = void 0, this.val = t;
                }
                function g(e, t, n) {
                    for(; e.hi;)t[n++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
                    for(; e.lo > 127;)t[n++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;
                    t[n++] = e.lo;
                }
                function m(e, t, n) {
                    t[n] = 255 & e, t[n + 1] = e >>> 8 & 255, t[n + 2] = e >>> 16 & 255, t[n + 3] = e >>> 24;
                }
                p.create = d(), p.alloc = function(e) {
                    return new i.Array(e);
                }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(e, t, n) {
                    return this.tail = this.tail.next = new u(e, t, n), this.len += t, this;
                }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(e, t, n) {
                    for(; e > 127;)t[n++] = 127 & e | 128, e >>>= 7;
                    t[n] = e;
                }, p.prototype.uint32 = function(e) {
                    return this.len += (this.tail = this.tail.next = new h((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;
                }, p.prototype.int32 = function(e) {
                    return e < 0 ? this._push(g, 10, o.fromNumber(e)) : this.uint32(e);
                }, p.prototype.sint32 = function(e) {
                    return this.uint32((e << 1 ^ e >> 31) >>> 0);
                }, p.prototype.uint64 = function(e) {
                    var t = o.from(e);
                    return this._push(g, t.length(), t);
                }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(e) {
                    var t = o.from(e).zzEncode();
                    return this._push(g, t.length(), t);
                }, p.prototype.bool = function(e) {
                    return this._push(f, 1, e ? 1 : 0);
                }, p.prototype.fixed32 = function(e) {
                    return this._push(m, 4, e >>> 0);
                }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(e) {
                    var t = o.from(e);
                    return this._push(m, 4, t.lo)._push(m, 4, t.hi);
                }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(e) {
                    return this._push(i.float.writeFloatLE, 4, e);
                }, p.prototype.double = function(e) {
                    return this._push(i.float.writeDoubleLE, 8, e);
                };
                var b = i.Array.prototype.set ? function(e, t, n) {
                    t.set(e, n);
                } : function(e, t, n) {
                    for(var r = 0; r < e.length; ++r)t[n + r] = e[r];
                };
                p.prototype.bytes = function(e) {
                    var t = e.length >>> 0;
                    if (!t) return this._push(f, 1, 0);
                    if (i.isString(e)) {
                        var n = p.alloc(t = s.length(e));
                        s.decode(e, n, 0), e = n;
                    }
                    return this.uint32(t)._push(b, t, e);
                }, p.prototype.string = function(e) {
                    var t = a.length(e);
                    return t ? this.uint32(t)._push(a.write, t, e) : this._push(f, 1, 0);
                }, p.prototype.fork = function() {
                    return this.states = new c(this), this.head = this.tail = new u(l, 0, 0), this.len = 0, this;
                }, p.prototype.reset = function() {
                    return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(l, 0, 0), this.len = 0), this;
                }, p.prototype.ldelim = function() {
                    var e = this.head, t = this.tail, n = this.len;
                    return this.reset().uint32(n), n && (this.tail.next = e.next, this.tail = t, this.len += n), this;
                }, p.prototype.finish = function() {
                    for(var e = this.head.next, t = this.constructor.alloc(this.len), n = 0; e;)e.fn(e.val, t, n), n += e.len, e = e.next;
                    return t;
                }, p._configure = function(e) {
                    r19 = e, p.create = d(), r19._configure();
                };
            },
            3155: (e79, t37, n26)=>{
                "use strict";
                e79.exports = o;
                var r20 = n26(1173);
                (o.prototype = Object.create(r20.prototype)).constructor = o;
                var i = n26(9693);
                function o() {
                    r20.call(this);
                }
                function s(e, t, n) {
                    e.length < 40 ? i.utf8.write(e, t, n) : t.utf8Write ? t.utf8Write(e, n) : t.write(e, n);
                }
                o._configure = function() {
                    o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(e, t, n) {
                        t.set(e, n);
                    } : function(e, t, n) {
                        if (e.copy) e.copy(t, n, 0, e.length);
                        else for(var r = 0; r < e.length;)t[n++] = e[r++];
                    };
                }, o.prototype.bytes = function(e) {
                    i.isString(e) && (e = i._Buffer_from(e, "base64"));
                    var t = e.length >>> 0;
                    return this.uint32(t), t && this._push(o.writeBytesBuffer, t, e), this;
                }, o.prototype.string = function(e) {
                    var t = i.Buffer.byteLength(e);
                    return this.uint32(t), t && this._push(s, t, e), this;
                }, o._configure();
            },
            7714: (e80, t38, n27)=>{
                "use strict";
                t38.R = void 0;
                const r = n27(6919), i = n27(7448);
                t38.R = new class {
                    async init() {}
                    async createSessionHandler(e, t) {
                        const n = new r.Session(t);
                        return await n.loadModel(e), new i.OnnxjsSessionHandler(n);
                    }
                };
            },
            4200: (e81, t39, n28)=>{
                "use strict";
                Object.defineProperty(t39, "__esModule", {
                    value: !0
                }), t39.wasmBackend = t39.initializeFlags = void 0;
                const r21 = n28(2203), i12 = n28(2174), o = n28(5381), s = n28(8022), a = n28(2157), u = n28(2306);
                t39.initializeFlags = ()=>{
                    if (("number" != typeof i12.env.wasm.initTimeout || i12.env.wasm.initTimeout < 0) && (i12.env.wasm.initTimeout = 0), "boolean" != typeof i12.env.wasm.simd && (i12.env.wasm.simd = !0), "boolean" != typeof i12.env.wasm.proxy && (i12.env.wasm.proxy = !1), "number" != typeof i12.env.wasm.numThreads || !Number.isInteger(i12.env.wasm.numThreads) || i12.env.wasm.numThreads <= 0) {
                        const e = "undefined" == typeof navigator ? o.cpus().length : navigator.hardwareConcurrency;
                        i12.env.wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));
                    }
                }, t39.wasmBackend = new class {
                    async init() {
                        t39.initializeFlags(), await a.initWasm();
                    }
                    async createSessionHandler(e, t) {
                        let n;
                        if ("string" == typeof e) {
                            if ("undefined" == typeof fetch) n = await s.promisify(r21.readFile)(e);
                            else {
                                const t = await fetch(e), r = await t.arrayBuffer();
                                n = new Uint8Array(r);
                            }
                        } else n = e;
                        const i = new u.OnnxruntimeWebAssemblySessionHandler;
                        return await i.loadModel(n, t), Promise.resolve(i);
                    }
                };
            },
            6018: function(e82, t40, n29) {
                "use strict";
                var r22 = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), i = this && this.__exportStar || function(e, t) {
                    for(var n in e)"default" === n || Object.prototype.hasOwnProperty.call(t, n) || r22(t, e, n);
                };
                Object.defineProperty(t40, "__esModule", {
                    value: !0
                }), i(n29(2174), t40);
                const o = n29(2174);
                {
                    const e = n29(7714).R;
                    o.registerBackend("webgl", e, -1);
                }
                {
                    const e = n29(4200).wasmBackend;
                    o.registerBackend("wasm", e, 0);
                }
            },
            246: (e83, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createAttributeWithCacheKey = void 0;
                class n {
                    constructor(e){
                        Object.assign(this, e);
                    }
                    get cacheKey() {
                        return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e)=>`${this[e]}`
                        ).join(";")), this._cacheKey;
                    }
                }
                t.createAttributeWithCacheKey = (e)=>new n(e)
                ;
            },
            7778: (e84, t41, n30)=>{
                "use strict";
                Object.defineProperty(t41, "__esModule", {
                    value: !0
                }), t41.Attribute = void 0;
                const r23 = n30(1446);
                var i = n30(9395).onnxruntime.experimental.fbs;
                const o = n30(9162), s = n30(2517);
                class a {
                    constructor(e){
                        if (this._attributes = new Map, null != e) {
                            for (const t of e)t instanceof r23.onnx.AttributeProto ? this._attributes.set(t.name, [
                                a.getValue(t),
                                a.getType(t)
                            ]) : t instanceof i.Attribute && this._attributes.set(t.name(), [
                                a.getValue(t),
                                a.getType(t)
                            ]);
                            if (this._attributes.size < e.length) throw new Error("duplicated attribute names");
                        }
                    }
                    set(e, t, n) {
                        this._attributes.set(e, [
                            n,
                            t
                        ]);
                    }
                    delete(e) {
                        this._attributes.delete(e);
                    }
                    getFloat(e, t) {
                        return this.get(e, "float", t);
                    }
                    getInt(e, t) {
                        return this.get(e, "int", t);
                    }
                    getString(e, t) {
                        return this.get(e, "string", t);
                    }
                    getTensor(e, t) {
                        return this.get(e, "tensor", t);
                    }
                    getFloats(e, t) {
                        return this.get(e, "floats", t);
                    }
                    getInts(e, t) {
                        return this.get(e, "ints", t);
                    }
                    getStrings(e, t) {
                        return this.get(e, "strings", t);
                    }
                    getTensors(e, t) {
                        return this.get(e, "tensors", t);
                    }
                    get(e, t, n) {
                        const r = this._attributes.get(e);
                        if (void 0 === r) {
                            if (void 0 !== n) return n;
                            throw new Error(`required attribute not found: ${e}`);
                        }
                        if (r[1] !== t) throw new Error(`type mismatch: expected ${t} but got ${r[1]}`);
                        return r[0];
                    }
                    static getType(e) {
                        const t = e instanceof r23.onnx.AttributeProto ? e.type : e.type();
                        switch(t){
                            case r23.onnx.AttributeProto.AttributeType.FLOAT:
                                return "float";
                            case r23.onnx.AttributeProto.AttributeType.INT:
                                return "int";
                            case r23.onnx.AttributeProto.AttributeType.STRING:
                                return "string";
                            case r23.onnx.AttributeProto.AttributeType.TENSOR:
                                return "tensor";
                            case r23.onnx.AttributeProto.AttributeType.FLOATS:
                                return "floats";
                            case r23.onnx.AttributeProto.AttributeType.INTS:
                                return "ints";
                            case r23.onnx.AttributeProto.AttributeType.STRINGS:
                                return "strings";
                            case r23.onnx.AttributeProto.AttributeType.TENSORS:
                                return "tensors";
                            default:
                                throw new Error(`attribute type is not supported yet: ${r23.onnx.AttributeProto.AttributeType[t]}`);
                        }
                    }
                    static getValue(e85) {
                        const t = e85 instanceof r23.onnx.AttributeProto ? e85.type : e85.type();
                        if (t === r23.onnx.AttributeProto.AttributeType.GRAPH || t === r23.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error("graph attribute is not supported yet");
                        const n = this.getValueNoCheck(e85);
                        if (t === r23.onnx.AttributeProto.AttributeType.INT && s.LongUtil.isLong(n)) return s.LongUtil.longToNumber(n);
                        if (t === r23.onnx.AttributeProto.AttributeType.INTS) {
                            const e = n, t = new Array(e.length);
                            for(let n31 = 0; n31 < e.length; n31++){
                                const r = e[n31];
                                t[n31] = s.LongUtil.longToNumber(r);
                            }
                            return t;
                        }
                        if (t === r23.onnx.AttributeProto.AttributeType.TENSOR) return e85 instanceof r23.onnx.AttributeProto ? o.Tensor.fromProto(n) : o.Tensor.fromOrtTensor(n);
                        if (t === r23.onnx.AttributeProto.AttributeType.TENSORS) {
                            if (e85 instanceof r23.onnx.AttributeProto) return n.map((e)=>o.Tensor.fromProto(e)
                            );
                            if (e85 instanceof i.Attribute) return n.map((e)=>o.Tensor.fromOrtTensor(e)
                            );
                        }
                        if (t === r23.onnx.AttributeProto.AttributeType.STRING && e85 instanceof r23.onnx.AttributeProto) {
                            const e = n;
                            return s.decodeUtf8String(e);
                        }
                        return t === r23.onnx.AttributeProto.AttributeType.STRINGS && e85 instanceof r23.onnx.AttributeProto ? n.map(s.decodeUtf8String) : n;
                    }
                    static getValueNoCheck(e) {
                        return e instanceof r23.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e) : this.getValueNoCheckFromOrtFormat(e);
                    }
                    static getValueNoCheckFromOnnxFormat(e) {
                        switch(e.type){
                            case r23.onnx.AttributeProto.AttributeType.FLOAT:
                                return e.f;
                            case r23.onnx.AttributeProto.AttributeType.INT:
                                return e.i;
                            case r23.onnx.AttributeProto.AttributeType.STRING:
                                return e.s;
                            case r23.onnx.AttributeProto.AttributeType.TENSOR:
                                return e.t;
                            case r23.onnx.AttributeProto.AttributeType.GRAPH:
                                return e.g;
                            case r23.onnx.AttributeProto.AttributeType.FLOATS:
                                return e.floats;
                            case r23.onnx.AttributeProto.AttributeType.INTS:
                                return e.ints;
                            case r23.onnx.AttributeProto.AttributeType.STRINGS:
                                return e.strings;
                            case r23.onnx.AttributeProto.AttributeType.TENSORS:
                                return e.tensors;
                            case r23.onnx.AttributeProto.AttributeType.GRAPHS:
                                return e.graphs;
                            default:
                                throw new Error(`unsupported attribute type: ${r23.onnx.AttributeProto.AttributeType[e.type]}`);
                        }
                    }
                    static getValueNoCheckFromOrtFormat(e) {
                        switch(e.type()){
                            case i.AttributeType.FLOAT:
                                return e.f();
                            case i.AttributeType.INT:
                                return e.i();
                            case i.AttributeType.STRING:
                                return e.s();
                            case i.AttributeType.TENSOR:
                                return e.t();
                            case i.AttributeType.GRAPH:
                                return e.g();
                            case i.AttributeType.FLOATS:
                                return e.floatsArray();
                            case i.AttributeType.INTS:
                                {
                                    const t = [];
                                    for(let n = 0; n < e.intsLength(); n++)t.push(e.ints(n));
                                    return t;
                                }
                            case i.AttributeType.STRINGS:
                                {
                                    const t = [];
                                    for(let n = 0; n < e.stringsLength(); n++)t.push(e.strings(n));
                                    return t;
                                }
                            case i.AttributeType.TENSORS:
                                {
                                    const t = [];
                                    for(let n = 0; n < e.tensorsLength(); n++)t.push(e.tensors(n));
                                    return t;
                                }
                            default:
                                throw new Error(`unsupported attribute type: ${i.AttributeType[e.type()]}`);
                        }
                    }
                }
                t41.Attribute = a;
            },
            7091: (e86, t42, n32)=>{
                "use strict";
                Object.defineProperty(t42, "__esModule", {
                    value: !0
                }), t42.resolveBackend = t42.backend = void 0;
                const r24 = n32(5038), i = new Map;
                async function o(e87) {
                    const n = t42.backend;
                    if (void 0 !== n[e87] && function(e) {
                        const t = e;
                        return "initialize" in t && "function" == typeof t.initialize && "createSessionHandler" in t && "function" == typeof t.createSessionHandler && "dispose" in t && "function" == typeof t.dispose;
                    }(n[e87])) {
                        const t = n[e87];
                        let r = t.initialize();
                        if ("object" == typeof r && "then" in r && (r = await r), r) return i.set(e87, t), t;
                    }
                }
                t42.backend = {
                    webgl: new r24.WebGLBackend
                }, t42.resolveBackend = async function e(t) {
                    if (!t) return e([
                        "webgl"
                    ]);
                    {
                        const e = "string" == typeof t ? [
                            t
                        ] : t;
                        for (const t43 of e){
                            const e = i.get(t43);
                            if (e) return e;
                            const n = await o(t43);
                            if (n) return n;
                        }
                    }
                    throw new Error("no available backend to use");
                };
            },
            5038: (e88, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.WebGLBackend = void 0;
                const r = n(2174), i = n(6231), o = n(6416), s = n(7305);
                t.WebGLBackend = class {
                    get contextId() {
                        return r.env.webgl.contextId;
                    }
                    set contextId(e) {
                        r.env.webgl.contextId = e;
                    }
                    get matmulMaxBatchSize() {
                        return r.env.webgl.matmulMaxBatchSize;
                    }
                    set matmulMaxBatchSize(e) {
                        r.env.webgl.matmulMaxBatchSize = e;
                    }
                    get textureCacheMode() {
                        return r.env.webgl.textureCacheMode;
                    }
                    set textureCacheMode(e) {
                        r.env.webgl.textureCacheMode = e;
                    }
                    get pack() {
                        return r.env.webgl.pack;
                    }
                    set pack(e) {
                        r.env.webgl.pack = e;
                    }
                    get async() {
                        return r.env.webgl.async;
                    }
                    set async(e) {
                        r.env.webgl.async = e;
                    }
                    initialize() {
                        try {
                            return this.glContext = s.createWebGLContext(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = !1), "boolean" != typeof this.async && (this.async = !1), i.Logger.setWithEnv(r.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;
                        } catch (e) {
                            return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e}`), !1;
                        }
                    }
                    createSessionHandler(e) {
                        return new o.WebGLSessionHandler(this, e);
                    }
                    dispose() {
                        this.glContext.dispose();
                    }
                };
            },
            5107: (e89, t44, n33)=>{
                "use strict";
                Object.defineProperty(t44, "__esModule", {
                    value: !0
                }), t44.CoordsGlslLib = void 0;
                const r25 = n33(2517), i13 = n33(8520), o7 = n33(5060), s7 = n33(7859), a4 = n33(9390);
                class u4 extends i13.GlslLib {
                    constructor(e){
                        super(e);
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
                    }
                    getCustomTypes() {
                        return {};
                    }
                    offsetToCoords() {
                        return {
                            offsetToCoords: new i13.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")
                        };
                    }
                    coordsToOffset() {
                        return {
                            coordsToOffset: new i13.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")
                        };
                    }
                    getOutputSamplingSnippet() {
                        const e = this.context.outputTextureLayout;
                        return e.isPacked ? this.getPackedOutputSamplingSnippet(e) : this.getUnpackedOutputSamplingSnippet(e);
                    }
                    getPackedOutputSamplingSnippet(e) {
                        const t = e.unpackedShape, n = [
                            e.width,
                            e.height
                        ], r = {}, s = "getOutputCoords";
                        switch(t.length){
                            case 0:
                                r[s] = this.getOutputScalarCoords();
                                break;
                            case 1:
                                r[s] = this.getOutputPacked1DCoords(t, n);
                                break;
                            case 2:
                                r[s] = this.getOutputPacked2DCoords(t, n);
                                break;
                            case 3:
                                r[s] = this.getOutputPacked3DCoords(t, n);
                                break;
                            default:
                                r[s] = this.getOutputPackedNDCoords(t, n);
                        }
                        const a = `\n      void setOutput(vec4 val) {\n        ${o7.getGlsl(this.context.glContext.version).output} = val;\n      }\n    `;
                        return r.floatTextureSetRGBA = new i13.GlslLibRoutine(a), r;
                    }
                    getUnpackedOutputSamplingSnippet(e) {
                        const t = e.unpackedShape, n = [
                            e.width,
                            e.height
                        ], r = {}, s = "getOutputCoords";
                        switch(t.length){
                            case 0:
                                r[s] = this.getOutputScalarCoords();
                                break;
                            case 1:
                                r[s] = this.getOutputUnpacked1DCoords(t, n);
                                break;
                            case 2:
                                r[s] = this.getOutputUnpacked2DCoords(t, n);
                                break;
                            case 3:
                                r[s] = this.getOutputUnpacked3DCoords(t, n);
                                break;
                            case 4:
                                r[s] = this.getOutputUnpacked4DCoords(t, n);
                                break;
                            case 5:
                                r[s] = this.getOutputUnpacked5DCoords(t, n);
                                break;
                            case 6:
                                r[s] = this.getOutputUnpacked6DCoords(t, n);
                                break;
                            default:
                                throw new Error(`Unsupported output dimensionality: ${t.length}`);
                        }
                        const a = `\n        void setOutput(float val) {\n          ${o7.getGlsl(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;
                        return r.floatTextureSetR = new i13.GlslLibRoutine(a), r;
                    }
                    getOutputScalarCoords() {
                        return new i13.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
                    }
                    getOutputPacked1DCoords(e, t) {
                        const n = t;
                        let r = "";
                        return 1 === n[0] ? (r = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${n[1]}.0);\n          }\n        `, new i13.GlslLibRoutine(r)) : 1 === n[1] ? (r = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${n[0]}.0);\n          }\n        `, new i13.GlslLibRoutine(r)) : (r = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${n[0]}, ${n[1]}));\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\n        }\n      `, new i13.GlslLibRoutine(r));
                    }
                    getOutputPacked2DCoords(e, t) {
                        let n = "";
                        if (r25.ArrayUtil.arraysEqual(e, t)) return n = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `, new i13.GlslLibRoutine(n);
                        const o = t, s = Math.ceil(e[1] / 2);
                        return n = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${o[0]}, ${o[1]}));\n\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${s}) * 2;\n          int c = 2 * (index / ${s});\n\n          return ivec2(r, c);\n        }\n      `, new i13.GlslLibRoutine(n);
                    }
                    getOutputPacked3DCoords(e, t) {
                        const n = [
                            t[0],
                            t[1]
                        ], r = Math.ceil(e[2] / 2), o = r * Math.ceil(e[1] / 2), s = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${n[0]}, ${n[1]}));\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n          int b = index / ${o};\n          index -= b * ${o};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${r}) * 2;\n          int c = 2 * (index / ${r});\n\n          return ivec3(b, r, c);\n        }\n      `;
                        return new i13.GlslLibRoutine(s);
                    }
                    getOutputPackedNDCoords(e, t) {
                        const n = [
                            t[0],
                            t[1]
                        ], r = Math.ceil(e[e.length - 1] / 2), o = r * Math.ceil(e[e.length - 2] / 2);
                        let s = o, a = "", u = "b, r, c";
                        for(let t45 = 2; t45 < e.length - 1; t45++)s *= e[e.length - t45 - 1], a = `\n      int b${t45} = index / ${s};\n      index -= b${t45} * ${s};\n    ` + a, u = `b${t45}, ` + u;
                        const l = `\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\n\n        ${a}\n\n        int b = index / ${o};\n        index -= b * ${o};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${r}) * 2;\n        int c = 2 * (index / ${r});\n\n        return ivec${e.length}(${u});\n      }\n    `;
                        return new i13.GlslLibRoutine(l);
                    }
                    getOutputUnpacked1DCoords(e, t) {
                        const n = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;
                        return new i13.GlslLibRoutine(n);
                    }
                    getOutputUnpacked2DCoords(e, t) {
                        const n = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;
                        return new i13.GlslLibRoutine(n);
                    }
                    getOutputUnpacked3DCoords(e90, t47) {
                        let n = "";
                        const r = e90.length;
                        let o = null;
                        r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = e90[r - 1];
                        for(let t46 = r - 3; t46 >= 0; --t46)o[t46] = o[t46 + 1] * e90[t46 + 1];
                        const s = [
                            "r",
                            "c",
                            "d"
                        ], a = o.map((e, t)=>`int ${s[t]} = index / ${e}; ${t === o.length - 1 ? `int ${s[t + 1]} = index - ${s[t]} * ${e}` : `index -= ${s[t]} * ${e}`};`
                        ).join("");
                        return n = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t47[0]}, ${t47[1]}));\n          int index = resTexRC.y * ${t47[0]} + resTexRC.x;\n          ${a}\n          return ivec3(r, c, d);\n        }\n      `, new i13.GlslLibRoutine(n);
                    }
                    getOutputUnpacked4DCoords(e91, t49) {
                        let n = "";
                        const r = e91.length;
                        let o = null;
                        r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = e91[r - 1];
                        for(let t48 = r - 3; t48 >= 0; --t48)o[t48] = o[t48 + 1] * e91[t48 + 1];
                        const s = [
                            "r",
                            "c",
                            "d",
                            "d2"
                        ], a = o.map((e, t)=>`int ${s[t]} = index / ${e}; ${t === o.length - 1 ? `int ${s[t + 1]} = index - ${s[t]} * ${e}` : `index -= ${s[t]} * ${e}`};`
                        ).join("");
                        return n = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t49[0]}, ${t49[1]}));\n          int index = resTexRC.y * ${t49[0]} + resTexRC.x;\n          ${a}\n          return ivec4(r, c, d, d2);\n        }\n      `, new i13.GlslLibRoutine(n);
                    }
                    getOutputUnpacked5DCoords(e92, t51) {
                        let n = "";
                        const r = e92.length;
                        let o = null;
                        r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = e92[r - 1];
                        for(let t50 = r - 3; t50 >= 0; --t50)o[t50] = o[t50 + 1] * e92[t50 + 1];
                        const s = [
                            "r",
                            "c",
                            "d",
                            "d2",
                            "d3"
                        ], a = o.map((e, t)=>`int ${s[t]} = index / ${e}; ${t === o.length - 1 ? `int ${s[t + 1]} = index - ${s[t]} * ${e}` : `index -= ${s[t]} * ${e}`};`
                        ).join("");
                        return n = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t51[0]}, ${t51[1]}));\n          int index = resTexRC.y * ${t51[0]} + resTexRC.x;\n          ${a}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `, new i13.GlslLibRoutine(n);
                    }
                    getOutputUnpacked6DCoords(e93, t53) {
                        let n = "";
                        const r = e93.length;
                        let o = null;
                        r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = e93[r - 1];
                        for(let t52 = r - 3; t52 >= 0; --t52)o[t52] = o[t52 + 1] * e93[t52 + 1];
                        const s = [
                            "r",
                            "c",
                            "d",
                            "d2",
                            "d3",
                            "d4"
                        ], a = o.map((e, t)=>`int ${s[t]} = index / ${e}; ${t === o.length - 1 ? `int ${s[t + 1]} = index - ${s[t]} * ${e}` : `index -= ${s[t]} * ${e}`};`
                        ).join("");
                        return n = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t53[0]}, ${t53[1]}));\n         int index = resTexRC.y * ${t53[0]} + resTexRC.x;\n         ${a}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `, new i13.GlslLibRoutine(n);
                    }
                    getCommonUtilFuncs() {
                        const e = {};
                        let t = "uvFromFlat";
                        e[t] = new i13.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), t = "packedUVfrom1D", e[t] = new i13.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t = "packedUVfrom2D", e[t] = new i13.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t = "packedUVfrom3D", e[t] = new i13.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t = "sampleTexture";
                        const n = o7.getGlsl(this.context.glContext.version);
                        return e[t] = new i13.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${n.texture2D}(textureSampler, uv).r;\n        }`), e;
                    }
                    getInputsSamplingSnippets() {
                        const e = {}, t = this.context.outputTextureLayout;
                        return this.context.programInfo.inputNames.forEach((n, r)=>{
                            const i = this.context.inputTextureLayouts[r], o = a4.generateShaderFuncNameFromInputSamplerName(n);
                            i.isPacked ? e[o] = this.getPackedSamplerFromInput(o, n, i) : e[o] = this.getUnpackedSamplerFromInput(o, n, i);
                            const s = a4.generateShaderFuncNameFromInputSamplerNameAtOutCoords(n);
                            i.unpackedShape.length <= t.unpackedShape.length && (i.isPacked ? e[s] = this.getPackedSamplerAtOutputCoords(s, i, t, n) : e[s] = this.getUnpackedSamplerAtOutputCoords(s, i, t, n));
                        }), e;
                    }
                    getPackedSamplerAtOutputCoords(e94, t54, n, o) {
                        const s = t54.unpackedShape, u = n.unpackedShape, l = o, c = a4.generateShaderFuncNameFromInputSamplerName(l), p = s.length, d = u.length, f = r25.BroadcastUtil.getBroadcastDims(s, u), h = a4.getCoordsDataType(d), g = d - p;
                        let m;
                        const b = a4.getGlChannels();
                        m = 0 === p ? "" : d < 2 && f.length >= 1 ? "coords = 0;" : f.map((e)=>`coords.${b[e + g]} = 0;`
                        ).join("\n");
                        let y = "";
                        y = d < 2 && p > 0 ? "coords" : s.map((e, t)=>`coords.${b[t + g]}`
                        ).join(", ");
                        let _ = "return outputValue;";
                        const v = 1 === r25.ShapeUtil.size(s), w = 1 === r25.ShapeUtil.size(u);
                        if (1 !== p || v || w) {
                            if (v && !w) _ = 1 === d ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
                            else if (f.length) {
                                const e = p - 2, t = p - 1;
                                f.indexOf(e) > -1 && f.indexOf(t) > -1 ? _ = "return vec4(outputValue.x);" : f.indexOf(e) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : f.indexOf(t) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
                            }
                        } else _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
                        const x = `\n      vec4 ${e94}() {\n        ${h} coords = getOutputCoords();\n        \n        int lastDim = coords.${b[d - 1]};\n        coords.${b[d - 1]} = coords.${b[d - 2]};\n        coords.${b[d - 2]} = lastDim;\n      \n        ${m}\n        vec4 outputValue = ${c}(${y});\n        ${_}\n      }\n    `;
                        return new i13.GlslLibRoutine(x, [
                            "coordinates.getOutputCoords"
                        ]);
                    }
                    getUnpackedSamplerAtOutputCoords(e95, t55, n, o) {
                        const s = [
                            n.width,
                            n.height
                        ], u = [
                            t55.width,
                            t55.height
                        ], l = t55.unpackedShape.length, c = n.unpackedShape.length, p = t55.unpackedShape, d = n.unpackedShape, f = a4.generateShaderFuncNameFromInputSamplerName(o);
                        if (l === c && r25.ArrayUtil.arraysEqual(u, s)) {
                            const t = `\n          float ${e95}() {\n            return sampleTexture(${o}, TexCoords);\n          }\n        `;
                            return new i13.GlslLibRoutine(t, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        const h = a4.getCoordsDataType(c), g = r25.BroadcastUtil.getBroadcastDims(p, d), m = c - l;
                        let b;
                        const y = a4.getGlChannels();
                        b = 0 === l ? "" : c < 2 && g.length >= 1 ? "coords = 0;" : g.map((e)=>`coords.${y[e + m]} = 0;`
                        ).join("\n");
                        let _ = "";
                        _ = c < 2 && l > 0 ? "coords" : t55.unpackedShape.map((e, t)=>`coords.${y[t + m]}`
                        ).join(", ");
                        const v = `\n        float ${e95}() {\n          ${h} coords = getOutputCoords();\n          ${b}\n          return ${f}(${_});\n        }\n      `;
                        return new i13.GlslLibRoutine(v, [
                            "coordinates.getOutputCoords"
                        ]);
                    }
                    getPackedSamplerFromInput(e, t, n) {
                        switch(n.unpackedShape.length){
                            case 0:
                                return this.getPackedSamplerScalar(e, t);
                            case 1:
                                return this.getPackedSampler1D(e, t, n);
                            case 2:
                                return this.getPackedSampler2D(e, t, n);
                            case 3:
                                return this.getPackedSampler3D(e, t, n);
                            default:
                                return this.getPackedSamplerND(e, t, n);
                        }
                    }
                    getUnpackedSamplerFromInput(e, t, n) {
                        const r = n.unpackedShape;
                        switch(r.length){
                            case 0:
                                return this.getUnpackedSamplerScalar(e, t, n);
                            case 1:
                                return this.getUnpackedSampler1D(e, t, n);
                            case 2:
                                return this.getUnpackedSampler2D(e, t, n);
                            case 3:
                                return this.getUnpackedSampler3D(e, t, n);
                            case 4:
                                return this.getUnpackedSampler4D(e, t, n);
                            case 5:
                                return this.getUnpackedSampler5D(e, t, n);
                            case 6:
                                return this.getUnpackedSampler6D(e, t, n);
                            default:
                                throw new Error(`Unsupported dimension ${r.length}-D`);
                        }
                    }
                    getPackedSamplerScalar(e, t) {
                        const n = `\n          vec4 ${e}() {\n            return ${o7.getGlsl(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;
                        return new i13.GlslLibRoutine(n);
                    }
                    getPackedSampler1D(e, t, n) {
                        const r = [
                            n.width,
                            n.height
                        ], s = [
                            r[1],
                            r[0]
                        ], a = o7.getGlsl(this.context.glContext.version), u = `vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${s[0]}, ${s[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }`;
                        return new i13.GlslLibRoutine(u, [
                            "coordinates.packedUVfrom1D"
                        ]);
                    }
                    getPackedSampler2D(e, t, n) {
                        const s = n.unpackedShape, a = [
                            n.width,
                            n.height
                        ], u = o7.getGlsl(this.context.glContext.version), l = a[0], c = a[1];
                        if (null != a && r25.ArrayUtil.arraysEqual(s, a)) {
                            const n = `vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);\n        return ${u.texture2D}(${t}, uv);\n      }`;
                            return new i13.GlslLibRoutine(n);
                        }
                        const p = a, d = Math.ceil(s[1] / 2), f = `vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);\n      return ${u.texture2D}(${t}, uv);\n    }`;
                        return new i13.GlslLibRoutine(f, [
                            "coordinates.packedUVfrom2D"
                        ]);
                    }
                    getPackedSampler3D(e, t, n) {
                        const r = n.unpackedShape, s = [
                            n.width,
                            n.height
                        ], u = [
                            s[0],
                            s[1]
                        ], l = o7.getGlsl(this.context.glContext.version);
                        if (1 === r[0]) {
                            const o = r.slice(1), s = [
                                1,
                                2
                            ], u = a4.squeezeInputShape(r, o), l = [
                                "b",
                                "row",
                                "col"
                            ], c = JSON.parse(JSON.stringify(n));
                            c.unpackedShape = u;
                            const p = this.getPackedSamplerFromInput(e, t, c), d = `${p.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${a4.getSqueezedParams(l, s)});\n      } `;
                            return new i13.GlslLibRoutine(d, p.dependencies);
                        }
                        const c = u[0], p = u[1], d = Math.ceil(r[2] / 2), f = `vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${c}, ${d * Math.ceil(r[1] / 2)}, ${d}, b, row, col);\n      return ${l.texture2D}(${t}, uv);}`;
                        return new i13.GlslLibRoutine(f, [
                            "coordinates.packedUVfrom3D"
                        ]);
                    }
                    getPackedSamplerND(e, t, n) {
                        const r = n.unpackedShape, s = r.length, a = [
                            n.width,
                            n.height
                        ], u = o7.getGlsl(this.context.glContext.version), l = [
                            a[0],
                            a[1]
                        ], c = l[1], p = l[0], d = Math.ceil(r[s - 1] / 2);
                        let f = d * Math.ceil(r[s - 2] / 2), h = "int b, int row, int col", g = `b * ${f} + (row / 2) * ${d} + (col / 2)`;
                        for(let e96 = 2; e96 < s - 1; e96++)h = `int b${e96}, ` + h, f *= r[s - e96 - 1], g = `b${e96} * ${f} + ` + g;
                        const m = `vec4 ${e}(${h}) {\n      int index = ${g};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});\n      return ${u.texture2D}(${t}, uv);\n    }`;
                        return new i13.GlslLibRoutine(m);
                    }
                    getUnpackedSamplerScalar(e, t, n) {
                        const [r, o] = [
                            n.width,
                            n.height
                        ];
                        if (1 === r && 1 === o) {
                            const n = `\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        const s = `\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${r}, ${o});\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;
                        return new i13.GlslLibRoutine(s, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture",
                            "coordinates.coordsToOffset"
                        ]);
                    }
                    getUnpackedSampler1D(e, t, n) {
                        const r = n.width, o = n.height;
                        if (1 === o && 1 === r) {
                            const n = `\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        if (1 === o) {
                            const n = `\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        if (1 === r) {
                            const n = `\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        const s = `\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;
                        return new i13.GlslLibRoutine(s, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture"
                        ]);
                    }
                    getUnpackedSampler2D(e, t, n) {
                        const o = n.unpackedShape, u = [
                            n.height,
                            n.width
                        ];
                        if (null != u && r25.ArrayUtil.arraysEqual(o, u)) {
                            const n = `\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        const { newShape: l , keptDims: c  } = s7.squeezeShape(o), p = l;
                        if (p.length < o.length) {
                            const r = a4.squeezeInputShape(o, p), s = JSON.parse(JSON.stringify(n));
                            s.unpackedShape = r;
                            const u = [
                                "col",
                                "row"
                            ], l = `\n          ${this.getUnpackedSamplerFromInput(e, t, s).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${a4.getSqueezedParams(u, c)});\n          }\n        `;
                            return new i13.GlslLibRoutine(l, [
                                "coordinates.sampleTexture"
                            ]);
                        }
                        const d = u[1], f = u[0];
                        if (1 === f) {
                            const n = `\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture",
                                "coordinates.coordsToOffset"
                            ]);
                        }
                        if (1 === d) {
                            const n = `\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                            return new i13.GlslLibRoutine(n, [
                                "coordinates.sampleTexture",
                                "coordinates.coordsToOffset"
                            ]);
                        }
                        const h = `\n        float ${e}(int row, int col) {\n          int index = col * ${o[1]} + row;\n          vec2 uv = uvFromFlat(${d}, ${f}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;
                        return new i13.GlslLibRoutine(h, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture",
                            "coordinates.coordsToOffset"
                        ]);
                    }
                    getUnpackedSampler3D(e, t, n) {
                        const r = n.unpackedShape, o = r[1] * r[2], u = r[2], { newShape: l , keptDims: c  } = s7.squeezeShape(r), p = l;
                        if (p.length < r.length) {
                            const o = a4.squeezeInputShape(r, p), s = [
                                "batch",
                                "col",
                                "row"
                            ], u = JSON.parse(JSON.stringify(n));
                            u.unpackedShape = o;
                            const l = this.getUnpackedSamplerFromInput(e, t, u), d = c.reverse(), f = `\n          ${l.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${a4.getSqueezedParams(s, d)});\n          }\n        `;
                            return new i13.GlslLibRoutine(f, l.dependencies);
                        }
                        const d = `\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${o} + col * ${u} + row;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;
                        return new i13.GlslLibRoutine(d, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture",
                            "coordinates.coordsToOffset"
                        ]);
                    }
                    getUnpackedSampler4D(e, t, n) {
                        const r = n.unpackedShape, o = r[3], s = r[2] * o, a = `\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${r[1] * s} + col * ${s} +\n              depth2 * ${o} + depth;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;
                        return new i13.GlslLibRoutine(a, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture"
                        ]);
                    }
                    getUnpackedSampler5D(e, t, n) {
                        const r = n.unpackedShape, o = r[4], u = r[3] * o, l = r[2] * u, c = r[1] * l, { newShape: p , keptDims: d  } = s7.squeezeShape(r);
                        if (p.length < r.length) {
                            const o = a4.squeezeInputShape(r, p), s = [
                                "row",
                                "col",
                                "depth",
                                "depth2",
                                "depth3"
                            ], u = JSON.parse(JSON.stringify(n));
                            u.unpackedShape = o;
                            const l = `\n          ${this.getUnpackedSamplerFromInput(e, t, u).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${a4.getSqueezedParams(s, d)});\n          }\n        `;
                            return new i13.GlslLibRoutine(l, [
                                "coordinates.sampleTexture",
                                "coordinates.uvFromFlat"
                            ]);
                        }
                        const f = `\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth3 * ${o} + depth2;\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;
                        return new i13.GlslLibRoutine(f, [
                            "coordinates.sampleTexture",
                            "coordinates.uvFromFlat"
                        ]);
                    }
                    getUnpackedSampler6D(e, t, n) {
                        const r = n.unpackedShape, o = r[5], u = r[4] * o, l = r[3] * u, c = r[2] * l, p = r[1] * c, { newShape: d , keptDims: f  } = s7.squeezeShape(r);
                        if (d.length < r.length) {
                            const o = a4.squeezeInputShape(r, d), s = [
                                "row",
                                "col",
                                "depth",
                                "depth2",
                                "depth3",
                                "depth4"
                            ], u = JSON.parse(JSON.stringify(n));
                            u.unpackedShape = o;
                            const l = `\n            ${this.getUnpackedSamplerFromInput(e, t, u).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${a4.getSqueezedParams(s, f)});\n            }\n          `;
                            return new i13.GlslLibRoutine(l, [
                                "coordinates.sampleTexture",
                                "coordinates.uvFromFlat"
                            ]);
                        }
                        const h = `\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${p} + col * ${c} + depth * ${l} +\n            depth2 * ${u} + depth3 * ${o} + depth4;\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;
                        return new i13.GlslLibRoutine(h, [
                            "coordinates.uvFromFlat",
                            "coordinates.sampleTexture",
                            "coordinates.coordsToOffset"
                        ]);
                    }
                    toVec() {
                        const e = this.context.outputTextureLayout, t = e.shape.length, n = e.strides, r = e.width, o = e.height, s = [];
                        for(let e97 = 0; e97 < t - 1; ++e97)s.push(`\n        c[${e97}] = offset / ${n[e97]};`), s.push(`\n        offset -= c[${e97}] * ${n[e97]};`);
                        s.push(`\n        c[${t - 1}] = offset;`);
                        const a = `\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\n        ${s.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${s.join("")}\n      }\n    `;
                        return {
                            toVec: new i13.GlslLibRoutine(a, [
                                "coordinates.coordsToOffset"
                            ])
                        };
                    }
                    valueFrom() {
                        const e = {};
                        return this.context.programInfo.inputNames.forEach((t, n)=>{
                            const r = this.context.inputTextureLayouts[n], o = (r.unpackedShape.length > 0 ? r.unpackedShape : r.shape).length;
                            let s = `_${t}`;
                            e[s] = new i13.GlslLibRoutine(this.getValueFromSingle(t, o, r.width, r.height, !1), [
                                `shapeUtils.indicesToOffset${s}`,
                                "coordinates.offsetToCoords",
                                "fragcolor.getColorAsFloat"
                            ]), s += "_T", e[s] = new i13.GlslLibRoutine(this.getValueFromSingle(t, o, r.width, r.height, !0), [
                                `shapeUtils.indicesToOffset${s}`,
                                "coordinates.offsetToCoords",
                                "fragcolor.getColorAsFloat"
                            ]);
                        }), e;
                    }
                    getValueFromSingle(e, t, n, r, i) {
                        let s = `_${e}`;
                        return i && (s += "_T"), `\n        float ${s}(int m[${t}]) {\n          int offset = indicesToOffset${s}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          float value = getColorAsFloat(${o7.getGlsl(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `;
                    }
                    getPackedValueFrom(e, t, n, r, i) {
                        let s = `_${e}_Pack`;
                        return i && (s += "_T"), `\n        vec4 ${s}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\n          return ${o7.getGlsl(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `;
                    }
                }
                t44.CoordsGlslLib = u4;
            },
            8520: (e98, t56)=>{
                "use strict";
                var n34;
                Object.defineProperty(t56, "__esModule", {
                    value: !0
                }), t56.TopologicalSortGlslRoutines = t56.GlslLibRoutineNode = t56.GlslLibRoutine = t56.GlslLib = t56.GlslContext = t56.FunctionType = void 0, (n34 = t56.FunctionType || (t56.FunctionType = {}))[n34.ValueBased = 0] = "ValueBased", n34[n34.Positional = 1] = "Positional", t56.GlslContext = class {
                    constructor(e, t, n, r){
                        this.glContext = e, this.programInfo = t, this.inputTextureLayouts = n, this.outputTextureLayout = r;
                    }
                }, t56.GlslLib = class {
                    constructor(e){
                        this.context = e;
                    }
                }, t56.GlslLibRoutine = class {
                    constructor(e, t){
                        this.routineBody = e, this.dependencies = t;
                    }
                }, t56.GlslLibRoutineNode = class {
                    constructor(e, t, n){
                        this.name = e, this.dependencies = n || [], t && (this.routineBody = t);
                    }
                    addDependency(e) {
                        e && this.dependencies.push(e);
                    }
                }, t56.TopologicalSortGlslRoutines = class {
                    static returnOrderedNodes(e) {
                        if (!e || 0 === e.length) return [];
                        if (1 === e.length) return e;
                        const t = new Set, n = new Set, r = new Array;
                        return this.createOrderedNodes(e, t, n, r), r;
                    }
                    static createOrderedNodes(e, t, n, r) {
                        for(let i = 0; i < e.length; ++i)this.dfsTraverse(e[i], t, n, r);
                    }
                    static dfsTraverse(e, t, n, r) {
                        if (!e || n.has(e.name)) return;
                        if (t.has(e.name)) throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
                        t.add(e.name);
                        const i = e.dependencies;
                        if (i && i.length > 0) for(let e99 = 0; e99 < i.length; ++e99)this.dfsTraverse(i[e99], t, n, r);
                        r.push(e), n.add(e.name), t.delete(e.name);
                    }
                };
            },
            7341: (e100, t57, n35)=>{
                "use strict";
                Object.defineProperty(t57, "__esModule", {
                    value: !0
                }), t57.EncodingGlslLib = void 0;
                const r = n35(8520);
                class i extends r.GlslLib {
                    constructor(e){
                        super(e);
                    }
                    getFunctions() {
                        return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
                    }
                    getCustomTypes() {
                        return {};
                    }
                    encodeFloat32() {
                        return {
                            encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")
                        };
                    }
                    decodeFloat32() {
                        return {
                            decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")
                        };
                    }
                    encodeUint8() {
                        const e = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                        return {
                            encode: new r.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)
                        };
                    }
                    decodeUint8() {
                        const e = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                        return {
                            decode: new r.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)
                        };
                    }
                    static isLittleEndian() {
                        const e = new ArrayBuffer(4), t = new Uint32Array(e), n = new Uint8Array(e);
                        if (t[0] = 3735928559, 239 === n[0]) return !0;
                        if (222 === n[0]) return !1;
                        throw new Error("unknown endianness");
                    }
                }
                t57.EncodingGlslLib = i;
            },
            9894: (e101, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FragColorGlslLib = void 0;
                const r = n(8520), i = n(5060);
                class o extends r.GlslLib {
                    constructor(e){
                        super(e);
                    }
                    getFunctions() {
                        return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
                    }
                    getCustomTypes() {
                        return {};
                    }
                    setFragColor() {
                        const e = i.getGlsl(this.context.glContext.version);
                        return {
                            setFragColor: new r.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `, [
                                "encoding.encode"
                            ])
                        };
                    }
                    getColorAsFloat() {
                        return {
                            getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", [
                                "encoding.decode"
                            ])
                        };
                    }
                }
                t.FragColorGlslLib = o;
            },
            2848: (e102, t58)=>{
                "use strict";
                Object.defineProperty(t58, "__esModule", {
                    value: !0
                }), t58.replaceInlines = void 0;
                const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
                t58.replaceInlines = function(e104) {
                    const t59 = {};
                    let r;
                    for(; null !== (r = n.exec(e104));){
                        const e103 = r[3].split(",").map((e)=>{
                            const t = e.trim().split(" ");
                            return t && 2 === t.length ? {
                                type: t[0],
                                name: t[1]
                            } : null;
                        }).filter((e)=>null !== e
                        );
                        t59[r[2]] = {
                            params: e103,
                            body: r[4]
                        };
                    }
                    for(const n36 in t59){
                        const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n36), o = new RegExp(i, "gm");
                        for(; null !== (r = o.exec(e104));){
                            const i = r[1], o = r[2], s = r[3].split(","), a = i ? `${i} ${o};` : "";
                            let u = t59[n36].body, l = "";
                            t59[n36].params.forEach((e, t)=>{
                                e && (l += `${e.type} ${e.name} = ${s[t]};\n`);
                            }), u = `${l}\n ${u}`, u = u.replace("return", `${o} = `);
                            const c = `\n      ${a}\n      {\n        ${u}\n      }\n      `;
                            e104 = e104.replace(r[0], c);
                        }
                    }
                    return e104.replace(n, "");
                };
            },
            8879: (e106, t60, n37)=>{
                "use strict";
                Object.defineProperty(t60, "__esModule", {
                    value: !0
                }), t60.GlslPreprocessor = void 0;
                const r26 = n37(8520), i14 = n37(2848), o8 = n37(5483), s8 = n37(5060);
                t60.GlslPreprocessor = class {
                    constructor(e107, t61, n, i){
                        this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r26.GlslContext(e107, t61, n, i), Object.keys(o8.glslRegistry).forEach((e)=>{
                            const t = new o8.glslRegistry[e](this.context);
                            this.libs[e] = t;
                        });
                        const s = this.glslLibRoutineDependencyGraph;
                        for(const e105 in this.libs){
                            const t = this.libs[e105].getFunctions();
                            for(const n in t){
                                const i = e105 + "." + n;
                                let o;
                                s[i] ? (o = s[i], o.routineBody = t[n].routineBody) : (o = new r26.GlslLibRoutineNode(i, t[n].routineBody), s[i] = o);
                                const a = t[n].dependencies;
                                if (a) for(let e = 0; e < a.length; ++e)if (s[a[e]]) o.addDependency(s[a[e]]);
                                else {
                                    const t = new r26.GlslLibRoutineNode(a[e]);
                                    s[a[e]] = t, o.addDependency(t);
                                }
                            }
                        }
                    }
                    preprocess() {
                        const e = this.context.programInfo;
                        let t = e.shaderSource;
                        return this.context.programInfo.hasMain || (t = `${t}\n      ${s8.getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t = i14.replaceInlines(t), `${s8.getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames, e.variables)}\n    ${this.getImports(t)}\n    ${t}`;
                    }
                    getImports(e) {
                        const t = this.selectGlslLibRoutinesToBeIncluded(e);
                        if (0 === t.length) return "";
                        let n = "";
                        for(let e108 = 0; e108 < t.length; ++e108){
                            if (!t[e108].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${t[e108].name}`);
                            n += t[e108].routineBody + "\n";
                        }
                        return n;
                    }
                    selectGlslLibRoutinesToBeIncluded(e) {
                        const t = [];
                        return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n)=>{
                            const r = n.split(".")[1];
                            -1 !== e.indexOf(r) && t.push(this.glslLibRoutineDependencyGraph[n]);
                        }), r26.TopologicalSortGlslRoutines.returnOrderedNodes(t);
                    }
                    getUniforms(e, t) {
                        const n = [];
                        if (e) for (const t62 of e)n.push(`uniform sampler2D ${t62};`);
                        if (t) for (const e109 of t)n.push(`uniform ${e109.type} ${e109.name}${e109.arrayLength ? `[${e109.arrayLength}]` : ""};`);
                        return n.join("\n");
                    }
                };
            },
            5483: (e, t, n)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.glslRegistry = void 0;
                const r = n(5107), i = n(7341), o = n(9894), s = n(2655), a = n(3891);
                t.glslRegistry = {
                    encoding: i.EncodingGlslLib,
                    fragcolor: o.FragColorGlslLib,
                    vec: a.VecGlslLib,
                    shapeUtils: s.ShapeUtilsGlslLib,
                    coordinates: r.CoordsGlslLib
                };
            },
            2655: (e110, t63, n38)=>{
                "use strict";
                Object.defineProperty(t63, "__esModule", {
                    value: !0
                }), t63.ShapeUtilsGlslLib = void 0;
                const r27 = n38(8520);
                class i15 extends r27.GlslLib {
                    constructor(e){
                        super(e);
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
                    }
                    getCustomTypes() {
                        return {};
                    }
                    bcastIndex() {
                        const e = this.context.outputTextureLayout.shape.length, t = {};
                        return this.context.programInfo.inputNames.forEach((n, i)=>{
                            const o = this.context.inputTextureLayouts[i].unpackedShape;
                            if (o.length <= e) {
                                const i = o.length, s = e - i, a = `bcastIndices_${n}`;
                                let u = "";
                                for(let e111 = 0; e111 < i; ++e111)u += `\n          realIndices[${e111}] = int( mod(float(bcastedIndices[${s + e111}]), ${o[e111]}.0) );\n          `;
                                const l = `\n        void ${a} (int bcastedIndices[${e}], out int realIndices[${i}]) {\n          ${u}\n        }\n        `;
                                t[a] = new r27.GlslLibRoutine(l);
                            }
                        }), t;
                    }
                    bcastMatmulIndex() {
                        const e = this.context.outputTextureLayout.shape.length, t = {};
                        return this.context.programInfo.inputNames.forEach((n, i)=>{
                            const o = this.context.inputTextureLayouts[i].shape;
                            if (!(o.length < 2 || o.length > e)) {
                                const i = o.length, s = e - i, a = `bcastMatmulIndices_${n}`;
                                let u = "";
                                for(let e113 = 0; e113 < i - 2; ++e113)u += `\n          realIndices[${e113}] = int( mod(float(bcastedIndices[${s + e113}]), ${o[e113]}.0) );\n          `;
                                const l = `\n        void ${a}(int bcastedIndices[${e}], out int realIndices[${i}]) {\n          ${u}\n          realIndices[${i - 1}] = bcastedIndices[${e - 1}];\n          realIndices[${i - 2}] = bcastedIndices[${e - 2}];\n        }\n        `;
                                t[a] = new r27.GlslLibRoutine(l);
                            }
                        }), t;
                    }
                    indicesToOffset() {
                        const e = {};
                        return this.context.programInfo.inputNames.forEach((t, n)=>{
                            const o = this.context.inputTextureLayouts[n].shape, s = this.context.inputTextureLayouts[n].strides, a = o.length;
                            let u = `indicesToOffset_${t}`;
                            e[u] = new r27.GlslLibRoutine(i15.indexToOffsetSingle(u, a, s)), u = `indicesToOffset_${t}_T`, e[u] = new r27.GlslLibRoutine(i15.indexToOffsetSingle(u, a, s.slice().reverse()));
                        }), e;
                    }
                    static indexToOffsetSingle(e, t, n) {
                        let r = "";
                        for(let e115 = t - 1; e115 >= 0; --e115)r += `\n        offset += indices[${e115}] * ${n[e115]};\n        `;
                        return `\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${r}\n        return offset;\n      }\n      `;
                    }
                    offsetToIndices() {
                        const e = {};
                        return this.context.programInfo.inputNames.forEach((t, n)=>{
                            const o = this.context.inputTextureLayouts[n].shape, s = this.context.inputTextureLayouts[n].strides, a = o.length;
                            let u = `offsetToIndices_${t}`;
                            e[u] = new r27.GlslLibRoutine(i15.offsetToIndicesSingle(u, a, s)), u = `offsetToIndices_${t}_T`, e[u] = new r27.GlslLibRoutine(i15.offsetToIndicesSingle(u, a, s.slice().reverse()));
                        }), e;
                    }
                    static offsetToIndicesSingle(e, t, n) {
                        const r = [];
                        for(let e116 = 0; e116 < t - 1; ++e116)r.push(`\n      indices[${e116}] = offset / ${n[e116]};`), r.push(`\n        offset -= indices[${e116}] * ${n[e116]};`);
                        return r.push(`\n      indices[${t - 1}] = offset;`), `\n      void ${e}(int offset, out int indices[${t}]) {\n        ${r.join("")}\n      }\n      `;
                    }
                    incrementIndices() {
                        const e117 = {};
                        return this.context.programInfo.inputNames.forEach((t, n)=>{
                            const i = this.context.inputTextureLayouts[n].shape, o = i.length, s = `incrementIndices_${t}`;
                            let a = "";
                            for(let e = 0; e < o; ++e)a += `\n        shape[${e}] = ${i[e]};`;
                            const u = `\n        void ${s}(int axis, out int indices[${o}]) {\n          int shape[${o}];\n          ${a};\n          for(int i = ${o} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;
                            e117[s] = new r27.GlslLibRoutine(u);
                        }), e117;
                    }
                }
                t63.ShapeUtilsGlslLib = i15;
            },
            5060: (e118, t64)=>{
                "use strict";
                Object.defineProperty(t64, "__esModule", {
                    value: !0
                }), t64.getDefaultFragShaderMain = t64.getFragShaderPreamble = t64.getVertexShaderSource = t64.getGlsl = void 0;
                const n = {
                    version: "",
                    attribute: "attribute",
                    varyingVertex: "varying",
                    varyingFrag: "varying",
                    texture2D: "texture2D",
                    output: "gl_FragColor",
                    outputDeclaration: ""
                }, r = {
                    version: "#version 300 es",
                    attribute: "in",
                    varyingVertex: "out",
                    varyingFrag: "in",
                    texture2D: "texture",
                    output: "outputColor",
                    outputDeclaration: "out vec4 outputColor;"
                };
                function i(e) {
                    return 1 === e ? n : r;
                }
                t64.getGlsl = i, t64.getVertexShaderSource = function(e) {
                    const t = i(e);
                    return `${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;
                }, t64.getFragShaderPreamble = function(e) {
                    const t = i(e);
                    return `${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;
                }, t64.getDefaultFragShaderMain = function(e, t) {
                    return `\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${i(e).output} = result;\n  }\n  `;
                };
            },
            3891: (e119, t65, n39)=>{
                "use strict";
                Object.defineProperty(t65, "__esModule", {
                    value: !0
                }), t65.VecGlslLib = void 0;
                const r = n39(8520);
                class i16 extends r.GlslLib {
                    constructor(e){
                        super(e);
                    }
                    getCustomTypes() {
                        return {};
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
                    }
                    binaryVecFunctions() {
                        const e = this.context.outputTextureLayout.shape.length, t = {
                            add: "+=",
                            sub: "-=",
                            mul: "*=",
                            div: "/="
                        }, n = {};
                        for(const i in t){
                            const o = `${i}Vec`;
                            let s = "";
                            for(let n40 = 0; n40 < e; ++n40)s += `\n          dest[${n40}] ${t[i]} src[${n40}];\n          `;
                            const a = `\n        void ${o}(int src[${e}], out int dest[${e}]) {\n          ${s}\n        }\n        `;
                            n[o] = new r.GlslLibRoutine(a);
                        }
                        return n;
                    }
                    copyVec() {
                        const e = this.context.outputTextureLayout.shape.length;
                        let t = "";
                        for(let n = 0; n < e; ++n)t += `\n        dest[${n}] = src[${n}];\n        `;
                        const n41 = `\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;
                        return {
                            copyVec: new r.GlslLibRoutine(n41)
                        };
                    }
                    setVecItem() {
                        const e = this.context.outputTextureLayout.shape.length;
                        let t = `\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;
                        for(let n = 1; n < e - 1; ++n)t += `\n        else if (index == ${n})\n            m[${n}] = value;\n            `;
                        t += `\n        else\n            m[${e - 1}] = value;\n        `;
                        const n42 = `\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;
                        return {
                            setVecItem: new r.GlslLibRoutine(n42)
                        };
                    }
                    getVecItem() {
                        const e = this.context.outputTextureLayout.shape.length;
                        let t = `\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;
                        for(let n = 1; n < e - 1; ++n)t += `\n        else if (index == ${n})\n            return m[${n}];\n      `;
                        t += `\n        else\n            return m[${e - 1}];\n        `;
                        const n43 = `\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;
                        return {
                            getVecItem: new r.GlslLibRoutine(n43)
                        };
                    }
                }
                t65.VecGlslLib = i16;
            },
            8316: (e120, t66, n44)=>{
                "use strict";
                Object.defineProperty(t66, "__esModule", {
                    value: !0
                }), t66.WebGLInferenceHandler = void 0;
                const r29 = n44(6231), i17 = n44(9162), o9 = n44(2517), s9 = n44(2403), a5 = n44(7019), u5 = n44(8710), l = n44(5611), c = n44(4057), p = n44(2039);
                t66.WebGLInferenceHandler = class {
                    constructor(e){
                        this.session = e, this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map;
                    }
                    calculateTextureWidthAndHeight(e, t) {
                        return c.calculateTextureWidthAndHeight(this.session.layoutStrategy, e, t);
                    }
                    executeProgram(e121, t67) {
                        if (t67.length < e121.inputNames.length) throw new Error(`Input size mustn't be less than ${e121.inputNames.length}.`);
                        if (e121.inputNames.length !== e121.inputTypes.length) throw new Error("input names size does not match input types");
                        const n45 = [];
                        for(let r30 = 0; r30 < e121.inputNames.length; ++r30)n45[r30] = this.getOrCreateTextureData(t67[r30], e121.inputTypes[r30]);
                        const r28 = ((e122, t)=>{
                            const n = t.map((e)=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`
                            ).join("_");
                            let r = e122.name;
                            return e122.cacheHint && (r += "[" + e122.cacheHint + "]"), r += ":" + n, r;
                        })(e121, n45);
                        let i = this.session.programManager.getArtifact(r28);
                        const o = i ? i.programInfo : "function" == typeof e121.get ? e121.get() : e121, s = c.createTextureLayoutFromTextureType(this.session.layoutStrategy, o.output.dims, o.output.textureType), a = this.createTextureData(s, o.output.type);
                        return i || (i = this.session.programManager.build(o, n45, a), this.session.programManager.setArtifact(r28, i)), this.runProgram(i, n45, a), a;
                    }
                    run(e, t) {
                        return this.executeProgram(e, t).tensor;
                    }
                    runProgram(e, t, n) {
                        for(let n46 = 0; n46 < t.length; ++n46)if (!!t[n46].isPacked != (e.programInfo.inputTypes[n46] === p.TextureType.packed)) throw new Error(`input[${n46}] property packed inconsistent`);
                        if (!!n.isPacked != (e.programInfo.output.textureType === p.TextureType.packed)) throw new Error("output property packed inconsistent");
                        this.session.programManager.run(e, t, n);
                    }
                    getOrCreateTextureData(e, t) {
                        let n = this.getTextureData(e.dataId, t === p.TextureType.packed);
                        if (!n && (n = this.getTextureData(e.dataId, t !== p.TextureType.packed), n)) return t === p.TextureType.packed ? this.pack(n) : this.unpack(n);
                        if (!n) {
                            const r = c.createTextureLayoutFromTextureType(this.session.layoutStrategy, e.dims, t);
                            if (t === p.TextureType.packedLastDimension) {
                                const n = 1, r = 4, i = e.dims;
                                if (4 === i.length) {
                                    const o = [
                                        i[0],
                                        Math.ceil(i[1] * i[2] * i[3] / r)
                                    ], s = c.createTextureLayoutFromTextureType(this.session.layoutStrategy, o, t);
                                    let a = e.numberData;
                                    if (i[1] * i[2] * i[3] % r != 0) {
                                        const t = i[0], o = i[1] * i[2] * i[3], s = Math.ceil(o * n / r) * r;
                                        a = new Float32Array(t * s);
                                        for(let r31 = 0; r31 < t; ++r31){
                                            const t = r31 * o, i = r31 * s + r31 % n * o;
                                            a.set(e.numberData.subarray(t, t + o), i);
                                        }
                                    }
                                    return this.createTextureData(s, e.type, a, e, 1);
                                }
                            }
                            if (t === p.TextureType.packed) {
                                const t = c.createTextureLayoutFromShape(this.session.layoutStrategy, e.dims, 1, [], {
                                    reverseWH: !0
                                }), r = this.createTextureData(t, e.type, e.numberData, e, 1);
                                n = this.pack(r);
                            } else n = this.createTextureData(r, e.type, e.numberData, e, 1);
                        }
                        return n;
                    }
                    createTextureDataFromLayoutBindTensor(e, t, n, r) {
                        return this.createTextureData(e, t, n, r, 1);
                    }
                    createTextureData(e, t, n, i, o) {
                        r29.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(e)}]`);
                        const s = this.session.textureManager.createTextureFromLayout(t, e, n, o);
                        return this.createTextureDataFromTexture(e, t, s, i);
                    }
                    reshapeUnpacked(e, t) {
                        const n = this.getOrCreateTextureData(e, p.TextureType.unpacked), r = {
                            channels: n.channels,
                            height: n.height,
                            width: n.width,
                            shape: 0 !== t.length ? t : [
                                1
                            ],
                            strides: o9.ShapeUtil.computeStrides(t),
                            unpackedShape: t
                        };
                        return this.createTextureDataFromTexture(r, e.type, n.texture).tensor;
                    }
                    reshapePacked(e, t) {
                        const n = this.getOrCreateTextureData(e, p.TextureType.packed);
                        if (a5.isReshapeCheap(e.dims, t)) {
                            const r = {
                                channels: n.channels,
                                height: n.height,
                                width: n.width,
                                shape: 0 !== t.length ? t : [
                                    1
                                ],
                                strides: o9.ShapeUtil.computeStrides(t),
                                unpackedShape: t,
                                isPacked: !0
                            };
                            return this.createTextureDataFromTexture(r, e.type, n.texture).tensor;
                        }
                        const r = a5.processDims3D(e.dims), i = a5.processDims3D(t), s = this.reshapePacked(e, r), u = this.run(a5.createPackedReshape3DProgramInfoLoader(this, s, i), [
                            s
                        ]);
                        return this.reshapePacked(u, t);
                    }
                    cast(e, t) {
                        const n = this.getOrCreateTextureData(e, p.TextureType.unpacked);
                        return this.createTextureDataFromTexture(n, t, n.texture).tensor;
                    }
                    createTextureDataFromTexture(e, t, n, r, o) {
                        const s = Object.assign(Object.assign({}, e), {
                            tensor: r || new i17.Tensor(e.unpackedShape, t, (e)=>this.readTexture(s)
                            , async (e)=>this.readTextureAsync(s)
                            , void 0, o),
                            texture: n
                        });
                        return this.setTextureData(s.tensor.dataId, s, e.isPacked), s;
                    }
                    getTextureData(e, t = !1) {
                        return this.session.isInitializer(e) ? this.session.getTextureData(e, t) : t ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);
                    }
                    setTextureData(e, t, n = !1) {
                        this.session.isInitializer(e) ? this.session.setTextureData(e, t, n) : (n ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e, t);
                    }
                    isTextureLayoutCached(e, t = !1) {
                        return !!this.getTextureData(e.dataId, t);
                    }
                    dispose() {
                        this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e)=>this.session.textureManager.releaseTexture(e)
                        ), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((e)=>this.session.textureManager.releaseTexture(e)
                        ), this.unpackedTextureDataCache = new Map;
                    }
                    readTexture(e) {
                        return e.isPacked ? this.readTexture(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat(u5.encodeAsUint8(this, e));
                    }
                    async readTextureAsync(e) {
                        return e.isPacked ? this.readTextureAsync(this.unpack(e)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e, e.tensor.type, e.channels) : this.session.textureManager.readUint8TextureAsFloat(u5.encodeAsUint8(this, e));
                    }
                    pack(e) {
                        return this.executeProgram(s9.createPackProgramInfoLoader(this, e.tensor), [
                            e.tensor
                        ]);
                    }
                    unpack(e) {
                        return this.executeProgram(l.createUnpackProgramInfoLoader(this, e.tensor), [
                            e.tensor
                        ]);
                    }
                };
            },
            1640: function(e123, t68, n47) {
                "use strict";
                var r33 = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    });
                } : function(e, t) {
                    e.default = t;
                }), o = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e) for(var n in e)"default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r33(t, e, n);
                    return i(t, e), t;
                };
                Object.defineProperty(t68, "__esModule", {
                    value: !0
                }), t68.WEBGL_OP_RESOLVE_RULES = void 0;
                const s = n47(2898), a = o(n47(7839)), u = n47(4196), l = n47(2069), c = n47(8138), p = n47(5193), d = n47(7992), f = n47(1253), h = n47(4776), g = n47(6572), m = n47(3346), b = n47(5623), y = n47(2870), _ = n47(2143), v = n47(2143), w = n47(2143), x = n47(2143), T = n47(4939), O = n47(4939), S = n47(718), A = n47(2268), E = n47(8117), I = n47(2278), D = n47(5524), P = n47(5975), $ = n47(3933), k = n47(6558), N = n47(5723), F = n47(3738), C = o(n47(4909)), R = n47(8428), L = n47(9793);
                t68.WEBGL_OP_RESOLVE_RULES = [
                    [
                        "Abs",
                        "",
                        "6+",
                        C.abs
                    ],
                    [
                        "Acos",
                        "",
                        "7+",
                        C.acos
                    ],
                    [
                        "Add",
                        "",
                        "7+",
                        a.add
                    ],
                    [
                        "And",
                        "",
                        "7+",
                        a.and
                    ],
                    [
                        "Asin",
                        "",
                        "7+",
                        C.asin
                    ],
                    [
                        "Atan",
                        "",
                        "7+",
                        C.atan
                    ],
                    [
                        "AveragePool",
                        "",
                        "7+",
                        _.averagePool,
                        _.parseAveragePoolAttributes
                    ],
                    [
                        "BatchNormalization",
                        "",
                        "7+",
                        s.batchNormalization,
                        s.parseBatchNormalizationAttributes
                    ],
                    [
                        "Cast",
                        "",
                        "6+",
                        u.cast,
                        u.parseCastAttributes
                    ],
                    [
                        "Ceil",
                        "",
                        "6+",
                        C.ceil
                    ],
                    [
                        "Clip",
                        "",
                        "6-10",
                        C.clip,
                        C.parseClipAttributes
                    ],
                    [
                        "Clip",
                        "",
                        "11+",
                        C.clipV11
                    ],
                    [
                        "Concat",
                        "",
                        "4+",
                        l.concat,
                        l.parseConcatAttributes
                    ],
                    [
                        "Conv",
                        "",
                        "1+",
                        c.conv,
                        c.parseConvAttributes
                    ],
                    [
                        "Cos",
                        "",
                        "7+",
                        C.cos
                    ],
                    [
                        "Div",
                        "",
                        "7+",
                        a.div
                    ],
                    [
                        "Dropout",
                        "",
                        "7+",
                        C.identity
                    ],
                    [
                        "DepthToSpace",
                        "",
                        "1+",
                        p.depthToSpace,
                        p.parseDepthToSpaceAttributes
                    ],
                    [
                        "Equal",
                        "",
                        "7+",
                        a.equal
                    ],
                    [
                        "Elu",
                        "",
                        "6+",
                        C.elu,
                        C.parseEluAttributes
                    ],
                    [
                        "Exp",
                        "",
                        "6+",
                        C.exp
                    ],
                    [
                        "Flatten",
                        "",
                        "1+",
                        d.flatten,
                        d.parseFlattenAttributes
                    ],
                    [
                        "Floor",
                        "",
                        "6+",
                        C.floor
                    ],
                    [
                        "FusedConv",
                        "com.microsoft",
                        "1+",
                        c.conv,
                        c.parseConvAttributes
                    ],
                    [
                        "Gather",
                        "",
                        "1+",
                        f.gather,
                        f.parseGatherAttributes
                    ],
                    [
                        "Gemm",
                        "",
                        "7-10",
                        h.gemm,
                        h.parseGemmAttributesV7
                    ],
                    [
                        "Gemm",
                        "",
                        "11+",
                        h.gemm,
                        h.parseGemmAttributesV11
                    ],
                    [
                        "GlobalAveragePool",
                        "",
                        "1+",
                        v.globalAveragePool,
                        v.parseGlobalAveragePoolAttributes
                    ],
                    [
                        "GlobalMaxPool",
                        "",
                        "1+",
                        x.globalMaxPool
                    ],
                    [
                        "Greater",
                        "",
                        "7+",
                        a.greater
                    ],
                    [
                        "Identity",
                        "",
                        "1+",
                        C.identity
                    ],
                    [
                        "ImageScaler",
                        "",
                        "1+",
                        g.imageScaler,
                        g.parseImageScalerAttributes
                    ],
                    [
                        "InstanceNormalization",
                        "",
                        "6+",
                        m.instanceNormalization,
                        m.parseInstanceNormalizationAttributes
                    ],
                    [
                        "LeakyRelu",
                        "",
                        "6+",
                        C.leakyRelu,
                        C.parseLeakyReluAttributes
                    ],
                    [
                        "Less",
                        "",
                        "7+",
                        a.less
                    ],
                    [
                        "Log",
                        "",
                        "6+",
                        C.log
                    ],
                    [
                        "MatMul",
                        "",
                        "1+",
                        b.matMul,
                        b.parseMatMulAttributes
                    ],
                    [
                        "MaxPool",
                        "",
                        "1+",
                        w.maxPool,
                        w.parseMaxPoolAttributes
                    ],
                    [
                        "Mul",
                        "",
                        "7+",
                        a.mul
                    ],
                    [
                        "Neg",
                        "",
                        "6+",
                        C.neg
                    ],
                    [
                        "Not",
                        "",
                        "1+",
                        C.not
                    ],
                    [
                        "Or",
                        "",
                        "7+",
                        a.or
                    ],
                    [
                        "Pad",
                        "",
                        "2-10",
                        y.padV2,
                        y.parsePadAttributesV2
                    ],
                    [
                        "Pad",
                        "",
                        "11+",
                        y.padV11,
                        y.parsePadAttributesV11
                    ],
                    [
                        "Pow",
                        "",
                        "7+",
                        a.pow
                    ],
                    [
                        "PRelu",
                        "",
                        "7+",
                        a.pRelu
                    ],
                    [
                        "ReduceLogSum",
                        "",
                        "1+",
                        T.reduceLogSum,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceMax",
                        "",
                        "1+",
                        T.reduceMax,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceMean",
                        "",
                        "1+",
                        T.reduceMean,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceMin",
                        "",
                        "1+",
                        T.reduceMin,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceProd",
                        "",
                        "1+",
                        T.reduceProd,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceSum",
                        "",
                        "1-12",
                        T.reduceSum,
                        O.parseReduceAttributes
                    ],
                    [
                        "ReduceSumSquare",
                        "",
                        "1+",
                        T.reduceLogSumSquare,
                        O.parseReduceAttributes
                    ],
                    [
                        "Relu",
                        "",
                        "6+",
                        C.relu
                    ],
                    [
                        "Reshape",
                        "",
                        "5+",
                        S.reshape
                    ],
                    [
                        "Resize",
                        "",
                        "10",
                        A.resize,
                        A.parseResizeAttributesV10
                    ],
                    [
                        "Resize",
                        "",
                        "11+",
                        A.resize,
                        A.parseResizeAttributesV11
                    ],
                    [
                        "Shape",
                        "",
                        "1+",
                        E.shape
                    ],
                    [
                        "Sigmoid",
                        "",
                        "6+",
                        C.sigmoid
                    ],
                    [
                        "Sin",
                        "",
                        "7+",
                        C.sin
                    ],
                    [
                        "Slice",
                        "",
                        "10+",
                        I.sliceV10
                    ],
                    [
                        "Slice",
                        "",
                        "1-9",
                        I.slice,
                        I.parseSliceAttributes
                    ],
                    [
                        "Softmax",
                        "",
                        "1-12",
                        D.softmax,
                        D.parseSoftmaxAttributes
                    ],
                    [
                        "Softmax",
                        "",
                        "13+",
                        D.softmaxV13,
                        D.parseSoftmaxAttributesV13
                    ],
                    [
                        "Split",
                        "",
                        "2-12",
                        P.split,
                        P.parseSplitAttributes
                    ],
                    [
                        "Sqrt",
                        "",
                        "6+",
                        C.sqrt
                    ],
                    [
                        "Squeeze",
                        "",
                        "1-12",
                        $.squeeze,
                        $.parseSqueezeAttributes
                    ],
                    [
                        "Squeeze",
                        "",
                        "13+",
                        $.squeezeV13
                    ],
                    [
                        "Sub",
                        "",
                        "7+",
                        a.sub
                    ],
                    [
                        "Sum",
                        "",
                        "6+",
                        k.sum
                    ],
                    [
                        "Tan",
                        "",
                        "7+",
                        C.tan
                    ],
                    [
                        "Tanh",
                        "",
                        "6+",
                        C.tanh
                    ],
                    [
                        "Tile",
                        "",
                        "6+",
                        N.tile
                    ],
                    [
                        "Transpose",
                        "",
                        "1+",
                        F.transpose,
                        F.parseTransposeAttributes
                    ],
                    [
                        "Upsample",
                        "",
                        "7-8",
                        L.upsample,
                        L.parseUpsampleAttributesV7
                    ],
                    [
                        "Upsample",
                        "",
                        "9",
                        L.upsample,
                        L.parseUpsampleAttributesV9
                    ],
                    [
                        "Unsqueeze",
                        "",
                        "1-12",
                        R.unsqueeze,
                        R.parseUnsqueezeAttributes
                    ],
                    [
                        "Unsqueeze",
                        "",
                        "13+",
                        R.unsqueezeV13
                    ],
                    [
                        "Xor",
                        "",
                        "7+",
                        a.xor
                    ]
                ];
            },
            2898: (e124, t69, n48)=>{
                "use strict";
                Object.defineProperty(t69, "__esModule", {
                    value: !0
                }), t69.parseBatchNormalizationAttributes = t69.batchNormalization = void 0;
                const r34 = n48(246), i18 = n48(5060), o10 = n48(2039), s = {
                    name: "BatchNormalization",
                    inputNames: [
                        "A",
                        "Scale",
                        "B",
                        "Mean",
                        "Variance"
                    ],
                    inputTypes: [
                        o10.TextureType.unpacked,
                        o10.TextureType.unpacked,
                        o10.TextureType.unpacked,
                        o10.TextureType.unpacked,
                        o10.TextureType.unpacked
                    ]
                };
                t69.batchNormalization = (e, t, n)=>(u6(t), [
                        e.run(Object.assign(Object.assign({}, s), {
                            cacheHint: n.cacheKey,
                            get: ()=>a6(e, t, n)
                        }), t)
                    ])
                , t69.parseBatchNormalizationAttributes = (e)=>{
                    const t = e.attributes.getFloat("epsilon", 1e-5), n = e.attributes.getFloat("momentum", .9), i = e.attributes.getInt("spatial", 1);
                    return r34.createAttributeWithCacheKey({
                        epsilon: t,
                        momentum: n,
                        spatial: i
                    });
                };
                const a6 = (e, t, n)=>{
                    const r = i18.getGlsl(e.session.backend.glContext.version), a = t[0].dims.length, [u, l] = e.calculateTextureWidthAndHeight(t[1].dims, o10.TextureType.unpacked), c = `\n  float process(int[${a}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${u}, ${l});\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\n    float b = getColorAsFloat(${r.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\n  }`;
                    return Object.assign(Object.assign({}, s), {
                        output: {
                            dims: t[0].dims,
                            type: t[0].type,
                            textureType: o10.TextureType.unpacked
                        },
                        shaderSource: c
                    });
                }, u6 = (e)=>{
                    if (!e || 5 !== e.length) throw new Error("BatchNormalization requires 5 inputs.");
                    const t = e[0], n = e[1], r = e[2], i = e[3], o = e[4];
                    if (t.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length || 1 !== i.dims.length || 1 !== o.dims.length) throw new Error("invalid input shape.");
                    if (n.dims[0] !== t.dims[1] || r.dims[0] !== t.dims[1] || i.dims[0] !== t.dims[1] || o.dims[0] !== t.dims[1]) throw new Error("invalid input shape.");
                    if ("float32" !== t.type && "float64" !== t.type || "float32" !== n.type && "float64" !== n.type || "float32" !== r.type && "float64" !== r.type || "float32" !== i.type && "float64" !== i.type || "float32" !== o.type && "float64" !== o.type) throw new Error("invalid input tensor types.");
                };
            },
            7839: (e125, t70, n49)=>{
                "use strict";
                Object.defineProperty(t70, "__esModule", {
                    value: !0
                }), t70.xor = t70.sub = t70.pRelu = t70.pow = t70.or = t70.mul = t70.less = t70.greater = t70.equal = t70.div = t70.and = t70.add = t70.glslPRelu = t70.glslPow = t70.glslXor = t70.glslOr = t70.glslAnd = t70.glslLess = t70.glslGreater = t70.glslEqual = t70.glslSub = t70.glslMul = t70.glslDiv = t70.glslAdd = void 0;
                const r35 = n49(2517), i19 = n49(8520), o11 = n49(5060), s10 = n49(2039);
                function a7() {
                    return {
                        body: "\n  float add_(float a, float b) {\n    return a + b;\n  }\n  vec4 add_(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  ",
                        name: "add_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function u7() {
                    return {
                        body: "\n  float div_(float a, float b) {\n    return a / b;\n  }\n  vec4 div_(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  ",
                        name: "div_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function l4() {
                    return {
                        body: "\n  float mul_(float a, float b) {\n    return a * b;\n  }\n  vec4 mul_(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  ",
                        name: "mul_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function c4() {
                    return {
                        body: "\n  float sub_(float a, float b) {\n    return a - b;\n  }\n  vec4 sub_(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  ",
                        name: "sub_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function p4() {
                    return {
                        body: "\n  float equal_(float a, float b) {\n    return float(a == b);\n  }\n  vec4 equal_(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  ",
                        name: "equal_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function d4() {
                    const e = "greater_";
                    return {
                        body: `\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,
                        name: e,
                        type: i19.FunctionType.ValueBased
                    };
                }
                function f3() {
                    return {
                        body: "\n  float less_(float a, float b) {\n    return float(a < b);\n  }\n  vec4 less_(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  ",
                        name: "less_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function h3() {
                    return {
                        body: "\n  float and_(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 and_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  ",
                        name: "and_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function g1() {
                    return {
                        body: "\n  float or_(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 or_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  ",
                        name: "or_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function m1() {
                    return {
                        body: "\n  float xor_(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 xor_(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  ",
                        name: "xor_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                function b() {
                    return function(e) {
                        const t = "pow_";
                        return {
                            body: "\n  float pow_(float a, float b) {\n    return pow(a, b);\n  }\n  vec4 pow_(vec4 v1, vec4 v2) {\n    return pow(v1, v2);\n  }\n  ",
                            name: t,
                            type: i19.FunctionType.ValueBased
                        };
                    }();
                }
                function y() {
                    return {
                        body: "\n  float prelu_(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 prelu_(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  ",
                        name: "prelu_",
                        type: i19.FunctionType.ValueBased
                    };
                }
                t70.glslAdd = a7, t70.glslDiv = u7, t70.glslMul = l4, t70.glslSub = c4, t70.glslEqual = p4, t70.glslGreater = d4, t70.glslLess = f3, t70.glslAnd = h3, t70.glslOr = g1, t70.glslXor = m1, t70.glslPow = b, t70.glslPRelu = y;
                const _ = (e, t, n, r = t[0].type, i)=>{
                    const o = e.session.pack ? s10.TextureType.packed : s10.TextureType.unpacked;
                    return {
                        name: n.name,
                        inputNames: [
                            "A",
                            "B"
                        ],
                        inputTypes: [
                            o,
                            o
                        ],
                        cacheHint: i,
                        get: ()=>v(e, t, n, r)
                    };
                }, v = (e, t, n, i = t[0].type)=>{
                    const a = e.session.pack ? s10.TextureType.packed : s10.TextureType.unpacked, u = !r35.ShapeUtil.areEqual(t[0].dims, t[1].dims);
                    let l = t[0].dims;
                    const c = e.session.pack;
                    if (u) {
                        const s = r35.BroadcastUtil.calcShape(t[0].dims, t[1].dims, !1);
                        if (!s) throw new Error("Can't perform binary op on the given tensors");
                        l = s;
                        const u = l.length, p = 0 !== t[0].dims.length ? t[0].dims.length : 1, d = 0 !== t[1].dims.length ? t[1].dims.length : 1, f = 0 !== t[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h = 0 !== t[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g = o11.getGlsl(e.session.backend.glContext.version), m = c ? `\n      ${n.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${n.name}(a, b);\n        ${g.output} = result;\n      }` : `\n      ${n.body}\n      float process(int indices[${u}]) {\n        int aindices[${p}];\n        int bindices[${d}];\n        ${f}\n        ${h}\n        return ${n.name}(_A(aindices), _B(bindices));\n      }`;
                        return {
                            name: n.name,
                            inputNames: [
                                "A",
                                "B"
                            ],
                            inputTypes: [
                                a,
                                a
                            ],
                            output: {
                                dims: l,
                                type: i,
                                textureType: a
                            },
                            shaderSource: m,
                            hasMain: c
                        };
                    }
                    const p = o11.getGlsl(e.session.backend.glContext.version), d = `\n    ${n.body}\n    void main() {\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\n      vec4 result = ${n.name}(v1, v2);\n      ${p.output} = result;\n    }\n    `;
                    return {
                        name: n.name,
                        inputNames: [
                            "A",
                            "B"
                        ],
                        inputTypes: [
                            a,
                            a
                        ],
                        output: {
                            dims: t[0].dims,
                            type: i,
                            textureType: a
                        },
                        shaderSource: d,
                        hasMain: !0
                    };
                };
                t70.add = (e, t)=>[
                        e.run(_(e, t, a7()), t)
                    ]
                , t70.and = (e, t)=>[
                        e.run(_(e, t, h3(), "bool"), t)
                    ]
                , t70.div = (e, t)=>[
                        e.run(_(e, t, u7()), t)
                    ]
                , t70.equal = (e, t)=>[
                        e.run(_(e, t, p4(), "bool"), t)
                    ]
                , t70.greater = (e, t)=>[
                        e.run(_(e, t, d4(), "bool"), t)
                    ]
                , t70.less = (e, t)=>[
                        e.run(_(e, t, f3(), "bool"), t)
                    ]
                , t70.mul = (e, t)=>[
                        e.run(_(e, t, l4()), t)
                    ]
                , t70.or = (e, t)=>[
                        e.run(_(e, t, g1(), "bool"), t)
                    ]
                , t70.pow = (e, t)=>[
                        e.run(_(e, t, b()), t)
                    ]
                , t70.pRelu = (e, t)=>[
                        e.run(_(e, t, y()), t)
                    ]
                , t70.sub = (e, t)=>[
                        e.run(_(e, t, c4()), t)
                    ]
                , t70.xor = (e, t)=>[
                        e.run(_(e, t, m1(), "bool"), t)
                    ]
                ;
            },
            4196: (e126, t71, n50)=>{
                "use strict";
                Object.defineProperty(t71, "__esModule", {
                    value: !0
                }), t71.parseCastAttributes = t71.cast = void 0;
                const r = n50(2517);
                t71.cast = (e, t, n)=>(i(t), [
                        e.cast(t[0], n)
                    ])
                , t71.parseCastAttributes = (e)=>r.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"))
                ;
                const i = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Cast requires 1 input.");
                    if ("string" === e[0].type) throw new Error("Invalid input type.");
                };
            },
            1163: (e130, t72, n51)=>{
                "use strict";
                Object.defineProperty(t72, "__esModule", {
                    value: !0
                }), t72.createPackedConcatProgramInfoLoader = void 0;
                const r36 = n51(5060), i = n51(2039), o = n51(9390), s = n51(2827);
                t72.createPackedConcatProgramInfoLoader = (e131, t73, n52)=>{
                    const u8 = (l5 = t73.length, c5 = n52.cacheKey, {
                        name: "Concat (packed)",
                        inputNames: Array.from({
                            length: l5
                        }, (e, t)=>`X${t}`
                        ),
                        inputTypes: Array(l5).fill(i.TextureType.packed),
                        cacheHint: c5
                    });
                    var l5, c5;
                    return Object.assign(Object.assign({}, u8), {
                        get: ()=>((e132, t, n, u)=>{
                                const l = n[0].dims.slice();
                                if (u >= l.length || u < -1 * l.length) throw new Error("axis specified for concat doesn't match input dimensionality");
                                u < 0 && (u = l.length + u);
                                const c = l.slice(0);
                                for(let e127 = 1; e127 < n.length; e127++){
                                    const t = n[e127].dims.slice();
                                    for(let e = 0; e < l.length; e++)if (e === u) c[u] += t[e];
                                    else if (l[e] !== t[e]) throw new Error("non concat dimensions must match");
                                }
                                const p = c.length, d = s.getChannels("coords", p), f = o.getCoordsDataType(p), h = s.unpackFromChannel(), g = n.map((e)=>e.dims
                                ), m = o.getGlChannels(p), b = new Array(g.length - 1);
                                b[0] = g[0][u];
                                for(let e128 = 1; e128 < b.length; e128++)b[e128] = b[e128 - 1] + g[e128][u];
                                const y = m[u], _ = m.slice(-2), v = m.join();
                                let w = `if (${y} < ${b[0]}) {\n        return getChannel(\n            getX0(${v}), vec2(${_.join()}));\n        }`;
                                for(let e129 = 1; e129 < b.length; e129++){
                                    const t = b[e129 - 1];
                                    w += `\n            if (${y} < ${b[e129]}  && ${y} >= ${b[e129 - 1]}) {\n              return getChannel(\n                getX${e129}(${a(m, y, t)}),\n                vec2(${a(_, y, t)}));\n            }`;
                                }
                                const x = b.length, T = b[b.length - 1];
                                w += `\n            return getChannel(\n              getX${x}(${a(m, y, T)}),\n              vec2(${a(_, y, T)}));`;
                                const O = r36.getGlsl(e132.session.backend.glContext.version), S = `\n          ${h}\n          float getValue(${m.map((e)=>"int " + e
                                )}) {\n            ${w}\n          }\n\n          void main() {\n            ${f} coords = getOutputCoords();\n            int lastDim = coords.${m[p - 1]};\n            coords.${m[p - 1]} = coords.${m[p - 2]};\n            coords.${m[p - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${d}), 0., 0., 0.);\n\n            ${d[p - 1]} = ${d[p - 1]} + 1;\n            if (${d[p - 1]} < ${c[p - 1]}) {\n              result.g = getValue(${d});\n            }\n\n            ${d[p - 2]} = ${d[p - 2]} + 1;\n            if (${d[p - 2]} < ${c[p - 2]}) {\n              result.a = getValue(${d});\n            }\n\n            ${d[p - 1]} = ${d[p - 1]} - 1;\n            if (${d[p - 2]} < ${c[p - 2]} &&\n                ${d[p - 1]} < ${c[p - 1]}) {\n              result.b = getValue(${d});\n            }\n            ${O.output} = result;\n          }\n        `;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: c,
                                        type: n[0].type,
                                        textureType: i.TextureType.packed
                                    },
                                    shaderSource: S,
                                    hasMain: !0
                                });
                            })(e131, u8, t73, n52.axis)
                    });
                };
                const a = (e133, t74, n)=>{
                    const r = e133.indexOf(t74);
                    return e133.map((e, t)=>t === r ? `${e} - ${n}` : e
                    ).join();
                };
            },
            2069: (e134, t75, n53)=>{
                "use strict";
                Object.defineProperty(t75, "__esModule", {
                    value: !0
                }), t75.parseConcatAttributes = t75.concat = void 0;
                const r37 = n53(246), i = n53(2039), o12 = n53(1163);
                t75.concat = (e, t, n)=>(p5(t), e.session.pack && t[0].dims.length > 1 ? [
                        e.run(o12.createPackedConcatProgramInfoLoader(e, t, n), t)
                    ] : [
                        e.run(s11(e, t, n), t)
                    ])
                ;
                const s11 = (e137, t76, n54)=>{
                    const r38 = (o13 = t76.length, s12 = n54.cacheKey, {
                        name: "Concat",
                        inputNames: Array.from({
                            length: o13
                        }, (e, t)=>`X${t}`
                        ),
                        inputTypes: Array(o13).fill(i.TextureType.unpacked),
                        cacheHint: s12
                    });
                    var o13, s12;
                    return Object.assign(Object.assign({}, r38), {
                        get: ()=>((e, t, n, r)=>{
                                const o = n[0].dims.slice();
                                if (r >= o.length || r < -1 * o.length) throw new Error("axis specified for concat doesn't match input dimensionality");
                                r < 0 && (r = o.length + r);
                                const s = o.slice(0);
                                for(let e135 = 1; e135 < n.length; e135++){
                                    const t = n[e135].dims.slice();
                                    for(let e = 0; e < o.length; e++)if (e === r) s[r] += t[e];
                                    else if (o[e] !== t[e]) throw new Error("non concat dimensions must match");
                                }
                                const p = s.length, d = new Array(n.length);
                                let f = 0;
                                for(let e136 = 0; e136 < d.length; ++e136)f += n[e136].dims[r], d[e136] = f;
                                let h = "";
                                h = n.length < 5 ? a(d) : u(d);
                                const g = `\n        ${l(n.length, p)}\n        ${c(d)}\n        ${h}\n        float process(int indices[${p}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\n\n          if(textureIndex != 0) {\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: s,
                                        type: n[0].type,
                                        textureType: i.TextureType.unpacked
                                    },
                                    shaderSource: g
                                });
                            })(0, r38, t76, n54.axis)
                    });
                }, a = (e138)=>`int getTextureWhereDataResides(int index) {\n      ${e138.map((e, t)=>`if(index<${e}) {return ${t};}\n`
                    ).join("")}\n    }`
                , u = (e)=>a(e)
                , l = (e, t)=>{
                    const n = [
                        `float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`
                    ];
                    for(let t77 = 0; t77 < e; ++t77)0 === t77 ? n.push(`\tif (textureIndex == ${t77}) { return _X${t77}(indices); }`) : t77 === e - 1 ? n.push(`\telse { return _X${t77}(indices); }`) : n.push(`\telse if (textureIndex == ${t77}) { return _X${t77}(indices); }`);
                    return n.push("\t}"), n.join("\n");
                }, c = (e)=>{
                    const t = [
                        "int getSizeInConcatAxisValueFromIndex(int index) {"
                    ];
                    for(let n = 0; n < e.length; ++n)0 === n ? t.push(`\tif (index == ${n}) { return ${e[n]}; }`) : n === e.length - 1 ? t.push(`\telse { return ${e[n]}; }`) : t.push(`\telse if (index == ${n}) { return ${e[n]}; }`);
                    return t.push("\t}"), t.join("\n");
                };
                t75.parseConcatAttributes = (e)=>r37.createAttributeWithCacheKey({
                        axis: e.attributes.getInt("axis")
                    })
                ;
                const p5 = (e)=>{
                    if (!e || e.length < 1) throw new Error("too few inputs");
                    const t = e[0].type, n = e[0].dims.length;
                    if ("string" === t) throw new Error("string tensor is not supported yet");
                    for (const r of e){
                        if (r.type !== t) throw new Error("input tensors should be one type");
                        if (r.dims.length !== n) throw new Error("input tensors should have the same shape");
                    }
                };
            },
            4770: (e139, t78, n55)=>{
                "use strict";
                Object.defineProperty(t78, "__esModule", {
                    value: !0
                }), t78.createUnpackedGroupedConvProgramInfoLoader = void 0;
                const r = n55(6231), i = n55(5060), o = n55(2039), s = n55(8138), a = n55(2823);
                t78.createUnpackedGroupedConvProgramInfoLoader = (e140, t79, n56)=>{
                    const u9 = (l6 = t79.length > 2, c6 = n56.cacheKey, {
                        name: "GroupedConv",
                        inputNames: l6 ? [
                            "X",
                            "W",
                            "Bias"
                        ] : [
                            "X",
                            "W"
                        ],
                        inputTypes: l6 ? [
                            o.TextureType.unpacked,
                            o.TextureType.unpacked,
                            o.TextureType.unpacked
                        ] : [
                            o.TextureType.unpacked,
                            o.TextureType.unpacked
                        ],
                        cacheHint: c6
                    });
                    var l6, c6;
                    return Object.assign(Object.assign({}, u9), {
                        get: ()=>((e, t, n, u)=>{
                                const l = t.length > 2 ? "value += getBias(output_channel);" : "", c = t[0].dims.slice(), p = t[1].dims.slice(), d = p[0] / u.group;
                                r.Logger.verbose("GroupedConv", `autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);
                                const f = s.calculateOutputShape(c, p, u.dilations, u.pads, u.strides), h = i.getGlsl(e.session.backend.glContext.version), { activationFunction: g , applyActivation: m  } = a.getActicationSnippet(u), b = `\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\n  ${g}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${d};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\n      int input_channel = group_id * ${p[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${c[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${c[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${l}\n    ${m}\n    ${h.output} = vec4(value, .0, .0, .0);\n  }\n`;
                                return Object.assign(Object.assign({}, n), {
                                    output: {
                                        dims: f,
                                        type: t[0].type,
                                        textureType: o.TextureType.unpacked
                                    },
                                    shaderSource: b,
                                    hasMain: !0
                                });
                            })(e140, t79, u9, n56)
                    });
                };
            },
            1386: (e141, t80, n57)=>{
                "use strict";
                Object.defineProperty(t80, "__esModule", {
                    value: !0
                }), t80.conv2DPacked = t80.conv2DPackedPointwise = void 0;
                const r = n57(8138), i20 = n57(8555), o = n57(708);
                t80.conv2DPackedPointwise = (e, t, n)=>{
                    const i = t[0].dims, s = t[1].dims, a = r.calculateOutputShape(i, s, n.dilations, n.pads, n.strides), u = e.reshapePacked(t[0], [
                        i[1],
                        i[2] * i[3]
                    ]), l = e.reshapePacked(t[1], [
                        s[0],
                        s[1]
                    ]), c = t.length > 2 ? [
                        l,
                        u,
                        t[2]
                    ] : [
                        l,
                        u
                    ], p = e.run(o.createPackedMatmulProgramInfoLoader(e, c, n), c);
                    return e.reshapePacked(p, a);
                }, t80.conv2DPacked = (e, t, n)=>{
                    const s = t[0].dims, a = t[1].dims, u = r.calculateOutputShape(s, a, n.dilations, n.pads, n.strides), l = e.run(i20.createPackedIm2ColProgramInfoLoader(e, t[0], t[1], u, n), [
                        t[0]
                    ]), c = e.reshapePacked(t[1], [
                        a[0],
                        a[1] * a[2] * a[3]
                    ]), p = 3 === t.length ? [
                        c,
                        l,
                        t[2]
                    ] : [
                        c,
                        l
                    ], d = e.run(o.createPackedMatmulProgramInfoLoader(e, p, n), p);
                    return e.reshapePacked(d, u);
                };
            },
            8138: (e142, t81, n58)=>{
                "use strict";
                Object.defineProperty(t81, "__esModule", {
                    value: !0
                }), t81.parseConvAttributes = t81.conv = t81.calculateOutputShape = void 0;
                const r39 = n58(246), i21 = n58(2517), o14 = n58(4770), s13 = n58(1386), a8 = n58(9828), u10 = n58(2823), l7 = n58(3248), c7 = n58(5623);
                t81.calculateOutputShape = (e143, t82, n, r, i)=>{
                    const o = e143[0], s = e143.slice(2), a = s.length, u = t82[0], l = t82.slice(2).map((e, t)=>e + (e - 1) * (n[t] - 1)
                    ), c = s.map((e, t)=>e + r[t] + r[t + a]
                    ).map((e, t)=>Math.floor((e - l[t] + i[t]) / i[t])
                    );
                    return [
                        o,
                        u
                    ].concat(...c);
                }, t81.conv = (e, t, n)=>(g(t, n), p6(e, t, n))
                ;
                const p6 = (e, t, n)=>{
                    const r = h(n, t), i = e.session.pack, a = 1 === r.kernelShape[0] && 1 === r.kernelShape[1];
                    return r.group > 1 ? [
                        e.run(o14.createUnpackedGroupedConvProgramInfoLoader(e, t, r), t)
                    ] : a && i ? [
                        d(e, t, r)
                    ] : i && 4 === t[0].dims.length && 1 === t[0].dims[0] && !a ? [
                        s13.conv2DPacked(e, t, r)
                    ] : [
                        f(e, t, r)
                    ];
                }, d = (e, n, r)=>{
                    const i = n[0].dims, o = n[1].dims, s = t81.calculateOutputShape(i, o, r.dilations, r.pads, r.strides), a = e.reshapeUnpacked(n[0], [
                        i[1],
                        i[2] * i[3]
                    ]), u = e.reshapeUnpacked(n[1], [
                        o[0],
                        o[1]
                    ]), l = n.length > 2 ? [
                        u,
                        a,
                        n[2]
                    ] : [
                        u,
                        a
                    ], p = e.run(c7.createMatmulProgramInfoLoader(l, r), l);
                    return e.reshapeUnpacked(p, s);
                }, f = (e, n, r)=>{
                    const i = n[0].dims, o = n[1].dims, s = t81.calculateOutputShape(i, o, r.dilations, r.pads, r.strides), u = e.run(l7.createIm2ColProgramInfoLoader(e, n[0], n[1], s, r), [
                        n[0]
                    ]), c = 3 === n.length ? [
                        u,
                        n[1],
                        n[2]
                    ] : [
                        u,
                        n[1]
                    ];
                    return e.run(a8.createDotProductProgramInfoLoader(e, n, s, r), c);
                }, h = (e, t)=>{
                    const n = e.kernelShape.slice();
                    if (0 === e.kernelShape.length) for(let e144 = 2; e144 < t[1].dims.length; ++e144)n.push(t[1].dims[e144]);
                    const r = e.pads.slice();
                    i21.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims, e.strides, e.dilations, n, r, e.autoPad);
                    const o = Object.assign({}, e);
                    return Object.assign(o, {
                        kernelShape: n,
                        pads: r,
                        cacheKey: e.cacheKey
                    }), o;
                };
                t81.parseConvAttributes = (e)=>{
                    const t = e.attributes, n = u10.parseInternalActivationAttributes(t), i = t.getString("auto_pad", "NOTSET"), o = t.getInts("dilations", [
                        1,
                        1
                    ]), s = t.getInt("group", 1), a = t.getInts("kernel_shape", []), l = t.getInts("pads", [
                        0,
                        0,
                        0,
                        0
                    ]), c = t.getInts("strides", [
                        1,
                        1
                    ]);
                    return r39.createAttributeWithCacheKey(Object.assign({
                        autoPad: i,
                        dilations: o,
                        group: s,
                        kernelShape: a,
                        pads: l,
                        strides: c
                    }, n));
                };
                const g = (e, t)=>{
                    if (!e || 2 !== e.length && 3 !== e.length) throw new Error("Conv requires 2 or 3 inputs");
                    if (4 !== e[0].dims.length || 4 !== e[1].dims.length) throw new Error("currently only support 2-dimensional conv");
                    if (e[0].dims[1] !== e[1].dims[1] * t.group) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                    if (3 === e.length && (1 !== e[2].dims.length || e[1].dims[0] !== e[2].dims[0])) throw new Error("invalid bias");
                    const n = e[0].dims.length - 2;
                    if (t.dilations.length !== n) throw new Error(`dilations should be ${n}D`);
                    if (t.strides.length !== n) throw new Error(`strides should be ${n}D`);
                    if (t.pads.length !== 2 * n) throw new Error(`pads should be ${2 * n}D`);
                    if (0 !== t.kernelShape.length && t.kernelShape.length !== e[1].dims.length - 2) throw new Error("invalid kernel shape");
                    if ("float32" !== e[0].type || "float32" !== e[1].type) throw new Error("Conv input(X,W) should be float tensor");
                    if (3 === e.length && "float32" !== e[2].type) throw new Error("Conv input(bias) should be float tensor");
                };
            },
            5193: (e145, t83, n59)=>{
                "use strict";
                Object.defineProperty(t83, "__esModule", {
                    value: !0
                }), t83.parseDepthToSpaceAttributes = t83.depthToSpace = void 0;
                const r = n59(3738);
                t83.depthToSpace = (e, t, n)=>{
                    i(t);
                    const o = n.blocksize, s = o * o, a = "DCR" === n.mode ? [
                        0,
                        3,
                        4,
                        1,
                        5,
                        2
                    ] : [
                        0,
                        1,
                        4,
                        2,
                        5,
                        3
                    ], u = "DCR" === n.mode ? [
                        t[0].dims[0],
                        o,
                        o,
                        t[0].dims[1] / s,
                        t[0].dims[2],
                        t[0].dims[3]
                    ] : [
                        t[0].dims[0],
                        t[0].dims[1] / s,
                        o,
                        o,
                        t[0].dims[2],
                        t[0].dims[3]
                    ], l = e.reshapeUnpacked(t[0], u), c = {
                        perm: a,
                        cacheKey: `${a}`
                    }, [p] = r.transpose(e, [
                        l
                    ], c), d = [
                        t[0].dims[0],
                        t[0].dims[1] / s,
                        t[0].dims[2] * o,
                        t[0].dims[3] * o
                    ];
                    return [
                        e.reshapeUnpacked(p, d)
                    ];
                }, t83.parseDepthToSpaceAttributes = (e)=>{
                    const t = e.attributes.getInt("blocksize");
                    if (t < 1) throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);
                    const n = e.attributes.getString("mode", "DCR");
                    if ("DCR" !== n && "CRD" !== n) throw new Error(`unrecognized mode: ${n} for DepthToSpace`);
                    return {
                        mode: n,
                        blocksize: t
                    };
                };
                const i = (e)=>{
                    if (1 !== e.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);
                    if ("string" === e[0].type || 4 !== e[0].dims.length) throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
                };
            },
            9828: (e146, t84, n60)=>{
                "use strict";
                Object.defineProperty(t84, "__esModule", {
                    value: !0
                }), t84.createDotProductProgramInfoLoader = void 0;
                const r = n60(2517), i = n60(5060), o = n60(2039), s = n60(2823), a = n60(3248);
                t84.createDotProductProgramInfoLoader = (e147, t85, n61, u11)=>{
                    const l8 = ((e, t)=>({
                            name: "ConvDotProduct",
                            inputNames: e ? [
                                "Im2Col",
                                "K",
                                "B"
                            ] : [
                                "Im2Col",
                                "K"
                            ],
                            inputTypes: e ? [
                                o.TextureType.unpacked,
                                o.TextureType.packedLastDimension,
                                o.TextureType.unpacked
                            ] : [
                                o.TextureType.unpacked,
                                o.TextureType.packedLastDimension
                            ],
                            cacheKey: t.activationCacheKey
                        })
                    )(t85.length > 2, u11);
                    return Object.assign(Object.assign({}, l8), {
                        get: ()=>((e, t, n, u, l)=>{
                                const c = n[0].dims, p = n[1].dims, d = [
                                    p[0],
                                    Math.ceil(c[1] * p[2] * p[3] / 4)
                                ], f = a.calculateIm2ColDims(c, p, u), [h, g] = e.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), m = r.ShapeUtil.computeStrides(f), [b, y] = e.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), _ = u.length, v = n.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(c[1] * p[2] * p[3] / 4), { activationFunction: x , applyActivation: T  } = s.getActicationSnippet(l), O = i.getGlsl(e.session.backend.glContext.version), S = `\n${x}\nfloat process(int indices[${_}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${m[0]} + im2col[1] * ${m[1]} + im2col[2] * ${m[2]};\n  int kernelOffset = indices[1] * ${d[1]};\n  float value = ${v};\n  for (int i = 0; i < ${w}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\n    value += dot(${O.texture2D}(Im2Col, im2colCoords), ${O.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${T}\n  return value;\n}`;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: u,
                                        type: n[0].type,
                                        textureType: o.TextureType.unpacked
                                    },
                                    shaderSource: S
                                });
                            })(e147, l8, t85, n61, u11)
                    });
                };
            },
            7992: (e148, t86, n62)=>{
                "use strict";
                Object.defineProperty(t86, "__esModule", {
                    value: !0
                }), t86.parseFlattenAttributes = t86.flatten = void 0;
                const r = n62(2517);
                t86.flatten = (e, t, n)=>{
                    i(t, n);
                    const o = r.ShapeUtil.flattenShape(t[0].dims, n);
                    return [
                        e.reshapeUnpacked(t[0], o)
                    ];
                }, t86.parseFlattenAttributes = (e)=>e.attributes.getInt("axis", 1)
                ;
                const i = (e, t)=>{
                    if (!e || 1 !== e.length) throw new Error("Flatten requires 1 input.");
                    const n = e[0].dims.length;
                    if (0 === n) throw new Error("scalar tensor is not supported.");
                    if (t < -n || t > n) throw new Error("Invalid axis");
                    if ("string" === e[0].type) throw new Error("string tensor is not supported.");
                };
            },
            2823: (e149, t87, n63)=>{
                "use strict";
                Object.defineProperty(t87, "__esModule", {
                    value: !0
                }), t87.parseInternalActivationAttributes = t87.getActicationSnippet = void 0;
                const r = n63(2517), i22 = n63(4909);
                t87.getActicationSnippet = function(e) {
                    let t;
                    switch(e.activation){
                        case "Relu":
                            t = i22.glslRelu();
                            break;
                        case "Sigmoid":
                            t = i22.glslSigmoid();
                            break;
                        case "Clip":
                            t = i22.glslClip(e.clipMin, e.clipMax);
                            break;
                        default:
                            return {
                                activationFunction: "",
                                applyActivation: ""
                            };
                    }
                    const n = t.name;
                    return {
                        activationFunction: t.body,
                        applyActivation: `value = ${n}_(value);`
                    };
                }, t87.parseInternalActivationAttributes = (e)=>{
                    const t = e.getString("activation", "");
                    if ("Clip" === t) {
                        const [n, i] = e.getFloats("activation_params", [
                            r.MIN_CLIP,
                            r.MAX_CLIP
                        ]);
                        return {
                            activation: t,
                            clipMax: i,
                            clipMin: n,
                            activationCacheKey: `${t}:${n},${i}`
                        };
                    }
                    return {
                        activation: t,
                        activationCacheKey: t
                    };
                };
            },
            1253: (e150, t88, n64)=>{
                "use strict";
                Object.defineProperty(t88, "__esModule", {
                    value: !0
                }), t88.parseGatherAttributes = t88.gather = void 0;
                const r40 = n64(246), i23 = n64(782), o = n64(2517), s = n64(2039);
                t88.gather = (e, t, n)=>(l9(t, n.axis), [
                        e.run(u12(e, t, n), t)
                    ])
                , t88.parseGatherAttributes = (e)=>r40.createAttributeWithCacheKey({
                        axis: e.attributes.getInt("axis", 0)
                    })
                ;
                const a9 = {
                    name: "Gather",
                    inputNames: [
                        "A",
                        "B"
                    ],
                    inputTypes: [
                        s.TextureType.unpacked,
                        s.TextureType.unpacked
                    ]
                }, u12 = (e, t89, n65)=>{
                    const r41 = Object.assign(Object.assign({}, a9), {
                        cacheHint: n65.cacheKey
                    });
                    return Object.assign(Object.assign({}, r41), {
                        get: ()=>((e, t, n, r)=>{
                                const i = n[0].dims.slice(), a = n[1].dims.slice(), u = new Array(i.length + a.length - 1);
                                r = o.ShapeUtil.normalizeAxis(r, i.length);
                                const l = [];
                                for(let e151 = 0; e151 < u.length; e151++)e151 < r ? (u[e151] = i[e151], l.push(`inputIdx[${e151}] = outputIdx[${e151}];`)) : e151 < r + a.length ? (u[e151] = a[e151 - r], l.push(`indexDataIdx[${e151 - r}] = outputIdx[${e151}];`)) : (u[e151] = i[e151 - a.length + 1], l.push(`inputIdx[${e151 - a.length + 1}] = outputIdx[${e151}];`));
                                const c = `\n      float process(int outputIdx[${u.length || 1}]) {\n        int inputIdx[${i.length}];\n        int indexDataIdx[${a.length || 1}];\n        indexDataIdx[0] = 0;\n        ${l.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\n        return _A(inputIdx);\n      }`;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: u,
                                        type: n[0].type,
                                        textureType: s.TextureType.unpacked
                                    },
                                    shaderSource: c
                                });
                            })(0, r41, t89, n65.axis)
                    });
                }, l9 = (e, t)=>{
                    if (!e || 2 !== e.length) throw new Error("Gather requires 2 inputs.");
                    const n = e[0].dims.length;
                    if (n < 1) throw new Error("Invalid input shape.");
                    if (t < -n || t > n - 1) throw new Error("Invalid axis.");
                    if (-1 === i23.NUMBER_TYPES.indexOf(e[0].type)) throw new Error("Invaid input type.");
                    if ("int32" !== e[1].type && "int16" !== e[1].type) throw new Error("Invaid input type.");
                };
            },
            4776: (e152, t90, n66)=>{
                "use strict";
                Object.defineProperty(t90, "__esModule", {
                    value: !0
                }), t90.parseGemmAttributesV11 = t90.parseGemmAttributesV7 = t90.gemm = void 0;
                const r42 = n66(246), i24 = n66(2517), o15 = n66(2039);
                t90.gemm = (e, t, n)=>(l10(t, n), [
                        e.run(a10(t, n), t)
                    ])
                ;
                const s14 = (e, t)=>{
                    const n = 0 !== e.attributes.getInt("transA", 0), i = 0 !== e.attributes.getInt("transB", 0), o = e.attributes.getFloat("alpha", 1), s = e.attributes.getFloat("beta", 1);
                    return r42.createAttributeWithCacheKey({
                        transA: n,
                        transB: i,
                        alpha: o,
                        beta: s,
                        isOptionalC: t
                    });
                };
                t90.parseGemmAttributesV7 = (e)=>s14(e, !1)
                , t90.parseGemmAttributesV11 = (e)=>s14(e, !0)
                ;
                const a10 = (e, t)=>{
                    const n = {
                        name: "Gemm",
                        inputNames: 3 === e.length ? [
                            "A",
                            "B",
                            "C"
                        ] : [
                            "A",
                            "B"
                        ],
                        inputTypes: 3 === e.length ? [
                            o15.TextureType.unpacked,
                            o15.TextureType.unpacked,
                            o15.TextureType.unpacked
                        ] : [
                            o15.TextureType.unpacked,
                            o15.TextureType.unpacked
                        ],
                        key: t.cacheKey
                    };
                    return Object.assign(Object.assign({}, n), {
                        get: ()=>u13(n, e, t)
                    });
                }, u13 = (e, t, n)=>{
                    const r = t[0].dims.slice(), s = t[1].dims.slice(), [a, u] = i24.GemmUtil.getShapeOfGemmResult(r, n.transA, s, n.transB, 3 === t.length ? t[2].dims : void 0), l = [
                        a,
                        u
                    ];
                    if (!l) throw new Error("Can't use gemm on the given tensors");
                    let c = r[r.length - 1], p = "";
                    n.transA && (c = r[0]), n.transA && n.transB ? p = "value += _A_T(a) * _B_T(b);" : n.transA && !n.transB ? p = "value += _A_T(a) * _B(b);" : !n.transA && n.transB ? p = "value += _A(a) * _B_T(b);" : n.transA || n.transB || (p = "value += _A(a) * _B(b);");
                    const d = l.length, f = `\n      float process(int indices[${d}]) {\n          int a[${d}];\n          int b[${d}];\n          ${3 === t.length ? `int c[${t[2].dims.length}];` : ""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3 === t.length ? "bcastIndices_C(indices, c);" : ""}\n\n          float value = 0.0;\n          for (int k=0; k<${c}; ++k) {\n              a[${d - 1}] = k;\n              b[${d - 2}] = k;\n              ${p}\n          }\n\n          value = value * alpha;\n          ${3 === t.length ? "value += beta * _C(c);" : ""}\n          return value;\n      }`;
                    return Object.assign(Object.assign({}, e), {
                        output: {
                            dims: l,
                            type: t[0].type,
                            textureType: o15.TextureType.unpacked
                        },
                        variables: [
                            {
                                name: "alpha",
                                type: "float",
                                data: n.alpha
                            },
                            {
                                name: "beta",
                                type: "float",
                                data: n.beta
                            }
                        ],
                        shaderSource: f
                    });
                }, l10 = (e, t)=>{
                    if (!e) throw new Error("Input is missing");
                    if (t.isOptionalC && (e.length < 2 || e.length > 3)) throw new Error("Invaid input shape.");
                    if (!t.isOptionalC && 3 !== e.length) throw new Error("Gemm requires 3 inputs");
                    if (3 === e.length && 1 !== e[2].dims.length && 2 !== e[2].dims.length) throw new Error("Invalid input shape of C");
                    if ("float32" !== e[0].type && "float64" !== e[0].type || "float32" !== e[1].type && "float64" !== e[1].type || 3 === e.length && "float32" !== e[2].type && "float64" !== e[2].type) throw new Error("Invalid input type.");
                    if (e[0].type !== e[1].type || 3 === e.length && e[0].type !== e[2].type) throw new Error("Input types are mismatched");
                };
            },
            8555: (e154, t92, n67)=>{
                "use strict";
                Object.defineProperty(t92, "__esModule", {
                    value: !0
                }), t92.createPackedIm2ColProgramInfoLoader = void 0;
                const r = n67(5060), i = n67(2039), o = n67(2827);
                t92.createPackedIm2ColProgramInfoLoader = (e155, t93, n68, s15, a11)=>{
                    const u14 = (l11 = a11.cacheKey, {
                        name: "Im2Col (packed)",
                        inputNames: [
                            "A"
                        ],
                        inputTypes: [
                            i.TextureType.packed
                        ],
                        cacheHint: l11
                    });
                    var l11;
                    return Object.assign(Object.assign({}, u14), {
                        get: ()=>((e, t, n, s, a, u)=>{
                                const l = n.dims, c = s.dims, p = a.length, d = [
                                    c[1] * c[2] * c[3],
                                    a[2] * a[3]
                                ], f = c[2] * c[3], h = o.unpackFromChannel(), g = r.getGlsl(e.session.backend.glContext.version);
                                let m = "";
                                for(let e153 = 0; e153 <= 1; e153++)for(let t91 = 0; t91 <= 1; t91++)m += `\n            blockIndex = rc.x + ${t91};\n            pos = rc.y + ${e153};\n\n            if(blockIndex < ${d[1]} && pos < ${d[0]}) {\n              offsetY = int(blockIndex / (${a[p - 1]})) * ${u.strides[0]} -\n                ${u.pads[0]};\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${f}) / ${c[2]});\n\n              if(d0 < ${l[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${a[p - 1]}) * ${u.strides[1]} -\n                  ${u.pads[1]};\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});\n\n                if(d1 < ${l[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${f}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2 * e153 + t91}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;
                                const b = `\n      ${h}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${m}\n          ${g.output} = result;\n      }\n            `;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: d,
                                        type: n.type,
                                        textureType: i.TextureType.packed
                                    },
                                    shaderSource: b,
                                    hasMain: !0
                                });
                            })(e155, u14, t93, n68, s15, a11)
                    });
                };
            },
            3248: (e156, t94, n69)=>{
                "use strict";
                Object.defineProperty(t94, "__esModule", {
                    value: !0
                }), t94.calculateIm2ColDims = t94.createIm2ColProgramInfoLoader = void 0;
                const r43 = n69(2039);
                t94.createIm2ColProgramInfoLoader = (e, n70, i25, o16, s16)=>{
                    const a12 = (u15 = s16.cacheKey, {
                        name: "Im2Col",
                        inputNames: [
                            "X"
                        ],
                        inputTypes: [
                            r43.TextureType.unpacked
                        ],
                        cacheHint: u15
                    });
                    var u15;
                    return Object.assign(Object.assign({}, a12), {
                        get: ()=>((e, n, i, o, s, a)=>{
                                const u = i.dims, l = o.dims, c = s.length, p = t94.calculateIm2ColDims(u, l, s, 4), d = `\n        const int XC = ${u[1]};\n        const int XH = ${u[2]};\n        const int XW = ${u[3]};\n        const int KH = ${a.kernelShape[0]};\n        const int KW = ${a.kernelShape[1]};\n        const int dilationH = ${a.dilations[0]};\n        const int dilationW = ${a.dilations[1]};\n        const int strideH = ${a.strides[0]};\n        const int strideW = ${a.strides[1]};\n        const int padH = ${a.pads[0]};\n        const int padW = ${a.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${c}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${u.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;
                                return Object.assign(Object.assign({}, n), {
                                    output: {
                                        dims: p,
                                        type: i.type,
                                        textureType: r43.TextureType.packedLastDimension
                                    },
                                    shaderSource: d
                                });
                            })(0, a12, n70, i25, o16, s16)
                    });
                }, t94.calculateIm2ColDims = (e, t, n, r = 4)=>[
                        n[0],
                        n[2],
                        n[3],
                        Math.ceil(e[1] * t[2] * t[3] / r)
                    ]
                ;
            },
            6572: (e157, t95, n71)=>{
                "use strict";
                Object.defineProperty(t95, "__esModule", {
                    value: !0
                }), t95.parseImageScalerAttributes = t95.imageScaler = void 0;
                const r44 = n71(246), i = n71(2039);
                t95.imageScaler = (e, t, n)=>(u16(t), [
                        e.run(s17(e, t, n), t)
                    ])
                , t95.parseImageScalerAttributes = (e)=>{
                    const t = e.attributes.getFloat("scale"), n = e.attributes.getFloats("bias");
                    return r44.createAttributeWithCacheKey({
                        scale: t,
                        bias: n
                    });
                };
                const o17 = {
                    name: "ImageScaler",
                    inputNames: [
                        "X"
                    ],
                    inputTypes: [
                        i.TextureType.unpacked
                    ]
                }, s17 = (e, t96, n72)=>{
                    const r45 = Object.assign(Object.assign({}, o17), {
                        cacheHint: n72.cacheKey
                    });
                    return Object.assign(Object.assign({}, r45), {
                        get: ()=>((e, t, n, r)=>{
                                const o = n[0].dims.slice(), s = o.length, u = `\n      ${a(r.bias.length)}\n      float process(int indices[${s}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: o,
                                        type: n[0].type,
                                        textureType: i.TextureType.unpacked
                                    },
                                    variables: [
                                        {
                                            name: "bias",
                                            type: "float",
                                            arrayLength: r.bias.length,
                                            data: r.bias
                                        },
                                        {
                                            name: "scale",
                                            type: "float",
                                            data: r.scale
                                        }
                                    ],
                                    shaderSource: u
                                });
                            })(0, r45, t96, n72)
                    });
                }, a = (e)=>{
                    const t = [
                        `float getBias(float bias[${e}], int channel) {`
                    ];
                    for(let n = 0; n < e; ++n)0 === n ? t.push(`\tif (channel == ${n}) { return bias[${n}]; }`) : n === e - 1 ? t.push(`\telse { return bias[${n}]; }`) : t.push(`\telse if (channel == ${n}) { return bias[${n}]; }`);
                    return t.push("\t}"), t.join("\n");
                }, u16 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("ImageScaler requires 1 input.");
                    if (4 !== e[0].dims.length) throw new Error("Invalid input shape.");
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("Invalid input type.");
                };
            },
            3346: (e158, t97, n73)=>{
                "use strict";
                Object.defineProperty(t97, "__esModule", {
                    value: !0
                }), t97.parseInstanceNormalizationAttributes = t97.instanceNormalization = void 0;
                const r46 = n73(5060), i = n73(2039);
                t97.instanceNormalization = (e, t, n)=>{
                    l12(t);
                    const r = e.run(s18(t[0]), t);
                    return [
                        e.run(u17(e, t[0], n, r.dims), [
                            t[0],
                            r,
                            t[1],
                            t[2]
                        ])
                    ];
                }, t97.parseInstanceNormalizationAttributes = (e)=>e.attributes.getFloat("epsilon", 1e-5)
                ;
                const o18 = {
                    name: "InstanceNormalization_MeanAndVariance",
                    inputNames: [
                        "X"
                    ],
                    inputTypes: [
                        i.TextureType.unpacked
                    ]
                }, s18 = (e159)=>Object.assign(Object.assign({}, o18), {
                        get: ()=>((e, t)=>{
                                const n = t.dims.slice(), r = n[1], o = n[2] * n[3], s = [
                                    n[0],
                                    r
                                ], a = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${o});\n        temp = 0.0;\n        for(int a2=0; a2<${n[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${n[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${o});\n\n        return v;\n      }`;
                                return Object.assign(Object.assign({}, e), {
                                    output: {
                                        dims: s,
                                        type: t.type,
                                        textureType: i.TextureType.packedLastDimension
                                    },
                                    shaderSource: a
                                });
                            })(o18, e159)
                    })
                , a13 = {
                    name: "InstanceNormalization_ComputeOutput",
                    inputNames: [
                        "X",
                        "MeanAndVariance",
                        "Scale",
                        "B"
                    ],
                    inputTypes: [
                        i.TextureType.unpacked,
                        i.TextureType.packedLastDimension,
                        i.TextureType.unpacked,
                        i.TextureType.unpacked
                    ]
                }, u17 = (e160, t98, n74, o19)=>{
                    const s19 = Object.assign(Object.assign({}, a13), {
                        cacheHint: `${n74}`
                    });
                    return Object.assign(Object.assign({}, s19), {
                        get: ()=>((e, t, n, o, s)=>{
                                const a = r46.getGlsl(e.session.backend.glContext.version), [u, l] = e.calculateTextureWidthAndHeight(s, i.TextureType.packedLastDimension), [c, p] = [
                                    u / 4,
                                    l
                                ], d = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${c}, ${p});\n        return ${a.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: n.dims,
                                        type: n.type,
                                        textureType: i.TextureType.unpacked
                                    },
                                    variables: [
                                        {
                                            name: "epsilon",
                                            type: "float",
                                            data: o
                                        }
                                    ],
                                    shaderSource: d
                                });
                            })(e160, s19, t98, n74, o19)
                    });
                }, l12 = (e)=>{
                    if (!e || 3 !== e.length) throw new Error("InstanceNormalization requires 3 inputs.");
                    const t = e[0], n = e[1], r = e[2];
                    if (t.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length) throw new Error("Invalid input shape.");
                    if (n.dims[0] !== t.dims[1] || r.dims[0] !== t.dims[1]) throw new Error("Input shapes are mismatched.");
                    if ("float32" !== t.type && "float64" !== t.type || "float32" !== n.type && "float64" !== n.type || "float32" !== r.type && "float64" !== r.type) throw new Error("Invalid input type.");
                    if (4 !== e[0].dims.length) throw new Error("Only support 4-D input shape.");
                };
            },
            708: (e161, t99, n75)=>{
                "use strict";
                Object.defineProperty(t99, "__esModule", {
                    value: !0
                }), t99.createPackedMatmulProgramInfoLoader = void 0;
                const r47 = n75(2517), i26 = n75(2517), o20 = n75(5060), s20 = n75(2039), a14 = n75(9390), u18 = n75(2823), l13 = n75(5623);
                t99.createPackedMatmulProgramInfoLoader = (e162, t100, n76)=>{
                    const c8 = (p7 = t100.length > 2, d5 = n76.activationCacheKey, {
                        name: "MatMul (packed)",
                        inputNames: p7 ? [
                            "A",
                            "B",
                            "Bias"
                        ] : [
                            "A",
                            "B"
                        ],
                        inputTypes: p7 ? [
                            s20.TextureType.packed,
                            s20.TextureType.packed,
                            s20.TextureType.packed
                        ] : [
                            s20.TextureType.packed,
                            s20.TextureType.packed
                        ],
                        cacheHint: d5
                    });
                    var p7, d5;
                    return Object.assign(Object.assign({}, c8), {
                        get: ()=>((e163, t101, n77, c9)=>{
                                const p8 = n77.length > 2, d6 = p8 ? "value += getBiasForMatmul();" : "", f4 = n77[0].dims, h4 = n77[1].dims, g2 = r47.BroadcastUtil.calcShape(f4, h4, !0), m2 = !i26.ShapeUtil.areEqual(n77[0].dims, n77[1].dims);
                                if (!g2) throw new Error("Can't use matmul on the given tensors");
                                const b2 = f4[f4.length - 1], y2 = Math.ceil(b2 / 2), _ = f4.length, v = h4.length, w = o20.getGlsl(e163.session.backend.glContext.version), x = a14.getCoordsDataType(g2.length), T = g2.length, O = a14.getGlChannels(), { activationFunction: S , applyActivation: A  } = u18.getActicationSnippet(c9), E = p8 ? `${l13.getBiasForMatmul(x, O, n77[2].dims, g2, !0)}` : "", I = m2 ? `${function(e164, t, n78, i) {
                                    let o = [], s = [];
                                    const a = n78[0].dims, u = n78[1].dims, l = a.length, c = u.length, p = i.length, d = p - l, f = p - c;
                                    o = a.map((e, n)=>`coords.${t[n + d]}`
                                    ), o[l - 1] = "i*2", o.join(", "), s = u.map((e, n)=>`coords.${t[n + f]}`
                                    ), s[c - 2] = "i*2", s.join(", ");
                                    const h = r47.BroadcastUtil.getBroadcastDims(a, i), g = r47.BroadcastUtil.getBroadcastDims(u, i), m = h.map((e)=>`coords.${t[e + d]} = 0;`
                                    ).join("\n"), b = g.map((e)=>`coords.${t[e + f]} = 0;`
                                    ).join("\n"), y = `int lastDim = coords.${t[p - 1]};\n  coords.${t[p - 1]} = coords.${t[p - 2]};\n  coords.${t[p - 2]} = lastDim;`;
                                    return `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e164} coords = getOutputCoords();\n  ${y}\n  ${m}\n  vec4 outputValue = getA(${o});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e164} coords = getOutputCoords();\n  ${y}\n  ${b}\n  vec4 outputValue = getB(${s});\n  return outputValue;\n}`;
                                }(x, O, n77, g2)}` : "", D = m2 ? "getAAtOutCoordsMatmul(i)" : `getA(${function(e, t) {
                                    let n = "";
                                    for(let r = 0; r < t - 2; r++)n += `rc.${e[r]}, `;
                                    return n += `rc.${e[t - 2]}, i*2`, n;
                                }(O, _)})`, P = m2 ? "getBAtOutCoordsMatmul(i)" : `getB(${function(e, t) {
                                    let n = "";
                                    for(let r = 0; r < t - 2; r++)n += `rc.${e[r]}, `;
                                    return n += `i*2, rc.${e[t - 1]}`, n;
                                }(O, v)})`, $ = `\n            ${I}\n            ${E}\n            ${S}\n            void main() {\n              ${m2 ? "" : `${x} rc =\n          getOutputCoords(); int lastDim = rc.${O[T - 1]}; rc.${O[T - 1]} =\n          rc.${O[T - 2]}; rc.${O[T - 2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${y2}; i++) {\n                vec4 a = ${D};\n                vec4 b = ${P};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${d6}\n              ${A}\n              ${w.output} = value;\n            }`;
                                return Object.assign(Object.assign({}, t101), {
                                    output: {
                                        dims: g2,
                                        type: n77[0].type,
                                        textureType: s20.TextureType.packed
                                    },
                                    shaderSource: $,
                                    hasMain: !0
                                });
                            })(e162, c8, t100, n76)
                    });
                };
            },
            5623: (e165, t102, n79)=>{
                "use strict";
                Object.defineProperty(t102, "__esModule", {
                    value: !0
                }), t102.getBiasForMatmul = t102.createMatmulProgramInfoLoader = t102.parseMatMulAttributes = t102.matMul = void 0;
                const r = n79(2517), i27 = n79(2039), o21 = n79(9390), s21 = n79(2823), a15 = n79(708);
                function u19(e166, t103) {
                    const n80 = (a16 = e166.length > 2, u20 = t103.activationCacheKey, {
                        name: "MatMul",
                        inputNames: a16 ? [
                            "A",
                            "B",
                            "Bias"
                        ] : [
                            "A",
                            "B"
                        ],
                        inputTypes: a16 ? [
                            i27.TextureType.unpacked,
                            i27.TextureType.unpacked,
                            i27.TextureType.unpacked
                        ] : [
                            i27.TextureType.unpacked,
                            i27.TextureType.unpacked
                        ],
                        cacheHint: u20
                    });
                    var a16, u20;
                    return Object.assign(Object.assign({}, n80), {
                        get: ()=>(function(e, t, n) {
                                const a = t[0].dims, u = t[1].dims, l = r.BroadcastUtil.calcShape(a, u, !0);
                                if (!l) throw new Error("Can't use matmul on the given tensors");
                                const p = o21.getCoordsDataType(l.length), d = o21.getGlChannels(), { activationFunction: f , applyActivation: h  } = s21.getActicationSnippet(n), g = t.length > 2, m = g ? "value += getBiasForMatmul();" : "", b = g ? `${c10(p, d, t[2].dims, l, !1)}` : "", y = l.length, _ = a.length, v = u.length, w = `\n    ${f}\n    ${b}\n    float process(int indices[${y}]) {\n        int a[${_}];\n        int b[${v}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${a[a.length - 1]}; ++k) {\n            a[${_ - 1}] = k;\n            b[${v - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${m}\n        ${h}\n        return value;\n    }`;
                                return Object.assign(Object.assign({}, e), {
                                    output: {
                                        dims: l,
                                        type: t[0].type,
                                        textureType: i27.TextureType.unpacked
                                    },
                                    shaderSource: w
                                });
                            })(n80, e166, t103)
                    });
                }
                t102.matMul = (e, t, n)=>(l14(t), e.session.pack ? [
                        e.run(a15.createPackedMatmulProgramInfoLoader(e, t, n), t)
                    ] : [
                        e.run(u19(t, n), t)
                    ])
                , t102.parseMatMulAttributes = (e)=>s21.parseInternalActivationAttributes(e.attributes)
                , t102.createMatmulProgramInfoLoader = u19;
                const l14 = (e)=>{
                    if (!e || 2 !== e.length) throw new Error("MatMul requires 2 inputs.");
                    if (e[0].dims[e[0].dims.length - 1] !== e[1].dims[e[1].dims.length - 2]) throw new Error("shared dimension does not match.");
                    if ("float32" !== e[0].type && "float64" !== e[0].type || "float32" !== e[1].type && "float64" !== e[1].type) throw new Error("inputs should be float type");
                    if (e[0].type !== e[1].type) throw new Error("inputs types should match");
                };
                function c10(e167, t, n81, i, o) {
                    let s = "";
                    const a = n81.length, u = i.length, l = u - a;
                    s = u < 2 && a > 0 ? "coords" : n81.map((e, n)=>`coords.${t[n + l]}`
                    ).join(", ");
                    const c = r.BroadcastUtil.getBroadcastDims(n81, i).map((e)=>`coords.${t[e + l]} = 0;`
                    ).join("\n");
                    let p = "vec4(outputValue.xx, outputValue.yy)";
                    return 1 === r.ShapeUtil.size(n81) && (p = "vec4(outputValue.x)"), o ? `\nvec4 getBiasForMatmul() {\n  ${e167} coords = getOutputCoords();\n  ${c}\n  vec4 outputValue = getBias(${s});\n  return ${p};\n}` : `\nfloat getBiasForMatmul() {\n  ${e167} coords = getOutputCoords();\n  ${c}\n  return getBias(coords.x);\n}`;
                }
                t102.getBiasForMatmul = c10;
            },
            2403: (e168, t104, n82)=>{
                "use strict";
                Object.defineProperty(t104, "__esModule", {
                    value: !0
                }), t104.createPackProgramInfoLoader = void 0;
                const r48 = n82(5060), i28 = n82(2039), o = n82(9390), s = n82(2827), a = {
                    name: "pack",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        i28.TextureType.unpackedReversed
                    ]
                };
                t104.createPackProgramInfoLoader = (e169, t105)=>Object.assign(Object.assign({}, a), {
                        get: ()=>((e170, t106)=>{
                                const n83 = r48.getGlsl(e170.session.backend.glContext.version), u = t106.dims, l = u.length, c = t106.dims.length, p = o.getCoordsDataType(c), d = s.getChannels("rc", c), f = (h = c, g = d, m = u[u.length - 2], b = u[u.length - 1], 0 === h || 1 === h ? "" : `\n    int r = ${g[h - 2]};\n    int c = ${g[h - 1]};\n    int rp1 = ${g[h - 2]} + 1;\n    int cp1 = ${g[h - 1]} + 1;\n    bool rEdge = rp1 >= ${b};\n    bool cEdge = cp1 >= ${m};\n    `);
                                var h, g, m, b;
                                let y;
                                y = 0 === l ? [
                                    1,
                                    1
                                ] : 1 === l ? [
                                    u[0],
                                    1
                                ] : [
                                    u[c - 1],
                                    u[c - 2]
                                ];
                                const _ = function(e, t, n) {
                                    if (0 === e) return "false";
                                    if (1 === e) return `rc > ${t[0]}`;
                                    let r = "";
                                    for(let i = e - 2; i < e; i++)r += `${n[i]} >= ${t[i - e + 2]}`, i < e - 1 && (r += "||");
                                    return r;
                                }(c, y, d), v = function(e, t) {
                                    const n = e.length;
                                    if (0 === n) return "getA(), 0, 0, 0";
                                    if (1 === n) return `getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;
                                    let r = "";
                                    if (n > 2) for(let e171 = 0; e171 < n - 2; ++e171)r += `${t[e171]},`;
                                    return `getA(${r}r, c),\n          rEdge ? 0. : getA(${r}rp1, c),\n          cEdge ? 0. : getA(${r}r, cp1),\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`;
                                }(u, d), w = `\n        void main() {\n          ${p} rc = getOutputCoords();\n\n          if(${_}) {\n            ${n83.output} = vec4(0);\n          } else {\n            ${f}\n\n            ${n83.output} = vec4(${v});\n          }\n        }\n      `;
                                return Object.assign(Object.assign({}, a), {
                                    hasMain: !0,
                                    output: {
                                        dims: t106.dims,
                                        type: t106.type,
                                        textureType: i28.TextureType.packed
                                    },
                                    shaderSource: w
                                });
                            })(e169, t105)
                    })
                ;
            },
            2827: (e172, t107, n)=>{
                "use strict";
                Object.defineProperty(t107, "__esModule", {
                    value: !0
                }), t107.unpackFromChannel = t107.getChannels = t107.getVecChannels = void 0;
                const r = n(9390);
                function i(e, t108) {
                    return r.getGlChannels(t108).map((t)=>`${e}.${t}`
                    );
                }
                t107.getVecChannels = i, t107.getChannels = function(e, t) {
                    return 1 === t ? [
                        e
                    ] : i(e, t);
                }, t107.unpackFromChannel = function() {
                    return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
                };
            },
            2870: (e173, t109, n84)=>{
                "use strict";
                Object.defineProperty(t109, "__esModule", {
                    value: !0
                }), t109.parsePadAttributesV11 = t109.padV11 = t109.parsePadAttributesV2 = t109.padV2 = void 0;
                const r49 = n84(246), i29 = n84(2517), o22 = n84(5060), s22 = n84(2039), a17 = {
                    name: "Pad",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        s22.TextureType.unpacked
                    ]
                };
                t109.padV2 = (e, t, n)=>(c(t), [
                        e.run(Object.assign(Object.assign({}, a17), {
                            cacheHint: n.cacheKey,
                            get: ()=>l15(e, t[0], n)
                        }), t)
                    ])
                , t109.parsePadAttributesV2 = (e)=>{
                    const t = e.attributes.getString("mode", "constant"), n = e.attributes.getFloat("value", 0), i = e.attributes.getInts("pads");
                    return r49.createAttributeWithCacheKey({
                        mode: t,
                        value: n,
                        pads: i
                    });
                }, t109.padV11 = (e, n, r)=>{
                    p(n);
                    const i = u21(e, n, r);
                    return t109.padV2(e, [
                        n[0]
                    ], i);
                }, t109.parsePadAttributesV11 = (e)=>e.attributes.getString("mode", "constant")
                ;
                const u21 = (e, t, n)=>{
                    if (!e.session.isInitializer(t[1].dataId) || t.length >= 3 && !e.session.isInitializer(t[2].dataId)) throw new Error("dynamic pad attributes are not allowed");
                    const i = Array.from(t[1].integerData), o = t.length >= 3 ? t[2].floatData[0] : 0;
                    return r49.createAttributeWithCacheKey({
                        mode: n,
                        pads: i,
                        value: o
                    });
                }, l15 = (e, t, n)=>{
                    const r = i29.ShapeUtil.padShape(t.dims.slice(), n.pads), o = r.length, a = `\n      ${d(e, t, n)}\n      float process(int[${o}] indices) {\n          return padA(indices);\n      }`;
                    return {
                        name: "Pad",
                        inputNames: [
                            "A"
                        ],
                        inputTypes: [
                            s22.TextureType.unpacked
                        ],
                        output: {
                            dims: r,
                            type: t.type,
                            textureType: s22.TextureType.unpacked
                        },
                        shaderSource: a
                    };
                }, c = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Pad requires 1 input");
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("Invalid input type.");
                }, p = (e)=>{
                    if (!e || 2 !== e.length && 3 !== e.length) throw new Error("Pad requires 2 or 3 inputs");
                    if ("int32" !== e[1].type) throw new Error("Invalid input type.");
                    if (e.length >= 3 && "string" === e[2].type) throw new Error("Invalid input type.");
                }, d = (e, t, n)=>{
                    const r = o22.getGlsl(e.session.backend.glContext.version), [a, u] = e.calculateTextureWidthAndHeight(t.dims, s22.TextureType.unpacked), l = i29.ShapeUtil.computeStrides(t.dims);
                    switch(n.mode){
                        case "constant":
                            return f(r, t.dims, l, a, u, n.pads, n.value);
                        case "reflect":
                            return h(r, t.dims, l, a, u, n.pads);
                        case "edge":
                            return g(r, t.dims, l, a, u, n.pads);
                        default:
                            throw new Error("Invalid mode");
                    }
                }, f = (e, t, n, r, i, o, s)=>{
                    const a = t.length;
                    let u = "";
                    for(let e174 = a - 1; e174 >= 0; --e174)u += `\n        k = m[${e174}] - ${o[e174]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e174]}) return constant;\n        offset += k * ${n[e174]};\n        `;
                    return `\n      float padA(int m[${a}]) {\n        const float constant = float(${s});\n        int offset = 0;\n        int k = 0;\n        ${u}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `;
                }, h = (e, t, n, r, i, o)=>{
                    const s = t.length;
                    let a = "";
                    for(let e175 = s - 1; e175 >= 0; --e175)a += `\n        k = m[${e175}] - ${o[e175]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (t[e175] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e175]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${n[e175]};\n        `;
                    return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `;
                }, g = (e, t, n, r, i, o)=>{
                    const s = t.length;
                    let a = "";
                    for(let e176 = s - 1; e176 >= 0; --e176)a += `\n        k = m[${e176}] - ${o[e176]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e176]}) k = ${t[e176] - 1};\n        offset += k * ${n[e176]};\n      `;
                    return `\n      float padA(int m[${s}]) {\n        int offset = 0;\n        int k = 0;\n        ${a}\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `;
                };
            },
            2143: (e177, t110, n85)=>{
                "use strict";
                Object.defineProperty(t110, "__esModule", {
                    value: !0
                }), t110.globalMaxPool = t110.parseMaxPoolAttributes = t110.maxPool = t110.parseGlobalAveragePoolAttributes = t110.globalAveragePool = t110.parseAveragePoolAttributes = t110.averagePool = void 0;
                const r50 = n85(246), i30 = n85(2517), o23 = n85(2039);
                t110.averagePool = (e, t, n)=>{
                    p9(t);
                    const r = {
                        name: "AveragePool",
                        inputNames: [
                            "X"
                        ],
                        inputTypes: [
                            o23.TextureType.unpacked
                        ],
                        cacheHint: n.cacheKey
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, r), {
                            get: ()=>s23(t, r, !1, n)
                        }), t)
                    ];
                }, t110.parseAveragePoolAttributes = (e)=>{
                    const t = e.attributes.getString("auto_pad", "NOTSET"), n = e.attributes.getInt("ceil_mode", 0), i = 0 !== e.attributes.getInt("count_include_pad", 0), o = e.attributes.getInts("kernel_shape"), s = e.attributes.getInts("strides", []), a = e.attributes.getInts("pads", []);
                    if (0 !== n) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
                    return r50.createAttributeWithCacheKey({
                        autoPad: t,
                        ceilMode: n,
                        countIncludePad: i,
                        kernelShape: o,
                        strides: s,
                        pads: a
                    });
                };
                const s23 = (e, t, n, r)=>{
                    const [s, a] = u22(e, r, n), l = i30.ShapeUtil.size(s.kernelShape);
                    let c = "";
                    s.countIncludePad ? c += `value /= float(${l});` : c += `value /= float(${l} - pad);`;
                    const p = `\n        ${d7(e[0].dims, s, "value += _X(x);", c, "0.0")}\n      `;
                    return Object.assign(Object.assign({}, t), {
                        output: {
                            dims: a,
                            type: e[0].type,
                            textureType: o23.TextureType.unpacked
                        },
                        shaderSource: p
                    });
                };
                t110.globalAveragePool = (e, t, n)=>{
                    p9(t);
                    const r = {
                        name: "GlobalAveragePool",
                        inputNames: [
                            "X"
                        ],
                        inputTypes: [
                            o23.TextureType.unpacked
                        ],
                        cacheHint: `${n.countIncludePad}`
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, r), {
                            get: ()=>s23(t, r, !0, n)
                        }), t)
                    ];
                }, t110.parseGlobalAveragePoolAttributes = (e)=>{
                    const t = 0 !== e.attributes.getInt("count_include_pad", 0);
                    return r50.createAttributeWithCacheKey({
                        autoPad: "",
                        ceilMode: 0,
                        countIncludePad: t,
                        kernelShape: [],
                        strides: [],
                        pads: []
                    });
                }, t110.maxPool = (e, t, n)=>{
                    p9(t);
                    const r = {
                        name: "MaxPool",
                        inputNames: [
                            "X"
                        ],
                        inputTypes: [
                            o23.TextureType.unpacked
                        ],
                        cacheHint: n.cacheKey
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, r), {
                            get: ()=>a18(t, r, !1, n)
                        }), t)
                    ];
                }, t110.parseMaxPoolAttributes = (e)=>{
                    const t = e.attributes.getString("auto_pad", "NOTSET"), n = e.attributes.getInt("ceil_mode", 0), i = e.attributes.getInts("kernel_shape"), o = e.attributes.getInts("strides", []), s = e.attributes.getInts("pads", []), a = e.attributes.getInt("storage_order", 0), u = e.attributes.getInts("dilations", []);
                    if (0 !== a) throw new Error("column major storage order is not yet supported for MaxPool");
                    if (0 !== n) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
                    return r50.createAttributeWithCacheKey({
                        autoPad: t,
                        ceilMode: n,
                        countIncludePad: !1,
                        kernelShape: i,
                        strides: o,
                        pads: s,
                        storageOrder: a,
                        dilations: u
                    });
                };
                const a18 = (e, t, n, r)=>{
                    const [i, s] = u22(e, r, n), a = `\n      ${d7(e[0].dims, i, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}\n    `;
                    return Object.assign(Object.assign({}, t), {
                        output: {
                            dims: s,
                            type: e[0].type,
                            textureType: o23.TextureType.unpacked
                        },
                        shaderSource: a
                    });
                }, u22 = (e, t, n)=>{
                    const r = e[0].dims.slice(), o = Object.hasOwnProperty.call(t, "dilations"), s = t.kernelShape.slice(), a = t.strides.slice(), u = o ? t.dilations.slice() : [], l = t.pads.slice();
                    i30.PoolConvUtil.adjustPoolAttributes(n, r, s, a, u, l);
                    const c = i30.PoolConvUtil.computePoolOutputShape(n, r, a, u, s, l, t.autoPad), p = Object.assign({}, t);
                    return o ? Object.assign(p, {
                        kernelShape: s,
                        strides: a,
                        pads: l,
                        dilations: u,
                        cacheKey: t.cacheKey
                    }) : Object.assign(p, {
                        kernelShape: s,
                        strides: a,
                        pads: l,
                        cacheKey: t.cacheKey
                    }), [
                        p,
                        c
                    ];
                }, l16 = {
                    autoPad: "",
                    ceilMode: 0,
                    countIncludePad: !1,
                    kernelShape: [],
                    strides: [],
                    pads: [],
                    storageOrder: 0,
                    dilations: [],
                    cacheKey: ""
                }, c11 = {
                    name: "GlobalMaxPool",
                    inputNames: [
                        "X"
                    ],
                    inputTypes: [
                        o23.TextureType.unpacked
                    ]
                };
                t110.globalMaxPool = (e, t)=>(p9(t), [
                        e.run(Object.assign(Object.assign({}, c11), {
                            get: ()=>a18(t, c11, !0, l16)
                        }), t)
                    ])
                ;
                const p9 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Pool ops requires 1 input.");
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("Invalid input type.");
                }, d7 = (e178, t111, n, r, o)=>{
                    const s = e178.length;
                    if (t111.kernelShape.length <= 2) {
                        const i = t111.kernelShape[t111.kernelShape.length - 1], a = t111.strides[t111.strides.length - 1], u = t111.pads[t111.pads.length / 2 - 1], l = t111.pads[t111.pads.length - 1], c = e178[s - 1];
                        let p = "", d = "", f = "";
                        if (p = u + l !== 0 ? `\n          for (int i = 0; i < ${i}; i++) {\n            x[${s} - 1] = indices[${s} - 1] * ${a} - ${u} + i;\n            if (x[${s} - 1] < 0 || x[${s} - 1] >= ${c}) {\n              pad++;\n              continue;\n            }\n            ${n}\n          }` : `\n          for (int i = 0; i < ${i}; i++) {\n            x[${s} - 1] = indices[${s} - 1] * ${a} - ${u} + i;\n            ${n}\n          }`, 2 === t111.kernelShape.length) {
                            const n = t111.kernelShape[t111.kernelShape.length - 2], r = t111.strides[t111.strides.length - 2], o = t111.pads[t111.pads.length / 2 - 2], a = t111.pads[t111.pads.length - 2], u = e178[s - 2];
                            d = o + a !== 0 ? `\n            for (int j = 0; j < ${n}; j++) {\n              x[${s} - 2] = indices[${s} - 2] * ${r} - ${o} + j;\n              if (x[${s} - 2] < 0 || x[${s} - 2] >= ${u}) {\n                pad+= ${i};\n                continue;\n              }\n          ` : `\n            for (int j = 0; j < ${n}; j++) {\n              x[${s} - 2] = indices[${s} - 2] * ${r} - ${o} + j;\n            `, f = "\n          }\n        ";
                        }
                        return `\n        float process(int indices[${s}]) {\n          int x[${s}];\n          copyVec(indices, x);\n\n          float value = ${o};\n          int pad = 0;\n          ${d}\n          ${p}\n          ${f}\n          ${r}\n          return value;\n        }\n      `;
                    }
                    {
                        const a = i30.ShapeUtil.size(t111.kernelShape), u = i30.ShapeUtil.computeStrides(t111.kernelShape), l = u.length, c = t111.pads.length, p = h(l), d = f5(e178, "inputDims"), g = f5(t111.pads, "pads"), m = f5(u, "kernelStrides"), b = f5(t111.strides, "strides");
                        let y = "";
                        return y = t111.pads.reduce((e, t)=>e + t
                        ) ? `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${n}\n          }` : `\n          }\n          ${n}\n        `, `\n        ${p}\n        float process(int indices[${s}]) {\n          int x[${s}];\n          copyVec(indices, x);\n          int offset[${l}];\n          int pads[${c}];\n          int inputDims[${s}];\n          int kernelStrides[${l}];\n          int strides[${l}];\n          ${g}\n          ${d}\n          ${b}\n          ${m}\n\n          float value = ${o};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${a}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${s} - ${l}; j < ${s}; j++) {\n              x[j] = indices[j] * strides[j - ${s} + ${l}]\n                + offset[j - ${s} + ${l}] - pads[j - 2];\n              ${y}\n          }\n          ${r}\n\n          return value;\n        }\n      `;
                    }
                }, f5 = (e, t)=>{
                    let n = "";
                    for(let r = 0; r < e.length; r++)n += `\n      ${t}[${r}] = ${e[r]};\n    `;
                    return n;
                }, h = (e)=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`
                ;
            },
            4939: (e179, t112, n86)=>{
                "use strict";
                Object.defineProperty(t112, "__esModule", {
                    value: !0
                }), t112.reduceLogSumSquare = t112.reduceLogSum = t112.reduceProd = t112.reduceMin = t112.reduceMax = t112.reduceMean = t112.reduceSum = t112.parseReduceAttributes = void 0;
                const r51 = n86(246), i31 = n86(782), o24 = n86(2517), s = n86(2039), a19 = (e, t, n, r, i)=>{
                    l17(t);
                    const o = {
                        name: r,
                        inputNames: [
                            "A"
                        ],
                        inputTypes: [
                            s.TextureType.unpacked
                        ]
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, o), {
                            cacheHint: n.cacheKey,
                            get: ()=>u23(e, t, n, r, i, o)
                        }), t)
                    ];
                };
                t112.parseReduceAttributes = (e)=>{
                    const t = e.attributes.getInts("axes", []), n = 1 === e.attributes.getInt("keepdims", 1);
                    return r51.createAttributeWithCacheKey({
                        axes: t,
                        keepDims: n
                    });
                };
                const u23 = (e, t, n, r, i, a)=>{
                    const u = [], l = t[0].dims.length || 1, c = [], p = o24.ShapeUtil.normalizeAxes(n.axes, t[0].dims.length), d = i(t, p);
                    let f = d[1];
                    for(let e180 = 0; e180 < t[0].dims.length; e180++)p.indexOf(e180) >= 0 || 0 === p.length ? (n.keepDims && u.push(1), f = `\n          for(int j${e180} = 0; j${e180} < ${t[0].dims[e180]}; j${e180}++) {\n            inputIdx[${e180}] = j${e180};\n            ${f}\n          }`) : (c.push(`inputIdx[${e180}] = outputIdx[${u.length}];`), u.push(t[0].dims[e180]));
                    const h = `\n      float process(int outputIdx[${u.length || 1}]) {\n        float value;                 // final result\n        int inputIdx[${l}];      // addressing input data\n        ${c.join("\n")}\n        ${d[0]}       // init ops for reduce max/min\n        ${f}\n        ${d[2]}       // final computation for reduce mean\n        return value;\n      }`;
                    return Object.assign(Object.assign({}, a), {
                        output: {
                            dims: u,
                            type: t[0].type,
                            textureType: s.TextureType.unpacked
                        },
                        shaderSource: h
                    });
                }, l17 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Reduce op requires 1 input.");
                    if (-1 === i31.NUMBER_TYPES.indexOf(e[0].type)) throw new Error("Invalid input type.");
                };
                t112.reduceSum = (e, t, n)=>a19(e, t, n, "ReduceSum", ()=>[
                            "value = 0.0;",
                            "value += _A(inputIdx);",
                            ""
                        ]
                    )
                , t112.reduceMean = (e181, t113, n87)=>a19(e181, t113, n87, "ReduceMean", (e, t)=>{
                        let n = 1;
                        for(let r = 0; r < e[0].dims.length; r++)(t.indexOf(r) >= 0 || 0 === t.length) && (n *= e[0].dims[r]);
                        return [
                            "value = 0.0;",
                            "value += _A(inputIdx);",
                            `value /= ${n}.;`
                        ];
                    })
                , t112.reduceMax = (e182, t114, n88)=>a19(e182, t114, n88, "ReduceMax", (e, t)=>{
                        const n = [];
                        for(let r = 0; r < e[0].dims.length; r++)(t.indexOf(r) >= 0 || 0 === t.length) && n.push(`inputIdx[${r}] = 0;`);
                        return [
                            `${n.join("\n")}\nvalue = _A(inputIdx);`,
                            "value = max(value, _A(inputIdx));",
                            ""
                        ];
                    })
                , t112.reduceMin = (e183, t115, n89)=>a19(e183, t115, n89, "ReduceMin", (e, t)=>{
                        const n = [];
                        for(let r = 0; r < e[0].dims.length; r++)(t.indexOf(r) >= 0 || 0 === t.length) && n.push(`inputIdx[${r}] = 0;`);
                        return [
                            `${n.join("\n")}\nvalue = _A(inputIdx);`,
                            "value = min(value, _A(inputIdx));",
                            ""
                        ];
                    })
                , t112.reduceProd = (e, t, n)=>a19(e, t, n, "ReduceProd", ()=>[
                            "value = 1.0;",
                            "value *= _A(inputIdx);",
                            ""
                        ]
                    )
                , t112.reduceLogSum = (e, t, n)=>a19(e, t, n, "ReduceLogSum", ()=>[
                            "value = 0.0;",
                            "value += _A(inputIdx);",
                            "value = log(value);"
                        ]
                    )
                , t112.reduceLogSumSquare = (e, t, n)=>a19(e, t, n, "ReduceLogSumSquare", ()=>[
                            "float t; value = 0.0;",
                            "t = _A(inputIdx); value += t * t;",
                            ""
                        ]
                    )
                ;
            },
            7019: (e184, t116, n90)=>{
                "use strict";
                Object.defineProperty(t116, "__esModule", {
                    value: !0
                }), t116.isReshapeCheap = t116.processDims3D = t116.createPackedReshape3DProgramInfoLoader = void 0;
                const r52 = n90(2517), i = n90(5060), o = n90(2039), s = n90(2827);
                t116.createPackedReshape3DProgramInfoLoader = (e185, t117, n91)=>{
                    const a20 = ((e)=>({
                            name: "Reshape (packed)",
                            inputTypes: [
                                o.TextureType.packed
                            ],
                            inputNames: [
                                "A"
                            ],
                            cacheHint: `${e}`
                        })
                    )(n91);
                    return Object.assign(Object.assign({}, a20), {
                        get: ()=>((e187, t118, n92, a)=>{
                                const u = t118.dims, l = a;
                                let c = "";
                                for(let e186 = 0; e186 < 4; e186++){
                                    let t = "";
                                    switch(e186){
                                        case 0:
                                            t = "outputCoords = rc;";
                                            break;
                                        case 1:
                                            t = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                                            break;
                                        case 2:
                                            t = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                                            break;
                                        case 3:
                                            t = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                                            break;
                                        default:
                                            throw new Error;
                                    }
                                    c += `\n        ${t}\n        ${e186 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e186}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e186 > 0 ? "}" : ""}\n      `;
                                }
                                const p = i.getGlsl(e187.session.backend.glContext.version), d = `\n      ${function(e188) {
                                    const t = r52.ShapeUtil.computeStrides(e188), n = [
                                        "b",
                                        "r",
                                        "c"
                                    ];
                                    return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map((e, r)=>`int ${n[r]} = index / ${e}; ${r === t.length - 1 ? `int ${n[r + 1]} = index - ${n[r]} * ${e}` : `index -= ${n[r]} * ${e}`};`
                                    ).join("")}\n      return ivec3(b, r, c);\n    }\n  `;
                                }(u)}\n      ${function(e) {
                                    const t = r52.ShapeUtil.computeStrides(e);
                                    return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`;
                                }(l)}\n      ${s.unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${l[2]};\n        int cols = ${l[1]};\n\n        ${c}\n        ${p.output} = result;\n      }\n    `;
                                return Object.assign(Object.assign({}, n92), {
                                    output: {
                                        dims: l,
                                        type: t118.type,
                                        textureType: o.TextureType.packed
                                    },
                                    shaderSource: d,
                                    hasMain: !0
                                });
                            })(e185, t117, a20, n91)
                    });
                }, t116.processDims3D = function(e) {
                    if (0 === e.length) return [
                        1,
                        1,
                        1
                    ];
                    let t = 1;
                    for(let n = 0; n < e.length - 2; ++n)t *= e[n];
                    return [
                        t,
                        e.length > 1 ? e[e.length - 2] : 1,
                        e[e.length - 1]
                    ];
                }, t116.isReshapeCheap = function(e, t) {
                    let n = !1;
                    return n = 0 === e.length || 0 === t.length || (e.length < 2 || t.length < 2 ? e[e.length - 1] === t[t.length - 1] : e[e.length - 1] === t[t.length - 1] && e[e.length - 2] === t[t.length - 2]), n;
                };
            },
            718: (e189, t119, n93)=>{
                "use strict";
                Object.defineProperty(t119, "__esModule", {
                    value: !0
                }), t119.reshape = void 0;
                const r = n93(2517);
                t119.reshape = (e, t)=>{
                    const n = r.ShapeUtil.calculateReshapedDims(t[0].dims, t[1].integerData);
                    return e.session.pack ? [
                        e.reshapePacked(t[0], n)
                    ] : [
                        e.reshapeUnpacked(t[0], n)
                    ];
                };
            },
            2268: (e190, t120, n94)=>{
                "use strict";
                Object.defineProperty(t120, "__esModule", {
                    value: !0
                }), t120.parseResizeAttributesV11 = t120.parseResizeAttributesV10 = t120.resize = void 0;
                const r53 = n94(5060), i32 = n94(2039), o25 = n94(9390), s = n94(2827), a21 = n94(9793), u = {
                    name: "Resize",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        i32.TextureType.packed
                    ]
                };
                t120.resize = (e, t, n)=>(a21.validateInputs(t, n), [
                        e.run(Object.assign(Object.assign({}, u), {
                            cacheHint: n.cacheKey,
                            get: ()=>l18(e, t, n)
                        }), t)
                    ])
                , t120.parseResizeAttributesV10 = (e)=>a21.parseUpsampleAttributes(e, 10)
                , t120.parseResizeAttributesV11 = (e)=>a21.parseUpsampleAttributes(e, 11)
                ;
                const l18 = (e191, t, n)=>{
                    const a = r53.getGlsl(e191.session.backend.glContext.version), [l, p] = c(t, n);
                    if (l.every((e)=>1 === e
                    ) && "tf_crop_and_resize" !== n.coordinateTransformMode) return Object.assign(Object.assign({}, u), {
                        output: {
                            dims: p,
                            type: t[0].type,
                            textureType: i32.TextureType.packed
                        },
                        hasMain: !0,
                        shaderSource: `void main() {\n                    vec4 v = ${a.texture2D}(X, TexCoords);\n                    ${a.output} = v;\n                }`
                    });
                    const d = p.length;
                    if (d < 2) throw new Error(`output dimension should be at least 2, but got ${d}`);
                    const f = p[d - 2], h = p[d - 1], g = t[0].dims;
                    if (d !== g.length) throw new Error(`output dimension should match input ${g.length}, but got ${d}`);
                    const m = g[d - 2], b = g[d - 1], y = l[d - 2], _ = l[d - 1];
                    let v = "";
                    if ("linear" !== n.mode) throw new Error(`resize (packed) does not support mode: '${n.mode}'`);
                    switch(n.coordinateTransformMode){
                        case "asymmetric":
                            v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
                            break;
                        case "half_pixel":
                            v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
                            break;
                        case "align_corners":
                            v = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,\n                            ${f}.0 - 1.0);\n                        vec4 original = vec4(${b}.0 - 1.0, ${m}.0 - 1.0, ${b}.0 - 1.0,\n                            ${m}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;
                            break;
                        default:
                            throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`);
                    }
                    const w = o25.getCoordsDataType(d), x = `\n            const vec2 inputWH = vec2(${m}.0, ${b}.0);\n            const vec4 scaleWHWH = vec4(${y}.0, ${_}.0, ${y}.0, ${_}.0);\n            ${s.unpackFromChannel()}\n            ${v}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${w} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${f - 1};\n                bool hasNextCol = rc.z < ${h - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${a.output} = vec4(newValue);\n            }\n        `;
                    return Object.assign(Object.assign({}, u), {
                        output: {
                            dims: p,
                            type: t[0].type,
                            textureType: i32.TextureType.packed
                        },
                        hasMain: !0,
                        shaderSource: x
                    });
                }, c = (e192, t121)=>{
                    const n = e192[0].dims;
                    let r, i = t121.scales;
                    if (0 === i.length) {
                        const o = e192[t121.scalesInputIdx];
                        if (o && 0 !== o.size) {
                            if (e192[t121.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
                            i = p10(o, t121.mode, t121.isResize);
                        } else {
                            const o = e192[t121.sizesInputIdx];
                            if (!o || 0 === o.size) throw new Error("Either scales or sizes MUST be provided as input.");
                            r = Array.from(o.integerData), i = d8(r, n, t121.mode, t121.isResize);
                        }
                    } else if (e192[t121.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
                    const o = r || n.map((e, t)=>Math.floor(e * i[t])
                    );
                    return [
                        i,
                        o
                    ];
                }, p10 = (e, t, n)=>{
                    const r = Array.from(e.floatData);
                    return a21.scalesValidation(r, t, n), r;
                }, d8 = (e, t, n, r)=>{
                    const i = t.length, o = new Array(i);
                    for(let n95 = 0, r54 = i; n95 < r54; n95++)if (0 === t[n95]) {
                        if (0 !== e[n95]) throw new Error("Input dim is zero but required output dim is non-zero.");
                        o[n95] = 1;
                    } else o[n95] = e[n95] / t[n95];
                    return a21.scalesValidation(o, n, r), o;
                };
            },
            8117: (e193, t122, n)=>{
                "use strict";
                Object.defineProperty(t122, "__esModule", {
                    value: !0
                }), t122.shape = void 0;
                const r = n(9162);
                t122.shape = (e, t)=>(i(t), [
                        new r.Tensor([
                            t[0].dims.length
                        ], "int32", void 0, void 0, new Int32Array(t[0].dims))
                    ])
                ;
                const i = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Shape requires 1 input.");
                };
            },
            2278: (e194, t123, n96)=>{
                "use strict";
                Object.defineProperty(t123, "__esModule", {
                    value: !0
                }), t123.sliceV10 = t123.parseSliceAttributes = t123.slice = void 0;
                const r55 = n96(246), i33 = n96(782), o = n96(2517), s = n96(2039), a = {
                    name: "Slice",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        s.TextureType.unpacked
                    ]
                };
                t123.slice = (e, t, n)=>(l19(t), [
                        e.run(Object.assign(Object.assign({}, a), {
                            cacheHint: n.cacheKey,
                            get: ()=>u24(e, t[0], n)
                        }), t)
                    ])
                , t123.parseSliceAttributes = (e)=>{
                    const t = e.attributes.getInts("starts"), n = e.attributes.getInts("ends"), i = e.attributes.getInts("axes", []);
                    return r55.createAttributeWithCacheKey({
                        starts: t,
                        ends: n,
                        axes: i
                    });
                };
                const u24 = (e196, t124, n97)=>{
                    const r = 0 === n97.axes.length ? t124.dims.slice(0).map((e, t)=>t
                    ) : n97.axes, i = o.ShapeUtil.normalizeAxes(r, t124.dims.length), u = n97.starts.map((e, n)=>e > t124.dims[i[n]] - 1 ? t124.dims[i[n]] : o.ShapeUtil.normalizeAxis(e, t124.dims[i[n]])
                    ), l = n97.ends.map((e, n)=>e > t124.dims[i[n]] - 1 ? t124.dims[i[n]] : o.ShapeUtil.normalizeAxis(e, t124.dims[i[n]])
                    ), c = t124.dims.slice(), p = [];
                    for(let e195 = 0; e195 < i.length; e195++)c[i[e195]] = l[e195] - u[e195], u[e195] > 0 && p.push(`outputIdx[${i[e195]}] += ${u[e195]};`);
                    const d = `\n      float process(int outputIdx[${c.length}]) {\n        ${p.join("\n      ")}\n        return _A(outputIdx);\n      }`;
                    return Object.assign(Object.assign({}, a), {
                        output: {
                            dims: c,
                            type: t124.type,
                            textureType: s.TextureType.unpacked
                        },
                        shaderSource: d
                    });
                }, l19 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Slice requires 1 input.");
                    if (-1 === i33.NUMBER_TYPES.indexOf(e[0].type)) throw new Error("Invalid input type.");
                };
                t123.sliceV10 = (e, t)=>{
                    p11(t);
                    const n = c12(e, t);
                    return [
                        e.run(Object.assign(Object.assign({}, a), {
                            cacheHint: n.cacheKey,
                            get: ()=>u24(e, t[0], n)
                        }), [
                            t[0]
                        ])
                    ];
                };
                const c12 = (e197, t)=>{
                    if (!e197.session.isInitializer(t[1].dataId) || !e197.session.isInitializer(t[2].dataId) || t.length >= 4 && !e197.session.isInitializer(t[3].dataId) || t.length >= 5 && !e197.session.isInitializer(t[4].dataId)) throw new Error("dynamic slice attributes are not allowed");
                    if (t.length >= 5 && t[4].integerData.some((e)=>1 !== e
                    )) throw new Error("currently non-1 steps is not supported for Slice");
                    const n = Array.from(t[1].integerData), r = Array.from(t[2].integerData), i = t.length >= 4 ? Array.from(t[3].integerData) : [];
                    return {
                        starts: n,
                        ends: r,
                        axes: i,
                        cacheKey: `${i};${n};${r}`
                    };
                }, p11 = (e)=>{
                    if (!e || e.length < 3 || e.length > 5) throw new Error("Invalid input number.");
                    if ("int32" !== e[1].type || 1 !== e[1].dims.length) throw new Error("Invalid input type.");
                    if ("int32" !== e[2].type || 1 !== e[2].dims.length) throw new Error("Invalid input type.");
                    if (e.length >= 4 && ("int32" !== e[3].type || 1 !== e[3].dims.length)) throw new Error("Invalid input type.");
                    if (e.length >= 5 && ("int32" !== e[4].type || 1 !== e[4].dims.length)) throw new Error("Invalid input type.");
                };
            },
            5524: (e198, t125, n98)=>{
                "use strict";
                Object.defineProperty(t125, "__esModule", {
                    value: !0
                }), t125.softmaxV13 = t125.parseSoftmaxAttributesV13 = t125.parseSoftmaxAttributes = t125.softmax = void 0;
                const r56 = n98(246), i34 = n98(2517), o26 = n98(5060), s24 = n98(2039), a22 = n98(3738), u25 = {
                    name: "SoftmaxComputeMax",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        s24.TextureType.unpacked
                    ]
                }, l20 = {
                    name: "SoftmaxComputeScale",
                    inputNames: [
                        "A",
                        "Max"
                    ],
                    inputTypes: [
                        s24.TextureType.unpacked,
                        s24.TextureType.unpacked
                    ]
                }, c13 = {
                    name: "SoftMax",
                    inputNames: [
                        "A",
                        "Max",
                        "Norm"
                    ],
                    inputTypes: [
                        s24.TextureType.unpacked,
                        s24.TextureType.unpacked,
                        s24.TextureType.unpacked
                    ]
                };
                t125.softmax = (e, t, n)=>{
                    g3(t);
                    const r = t[0].dims.slice(), o = i34.ShapeUtil.normalizeAxis(n.axis, r.length), s = i34.ShapeUtil.sizeToDimension(r, o), a = i34.ShapeUtil.sizeFromDimension(r, o);
                    return p12(e, t, n, s, a);
                }, t125.parseSoftmaxAttributes = (e)=>r56.createAttributeWithCacheKey({
                        axis: e.attributes.getInt("axis", 1)
                    })
                , t125.parseSoftmaxAttributesV13 = (e)=>r56.createAttributeWithCacheKey({
                        axis: e.attributes.getInt("axis", -1)
                    })
                , t125.softmaxV13 = (e199, t126, n)=>{
                    g3(t126);
                    const o = t126[0].dims.slice(), s = i34.ShapeUtil.normalizeAxis(n.axis, o.length), u = o.length, l = s !== u - 1, c = [];
                    let d, f = [], h = [];
                    l && (f = Array.from({
                        length: u
                    }).map((e, t)=>t
                    ), f[s] = u - 1, f[u - 1] = s, f.map((e)=>c.push(o[e])
                    ), d = r56.createAttributeWithCacheKey({
                        perm: f
                    }), h = a22.transpose(e199, t126, d));
                    const m = l ? i34.ShapeUtil.sizeToDimension(c, u - 1) : i34.ShapeUtil.sizeToDimension(o, u - 1), b = l ? i34.ShapeUtil.sizeFromDimension(c, u - 1) : i34.ShapeUtil.sizeFromDimension(o, u - 1), y = p12(e199, l ? h : t126, n, m, b);
                    return l ? a22.transpose(e199, y, d) : y;
                };
                const p12 = (e, t, n, r, i)=>{
                    const o = d9(e, t[0], r, i, [
                        r
                    ]), s = e.run(Object.assign(Object.assign({}, u25), {
                        cacheHint: n.cacheKey,
                        get: ()=>o
                    }), t), a = f6(e, t[0], r, i, o.output.dims, [
                        r
                    ]), p = e.run(Object.assign(Object.assign({}, l20), {
                        cacheHint: n.cacheKey,
                        get: ()=>a
                    }), [
                        t[0],
                        s
                    ]), g = h5(e, t[0], r, i, o.output.dims, a.output.dims);
                    return [
                        e.run(Object.assign(Object.assign({}, c13), {
                            cacheHint: n.cacheKey,
                            get: ()=>g
                        }), [
                            t[0],
                            s,
                            p
                        ])
                    ];
                }, d9 = (e, t, n, r, i)=>{
                    const [a, l] = e.calculateTextureWidthAndHeight(t.dims, s24.TextureType.unpacked), c = i.length;
                    if (n < 1 || r < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (1 !== i.length) throw new Error("Dimensionality of the output should be 1");
                    if (i[0] !== n) throw new Error("Shape of the output should be equal to logical row count");
                    const p = o26.getGlsl(e.session.backend.glContext.version), d = `\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${a},\n        ${l} )));\n        for(int i=1; i<${r}; ++i)\n        {\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${a}, ${l})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;
                    return Object.assign(Object.assign({}, u25), {
                        output: {
                            dims: i,
                            type: t.type,
                            textureType: s24.TextureType.unpacked
                        },
                        shaderSource: d
                    });
                }, f6 = (e, t, n, r, i, a)=>{
                    const [u, c] = e.calculateTextureWidthAndHeight(t.dims, s24.TextureType.unpacked), p = a.length;
                    if (n < 1 || r < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (1 !== a.length) throw new Error("Dimensionality of the output should be 1");
                    if (a[0] !== n) throw new Error("Shape of the output should be equal to logical row count");
                    if (1 !== i.length) throw new Error("Dimensionality of the intermediate results should be 1");
                    if (i[0] !== n) throw new Error("Shape of the intermediate results should be equal to logical row count");
                    const d = `\n      float process(int[${p}] indices) {\n        int logical_row_start_offset = indices[0] * ${r};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${r}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${o26.getGlsl(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${u}, ${c}))) - max);\n        }\n\n        return norm_factor;\n      }`;
                    return Object.assign(Object.assign({}, l20), {
                        output: {
                            dims: a,
                            type: t.type,
                            textureType: s24.TextureType.unpacked
                        },
                        shaderSource: d
                    });
                }, h5 = (e, t, n, r, i, o)=>{
                    const [a, u] = e.calculateTextureWidthAndHeight(t.dims, s24.TextureType.unpacked), l = t.dims.length;
                    if (n < 1 || r < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (1 !== i.length || 1 !== o.length) throw new Error("Dimensionality of the intermediate results should be 1");
                    if (i[0] !== n || o[0] !== n) throw new Error("Shape of the intermediate results should be equal to logical row count");
                    const p = `\n      float process(int[${l}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${a}, ${u});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${r};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;
                    return Object.assign(Object.assign({}, c13), {
                        output: {
                            dims: t.dims,
                            type: t.type,
                            textureType: s24.TextureType.unpacked
                        },
                        shaderSource: p
                    });
                }, g3 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Softmax requires 1 input.");
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("Invalid input type");
                };
            },
            5975: (e200, t127, n99)=>{
                "use strict";
                Object.defineProperty(t127, "__esModule", {
                    value: !0
                }), t127.parseSplitAttributes = t127.split = void 0;
                const r57 = n99(246), i36 = n99(2517), o27 = n99(2039), s = {
                    name: "Split",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        o27.TextureType.unpacked
                    ]
                };
                t127.split = (e, t, n)=>{
                    l21(t);
                    const r = i36.ShapeUtil.normalizeAxis(n.axis, t[0].dims.length), o = a23(e, t, r, n), c = [];
                    for(let i35 = 0; i35 < o; ++i35)c.push(e.run(Object.assign(Object.assign({}, s), {
                        cacheHint: `${n.cacheKey};${i35}`,
                        get: ()=>u26(e, t[0], n, r, i35)
                    }), t));
                    return c;
                }, t127.parseSplitAttributes = (e)=>{
                    const t = e.attributes.getInt("axis", 0), n = e.attributes.getInts("split", []), i = e.outputs.length;
                    return r57.createAttributeWithCacheKey({
                        axis: t,
                        split: n,
                        numOutputs: i
                    });
                };
                const a23 = (e, t, n, r)=>{
                    const [, o] = i36.SplitUtil.splitShape(t[0].dims, n, r.split, r.numOutputs);
                    return o.length;
                }, u26 = (e, t, n, r, a)=>{
                    const [u, l] = i36.SplitUtil.splitShape(t.dims, r, n.split, n.numOutputs), c = l[a], p = u[a], d = `\n      float process(int indices[${p.length}]) {\n        indices[${r}] += ${c};\n        return _A(indices);\n      }\n    `;
                    return Object.assign(Object.assign({}, s), {
                        cacheHint: `${n.cacheKey}:${a}`,
                        output: {
                            dims: p,
                            type: t.type,
                            textureType: o27.TextureType.unpacked
                        },
                        shaderSource: d
                    });
                }, l21 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Split requires one input.");
                    if ("int8" !== e[0].type && "uint8" !== e[0].type && "int16" !== e[0].type && "uint16" !== e[0].type && "int32" !== e[0].type && "uint32" !== e[0].type && "float32" !== e[0].type && "float64" !== e[0].type && "bool" !== e[0].type) throw new Error("Invalid input type.");
                };
            },
            3933: (e201, t128, n100)=>{
                "use strict";
                Object.defineProperty(t128, "__esModule", {
                    value: !0
                }), t128.parseSqueezeAttributes = t128.squeezeV13 = t128.squeeze = void 0;
                const r = n100(2517);
                t128.squeeze = (e, t, n)=>{
                    i(t);
                    const o = r.ShapeUtil.squeezeShape(t[0].dims, n);
                    return [
                        e.reshapeUnpacked(t[0], o)
                    ];
                }, t128.squeezeV13 = (e, n)=>(o28(n), t128.squeeze(e, [
                        n[0]
                    ], Array.from(n[1].integerData)))
                , t128.parseSqueezeAttributes = (e)=>e.attributes.getInts("axes")
                ;
                const i = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Squeeze requires 1 input.");
                    if ("string" === e[0].type) throw new Error("invalid input tensor types.");
                }, o28 = (e)=>{
                    if (!e || 2 !== e.length) throw new Error("Squeeze requires 2 inputs.");
                    if ("int32" !== e[1].type) throw new Error("Invalid input type.");
                };
            },
            6558: (e202, t129, n101)=>{
                "use strict";
                Object.defineProperty(t129, "__esModule", {
                    value: !0
                }), t129.sum = void 0;
                const r58 = n101(5060), i = n101(2039);
                t129.sum = (e, t130)=>{
                    s25(t130);
                    const n = {
                        name: "Sum",
                        inputNames: t130.map((e, t)=>`X${t}`
                        ),
                        inputTypes: new Array(t130.length).fill(i.TextureType.unpacked)
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, n), {
                            get: ()=>o29(e, t130, n)
                        }), t130)
                    ];
                };
                const o29 = (e, t131, n)=>{
                    const o = r58.getGlsl(e.session.backend.glContext.version), s = t131[0].dims.slice(), a = `\n      void main() {\n        vec4 result = ${t131.map((e, t)=>`${o.texture2D}(X${t},TexCoords)`
                    ).join(" + ")};\n        ${o.output} = result;\n      }\n    `;
                    return Object.assign(Object.assign({}, n), {
                        output: {
                            dims: s,
                            type: t131[0].type,
                            textureType: i.TextureType.unpacked
                        },
                        hasMain: !0,
                        shaderSource: a
                    });
                }, s25 = (e)=>{
                    if (!e || 0 === e.length) throw new Error("Sum requires inputs.");
                    const t = e[0].dims.length;
                    for(let n = 1; n < e.length; n++){
                        if (t !== e[n].dims.length) throw new Error("Input shapes are mismatched.");
                        for(let r = 0; r < t; r++)if (e[0].dims[r] !== e[n].dims[r]) throw new Error("Input shapes are not matched.");
                    }
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("Invalid input type.");
                    for(let t132 = 1; t132 < e.length; t132++)if (e[0].type !== e[t132].type) throw new Error("Input types are not matched.");
                };
            },
            5723: (e203, t133, n102)=>{
                "use strict";
                Object.defineProperty(t133, "__esModule", {
                    value: !0
                }), t133.tile = void 0;
                const r59 = n102(782), i = n102(2039);
                t133.tile = (e, t)=>{
                    s26(t);
                    const n = {
                        name: "Tile",
                        inputNames: [
                            "A"
                        ],
                        inputTypes: [
                            i.TextureType.unpacked
                        ]
                    };
                    return [
                        e.run(Object.assign(Object.assign({}, n), {
                            get: ()=>o30(e, t, n)
                        }), t)
                    ];
                };
                const o30 = (e, t, n)=>{
                    const r = t[0].dims.slice(), o = new Array(r.length), s = [];
                    for(let e204 = 0; e204 < r.length; e204++)o[e204] = r[e204] * t[1].numberData[e204], s.push(`inputIdx[${e204}] = int(mod(float(outputIdx[${e204}]), ${r[e204]}.));`);
                    const a = o.length, u = `\n      float process(int outputIdx[${a}]) {\n        int inputIdx[${a}];\n        ${s.join("\n")}\n        return _A(inputIdx);\n      }\n    `;
                    return Object.assign(Object.assign({}, n), {
                        output: {
                            dims: o,
                            type: t[0].type,
                            textureType: i.TextureType.unpacked
                        },
                        shaderSource: u
                    });
                }, s26 = (e)=>{
                    if (!e || 2 !== e.length) throw new Error("Tile requires 2 input.");
                    if (1 !== e[1].dims.length) throw new Error("The second input shape must 1 dimension.");
                    if (e[1].dims[0] !== e[0].dims.length) throw new Error("Invalid input shape.");
                    if (-1 === r59.NUMBER_TYPES.indexOf(e[0].type)) throw new Error("Invalid input type.");
                    if ("int32" !== e[1].type && "int16" !== e[1].type) throw new Error("Invalid repeat type.");
                };
            },
            3738: (e205, t134, n103)=>{
                "use strict";
                Object.defineProperty(t134, "__esModule", {
                    value: !0
                }), t134.parseTransposeAttributes = t134.transpose = void 0;
                const r60 = n103(246), i37 = n103(2517), o = n103(2039), s = {
                    name: "Transpose",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        o.TextureType.unpacked
                    ]
                };
                t134.transpose = (e, t, n)=>(p13(t), [
                        e.run(Object.assign(Object.assign({}, s), {
                            cacheHint: n.cacheKey,
                            get: ()=>a24(e, t[0], n.perm)
                        }), t)
                    ])
                , t134.parseTransposeAttributes = (e)=>r60.createAttributeWithCacheKey({
                        perm: e.attributes.getInts("perm", [])
                    })
                ;
                const a24 = (e, t, n)=>{
                    const r = t.dims;
                    n = u(r, n);
                    const i = l(r, n), a = r.length, p = `\n      ${c("perm", n, a)}\n      float process(int indices[${a}]) {\n        int a[${a}];\n        perm(a, indices);\n        return _A(a);\n      }`;
                    return Object.assign(Object.assign({}, s), {
                        output: {
                            dims: i,
                            type: t.type,
                            textureType: o.TextureType.unpacked
                        },
                        shaderSource: p
                    });
                }, u = (e, t)=>(t && t.length !== e.length && (t = [
                        ...e.keys()
                    ].reverse()), t)
                , l = (e, t)=>(t = u(e, t), i37.ShapeUtil.sortBasedOnPerm(e, t))
                , c = (e, t, n)=>{
                    const r = [];
                    r.push(`void ${e}(out int a[${n}], int src[${n}]) {`);
                    for(let e206 = 0; e206 < n; ++e206)r.push(`\ta[${t[e206]}]=src[${e206}];`);
                    return r.push("\t}"), r.join("\n");
                }, p13 = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Transpose requires 1 input.");
                    if ("float32" !== e[0].type && "float64" !== e[0].type) throw new Error("input should be float tensor");
                };
            },
            8710: (e207, t135, n104)=>{
                "use strict";
                Object.defineProperty(t135, "__esModule", {
                    value: !0
                }), t135.encodeAsUint8 = void 0;
                const r = n104(5060), i = n104(2039);
                t135.encodeAsUint8 = (e, t)=>{
                    const n = t.shape, o = r.getGlsl(e.session.backend.glContext.version), s = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${o.texture2D}(X,TexCoords).r;\n      ${o.output} = encodeAsUint8(value);\n    }`, a = {
                        name: "Uint8Encode",
                        inputTypes: [
                            i.TextureType.unpacked
                        ],
                        inputNames: [
                            "X"
                        ],
                        output: {
                            dims: n,
                            type: t.tensor.type,
                            textureType: i.TextureType.downloadUint8AsFloat
                        },
                        shaderSource: s,
                        hasMain: !0
                    };
                    return e.executeProgram(a, [
                        t.tensor
                    ]);
                };
            },
            4909: (e208, t136, n105)=>{
                "use strict";
                Object.defineProperty(t136, "__esModule", {
                    value: !0
                }), t136.tanh = t136.tan = t136.sqrt = t136.sin = t136.sigmoid = t136.relu = t136.not = t136.neg = t136.log = t136.parseLeakyReluAttributes = t136.leakyRelu = t136.identity = t136.floor = t136.exp = t136.parseEluAttributes = t136.elu = t136.cos = t136.ceil = t136.clipV11 = t136.parseClipAttributes = t136.clip = t136.atan = t136.asin = t136.acos = t136.abs = t136.glslTanh = t136.glslTan = t136.glslSqrt = t136.glslSigmoid = t136.glslRelu = t136.glslSin = t136.glslNot = t136.glslNeg = t136.glslLog = t136.glslLeakyRelu = t136.glslIdentity = t136.glslClip = t136.glslFloor = t136.glslExp = t136.glslElu = t136.glslCos = t136.glslCeil = t136.glslAtan = t136.glslAsin = t136.glslAcos = t136.glslAbs = void 0;
                const r61 = n105(246), i38 = n105(2517), o31 = n105(8520), s = n105(5060), a = n105(2039);
                function u() {
                    return D("abs");
                }
                function l() {
                    return D("acos");
                }
                function c() {
                    return D("asin");
                }
                function p() {
                    return D("atan");
                }
                function d() {
                    return D("ceil");
                }
                function f() {
                    return D("cos");
                }
                function h(e) {
                    return {
                        body: `\n  const float alpha = float(${e});\n\n  float elu_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 elu_(vec4 v) {\n    return vec4(elu_(v.x), elu_(v.y), elu_(v.z), elu_(v.w));\n  }\n  `,
                        name: "elu",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function g() {
                    return D("exp");
                }
                function m() {
                    return D("floor");
                }
                function b(e, t) {
                    return {
                        body: `\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float clip_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 clip_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,
                        name: "clip",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function y() {
                    const e = "indentity";
                    return {
                        body: `\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,
                        name: e,
                        type: o31.FunctionType.ValueBased
                    };
                }
                function _(e) {
                    const t = "leakyRelu";
                    return {
                        body: `\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,
                        name: t,
                        type: o31.FunctionType.ValueBased
                    };
                }
                function v() {
                    return D("log");
                }
                function w() {
                    return {
                        body: "\n  float neg_(float a) {\n    return -a;\n  }\n  vec4 neg_(vec4 v) {\n    return -v;\n  }\n  ",
                        name: "neg",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function x() {
                    return {
                        body: "\n  float not_(float a) {\n    return float( ! bool(a) );\n  }\n  bool not_(bool a) {\n    return !a;\n  }\n  vec4 not_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 not_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  ",
                        name: "not",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function T() {
                    return D("sin");
                }
                function O() {
                    return {
                        body: "\n  float relu_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 relu_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  ",
                        name: "relu",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function S() {
                    return {
                        body: "\n  float sigmoid_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 sigmoid_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  ",
                        name: "sigmoid",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function A() {
                    return D("sqrt");
                }
                function E() {
                    return D("tan");
                }
                function I() {
                    return {
                        body: "\n  float tanh_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 tanh_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  ",
                        name: "tanh",
                        type: o31.FunctionType.ValueBased
                    };
                }
                function D(e) {
                    return {
                        body: `\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,
                        name: e,
                        type: o31.FunctionType.ValueBased
                    };
                }
                t136.glslAbs = u, t136.glslAcos = l, t136.glslAsin = c, t136.glslAtan = p, t136.glslCeil = d, t136.glslCos = f, t136.glslElu = h, t136.glslExp = g, t136.glslFloor = m, t136.glslClip = b, t136.glslIdentity = y, t136.glslLeakyRelu = _, t136.glslLog = v, t136.glslNeg = w, t136.glslNot = x, t136.glslSin = T, t136.glslRelu = O, t136.glslSigmoid = S, t136.glslSqrt = A, t136.glslTan = E, t136.glslTanh = I;
                const P = (e209, t137, n106, r62)=>{
                    const i39 = e209.session.pack ? a.TextureType.packed : a.TextureType.unpacked, o32 = {
                        name: n106.name,
                        inputTypes: [
                            i39
                        ],
                        inputNames: [
                            "A"
                        ],
                        cacheHint: r62
                    };
                    return Object.assign(Object.assign({}, o32), {
                        get: ()=>((e, t, n, r)=>{
                                const i = e.session.pack ? a.TextureType.packed : a.TextureType.unpacked, o = s.getGlsl(e.session.backend.glContext.version);
                                return Object.assign(Object.assign({}, t), {
                                    output: {
                                        dims: n.dims,
                                        type: n.type,
                                        textureType: i
                                    },
                                    shaderSource: `\n     ${r.body}\n     void main() {\n       vec4 v = ${o.texture2D}(A, TexCoords);\n       v = ${r.name}_(v);\n       ${o.output} = v;\n     }\n     `,
                                    hasMain: !0
                                });
                            })(e209, o32, t137, n106)
                    });
                };
                t136.abs = (e, t)=>[
                        e.run(P(e, t[0], u()), t)
                    ]
                , t136.acos = (e, t)=>[
                        e.run(P(e, t[0], l()), t)
                    ]
                , t136.asin = (e, t)=>[
                        e.run(P(e, t[0], c()), t)
                    ]
                , t136.atan = (e, t)=>[
                        e.run(P(e, t[0], p()), t)
                    ]
                , t136.clip = (e, t, n)=>[
                        e.run(P(e, t[0], b(n.min, n.max), n.cacheKey), t)
                    ]
                , t136.parseClipAttributes = (e)=>r61.createAttributeWithCacheKey({
                        min: e.attributes.getFloat("min", i38.MIN_CLIP),
                        max: e.attributes.getFloat("max", i38.MAX_CLIP)
                    })
                , t136.clipV11 = (e, n)=>{
                    const r = $(e, n);
                    return t136.clip(e, [
                        n[0]
                    ], r);
                };
                const $ = (e, t)=>{
                    if (t.length >= 3 && (!e.session.isInitializer(t[1].dataId) || !e.session.isInitializer(t[2].dataId))) throw new Error("dynamic clip attributes are not allowed");
                    const n = t.length >= 3 ? t[1].numberData[0] : i38.MIN_CLIP, o = t.length >= 3 ? t[2].numberData[0] : i38.MAX_CLIP;
                    return r61.createAttributeWithCacheKey({
                        min: n,
                        max: o
                    });
                };
                t136.ceil = (e, t)=>[
                        e.run(P(e, t[0], d()), t)
                    ]
                , t136.cos = (e, t)=>[
                        e.run(P(e, t[0], f()), t)
                    ]
                , t136.elu = (e, t, n)=>[
                        e.run(P(e, t[0], h(n.alpha), n.cacheKey), t)
                    ]
                , t136.parseEluAttributes = (e)=>r61.createAttributeWithCacheKey({
                        alpha: e.attributes.getFloat("alpha", 1)
                    })
                , t136.exp = (e, t)=>[
                        e.run(P(e, t[0], g()), t)
                    ]
                , t136.floor = (e, t)=>[
                        e.run(P(e, t[0], m()), t)
                    ]
                , t136.identity = (e, t)=>[
                        e.run(P(e, t[0], y()), t)
                    ]
                , t136.leakyRelu = (e, t, n)=>[
                        e.run(P(e, t[0], _(n.alpha), n.cacheKey), t)
                    ]
                , t136.parseLeakyReluAttributes = (e)=>r61.createAttributeWithCacheKey({
                        alpha: e.attributes.getFloat("alpha", .01)
                    })
                , t136.log = (e, t)=>[
                        e.run(P(e, t[0], v()), t)
                    ]
                , t136.neg = (e, t)=>[
                        e.run(P(e, t[0], w()), t)
                    ]
                , t136.not = (e, t)=>[
                        e.run(P(e, t[0], x()), t)
                    ]
                , t136.relu = (e, t)=>[
                        e.run(P(e, t[0], O()), t)
                    ]
                , t136.sigmoid = (e, t)=>[
                        e.run(P(e, t[0], S()), t)
                    ]
                , t136.sin = (e, t)=>[
                        e.run(P(e, t[0], T()), t)
                    ]
                , t136.sqrt = (e, t)=>[
                        e.run(P(e, t[0], A()), t)
                    ]
                , t136.tan = (e, t)=>[
                        e.run(P(e, t[0], E()), t)
                    ]
                , t136.tanh = (e, t)=>[
                        e.run(P(e, t[0], I()), t)
                    ]
                ;
            },
            5611: (e210, t138, n107)=>{
                "use strict";
                Object.defineProperty(t138, "__esModule", {
                    value: !0
                }), t138.createUnpackProgramInfoLoader = t138.createUnpackProgramInfo = void 0;
                const r63 = n107(5060), i = n107(2039), o = n107(9390), s = n107(2827), a = {
                    name: "unpack",
                    inputNames: [
                        "A"
                    ],
                    inputTypes: [
                        i.TextureType.packed
                    ]
                };
                t138.createUnpackProgramInfo = (e211, t139)=>{
                    const n108 = t139.dims.length, u = s.getChannels("rc", n108), l = u.slice(-2), c = o.getCoordsDataType(n108), p = s.unpackFromChannel(), d = 0 === t139.dims.length ? "" : function(e, t) {
                        if (1 === e) return "rc";
                        let n = "";
                        for(let r = 0; r < e; r++)n += t[r], r < e - 1 && (n += ",");
                        return n;
                    }(n108, u), f = n108 <= 1 ? "rc" : `vec2(${l.join(",")})`, h = `\n    ${p}\n    void main() {\n      ${c} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${d});\n\n       ${r63.getGlsl(e211.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);\n     }\n   `;
                    return Object.assign(Object.assign({}, a), {
                        hasMain: !0,
                        output: {
                            dims: t139.dims,
                            type: t139.type,
                            textureType: i.TextureType.unpacked
                        },
                        shaderSource: h
                    });
                }, t138.createUnpackProgramInfoLoader = (e, n)=>Object.assign(Object.assign({}, a), {
                        get: ()=>t138.createUnpackProgramInfo(e, n)
                    })
                ;
            },
            8428: (e212, t140, n109)=>{
                "use strict";
                Object.defineProperty(t140, "__esModule", {
                    value: !0
                }), t140.parseUnsqueezeAttributes = t140.unsqueezeV13 = t140.unsqueeze = void 0;
                const r = n109(2517);
                t140.unsqueeze = (e, t, n)=>{
                    i(t);
                    const o = r.ShapeUtil.unsqueezeShape(t[0].dims, n);
                    return [
                        e.reshapeUnpacked(t[0], o)
                    ];
                }, t140.unsqueezeV13 = (e, n)=>(o33(n), t140.unsqueeze(e, [
                        n[0]
                    ], Array.from(n[1].integerData)))
                , t140.parseUnsqueezeAttributes = (e)=>e.attributes.getInts("axes")
                ;
                const i = (e)=>{
                    if (!e || 1 !== e.length) throw new Error("Unsqueeze requires 1 input.");
                    if ("string" === e[0].type) throw new Error("invalid input tensor types.");
                }, o33 = (e)=>{
                    if (!e || 2 !== e.length) throw new Error("Unsqueeze requires 2 inputs.");
                    if ("int32" !== e[1].type) throw new Error("Invalid input type.");
                };
            },
            9793: (e213, t141, n110)=>{
                "use strict";
                Object.defineProperty(t141, "__esModule", {
                    value: !0
                }), t141.scalesValidation = t141.validateInputs = t141.parseUpsampleAttributes = t141.parseUpsampleAttributesV9 = t141.parseUpsampleAttributesV7 = t141.upsample = void 0;
                const r64 = n110(246), i40 = n110(5060), o34 = n110(2039), s27 = {
                    name: "Upsample",
                    inputNames: [
                        "X"
                    ],
                    inputTypes: [
                        o34.TextureType.unpacked
                    ]
                };
                t141.upsample = (e, n, r)=>(t141.validateInputs(n, r), [
                        e.run(Object.assign(Object.assign({}, s27), {
                            cacheHint: r.cacheKey,
                            get: ()=>a25(e, n, r)
                        }), n)
                    ])
                , t141.parseUpsampleAttributesV7 = (e)=>t141.parseUpsampleAttributes(e, 7)
                , t141.parseUpsampleAttributesV9 = (e)=>t141.parseUpsampleAttributes(e, 9)
                , t141.parseUpsampleAttributes = (e, n)=>{
                    const i = n >= 10, o = e.attributes.getString("mode", "nearest");
                    if ("nearest" !== o && "linear" !== o && (n < 11 || "cubic" !== o)) throw new Error(`unrecognized mode: ${o}`);
                    let s = [];
                    n < 9 && (s = e.attributes.getFloats("scales"), t141.scalesValidation(s, o, i));
                    const a = e.attributes.getFloat("extrapolation_value", 0), u = n > 10 ? e.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
                    if (-1 === [
                        "asymmetric",
                        "pytorch_half_pixel",
                        "tf_half_pixel_for_nn",
                        "align_corners",
                        "tf_crop_and_resize",
                        "half_pixel"
                    ].indexOf(u)) throw new Error(`coordinate_transform_mode '${u}' is not supported`);
                    const l = "tf_crop_and_resize" === u, c = l, p = "nearest" === o && n >= 11 ? e.attributes.getString("nearest_mode", "round_prefer_floor") : "";
                    if (-1 === [
                        "round_prefer_floor",
                        "round_prefer_ceil",
                        "floor",
                        "ceil",
                        ""
                    ].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);
                    const d = e.attributes.getFloat("cubic_coeff_a", -0.75), f = 0 !== e.attributes.getInt("exclude_outside", 0);
                    if (f && "cubic" !== o) throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
                    const h = n < 11 || "nearest" === o && "asymmetric" === u && "floor" === p;
                    let g = 0, m = 0, b = 0;
                    return n > 10 ? (g = 1, m = 2, b = 3) : 9 === n && (m = 1), r64.createAttributeWithCacheKey({
                        opset: n,
                        isResize: i,
                        mode: o,
                        scales: s,
                        extrapolationValue: a,
                        coordinateTransformMode: u,
                        useExtrapolation: c,
                        needRoiInput: l,
                        nearestMode: p,
                        cubicCoefficientA: d,
                        excludeOutside: f,
                        useNearest2xOptimization: h,
                        roiInputIdx: g,
                        scalesInputIdx: m,
                        sizesInputIdx: b
                    });
                };
                const a25 = (e215, t142, n)=>{
                    const r = i40.getGlsl(e215.session.backend.glContext.version), [a, u] = e215.calculateTextureWidthAndHeight(t142[0].dims, o34.TextureType.unpacked), l = t142[0].dims.map((e, t)=>Math.floor(e * n.scales[t])
                    ), [c, p] = e215.calculateTextureWidthAndHeight(l, o34.TextureType.unpacked), d = l.length, f = new Array(d), h = new Array(d);
                    let g = `\n      int output_pitches[${d}];\n      int input_pitches[${d}];\n      `;
                    for(let e214 = d - 1; e214 >= 0; e214--)f[e214] = e214 === d - 1 ? 1 : f[e214 + 1] * l[e214 + 1], h[e214] = e214 === d - 1 ? 1 : h[e214 + 1] * t142[0].dims[e214 + 1], g += `\n        output_pitches[${e214}] = ${f[e214]};\n        input_pitches[${e214}] = ${h[e214]};\n        `;
                    const m = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${a}, ${u});\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\n        return value;\n      }\n      `, b = "nearest" === n.mode ? `\n    ${m}\n    float process(int indices[${d}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int d, m;\n      for (int dim = 0; dim < ${d}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }` : 4 === d ? `\n    ${m}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t142[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }` : `\n    ${m}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${c}, ${p});\n\n      ${g}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t142[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;
                    return Object.assign(Object.assign({}, s27), {
                        output: {
                            dims: l,
                            type: t142[0].type,
                            textureType: o34.TextureType.unpacked
                        },
                        shaderSource: b,
                        variables: [
                            {
                                name: "scales",
                                type: "int",
                                arrayLength: n.scales.length,
                                data: n.scales.map((e)=>Math.ceil(e)
                                )
                            }
                        ]
                    });
                };
                t141.validateInputs = (e, t)=>{
                    if (!e || t.opset < 9 && 1 !== e.length || t.opset >= 9 && t.opset < 11 && 2 !== e.length || t.opset >= 11 && 3 !== e.length && 4 !== e.length) throw new Error("invalid inputs.");
                    if (t.scales.length > 0 && e[0].dims.length !== t.scales.length) throw new Error("Invalid input shape.");
                    if ("string" === e[0].type) throw new Error("Invalid input tensor types.");
                }, t141.scalesValidation = (e, t, n)=>{
                    if (n) {
                        for (const t of e)if (t <= 0) throw new Error("Scale value should be greater than 0.");
                    } else for (const t143 of e)if (t143 < 1) throw new Error("Scale value should be greater than or equal to 1.");
                    if (!("linear" !== t && "cubic" !== t || 2 === e.length || 4 === e.length && 1 === e[0] && 1 === e[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n ? "Resize" : "Upsample"} opeartor.`);
                };
            },
            1958: (e216, t144, n111)=>{
                "use strict";
                Object.defineProperty(t144, "__esModule", {
                    value: !0
                }), t144.ProgramManager = void 0;
                const r65 = n111(2174), i41 = n111(6231), o35 = n111(8879), s28 = n111(5060);
                t144.ProgramManager = class {
                    constructor(e, t, n){
                        this.profiler = e, this.glContext = t, this.textureLayoutStrategy = n, this.repo = new Map, this.attributesBound = !1;
                    }
                    getArtifact(e) {
                        return this.repo.get(e);
                    }
                    setArtifact(e, t) {
                        this.repo.set(e, t);
                    }
                    run(e, t145, n) {
                        var r66;
                        this.profiler.event("op", `ProgramManager.run ${null !== (r66 = e.programInfo.name) && void 0 !== r66 ? r66 : "unknown kernel"}`, ()=>{
                            var r;
                            const o = this.glContext.gl, s = e.program;
                            o.useProgram(s);
                            try {
                                this.bindOutput(n), this.attributesBound || this.bindAttributes(e.attribLocations), this.bindUniforms(e.uniformLocations, null !== (r = e.programInfo.variables) && void 0 !== r ? r : [], t145);
                            } catch (t) {
                                throw i41.Logger.error("ProgramManager", e.programInfo.shaderSource), t;
                            }
                            this.profiler.event("backend", "GlContext.draw()", ()=>{
                                this.glContext.draw();
                            });
                        }, this.glContext);
                    }
                    dispose() {
                        this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((e)=>this.glContext.deleteProgram(e.program)
                        );
                    }
                    build(e, t, n) {
                        return this.profiler.event("backend", "ProgramManager.build", ()=>{
                            const r = new o35.GlslPreprocessor(this.glContext, e, t, n), i = r.preprocess(), s = this.compile(i);
                            return {
                                programInfo: e,
                                program: s,
                                uniformLocations: this.getUniformLocations(s, r.context.programInfo.inputNames, r.context.programInfo.variables),
                                attribLocations: this.getAttribLocations(s)
                            };
                        });
                    }
                    compile(e) {
                        if (!this.vertexShader) {
                            i41.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                            const e = s28.getVertexShaderSource(this.glContext.version);
                            this.vertexShader = this.glContext.compileShader(e, this.glContext.gl.VERTEX_SHADER);
                        }
                        r65.env.debug && i41.Logger.verbose("ProrgramManager", `FragShader:\n${e}\n`);
                        const t = this.glContext.compileShader(e, this.glContext.gl.FRAGMENT_SHADER), n = this.glContext.createProgram(this.vertexShader, t);
                        return this.glContext.deleteShader(t), n;
                    }
                    bindOutput(e) {
                        const t = e.width, n = e.height;
                        i41.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${t}/${n}, shape=${e.shape}, type=${e.tensor.type}`), this.glContext.attachFramebuffer(e.texture, t, n);
                    }
                    bindAttributes(e) {
                        const t = e.position, n = e.textureCoord;
                        this.glContext.setVertexAttributes(t, n), this.attributesBound = !0;
                    }
                    bindUniforms(e, t, n) {
                        var r;
                        const i = this.glContext.gl;
                        let o = 0;
                        for (const { name: s , type: a , location: u , arrayLength: l  } of e){
                            const e217 = null === (r = t.find((e)=>e.name === s
                            )) || void 0 === r ? void 0 : r.data;
                            if ("sampler2D" !== a && !e217) throw new Error(`variable '${s}' does not have data defined in program info`);
                            switch(a){
                                case "sampler2D":
                                    this.bindTexture(n[o], u, o), o++;
                                    break;
                                case "float":
                                    l ? i.uniform1fv(u, e217) : i.uniform1f(u, e217);
                                    break;
                                case "int":
                                    l ? i.uniform1iv(u, e217) : i.uniform1i(u, e217);
                                    break;
                                default:
                                    throw new Error(`Uniform not implemented: ${a}`);
                            }
                        }
                    }
                    bindTexture(e, t, n) {
                        this.glContext.bindTextureToUniform(e.texture, n, t);
                    }
                    getAttribLocations(e) {
                        return {
                            position: this.getAttribLocation(e, "position"),
                            textureCoord: this.getAttribLocation(e, "textureCoord")
                        };
                    }
                    getUniformLocations(e, t, n) {
                        const r = [];
                        if (t) for (const n112 of t)r.push({
                            name: n112,
                            type: "sampler2D",
                            location: this.getUniformLocation(e, n112)
                        });
                        if (n) for (const t146 of n)r.push(Object.assign(Object.assign({}, t146), {
                            location: this.getUniformLocation(e, t146.name)
                        }));
                        return r;
                    }
                    getUniformLocation(e, t) {
                        const n = this.glContext.gl.getUniformLocation(e, t);
                        if (null === n) throw new Error(`Uniform ${t} not found.`);
                        return n;
                    }
                    getAttribLocation(e, t) {
                        return this.glContext.gl.getAttribLocation(e, t);
                    }
                };
            },
            6416: (e218, t147, n113)=>{
                "use strict";
                Object.defineProperty(t147, "__esModule", {
                    value: !0
                }), t147.WebGLSessionHandler = void 0;
                const r67 = n113(6231), i = n113(1047), o = n113(8316), s = n113(1640), a = n113(1958), u = n113(7859), l = n113(5702);
                t147.WebGLSessionHandler = class {
                    constructor(e, t){
                        this.backend = e, this.context = t, this.layoutStrategy = new u.PreferLogicalStrategy(e.glContext.maxTextureSize), this.programManager = new a.ProgramManager(this.context.profiler, e.glContext, this.layoutStrategy), this.textureManager = new l.TextureManager(e.glContext, this.layoutStrategy, this.context.profiler, {
                            reuseTextures: "full" === e.textureCacheMode
                        }), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map, this.pack = e.pack, this.pack2unpackMap = new Map, this.unpack2packMap = new Map;
                    }
                    createInferenceHandler() {
                        return new o.WebGLInferenceHandler(this);
                    }
                    onGraphInitialized(e219) {
                        const t = e219.getValues().filter((e)=>-1 === e.from && e.tensor
                        ).map((e)=>e.tensor.dataId
                        );
                        this.initializers = new Set(t);
                    }
                    isInitializer(e) {
                        return !!this.initializers && this.initializers.has(e);
                    }
                    addInitializer(e) {
                        this.initializers.add(e);
                    }
                    getTextureData(e, t) {
                        return t ? this.packedTextureDataCache.get(e) : this.unpackedTextureDataCache.get(e);
                    }
                    setTextureData(e, t, n = !1) {
                        r67.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n ? this.packedTextureDataCache.set(e, t) : this.unpackedTextureDataCache.set(e, t);
                    }
                    dispose() {
                        this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e)=>this.textureManager.releaseTexture(e, !0)
                        ), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((e)=>this.textureManager.releaseTexture(e, !0)
                        ), this.unpackedTextureDataCache = new Map;
                    }
                    resolve(e, t, n) {
                        const r = i.resolveOperator(e, t, s.WEBGL_OP_RESOLVE_RULES);
                        return {
                            impl: r.opImpl,
                            context: r.opInit ? r.opInit(e, n) : e
                        };
                    }
                };
            },
            7769: (e220, t148, n114)=>{
                "use strict";
                Object.defineProperty(t148, "__esModule", {
                    value: !0
                }), t148.Uint8DataEncoder = t148.RGBAFloatDataEncoder = t148.RedFloat32DataEncoder = void 0;
                const r = n114(6231);
                t148.RedFloat32DataEncoder = class {
                    constructor(e, t = 1){
                        if (1 === t) this.internalFormat = e.R32F, this.format = e.RED, this.textureType = e.FLOAT, this.channelSize = t;
                        else {
                            if (4 !== t) throw new Error(`Invalid number of channels: ${t}`);
                            this.internalFormat = e.RGBA32F, this.format = e.RGBA, this.textureType = e.FLOAT, this.channelSize = t;
                        }
                    }
                    encode(e221, t149) {
                        let n, i;
                        return e221.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(e221)), t149 * this.channelSize > e221.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = e221, n = this.allocate(t149 * this.channelSize), i.forEach((e, t)=>n[t] = e
                        )) : (i = e221, n = i), n;
                    }
                    allocate(e) {
                        return new Float32Array(4 * e);
                    }
                    decode(e, t150) {
                        return 1 === this.channelSize ? e.filter((e, t)=>t % 4 == 0
                        ).subarray(0, t150) : e.subarray(0, t150);
                    }
                }, t148.RGBAFloatDataEncoder = class {
                    constructor(e, t = 1, n){
                        if (1 !== t && 4 !== t) throw new Error(`Invalid number of channels: ${t}`);
                        this.internalFormat = e.RGBA, this.format = e.RGBA, this.channelSize = t, this.textureType = n || e.FLOAT;
                    }
                    encode(e222, t151) {
                        let n = e222;
                        return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n = this.allocate(t151), e222.forEach((e, t)=>n[4 * t] = e
                        )), n;
                    }
                    allocate(e) {
                        return new Float32Array(4 * e);
                    }
                    decode(e, t152) {
                        return 1 === this.channelSize ? e.filter((e, t)=>t % 4 == 0
                        ).subarray(0, t152) : e.subarray(0, t152);
                    }
                }, t148.Uint8DataEncoder = class {
                    constructor(e, t = 1){
                        if (this.channelSize = 4, 1 === t) this.internalFormat = e.ALPHA, this.format = e.ALPHA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = t;
                        else {
                            if (4 !== t) throw new Error(`Invalid number of channels: ${t}`);
                            this.internalFormat = e.RGBA, this.format = e.RGBA, this.textureType = e.UNSIGNED_BYTE, this.channelSize = t;
                        }
                    }
                    encode(e, t) {
                        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
                    }
                    allocate(e) {
                        return new Uint8Array(e * this.channelSize);
                    }
                    decode(e, t) {
                        if (e instanceof Uint8Array) return e.subarray(0, t);
                        throw new Error(`Invalid array type: ${e.constructor}`);
                    }
                };
            },
            7859: (e223, t154, n115)=>{
                "use strict";
                Object.defineProperty(t154, "__esModule", {
                    value: !0
                }), t154.getBatchDim = t154.sizeToSquarishShape = t154.getRowsCols = t154.sizeFromShape = t154.isInt = t154.parseAxisParam = t154.squeezeShape = t154.PreferLogicalStrategy = t154.AlwaysKeepOriginalSizeStrategy = void 0;
                const r68 = n115(6231), i42 = n115(2517);
                function o36(e, t) {
                    const n = [], r = [], i = null != t && Array.isArray(t) && 0 === t.length, o = null == t || i ? null : s29(t, e).sort();
                    let a = 0;
                    for(let t153 = 0; t153 < e.length; ++t153){
                        if (null != o) {
                            if (o[a] === t153 && 1 !== e[t153]) throw new Error(`Can't squeeze axis ${t153} since its dim '${e[t153]}' is not 1`);
                            (null == o[a] || o[a] > t153) && 1 === e[t153] && (n.push(e[t153]), r.push(t153)), o[a] <= t153 && a++;
                        }
                        1 !== e[t153] && (n.push(e[t153]), r.push(t153));
                    }
                    return {
                        newShape: n,
                        keptDims: r
                    };
                }
                function s29(e224, t155) {
                    const n = t155.length;
                    return e224 = null == e224 ? t155.map((e, t)=>t
                    ) : [].concat(e224), i42.assert(e224.every((e)=>e >= -n && e < n
                    ), ()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e224}`
                    ), i42.assert(e224.every(a26), ()=>`All values in axis param must be integers but got axis ${e224}`
                    ), e224.map((e)=>e < 0 ? n + e : e
                    );
                }
                function a26(e) {
                    return e % 1 == 0;
                }
                function u(e) {
                    if (0 === e.length) return 1;
                    let t = e[0];
                    for(let n = 1; n < e.length; n++)t *= e[n];
                    return t;
                }
                function l(e) {
                    const t = Math.ceil(Math.sqrt(e));
                    return [
                        t,
                        Math.ceil(e / t)
                    ];
                }
                t154.AlwaysKeepOriginalSizeStrategy = class {
                    constructor(e){
                        this.maxTextureSize = e;
                    }
                    computeTextureWH(e225, t156) {
                        if (0 === e225.length) return [
                            1,
                            1
                        ];
                        const n = this.maxTextureSize;
                        if (t156 && void 0 !== t156.breakAxis) {
                            const i = t156.breakAxis >= e225.length ? 1 : e225.slice(t156.breakAxis).reduce((e, t)=>e * t
                            ), o = t156.breakAxis <= 0 ? 1 : e225.slice(0, t156.breakAxis).reduce((e, t)=>e * t
                            );
                            if (!(i > n || o > n)) return [
                                i,
                                o
                            ];
                            r68.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e225}, breakAxis:${t156.breakAxis}`);
                        }
                        const i = e225.reduce((e, t)=>e * t
                        );
                        let o = Math.floor(Math.sqrt(i));
                        for(; o < n && o < i && i % o != 0; o++);
                        if (o >= n || i % o != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${e225}`);
                        return [
                            o,
                            i / o
                        ];
                    }
                }, t154.PreferLogicalStrategy = class {
                    constructor(e){
                        this.maxTextureSize = e;
                    }
                    computeTextureWH(e, t) {
                        const n = this.computeTexture(e, t);
                        return t && t.isPacked && (n[0] /= 2, n[1] /= 2), t && t.reverseWH ? [
                            n[1],
                            n[0]
                        ] : n;
                    }
                    computeTexture(e226, t157) {
                        const n = t157 && t157.isPacked;
                        if (0 === e226.length) return n ? [
                            2,
                            2
                        ] : [
                            1,
                            1
                        ];
                        let i = this.maxTextureSize;
                        if (t157 && void 0 !== t157.breakAxis) {
                            const n = t157.breakAxis >= e226.length ? 1 : e226.slice(t157.breakAxis).reduce((e, t)=>e * t
                            ), o = t157.breakAxis <= 0 ? 1 : e226.slice(0, t157.breakAxis).reduce((e, t)=>e * t
                            );
                            if (!(n > i || o > i)) return [
                                n,
                                o
                            ];
                            r68.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e226}, breakAxis:${t157.breakAxis}`);
                        }
                        let s = e226.slice(0);
                        if (n && (i *= 2, s = s.map((e, t)=>t >= s.length - 2 ? s[t] % 2 == 0 ? s[t] : s[t] + 1 : s[t]
                        ), 1 === s.length && (s = [
                            2,
                            s[0]
                        ])), 2 !== s.length) {
                            const e = o36(s);
                            s = e.newShape;
                        }
                        const a = u(s);
                        return s.length <= 1 && a <= i ? [
                            1,
                            a
                        ] : 2 === s.length && s[0] <= i && s[1] <= i ? s : 3 === s.length && s[0] * s[1] <= i && s[2] <= i ? [
                            s[0] * s[1],
                            s[2]
                        ] : 3 === s.length && s[0] <= i && s[1] * s[2] <= i ? [
                            s[0],
                            s[1] * s[2]
                        ] : 4 === s.length && s[0] * s[1] * s[2] <= i && s[3] <= i ? [
                            s[0] * s[1] * s[2],
                            s[3]
                        ] : 4 === s.length && s[0] <= i && s[1] * s[2] * s[3] <= i ? [
                            s[0],
                            s[1] * s[2] * s[3]
                        ] : n ? l(a / 4).map((e)=>2 * e
                        ) : l(a);
                    }
                }, t154.squeezeShape = o36, t154.parseAxisParam = s29, t154.isInt = a26, t154.sizeFromShape = u, t154.getRowsCols = function(e) {
                    if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
                    return [
                        e.length > 1 ? e[e.length - 2] : 1,
                        e[e.length - 1]
                    ];
                }, t154.sizeToSquarishShape = l, t154.getBatchDim = function(e, t = 2) {
                    return u(e.slice(0, e.length - t));
                };
            },
            4057: (e227, t158, n116)=>{
                "use strict";
                Object.defineProperty(t158, "__esModule", {
                    value: !0
                }), t158.createTextureLayoutFromShape = t158.calculateTextureWidthAndHeight = t158.createTextureLayoutFromTextureType = void 0;
                const r69 = n116(2517), i43 = n116(2039);
                t158.createTextureLayoutFromTextureType = (e228, n, r)=>{
                    const o = r === i43.TextureType.unpacked || r === i43.TextureType.unpackedReversed ? 1 : 4, s = r === i43.TextureType.packed, a = r === i43.TextureType.unpackedReversed || r === i43.TextureType.packed, u = r === i43.TextureType.packedLastDimension ? n.length - 1 : void 0, l = r === i43.TextureType.packedLastDimension ? n.map((e, t)=>t === n.length - 1 ? 4 * e : e
                    ) : void 0;
                    return t158.createTextureLayoutFromShape(e228, n, o, l, {
                        isPacked: s,
                        reverseWH: a,
                        breakAxis: u
                    });
                }, t158.calculateTextureWidthAndHeight = (e, n, r)=>{
                    const i = t158.createTextureLayoutFromTextureType(e, n, r);
                    return [
                        i.width,
                        i.height
                    ];
                }, t158.createTextureLayoutFromShape = (e, t, n = 1, i, o)=>{
                    const s = !(!o || !o.isPacked), [a, u] = e.computeTextureWH(s && i || t, o), l = t.length;
                    let c = t.slice(0);
                    if (0 === l && (c = [
                        1
                    ]), 1 === n) i = t;
                    else if (s) {
                        if (4 !== n) throw new Error("a packed texture must be 4-channel");
                        i = t, l > 0 && (c[l - 1] = Math.ceil(c[l - 1] / 2)), l > 1 && (c[l - 2] = Math.ceil(c[l - 2] / 2));
                    } else if (!i) throw new Error("Unpacked shape is needed when using channels > 1");
                    return {
                        width: a,
                        height: u,
                        channels: n,
                        isPacked: s,
                        shape: c,
                        strides: r69.ShapeUtil.computeStrides(c),
                        unpackedShape: i,
                        reversedWH: o && o.reverseWH
                    };
                };
            },
            5702: (e229, t159, n117)=>{
                "use strict";
                Object.defineProperty(t159, "__esModule", {
                    value: !0
                }), t159.TextureManager = void 0;
                const r70 = n117(6231);
                t159.TextureManager = class {
                    constructor(e, t, n, r){
                        this.glContext = e, this.layoutStrategy = t, this.profiler = n, this.config = r, this.pendingRead = new Map, r.reuseTextures && (this.inUseTextures = new Map, this.idleTextures = new Map, this.textureLookup = new Map);
                    }
                    createTextureFromLayout(e, t, n, i) {
                        const o = this.toEncoderType(e), s = this.glContext.getEncoder(o, t.channels || 1, i);
                        if (t.isPacked && 1 === i) throw new Error("not implemented");
                        const a = t.width, u = t.height;
                        let l, c;
                        if (this.config.reuseTextures) {
                            l = `${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`, c = this.inUseTextures.get(l), c || (c = [], this.inUseTextures.set(l, c));
                            const t = this.idleTextures.get(l);
                            if (t && t.length > 0) {
                                const r = t.pop();
                                return c.push(r), 1 === i && this.glContext.updateTexture(r, a, u, s, this.toTextureData(e, n)), r;
                            }
                        }
                        r70.Logger.verbose("TextureManager", `Creating new texture of size ${t.width}x${t.height}`);
                        const p = this.glContext.allocateTexture(a, u, s, this.toTextureData(e, n));
                        return this.config.reuseTextures && (c.push(p), this.textureLookup.set(p, l)), p;
                    }
                    readTexture(e230, t160, n) {
                        return n || (n = 1), this.profiler.event("backend", "TextureManager.readTexture", ()=>{
                            const r = e230.shape.reduce((e, t)=>e * t
                            ) * n, i = this.glContext.readTexture(e230.texture, e230.width, e230.height, r, this.toEncoderType(t160), n);
                            return this.toTensorData(t160, i);
                        });
                    }
                    async readTextureAsync(e231, t161, n) {
                        const r = e231.tensor.dataId;
                        if (n || (n = 1), this.pendingRead.has(r)) {
                            const e = this.pendingRead.get(r);
                            return new Promise((t)=>null == e ? void 0 : e.push(t)
                            );
                        }
                        return this.profiler.event("backend", "TextureManager.readTextureAsync", async ()=>{
                            this.pendingRead.set(r, []);
                            const i = e231.shape.reduce((e, t)=>e * t
                            ) * n;
                            await this.glContext.createAndWaitForFence();
                            const o = this.glContext.readTexture(e231.texture, e231.width, e231.height, i, this.toEncoderType(t161), n), s = this.toTensorData(t161, o), a = this.pendingRead.get(r);
                            return this.pendingRead.delete(r), null == a || a.forEach((e)=>e(s)
                            ), s;
                        });
                    }
                    readUint8TextureAsFloat(e232) {
                        return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", ()=>{
                            const t162 = e232.shape.reduce((e, t)=>e * t
                            ), n = this.glContext.readTexture(e232.texture, e232.width, e232.height, 4 * t162, "byte", 4);
                            return new Float32Array(n.buffer, n.byteOffset, t162);
                        });
                    }
                    releaseTexture(e, t) {
                        let n;
                        if (this.config.reuseTextures && (n = this.textureLookup.get(e.texture), n)) {
                            t && this.textureLookup.delete(n);
                            const r = this.inUseTextures.get(n);
                            if (r) {
                                const t = r.indexOf(e.texture);
                                if (-1 !== t) {
                                    r.splice(t, 1);
                                    let i = this.idleTextures.get(n);
                                    i || (i = [], this.idleTextures.set(n, i)), i.push(e.texture);
                                }
                            }
                        }
                        n && !t || (r70.Logger.verbose("TextureManager", `Deleting texture of size ${e.width}x${e.height}`), this.glContext.deleteTexture(e.texture));
                    }
                    toTensorData(e, t) {
                        switch(e){
                            case "int16":
                                return t instanceof Int16Array ? t : Int16Array.from(t);
                            case "int32":
                                return t instanceof Int32Array ? t : Int32Array.from(t);
                            case "int8":
                                return t instanceof Int8Array ? t : Int8Array.from(t);
                            case "uint16":
                                return t instanceof Uint16Array ? t : Uint16Array.from(t);
                            case "uint32":
                                return t instanceof Uint32Array ? t : Uint32Array.from(t);
                            case "uint8":
                            case "bool":
                                return t instanceof Uint8Array ? t : Uint8Array.from(t);
                            case "float32":
                                return t instanceof Float32Array ? t : Float32Array.from(t);
                            case "float64":
                                return t instanceof Float64Array ? t : Float64Array.from(t);
                            default:
                                throw new Error(`TensorData type ${e} is not supported`);
                        }
                    }
                    toTextureData(e, t) {
                        if (t) return t instanceof Float32Array ? t : new Float32Array(t);
                    }
                    toEncoderType(e) {
                        return "float";
                    }
                    clearActiveTextures() {
                        this.glContext.clearActiveTextures();
                    }
                };
            },
            2039: (e, t)=>{
                "use strict";
                var n;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
            },
            9390: (e233, t163, n118)=>{
                "use strict";
                Object.defineProperty(t163, "__esModule", {
                    value: !0
                }), t163.getGlChannels = t163.getCoordsDataType = t163.getSqueezedParams = t163.squeezeInputShape = t163.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t163.generateShaderFuncNameFromInputSamplerName = t163.repeatedTry = t163.getPackedShape = void 0;
                const r71 = n118(2517);
                t163.getPackedShape = function(e) {
                    const t = e.length;
                    return e.slice(0, t - 1).concat(e[t - 1] / 4);
                }, t163.repeatedTry = async function(e, t = (e)=>0
                , n) {
                    return new Promise((r, i)=>{
                        let o = 0;
                        const s = ()=>{
                            if (e()) return void r();
                            o++;
                            const a = t(o);
                            null != n && o >= n ? i() : setTimeout(s, a);
                        };
                        s();
                    });
                }, t163.generateShaderFuncNameFromInputSamplerName = function(e) {
                    return r71.assert(void 0 !== e && 0 !== e.length, ()=>"empty string found for sampler name"
                    ), "get" + e.charAt(0).toUpperCase() + e.slice(1);
                }, t163.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e) {
                    return r71.assert(void 0 !== e && 0 !== e.length, ()=>"empty string found for sampler name"
                    ), "get" + e.charAt(0).toUpperCase() + e.slice(1) + "AtOutCoords";
                }, t163.squeezeInputShape = function(e, t) {
                    let n = JSON.parse(JSON.stringify(e));
                    return n = t, n;
                }, t163.getSqueezedParams = function(e, t164) {
                    return t164.map((t)=>e[t]
                    ).join(", ");
                }, t163.getCoordsDataType = function(e) {
                    if (e <= 1) return "int";
                    if (2 === e) return "ivec2";
                    if (3 === e) return "ivec3";
                    if (4 === e) return "ivec4";
                    if (5 === e) return "ivec5";
                    if (6 === e) return "ivec6";
                    throw Error(`GPU for rank ${e} is not yet supported`);
                }, t163.getGlChannels = function(e = 6) {
                    return [
                        "x",
                        "y",
                        "z",
                        "w",
                        "u",
                        "v"
                    ].slice(0, e);
                };
            },
            7305: (e234, t165, n119)=>{
                "use strict";
                Object.defineProperty(t165, "__esModule", {
                    value: !0
                }), t165.createNewWebGLContext = t165.createWebGLContext = void 0;
                const r72 = n119(6231), i = n119(1713), o37 = {};
                function s(e235) {
                    const t = function() {
                        const e = document.createElement("canvas");
                        return e.width = 1, e.height = 1, e;
                    }();
                    let n;
                    const o = {
                        alpha: !1,
                        depth: !1,
                        antialias: !1,
                        stencil: !1,
                        preserveDrawingBuffer: !1,
                        premultipliedAlpha: !1,
                        failIfMajorPerformanceCaveat: !1
                    };
                    if ((!e235 || "webgl2" === e235) && (n = t.getContext("webgl2", o), n)) try {
                        return new i.WebGLContext(n, 2);
                    } catch (e) {
                        r72.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`);
                    }
                    if ((!e235 || "webgl" === e235) && (n = t.getContext("webgl", o) || t.getContext("experimental-webgl", o), n)) try {
                        return new i.WebGLContext(n, 1);
                    } catch (e236) {
                        r72.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e236}`);
                    }
                    throw new Error("WebGL is not supported");
                }
                t165.createWebGLContext = function e(t) {
                    let n;
                    t && "webgl2" !== t || !("webgl2" in o37) ? t && "webgl" !== t || !("webgl" in o37) || (n = o37.webgl) : n = o37.webgl2, n = n || s(t), t = t || 1 === n.version ? "webgl" : "webgl2";
                    const r = n.gl;
                    return o37[t] = n, r.isContextLost() ? (delete o37[t], e(t)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), n);
                }, t165.createNewWebGLContext = s;
            },
            1713: function(e237, t166, n120) {
                "use strict";
                var r73 = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), i44 = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    });
                } : function(e, t) {
                    e.default = t;
                }), o38 = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e) for(var n in e)"default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r73(t, e, n);
                    return i44(t, e), t;
                };
                Object.defineProperty(t166, "__esModule", {
                    value: !0
                }), t166.WebGLContext = t166.linearSearchLastTrue = void 0;
                const s30 = n120(2174), a27 = o38(n120(7769)), u27 = n120(9390);
                function l(e) {
                    let t = 0;
                    for(; t < e.length && e[t](); ++t);
                    return t - 1;
                }
                t166.linearSearchLastTrue = l, t166.WebGLContext = class {
                    constructor(e, t){
                        this.frameBufferBound = !1, this.itemsToPoll = [], this.gl = e, this.version = t, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
                    }
                    allocateTexture(e, t, n, r) {
                        const i = this.gl, o = i.createTexture();
                        i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE);
                        const s = r ? n.encode(r, e * t) : null;
                        return i.texImage2D(i.TEXTURE_2D, 0, n.internalFormat, e, t, 0, n.format, n.textureType, s), this.checkError(), o;
                    }
                    updateTexture(e, t, n, r, i) {
                        const o = this.gl;
                        o.bindTexture(o.TEXTURE_2D, e);
                        const s = r.encode(i, t * n);
                        o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, t, n, r.format, r.textureType, s), this.checkError();
                    }
                    attachFramebuffer(e, t, n) {
                        const r = this.gl;
                        r.bindTexture(r.TEXTURE_2D, e), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e, 0), this.checkError(), r.viewport(0, 0, t, n), r.scissor(0, 0, t, n);
                    }
                    readTexture(e, t, n, r, i, o) {
                        const s = this.gl;
                        o || (o = 1), this.frameBufferBound || this.attachFramebuffer(e, t, n);
                        const a = this.getEncoder(i, o), u = a.allocate(t * n);
                        return s.bindTexture(s.TEXTURE_2D, e), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e, 0), s.readPixels(0, 0, t, n, s.RGBA, a.textureType, u), this.checkError(), a.decode(u, r);
                    }
                    isFramebufferReady() {
                        return !0;
                    }
                    getActiveTexture() {
                        const e = this.gl;
                        return "TEXTURE" + (e.getParameter(this.gl.ACTIVE_TEXTURE) - e.TEXTURE0);
                    }
                    getTextureBinding() {
                        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
                    }
                    getFramebufferBinding() {
                        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
                    }
                    setVertexAttributes(e, t) {
                        const n = this.gl;
                        n.vertexAttribPointer(e, 3, n.FLOAT, !1, 20, 0), n.enableVertexAttribArray(e), -1 !== t && (n.vertexAttribPointer(t, 2, n.FLOAT, !1, 20, 12), n.enableVertexAttribArray(t)), this.checkError();
                    }
                    createProgram(e, t) {
                        const n = this.gl, r = n.createProgram();
                        return n.attachShader(r, e), n.attachShader(r, t), n.linkProgram(r), r;
                    }
                    compileShader(e, t) {
                        const n = this.gl, r = n.createShader(t);
                        if (!r) throw new Error(`createShader() returned null with type ${t}`);
                        if (n.shaderSource(r, e), n.compileShader(r), !1 === n.getShaderParameter(r, n.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\nShader source:\n${e}`);
                        return r;
                    }
                    deleteShader(e) {
                        this.gl.deleteShader(e);
                    }
                    bindTextureToUniform(e, t, n) {
                        const r = this.gl;
                        r.activeTexture(r.TEXTURE0 + t), this.checkError(), r.bindTexture(r.TEXTURE_2D, e), this.checkError(), r.uniform1i(n, t), this.checkError();
                    }
                    draw() {
                        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
                    }
                    checkError() {
                        if (s30.env.debug) {
                            const e = this.gl, t = e.getError();
                            let n = "";
                            switch(t){
                                case e.NO_ERROR:
                                    return;
                                case e.INVALID_ENUM:
                                    n = "INVALID_ENUM";
                                    break;
                                case e.INVALID_VALUE:
                                    n = "INVALID_VALUE";
                                    break;
                                case e.INVALID_OPERATION:
                                    n = "INVALID_OPERATION";
                                    break;
                                case e.INVALID_FRAMEBUFFER_OPERATION:
                                    n = "INVALID_FRAMEBUFFER_OPERATION";
                                    break;
                                case e.OUT_OF_MEMORY:
                                    n = "OUT_OF_MEMORY";
                                    break;
                                case e.CONTEXT_LOST_WEBGL:
                                    n = "CONTEXT_LOST_WEBGL";
                                    break;
                                default:
                                    n = `Unknown WebGL Error: ${t.toString(16)}`;
                            }
                            throw new Error(n);
                        }
                    }
                    deleteTexture(e) {
                        this.gl.deleteTexture(e);
                    }
                    deleteProgram(e) {
                        this.gl.deleteProgram(e);
                    }
                    getEncoder(e, t, n = 0) {
                        if (2 === this.version) return new a27.RedFloat32DataEncoder(this.gl, t);
                        switch(e){
                            case "float":
                                return 1 === n || this.isRenderFloat32Supported ? new a27.RGBAFloatDataEncoder(this.gl, t) : new a27.RGBAFloatDataEncoder(this.gl, t, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                            case "int":
                                throw new Error("not implemented");
                            case "byte":
                                return new a27.Uint8DataEncoder(this.gl, t);
                            default:
                                throw new Error(`Invalid dataType: ${e}`);
                        }
                    }
                    clearActiveTextures() {
                        const e = this.gl;
                        for(let t = 0; t < this.maxTextureImageUnits; ++t)e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, null);
                    }
                    dispose() {
                        if (this.disposed) return;
                        const e = this.gl;
                        e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(this.framebuffer), e.bindBuffer(e.ARRAY_BUFFER, null), e.deleteBuffer(this.vertexbuffer), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), e.finish(), this.disposed = !0;
                    }
                    createDefaultGeometry() {
                        return new Float32Array([
                            -1,
                            1,
                            0,
                            0,
                            1,
                            -1,
                            -1,
                            0,
                            0,
                            0,
                            1,
                            1,
                            0,
                            1,
                            1,
                            1,
                            -1,
                            0,
                            1,
                            0
                        ]);
                    }
                    createVertexbuffer() {
                        const e = this.gl, t = e.createBuffer();
                        if (!t) throw new Error("createBuffer() returned null");
                        const n = this.createDefaultGeometry();
                        return e.bindBuffer(e.ARRAY_BUFFER, t), e.bufferData(e.ARRAY_BUFFER, n, e.STATIC_DRAW), this.checkError(), t;
                    }
                    createFramebuffer() {
                        const e = this.gl.createFramebuffer();
                        if (!e) throw new Error("createFramebuffer returned null");
                        return e;
                    }
                    queryVitalParameters() {
                        const e = this.gl;
                        if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error("both float32 and float16 TextureType are not supported");
                        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.version;
                    }
                    getExtensions() {
                        2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
                    }
                    checkFloatTextureAttachableToFrameBuffer() {
                        const e = this.gl, t = e.createTexture();
                        e.bindTexture(e.TEXTURE_2D, t);
                        const n = 2 === this.version ? e.RGBA32F : e.RGBA;
                        e.texImage2D(e.TEXTURE_2D, 0, n, 1, 1, 0, e.RGBA, e.FLOAT, null);
                        const r = e.createFramebuffer();
                        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
                        const i = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
                        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(t), e.deleteFramebuffer(r), i;
                    }
                    checkRenderFloat32() {
                        if (2 === this.version) {
                            if (!this.colorBufferFloatExtension) return !1;
                        } else if (!this.textureFloatExtension) return !1;
                        return this.isFloatTextureAttachableToFrameBuffer;
                    }
                    checkFloat32Download() {
                        if (2 === this.version) {
                            if (!this.colorBufferFloatExtension) return !1;
                        } else {
                            if (!this.textureFloatExtension) return !1;
                            if (!this.gl.getExtension("WEBGL_color_buffer_float")) return !1;
                        }
                        return this.isFloatTextureAttachableToFrameBuffer;
                    }
                    checkFloat32Blend() {
                        const e = this.gl;
                        let t, n, r, i, o;
                        try {
                            t = e.createTexture(), n = e.createFramebuffer(), e.bindTexture(e.TEXTURE_2D, t);
                            const s = 2 === this.version ? e.RGBA32F : e.RGBA;
                            return e.texImage2D(e.TEXTURE_2D, 0, s, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, n), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0), e.enable(e.BLEND), r = e.createShader(e.VERTEX_SHADER), !!r && (e.shaderSource(r, "void main(){}"), e.compileShader(r), i = e.createShader(e.FRAGMENT_SHADER), !!i && (e.shaderSource(i, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), e.compileShader(i), o = e.createProgram(), !!o && (e.attachShader(o, r), e.attachShader(o, i), e.linkProgram(o), e.useProgram(o), e.drawArrays(e.POINTS, 0, 1), e.getError() === e.NO_ERROR)));
                        } finally{
                            e.disable(e.BLEND), o && e.deleteProgram(o), r && e.deleteShader(r), i && e.deleteShader(i), n && (e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteFramebuffer(n)), t && (e.bindTexture(e.TEXTURE_2D, null), e.deleteTexture(t));
                        }
                    }
                    beginTimer() {
                        if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
                            const e = this.gl, t = this.disjointTimerQueryWebgl2Extension, n = e.createQuery();
                            return e.beginQuery(t.TIME_ELAPSED_EXT, n), n;
                        }
                        throw new Error("WebGL1 profiling currently not supported.");
                    }
                    endTimer() {
                        if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
                        {
                            const e = this.gl, t = this.disjointTimerQueryWebgl2Extension;
                            e.endQuery(t.TIME_ELAPSED_EXT);
                        }
                    }
                    isTimerResultAvailable(e) {
                        let t = !1, n = !1;
                        if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
                        {
                            const r = this.gl, i = this.disjointTimerQueryWebgl2Extension;
                            t = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE), n = r.getParameter(i.GPU_DISJOINT_EXT);
                        }
                        return t && !n;
                    }
                    getTimerResult(e) {
                        let t = 0;
                        if (2 !== this.version) throw new Error("WebGL1 profiling currently not supported");
                        {
                            const n = this.gl;
                            t = n.getQueryParameter(e, n.QUERY_RESULT), n.deleteQuery(e);
                        }
                        return t / 1e6;
                    }
                    async waitForQueryAndGetTime(e) {
                        return await u27.repeatedTry(()=>this.isTimerResultAvailable(e)
                        ), this.getTimerResult(e);
                    }
                    async createAndWaitForFence() {
                        const e = this.createFence(this.gl);
                        return this.pollFence(e);
                    }
                    createFence(e238) {
                        let t;
                        const n = e238, r = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        return e238.flush(), t = null === r ? ()=>!0
                         : ()=>{
                            const e = n.clientWaitSync(r, 0, 0);
                            return e === n.ALREADY_SIGNALED || e === n.CONDITION_SATISFIED;
                        }, {
                            query: r,
                            isFencePassed: t
                        };
                    }
                    async pollFence(e) {
                        return new Promise((t)=>{
                            this.addItemToPoll(()=>e.isFencePassed()
                            , ()=>t()
                            );
                        });
                    }
                    pollItems() {
                        const e239 = l(this.itemsToPoll.map((e)=>e.isDoneFn
                        ));
                        for(let t = 0; t <= e239; ++t){
                            const { resolveFn: e  } = this.itemsToPoll[t];
                            e();
                        }
                        this.itemsToPoll = this.itemsToPoll.slice(e239 + 1);
                    }
                    async addItemToPoll(e, t) {
                        this.itemsToPoll.push({
                            isDoneFn: e,
                            resolveFn: t
                        }), this.itemsToPoll.length > 1 || await u27.repeatedTry(()=>(this.pollItems(), 0 === this.itemsToPoll.length)
                        );
                    }
                };
            },
            1036: (e240, t167, n121)=>{
                "use strict";
                Object.defineProperty(t167, "__esModule", {
                    value: !0
                }), t167.ExecutionPlan = void 0;
                const r74 = n121(6231);
                class i45 {
                    constructor(e, t){
                        this.op = e, this.node = t;
                    }
                }
                t167.ExecutionPlan = class {
                    constructor(e, t, n){
                        this.graph = e, this.profiler = n, this.initialize(t);
                    }
                    initialize(e241) {
                        this.profiler.event("session", "ExecutionPlan.initialize", ()=>{
                            const t169 = this.graph.getNodes();
                            if (t169.length !== e241.length) throw new Error("The size of nodes and OPs do not match.");
                            this._ops = e241.map((e, n)=>new i45(e, t169[n])
                            ), this.reset(), this._starter = [], this._ops.forEach((e, t)=>{
                                let n = !0;
                                for (const t168 of e.node.inputs)if (!this._values[t168] && -1 === this.graph.getInputIndices().indexOf(t168)) {
                                    n = !1;
                                    break;
                                }
                                n && this._starter.push(t);
                            });
                        });
                    }
                    reset() {
                        this._values = this.graph.getValues().map((e)=>e.tensor
                        );
                    }
                    async execute(e243, t170) {
                        return this.profiler.event("session", "ExecutionPlan.execute", async ()=>{
                            this.reset();
                            const n122 = e243.createInferenceHandler(), i = this.graph.getInputIndices();
                            if (t170.length !== i.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t170.length} expected: ${i.length}`);
                            t170.forEach((e, t)=>{
                                const n = i[t];
                                this._values[n] = e;
                            });
                            const o = this._starter.slice(0), s = this.graph.getValues(), a = this.graph.getNodes();
                            let u = 0;
                            for(; u < o.length;){
                                const e244 = o[u++], t171 = this._ops[e244], i = t171.node.inputs.map((e)=>this._values[e]
                                );
                                if (-1 !== i.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${t171.node}`);
                                const l = i;
                                r74.Logger.verbose("ExecPlan", `Runing op:${t171.node.name} (${l.map((e, n)=>`'${t171.node.inputs[n]}': ${e.type}[${e.dims.join(",")}]`
                                ).join(", ")})`);
                                const c = await this.profiler.event("node", t171.node.name, async ()=>t171.op.impl(n122, l, t171.op.context)
                                );
                                if (c.length !== t171.node.outputs.length) throw new Error("the size of output does not match model definition.");
                                c.forEach((e, n)=>{
                                    const r = t171.node.outputs[n];
                                    if (this._values[r]) throw new Error(`output [${r}] already has value: op:${t171.node.name}`);
                                    this._values[r] = e;
                                });
                                const p = new Set;
                                c.forEach((e, n)=>{
                                    const r = t171.node.outputs[n];
                                    for (const e246 of s[r].to){
                                        const t = a[e246];
                                        let n = !0;
                                        for (const e of t.inputs)if (!this._values[e]) {
                                            n = !1;
                                            break;
                                        }
                                        n && p.add(e246);
                                    }
                                }), o.push(...p);
                            }
                            const l = [];
                            for(let e242 = 0; e242 < this.graph.getOutputIndices().length; e242++){
                                const t = this.graph.getOutputIndices()[e242], n = this._values[t];
                                if (void 0 === n) throw new Error(`required output [${t}] does not have value`);
                                0 === t ? await n.getData() : n.data, l.push(n);
                            }
                            return r74.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n122.dispose(), l;
                        });
                    }
                };
            },
            7070: (e247, t173, n128)=>{
                "use strict";
                Object.defineProperty(t173, "__esModule", {
                    value: !0
                }), t173.Graph = void 0;
                const r75 = n128(1446), i46 = n128(7778);
                var o39 = n128(9395).onnxruntime.experimental.fbs;
                const s31 = n128(9162), a28 = n128(2517);
                t173.Graph = {
                    from: (e, t)=>new c14(e, t)
                };
                class u {
                    constructor(e){
                        this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e && (this.type = a28.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType));
                    }
                    get from() {
                        return this._from;
                    }
                    get to() {
                        return this._to;
                    }
                }
                class l22 {
                    constructor(e, t){
                        e instanceof r75.onnx.NodeProto ? (this.name = e.name, this.opType = e.opType, this.attributes = new i46.Attribute(e.attribute)) : e instanceof o39.Node && (this.name = null != t ? t : e.name(), this.opType = e.opType(), this.attributes = new i46.Attribute(a28.ProtoUtil.tensorAttributesFromORTFormat(e))), this.inputs = [], this.outputs = [], this.executeNode = !0;
                    }
                }
                class c14 {
                    constructor(e, t){
                        if (!e) throw new TypeError("graph is empty");
                        this.buildGraph(e), this.transformGraph(t), this.checkIsAcyclic();
                    }
                    getInputIndices() {
                        return this._allInputIndices;
                    }
                    getInputNames() {
                        return this._allInputNames;
                    }
                    getOutputIndices() {
                        return this._allOutputIndices;
                    }
                    getOutputNames() {
                        return this._allOutputNames;
                    }
                    getValues() {
                        return this._allData;
                    }
                    getNodes() {
                        return this._nodes;
                    }
                    buildGraph(e) {
                        if (e instanceof r75.onnx.GraphProto) this.buildGraphFromOnnxFormat(e);
                        else {
                            if (!(e instanceof o39.Graph)) throw new TypeError("Graph type is not supported.");
                            this.buildGraphFromOrtFormat(e);
                        }
                    }
                    buildGraphFromOnnxFormat(e) {
                        const t = new Map;
                        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
                        const n = new Map;
                        if (!e.input) throw new Error("missing information in graph: input");
                        const r = [];
                        for (const n123 of e.input){
                            if (t.has(n123.name)) throw new Error(`duplicated input name: ${n123.name}`);
                            const e = this._allData.push(new u(n123)) - 1;
                            t.set(n123.name, e), r.push(n123.name);
                        }
                        if (!e.initializer) throw new Error("missing information in graph: initializer");
                        for (const n124 of e.initializer){
                            let e = t.get(n124.name);
                            if (void 0 === e) {
                                const r = new u;
                                r.type = {
                                    shape: {
                                        dims: a28.ProtoUtil.tensorDimsFromProto(n124.dims)
                                    },
                                    tensorType: a28.ProtoUtil.tensorDataTypeFromProto(n124.dataType)
                                }, e = this._allData.push(r) - 1, t.set(n124.name, e);
                            }
                            this._allData[e]._from = -1, this._allData[e].tensor = s31.Tensor.fromProto(n124);
                        }
                        for(let e248 = 0; e248 < this._allData.length; e248++)this._allData[e248].tensor || (this._allInputIndices.push(e248), this._allInputNames.push(r[e248]));
                        if (!e.output) throw new Error("missing information in graph: output");
                        for (const n125 of e.output){
                            if (t.has(n125.name)) throw new Error(`duplicated output name: ${n125.name}`);
                            const e = this._allData.push(new u(n125)) - 1;
                            t.set(n125.name, e), this._allOutputIndices.push(e), this._allOutputNames.push(n125.name);
                        }
                        if (!e.node) throw new Error("missing information in graph: node");
                        for (const t174 of e.node){
                            if (!t174.name) for(let e = 0;; e++){
                                const r = `unnamed_${t174.opType}_${e}`;
                                if (!n.has(r)) {
                                    t174.name = r;
                                    break;
                                }
                            }
                            if (n.has(t174.name)) throw new Error(`duplicated node name: ${t174.name}`);
                            const e249 = this._nodes.push(new l22(t174)) - 1;
                            n.set(t174.name, e249);
                        }
                        for(let n126 = 0; n126 < this._nodes.length; n126++){
                            const r = this._nodes[n126], i = e.node[n126];
                            if (!i.output) throw new Error(`missing output for node: ${i.name}`);
                            for (const e250 of i.output){
                                let o = t.get(e250);
                                if (void 0 === o && (o = this._allData.push(new u) - 1, t.set(e250, o)), r.outputs.push(o), void 0 !== this._allData[o]._from) throw new Error(`multiple nodes output to one data value: ${o}`);
                                if (this._allData[o]._from = n126, "Constant" === i.opType) {
                                    if (!i.attribute || 1 !== i.attribute.length || !i.attribute[0].t) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                                    if (!i.output || 1 !== i.output.length) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                                    r.outputs.pop(), r.executeNode = !1, this._allData[o]._from = -1, this._allData[o].tensor = s31.Tensor.fromProto(i.attribute[0].t);
                                }
                            }
                        }
                        for(let n127 = 0; n127 < this._nodes.length; n127++){
                            const r = this._nodes[n127], i = e.node[n127];
                            if (!i.input) throw new Error(`missing input for node: ${i.name}`);
                            for (const e251 of i.input){
                                const o = t.get(e251);
                                if (void 0 === o) throw new Error(`unrecognized input '${e251}' for node: ${i.name}`);
                                r.inputs.push(o), this._allData[o]._to.push(n127);
                            }
                        }
                        return !0;
                    }
                    buildGraphFromOrtFormat(e) {
                        var t, n, r;
                        const i = new Map;
                        this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
                        const c = new Map, p = [];
                        for(let s = 0; s < e.inputsLength(); s++){
                            const l = e.inputs(s);
                            if (i.has(l)) throw new Error(`duplicated input name: ${l}`);
                            for(let s32 = 0; s32 < e.nodeArgsLength(); s32++)if ((null === (t = e.nodeArgs(s32)) || void 0 === t ? void 0 : t.name()) === l) {
                                const t = new u;
                                if ((null === (r = null === (n = e.nodeArgs(s32)) || void 0 === n ? void 0 : n.type()) || void 0 === r ? void 0 : r.valueType()) !== o39.TypeInfoValue.tensor_type) throw new Error("Unexpected value type for the nodeArg.");
                                const c = e.nodeArgs(s32).type().value(new o39.TensorTypeAndShape), d = a28.ProtoUtil.tensorDataTypeFromProto(c.elemType()), f = c.shape(), h = [];
                                for(let e253 = 0; e253 < f.dimLength(); e253++)h.push(a28.LongUtil.longToNumber(f.dim(e253).value().dimValue()));
                                t.type = {
                                    shape: {
                                        dims: h
                                    },
                                    tensorType: d
                                };
                                const g = this._allData.push(t) - 1;
                                i.set(l, g), p.push(l);
                            }
                        }
                        for(let t175 = 0; t175 < e.initializersLength(); t175++){
                            const n = e.initializers(t175);
                            let r = i.get(n.name());
                            if (void 0 === r) {
                                const e = new u, t = a28.ProtoUtil.tensorDimsFromORTFormat(n), o = a28.ProtoUtil.tensorDataTypeFromProto(n.dataType());
                                e.type = {
                                    shape: {
                                        dims: t
                                    },
                                    tensorType: o
                                }, r = this._allData.push(e) - 1, i.set(n.name(), r);
                            }
                            this._allData[r]._from = -1, this._allData[r].tensor = s31.Tensor.fromOrtTensor(n);
                        }
                        for(let e252 = 0; e252 < this._allData.length; e252++)this._allData[e252].tensor || (this._allInputIndices.push(e252), this._allInputNames.push(p[e252]));
                        for(let t176 = 0; t176 < e.outputsLength(); t176++){
                            const n = e.outputs(t176);
                            if (i.has(n)) throw new Error(`duplicated output name: ${n}`);
                            const r = this._allData.push(new u) - 1;
                            i.set(n, r), this._allOutputIndices.push(r), this._allOutputNames.push(n);
                        }
                        if (!e.nodes) throw new Error("missing information in graph: node");
                        for(let t177 = 0; t177 < e.nodesLength(); t177++){
                            const n = e.nodes(t177);
                            let r = n.name();
                            if (!r) for(let e255 = 0; r = `unnamed_${n.opType()}_${e255}`, c.has(r); e255++);
                            if (c.has(r)) throw new Error(`duplicated node name: ${r}`);
                            const i = this._nodes.push(new l22(n, r)) - 1;
                            c.set(r, i);
                        }
                        for(let t178 = 0; t178 < this._nodes.length; t178++){
                            const n = this._nodes[t178], r = e.nodes(t178);
                            if (null == r) throw new Error(`No node exists at index ${t178}`);
                            if (0 === (null == r ? void 0 : r.outputsLength())) throw new Error(`missing output for node: ${r.name}`);
                            for(let e256 = 0; e256 < (null == r ? void 0 : r.outputsLength()); e256++){
                                const o = null == r ? void 0 : r.outputs(e256);
                                let a = i.get(o);
                                if (void 0 === a && (a = this._allData.push(new u) - 1, i.set(o, a)), n.outputs.push(a), void 0 !== this._allData[a]._from) throw new Error(`multiple nodes output to one data value: ${a}`);
                                if (this._allData[a]._from = t178, "Constant" === r.opType()) {
                                    if (1 !== r.attributesLength() || !r.attributes(0).t()) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                                    if (1 !== r.outputsLength()) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                                    n.outputs.pop(), n.executeNode = !1, this._allData[a]._from = -1, this._allData[a].tensor = s31.Tensor.fromOrtTensor(r.attributes(0).t());
                                }
                            }
                        }
                        for(let t179 = 0; t179 < this._nodes.length; t179++){
                            const n = this._nodes[t179], r = e.nodes(t179);
                            if (0 === r.inputsLength()) throw new Error(`missing input for node: ${r.name}`);
                            for(let e257 = 0; e257 < r.inputsLength(); e257++){
                                const o = r.inputs(e257), s = i.get(o);
                                if (void 0 === s) throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);
                                n.inputs.push(s), this._allData[s]._to.push(t179);
                            }
                        }
                    }
                    checkIsAcyclic() {
                        const e259 = new Set;
                        this._allInputIndices.forEach((t181)=>{
                            this._allData[t181]._to.forEach((t)=>{
                                e259.add(t);
                            });
                        });
                        const t180 = Array.from(e259), n = new Array(this._nodes.length).fill("white");
                        for(; t180.length > 0;){
                            const e258 = t180.pop();
                            "gray" === n[e258] ? n[e258] = "black" : (t180.push(e258), n[e258] = "gray", this._nodes[e258].outputs.forEach((r)=>{
                                const i = this._allData[r];
                                if (void 0 !== i.tensor) throw new Error("node outputs should not be initialized");
                                if (i._from !== e258) throw new Error("from property of the Value object doesn't match index of Node being processed");
                                i._to.forEach((e)=>{
                                    if ("gray" === n[e]) throw new Error("model graph is cyclic");
                                    "white" === n[e] && t180.push(e);
                                });
                            }));
                        }
                    }
                    transformGraph(e) {
                        this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e && e.transformGraph(this), this.finalizeGraph();
                    }
                    finalizeGraph() {
                        let e260 = 0;
                        for(let t = 0; t < this._nodes.length; t++)this._nodes[t].executeNode ? e260 > 0 && (this._nodes[t].inputs.forEach((n)=>{
                            const r = this._allData[n]._to.indexOf(t + e260);
                            -1 !== r && (this._allData[n]._to[r] = t);
                        }), this._nodes[t].outputs.forEach((n)=>{
                            this._allData[n]._from && this._allData[n]._from === t + e260 && (this._allData[n]._from = t);
                        })) : (e260++, this._nodes[t].outputs.forEach((e)=>{
                            this._allData[e]._from = -2;
                        }), this._nodes.splice(t, 1), t--);
                        e260 = 0;
                        for(let t182 = 0; t182 < this._allData.length; t182++)if (-2 !== this._allData[t182].from || -1 !== this._allOutputIndices.indexOf(t182 + e260)) {
                            if (e260 > 0) {
                                let n = -1;
                                void 0 !== this._allData[t182].from && -1 !== this._allData[t182].from ? (n = this._nodes[this._allData[t182].from].outputs.indexOf(t182 + e260), -1 !== n && (this._nodes[this._allData[t182].from].outputs[n] = t182)) : (n = this._allInputIndices.indexOf(t182 + e260), -1 !== n && (this._allInputIndices[n] = t182)), this._allData[t182].to.forEach((r)=>{
                                    n = this._nodes[r].inputs.indexOf(t182 + e260), -1 !== n && (this._nodes[r].inputs[n] = t182);
                                }), 0 === this._allData[t182].to.length && (n = this._allOutputIndices.indexOf(t182 + e260), -1 !== n && (this._allOutputIndices[n] = t182));
                            }
                        } else e260++, this._allData.splice(t182, 1), t182--;
                    }
                    deleteNode(e) {
                        const t = this._nodes[e];
                        if (t.outputs.length > 1) {
                            for(let e = 1; e < t.outputs.length; e++)if (this._allData[t.outputs[e]].to.length > 0) throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
                        }
                        t.executeNode = !1;
                        const n = t.inputs[0], r = t.outputs[0], i = this._allData[r].to, o = this._allData[n].to.indexOf(e);
                        if (-1 === o) throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
                        this._allData[n].to.splice(o, 1), this._allData[r]._to = [];
                        const s = this._allOutputIndices.indexOf(r);
                        if (-1 !== s && (this._allOutputIndices[s] = n), i && i.length > 0) for (const e261 of i){
                            const t = this._nodes[e261].inputs.indexOf(r);
                            if (-1 === t) throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                            this._nodes[e261].inputs[t] = n, this._allData[n].to.push(e261);
                        }
                    }
                    removeAllDropoutNodes() {
                        let e = 0;
                        for (const t of this._nodes){
                            if ("Dropout" === t.opType) {
                                if (1 !== t.inputs.length) throw new Error("Dropout nodes should only contain one input. ");
                                if (1 !== t.outputs.length && 2 !== t.outputs.length) throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                                if (2 === t.outputs.length && 0 !== this._allData[t.outputs[1]]._to.length) throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                                this.deleteNode(e);
                            }
                            e++;
                        }
                    }
                    removeAllIdentityNodes() {
                        let e = 0;
                        for (const t of this._nodes)"Identity" === t.opType && this.deleteNode(e), e++;
                    }
                    isActivation(e) {
                        switch(e.opType){
                            case "Relu":
                            case "Sigmoid":
                            case "Clip":
                                return !0;
                            default:
                                return !1;
                        }
                    }
                    fuseConvActivationNodes() {
                        for (const e of this._nodes)if ("Conv" === e.opType) {
                            const t = this._allData[e.outputs[0]]._to;
                            if (1 === t.length && this.isActivation(this._nodes[t[0]])) {
                                const n = this._nodes[t[0]];
                                if ("Clip" === n.opType) {
                                    if (1 === n.inputs.length) try {
                                        e.attributes.set("activation_params", "floats", [
                                            n.attributes.getFloat("min"),
                                            n.attributes.getFloat("max")
                                        ]);
                                    } catch (t) {
                                        e.attributes.set("activation_params", "floats", [
                                            a28.MIN_CLIP,
                                            a28.MAX_CLIP
                                        ]);
                                    }
                                    else {
                                        if (!(n.inputs.length >= 3 && void 0 !== this._allData[n.inputs[1]].tensor && void 0 !== this._allData[n.inputs[2]].tensor)) continue;
                                        e.attributes.set("activation_params", "floats", [
                                            this._allData[n.inputs[1]].tensor.floatData[0],
                                            this._allData[n.inputs[2]].tensor.floatData[0]
                                        ]);
                                    }
                                }
                                e.attributes.set("activation", "string", n.opType), this.deleteNode(t[0]);
                            }
                        }
                    }
                }
            },
            6231: (e262, t183)=>{
                "use strict";
                Object.defineProperty(t183, "__esModule", {
                    value: !0
                }), t183.now = t183.Profiler = t183.Logger = void 0;
                const n129 = {
                    verbose: 1e3,
                    info: 2e3,
                    warning: 4e3,
                    error: 5e3,
                    fatal: 6e3
                }, r76 = {
                    none: new class {
                        log(e, t, n) {}
                    },
                    console: new class {
                        log(e, t, n) {
                            console.log(`${this.color(e)} ${n ? "[35m" + n + "[0m " : ""}${t}`);
                        }
                        color(e) {
                            switch(e){
                                case "verbose":
                                    return "[34;40mv[0m";
                                case "info":
                                    return "[32mi[0m";
                                case "warning":
                                    return "[30;43mw[0m";
                                case "error":
                                    return "[31;40me[0m";
                                case "fatal":
                                    return "[101mf[0m";
                                default:
                                    throw new Error(`unsupported severity: ${e}`);
                            }
                        }
                    }
                }, i47 = {
                    provider: "console",
                    minimalSeverity: "warning",
                    logDateTime: !0,
                    logSourceLocation: !1
                };
                let o40 = {
                    "": i47
                };
                function s33(e, t, n, r) {
                    if (void 0 === t) return i = e, {
                        verbose: s33.verbose.bind(null, i),
                        info: s33.info.bind(null, i),
                        warning: s33.warning.bind(null, i),
                        error: s33.error.bind(null, i),
                        fatal: s33.fatal.bind(null, i)
                    };
                    if (void 0 === n) a29(e, t);
                    else if ("number" == typeof n && void 0 === r) a29(e, t);
                    else if ("string" == typeof n && void 0 === r) a29(e, n, 0, t);
                    else {
                        if ("string" != typeof n || "number" != typeof r) throw new TypeError("input is valid");
                        a29(e, n, 0, t);
                    }
                    var i;
                }
                function a29(e, t, i, s) {
                    const a = o40[s || ""] || o40[""];
                    n129[e] < n129[a.minimalSeverity] || (a.logDateTime && (t = `${(new Date).toISOString()}|${t}`), a.logSourceLocation, r76[a.provider].log(e, t, s));
                }
                !function(e263) {
                    function t184(e) {
                        o40 = {}, n130("", e || {});
                    }
                    function n130(e, n) {
                        if ("*" === e) t184(n);
                        else {
                            const t = o40[e] || i47;
                            o40[e] = {
                                provider: n.provider || t.provider,
                                minimalSeverity: n.minimalSeverity || t.minimalSeverity,
                                logDateTime: void 0 === n.logDateTime ? t.logDateTime : n.logDateTime,
                                logSourceLocation: void 0 === n.logSourceLocation ? t.logSourceLocation : n.logSourceLocation
                            };
                        }
                    }
                    e263.verbose = function(t, n) {
                        e263("verbose", t, n);
                    }, e263.info = function(t, n) {
                        e263("info", t, n);
                    }, e263.warning = function(t, n) {
                        e263("warning", t, n);
                    }, e263.error = function(t, n) {
                        e263("error", t, n);
                    }, e263.fatal = function(t, n) {
                        e263("fatal", t, n);
                    }, e263.reset = t184, e263.set = n130, e263.setWithEnv = function(e) {
                        const t = {};
                        e.logLevel && (t.minimalSeverity = e.logLevel), n130("", t);
                    };
                }(s33 || (s33 = {})), t183.Logger = s33;
                class u {
                    constructor(e, t, n, r, i, o){
                        this.category = e, this.name = t, this.startTime = n, this.endCallback = r, this.timer = i, this.ctx = o;
                    }
                    end() {
                        return this.endCallback(this);
                    }
                    async checkTimer() {
                        if (void 0 === this.ctx || void 0 === this.timer) throw new Error("No webgl timer found");
                        return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
                    }
                }
                class l {
                    constructor(e, t, n, r){
                        this.category = e, this.name = t, this.startTime = n, this.endTime = r;
                    }
                }
                t183.Profiler = class {
                    constructor(e, t, n){
                        this._started = !1, this._flushPointer = 0, this._started = !1, this._maxNumberEvents = void 0 === e ? 1e4 : e, this._flushBatchSize = void 0 === t ? 10 : t, this._flushIntervalInMilliseconds = void 0 === n ? 5e3 : n;
                    }
                    static create(e) {
                        return void 0 === e ? new this : new this(e.maxNumberEvents, e.flushBatchSize, e.flushIntervalInMilliseconds);
                    }
                    start() {
                        this._started = !0, this._timingEvents = [], this._flushTime = t183.now(), this._flushPointer = 0;
                    }
                    stop() {
                        for(this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);
                    }
                    event(e264, t185, n131, r) {
                        const i = this._started ? this.begin(e264, t185, r) : void 0;
                        let o = !1;
                        const s = n131();
                        if (s && "function" == typeof s.then) return o = !0, new Promise((e265, t186)=>{
                            s.then(async (t)=>{
                                i && await i.end(), e265(t);
                            }, async (e)=>{
                                i && await i.end(), t186(e);
                            });
                        });
                        if (!o && i) {
                            const e266 = i.end();
                            if (e266 && "function" == typeof e266.then) return new Promise((t, n)=>{
                                e266.then(()=>{
                                    t(s);
                                }, (e)=>{
                                    n(e);
                                });
                            });
                        }
                        return s;
                    }
                    begin(e268, n, r) {
                        if (!this._started) throw new Error("profiler is not started yet");
                        if (void 0 === r) {
                            const r = t183.now();
                            return this.flush(r), new u(e268, n, r, (e)=>this.endSync(e)
                            );
                        }
                        {
                            const t = r.beginTimer();
                            return new u(e268, n, 0, async (e)=>this.end(e)
                            , t, r);
                        }
                    }
                    async end(e) {
                        const t = await e.checkTimer();
                        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e.category, e.name, e.startTime, t)), this.flush(t));
                    }
                    endSync(e) {
                        const n = t183.now();
                        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e.category, e.name, e.startTime, n)), this.flush(n));
                    }
                    logOneEvent(e) {
                        t183.Logger.verbose(`Profiler.${e.category}`, `${(e.endTime - e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`);
                    }
                    flush(e) {
                        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e - this._flushTime >= this._flushIntervalInMilliseconds) {
                            for(const e = this._flushPointer; this._flushPointer < e + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);
                            this._flushTime = t183.now();
                        }
                    }
                    get started() {
                        return this._started;
                    }
                }, t183.now = "undefined" != typeof performance && performance.now ? ()=>performance.now()
                 : Date.now;
            },
            2644: (e269, t187, n132)=>{
                "use strict";
                Object.defineProperty(t187, "__esModule", {
                    value: !0
                }), t187.Model = void 0;
                const r = n132(4819), i48 = n132(1446), o = n132(7070);
                var s = n132(9395).onnxruntime.experimental.fbs;
                const a = n132(2517);
                t187.Model = class {
                    constructor(){}
                    load(e, t, n) {
                        if (!n) try {
                            return void this.loadFromOnnxFormat(e, t);
                        } catch (e270) {
                            if (void 0 !== n) throw e270;
                        }
                        this.loadFromOrtFormat(e, t);
                    }
                    loadFromOnnxFormat(e271, t) {
                        const n = i48.onnx.ModelProto.decode(e271);
                        if (a.LongUtil.longToNumber(n.irVersion) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
                        this._opsets = n.opsetImport.map((e)=>({
                                domain: e.domain,
                                version: a.LongUtil.longToNumber(e.version)
                            })
                        ), this._graph = o.Graph.from(n.graph, t);
                    }
                    loadFromOrtFormat(e, t) {
                        const n = new r.flatbuffers.ByteBuffer(e), i = s.InferenceSession.getRootAsInferenceSession(n).model();
                        if (a.LongUtil.longToNumber(i.irVersion()) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
                        this._opsets = [];
                        for(let e272 = 0; e272 < i.opsetImportLength(); e272++){
                            const t = i.opsetImport(e272);
                            this._opsets.push({
                                domain: null == t ? void 0 : t.domain(),
                                version: a.LongUtil.longToNumber(t.version())
                            });
                        }
                        this._graph = o.Graph.from(i.graph(), t);
                    }
                    get graph() {
                        return this._graph;
                    }
                    get opsets() {
                        return this._opsets;
                    }
                };
            },
            782: (e, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = [
                    "float32",
                    "float64",
                    "int32",
                    "int16",
                    "int8",
                    "uint16",
                    "uint32",
                    "uint8"
                ], t.INT_TYPES = [
                    "int32",
                    "int16",
                    "int8",
                    "uint16",
                    "uint32",
                    "uint8"
                ], t.FLOAT_TYPES = [
                    "float32",
                    "float64"
                ];
            },
            1047: (e273, t188)=>{
                "use strict";
                function n133(e, t) {
                    if (t.endsWith("+")) {
                        const n = Number.parseInt(t.substring(0, t.length - 1), 10);
                        return !isNaN(n) && n <= e;
                    }
                    if (2 === t.split("-").length) {
                        const n = t.split("-"), r = Number.parseInt(n[0], 10), i = Number.parseInt(n[1], 10);
                        return !isNaN(r) && !isNaN(i) && r <= e && e <= i;
                    }
                    return Number.parseInt(t, 10) === e;
                }
                Object.defineProperty(t188, "__esModule", {
                    value: !0
                }), t188.resolveOperator = void 0, t188.resolveOperator = function(e274, t, r) {
                    for (const i of r){
                        const r = i[0], o = i[1], s = i[2], a = i[3], u = i[4];
                        if (e274.opType === r) {
                            for (const e of t)if ((e.domain === o || "ai.onnx" === e.domain && "" === o) && n133(e.version, s)) return {
                                opImpl: a,
                                opInit: u
                            };
                        }
                    }
                    throw new TypeError(`cannot resolve operator '${e274.opType}' with opsets: ${t.map((e)=>`${e.domain || "ai.onnx"} v${e.version}`
                    ).join(", ")}`);
                };
            },
            9395: (e275, t189, n134)=>{
                "use strict";
                Object.defineProperty(t189, "__esModule", {
                    value: !0
                }), t189.onnxruntime = void 0;
                const r77 = n134(4819);
                var i49, o41;
                i49 = t189.onnxruntime || (t189.onnxruntime = {}), function(e276) {
                    let t;
                    !function(e) {
                        e[e.UNDEFINED = 0] = "UNDEFINED", e[e.FLOAT = 1] = "FLOAT", e[e.INT = 2] = "INT", e[e.STRING = 3] = "STRING", e[e.TENSOR = 4] = "TENSOR", e[e.GRAPH = 5] = "GRAPH", e[e.FLOATS = 6] = "FLOATS", e[e.INTS = 7] = "INTS", e[e.STRINGS = 8] = "STRINGS", e[e.TENSORS = 9] = "TENSORS", e[e.GRAPHS = 10] = "GRAPHS", e[e.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", e[e.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
                    }(t = e276.AttributeType || (e276.AttributeType = {}));
                }((o41 = i49.experimental || (i49.experimental = {})).fbs || (o41.fbs = {})), function(e277) {
                    !function(e278) {
                        !function(e279) {
                            let t;
                            !function(e) {
                                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.VALUE = 1] = "VALUE", e[e.PARAM = 2] = "PARAM";
                            }(t = e279.DimensionValueType || (e279.DimensionValueType = {}));
                        }(e278.fbs || (e278.fbs = {}));
                    }(e277.experimental || (e277.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e280) {
                    !function(e281) {
                        !function(e282) {
                            let t;
                            !function(e) {
                                e[e.UNDEFINED = 0] = "UNDEFINED", e[e.FLOAT = 1] = "FLOAT", e[e.UINT8 = 2] = "UINT8", e[e.INT8 = 3] = "INT8", e[e.UINT16 = 4] = "UINT16", e[e.INT16 = 5] = "INT16", e[e.INT32 = 6] = "INT32", e[e.INT64 = 7] = "INT64", e[e.STRING = 8] = "STRING", e[e.BOOL = 9] = "BOOL", e[e.FLOAT16 = 10] = "FLOAT16", e[e.DOUBLE = 11] = "DOUBLE", e[e.UINT32 = 12] = "UINT32", e[e.UINT64 = 13] = "UINT64", e[e.COMPLEX64 = 14] = "COMPLEX64", e[e.COMPLEX128 = 15] = "COMPLEX128", e[e.BFLOAT16 = 16] = "BFLOAT16";
                            }(t = e282.TensorDataType || (e282.TensorDataType = {}));
                        }(e281.fbs || (e281.fbs = {}));
                    }(e280.experimental || (e280.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e283) {
                    !function(e284) {
                        !function(e285) {
                            let t;
                            !function(e) {
                                e[e.Primitive = 0] = "Primitive", e[e.Fused = 1] = "Fused";
                            }(t = e285.NodeType || (e285.NodeType = {}));
                        }(e284.fbs || (e284.fbs = {}));
                    }(e283.experimental || (e283.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e286) {
                    !function(e287) {
                        !function(e288) {
                            let t;
                            !function(e) {
                                e[e.NONE = 0] = "NONE", e[e.tensor_type = 1] = "tensor_type", e[e.sequence_type = 2] = "sequence_type", e[e.map_type = 3] = "map_type";
                            }(t = e288.TypeInfoValue || (e288.TypeInfoValue = {}));
                        }(e287.fbs || (e287.fbs = {}));
                    }(e286.experimental || (e286.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e289) {
                    !function(t190) {
                        !function(t191) {
                            class n135 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsShape(e, t) {
                                    return (t || new n135).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsShape(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n135).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                dim(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 4);
                                    return r ? (n || new e289.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                dimLength() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startShape(e) {
                                    e.startObject(1);
                                }
                                static addDim(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static createDimVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startDimVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endShape(e) {
                                    return e.endObject();
                                }
                                static createShape(e, t) {
                                    return n135.startShape(e), n135.addDim(e, t), n135.endShape(e);
                                }
                            }
                            t191.Shape = n135;
                        }(t190.fbs || (t190.fbs = {}));
                    }(e289.experimental || (e289.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e290) {
                    !function(t192) {
                        !function(t193) {
                            class n136 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsDimension(e, t) {
                                    return (t || new n136).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsDimension(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n136).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                value(t) {
                                    let n = this.bb.__offset(this.bb_pos, 4);
                                    return n ? (t || new e290.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                denotation(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                static startDimension(e) {
                                    e.startObject(2);
                                }
                                static addValue(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addDenotation(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static endDimension(e) {
                                    return e.endObject();
                                }
                                static createDimension(e, t, r) {
                                    return n136.startDimension(e), n136.addValue(e, t), n136.addDenotation(e, r), n136.endDimension(e);
                                }
                            }
                            t193.Dimension = n136;
                        }(t192.fbs || (t192.fbs = {}));
                    }(e290.experimental || (e290.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e291) {
                    !function(t194) {
                        !function(t195) {
                            class n137 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsDimensionValue(e, t) {
                                    return (t || new n137).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsDimensionValue(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n137).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                dimType() {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.readInt8(this.bb_pos + t) : e291.experimental.fbs.DimensionValueType.UNKNOWN;
                                }
                                dimValue() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);
                                }
                                dimParam(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                static startDimensionValue(e) {
                                    e.startObject(3);
                                }
                                static addDimType(t, n) {
                                    t.addFieldInt8(0, n, e291.experimental.fbs.DimensionValueType.UNKNOWN);
                                }
                                static addDimValue(e, t) {
                                    e.addFieldInt64(1, t, e.createLong(0, 0));
                                }
                                static addDimParam(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static endDimensionValue(e) {
                                    return e.endObject();
                                }
                                static createDimensionValue(e, t, r, i) {
                                    return n137.startDimensionValue(e), n137.addDimType(e, t), n137.addDimValue(e, r), n137.addDimParam(e, i), n137.endDimensionValue(e);
                                }
                            }
                            t195.DimensionValue = n137;
                        }(t194.fbs || (t194.fbs = {}));
                    }(e291.experimental || (e291.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e292) {
                    !function(t196) {
                        !function(t197) {
                            class n138 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsTensorTypeAndShape(e, t) {
                                    return (t || new n138).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsTensorTypeAndShape(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n138).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                elemType() {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.readInt32(this.bb_pos + t) : e292.experimental.fbs.TensorDataType.UNDEFINED;
                                }
                                shape(t) {
                                    let n = this.bb.__offset(this.bb_pos, 6);
                                    return n ? (t || new e292.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startTensorTypeAndShape(e) {
                                    e.startObject(2);
                                }
                                static addElemType(t, n) {
                                    t.addFieldInt32(0, n, e292.experimental.fbs.TensorDataType.UNDEFINED);
                                }
                                static addShape(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static endTensorTypeAndShape(e) {
                                    return e.endObject();
                                }
                                static createTensorTypeAndShape(e, t, r) {
                                    return n138.startTensorTypeAndShape(e), n138.addElemType(e, t), n138.addShape(e, r), n138.endTensorTypeAndShape(e);
                                }
                            }
                            t197.TensorTypeAndShape = n138;
                        }(t196.fbs || (t196.fbs = {}));
                    }(e292.experimental || (e292.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e293) {
                    !function(t198) {
                        !function(t199) {
                            class n139 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsMapType(e, t) {
                                    return (t || new n139).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsMapType(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n139).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                keyType() {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.readInt32(this.bb_pos + t) : e293.experimental.fbs.TensorDataType.UNDEFINED;
                                }
                                valueType(t) {
                                    let n = this.bb.__offset(this.bb_pos, 6);
                                    return n ? (t || new e293.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startMapType(e) {
                                    e.startObject(2);
                                }
                                static addKeyType(t, n) {
                                    t.addFieldInt32(0, n, e293.experimental.fbs.TensorDataType.UNDEFINED);
                                }
                                static addValueType(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static endMapType(e) {
                                    return e.endObject();
                                }
                                static createMapType(e, t, r) {
                                    return n139.startMapType(e), n139.addKeyType(e, t), n139.addValueType(e, r), n139.endMapType(e);
                                }
                            }
                            t199.MapType = n139;
                        }(t198.fbs || (t198.fbs = {}));
                    }(e293.experimental || (e293.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e294) {
                    !function(t200) {
                        !function(t201) {
                            class n140 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsSequenceType(e, t) {
                                    return (t || new n140).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsSequenceType(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n140).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                elemType(t) {
                                    let n = this.bb.__offset(this.bb_pos, 4);
                                    return n ? (t || new e294.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startSequenceType(e) {
                                    e.startObject(1);
                                }
                                static addElemType(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static endSequenceType(e) {
                                    return e.endObject();
                                }
                                static createSequenceType(e, t) {
                                    return n140.startSequenceType(e), n140.addElemType(e, t), n140.endSequenceType(e);
                                }
                            }
                            t201.SequenceType = n140;
                        }(t200.fbs || (t200.fbs = {}));
                    }(e294.experimental || (e294.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e295) {
                    !function(e296) {
                        (e296.fbs || (e296.fbs = {})).EdgeEnd = class {
                            constructor(){
                                this.bb = null, this.bb_pos = 0;
                            }
                            __init(e, t) {
                                return this.bb_pos = e, this.bb = t, this;
                            }
                            nodeIndex() {
                                return this.bb.readUint32(this.bb_pos);
                            }
                            srcArgIndex() {
                                return this.bb.readInt32(this.bb_pos + 4);
                            }
                            dstArgIndex() {
                                return this.bb.readInt32(this.bb_pos + 8);
                            }
                            static createEdgeEnd(e, t, n, r) {
                                return e.prep(4, 12), e.writeInt32(r), e.writeInt32(n), e.writeInt32(t), e.offset();
                            }
                        };
                    }(e295.experimental || (e295.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e297) {
                    !function(t202) {
                        !function(t203) {
                            class n141 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsNodeEdge(e, t) {
                                    return (t || new n141).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsNodeEdge(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n141).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                nodeIndex() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? this.bb.readUint32(this.bb_pos + e) : 0;
                                }
                                inputEdges(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 6);
                                    return r ? (n || new e297.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r) + 12 * t, this.bb) : null;
                                }
                                inputEdgesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                outputEdges(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 8);
                                    return r ? (n || new e297.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r) + 12 * t, this.bb) : null;
                                }
                                outputEdgesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 8);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startNodeEdge(e) {
                                    e.startObject(3);
                                }
                                static addNodeIndex(e, t) {
                                    e.addFieldInt32(0, t, 0);
                                }
                                static addInputEdges(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static startInputEdgesVector(e, t) {
                                    e.startVector(12, t, 4);
                                }
                                static addOutputEdges(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static startOutputEdgesVector(e, t) {
                                    e.startVector(12, t, 4);
                                }
                                static endNodeEdge(e) {
                                    return e.endObject();
                                }
                                static createNodeEdge(e, t, r, i) {
                                    return n141.startNodeEdge(e), n141.addNodeIndex(e, t), n141.addInputEdges(e, r), n141.addOutputEdges(e, i), n141.endNodeEdge(e);
                                }
                            }
                            t203.NodeEdge = n141;
                        }(t202.fbs || (t202.fbs = {}));
                    }(e297.experimental || (e297.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e298) {
                    !function(t204) {
                        !function(t205) {
                            class n142 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsNode(e, t) {
                                    return (t || new n142).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsNode(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n142).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                name(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                docString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                domain(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                sinceVersion() {
                                    let e = this.bb.__offset(this.bb_pos, 10);
                                    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
                                }
                                index() {
                                    let e = this.bb.__offset(this.bb_pos, 12);
                                    return e ? this.bb.readUint32(this.bb_pos + e) : 0;
                                }
                                opType(e) {
                                    let t = this.bb.__offset(this.bb_pos, 14);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                type() {
                                    let t = this.bb.__offset(this.bb_pos, 16);
                                    return t ? this.bb.readInt32(this.bb_pos + t) : e298.experimental.fbs.NodeType.Primitive;
                                }
                                executionProviderType(e) {
                                    let t = this.bb.__offset(this.bb_pos, 18);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                inputs(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 20);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                inputsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 20);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                outputs(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 22);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                outputsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 22);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                attributes(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 24);
                                    return r ? (n || new e298.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                attributesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 24);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                inputArgCounts(e) {
                                    let t = this.bb.__offset(this.bb_pos, 26);
                                    return t ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
                                }
                                inputArgCountsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 26);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                inputArgCountsArray() {
                                    let e = this.bb.__offset(this.bb_pos, 26);
                                    return e ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
                                }
                                implicitInputs(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 28);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                implicitInputsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 28);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startNode(e) {
                                    e.startObject(13);
                                }
                                static addName(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addDocString(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addDomain(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static addSinceVersion(e, t) {
                                    e.addFieldInt32(3, t, 0);
                                }
                                static addIndex(e, t) {
                                    e.addFieldInt32(4, t, 0);
                                }
                                static addOpType(e, t) {
                                    e.addFieldOffset(5, t, 0);
                                }
                                static addType(t, n) {
                                    t.addFieldInt32(6, n, e298.experimental.fbs.NodeType.Primitive);
                                }
                                static addExecutionProviderType(e, t) {
                                    e.addFieldOffset(7, t, 0);
                                }
                                static addInputs(e, t) {
                                    e.addFieldOffset(8, t, 0);
                                }
                                static createInputsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startInputsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addOutputs(e, t) {
                                    e.addFieldOffset(9, t, 0);
                                }
                                static createOutputsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startOutputsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addAttributes(e, t) {
                                    e.addFieldOffset(10, t, 0);
                                }
                                static createAttributesVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startAttributesVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addInputArgCounts(e, t) {
                                    e.addFieldOffset(11, t, 0);
                                }
                                static createInputArgCountsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt32(t[n]);
                                    return e.endVector();
                                }
                                static startInputArgCountsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addImplicitInputs(e, t) {
                                    e.addFieldOffset(12, t, 0);
                                }
                                static createImplicitInputsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startImplicitInputsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endNode(e) {
                                    return e.endObject();
                                }
                                static createNode(e, t, r, i, o, s, a, u, l, c, p, d, f, h) {
                                    return n142.startNode(e), n142.addName(e, t), n142.addDocString(e, r), n142.addDomain(e, i), n142.addSinceVersion(e, o), n142.addIndex(e, s), n142.addOpType(e, a), n142.addType(e, u), n142.addExecutionProviderType(e, l), n142.addInputs(e, c), n142.addOutputs(e, p), n142.addAttributes(e, d), n142.addInputArgCounts(e, f), n142.addImplicitInputs(e, h), n142.endNode(e);
                                }
                            }
                            t205.Node = n142;
                        }(t204.fbs || (t204.fbs = {}));
                    }(e298.experimental || (e298.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e299) {
                    !function(t206) {
                        !function(t207) {
                            class n143 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsValueInfo(e, t) {
                                    return (t || new n143).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsValueInfo(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n143).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                name(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                docString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                type(t) {
                                    let n = this.bb.__offset(this.bb_pos, 8);
                                    return n ? (t || new e299.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startValueInfo(e) {
                                    e.startObject(3);
                                }
                                static addName(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addDocString(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addType(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static endValueInfo(e) {
                                    return e.endObject();
                                }
                                static createValueInfo(e, t, r, i) {
                                    return n143.startValueInfo(e), n143.addName(e, t), n143.addDocString(e, r), n143.addType(e, i), n143.endValueInfo(e);
                                }
                            }
                            t207.ValueInfo = n143;
                        }(t206.fbs || (t206.fbs = {}));
                    }(e299.experimental || (e299.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e300) {
                    !function(t208) {
                        !function(t209) {
                            class n144 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsTypeInfo(e, t) {
                                    return (t || new n144).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsTypeInfo(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n144).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                denotation(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                valueType() {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.readUint8(this.bb_pos + t) : e300.experimental.fbs.TypeInfoValue.NONE;
                                }
                                value(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.__union(e, this.bb_pos + t) : null;
                                }
                                static startTypeInfo(e) {
                                    e.startObject(3);
                                }
                                static addDenotation(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addValueType(t, n) {
                                    t.addFieldInt8(1, n, e300.experimental.fbs.TypeInfoValue.NONE);
                                }
                                static addValue(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static endTypeInfo(e) {
                                    return e.endObject();
                                }
                                static createTypeInfo(e, t, r, i) {
                                    return n144.startTypeInfo(e), n144.addDenotation(e, t), n144.addValueType(e, r), n144.addValue(e, i), n144.endTypeInfo(e);
                                }
                            }
                            t209.TypeInfo = n144;
                        }(t208.fbs || (t208.fbs = {}));
                    }(e300.experimental || (e300.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e301) {
                    !function(e302) {
                        !function(e303) {
                            class t210 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsOperatorSetId(e, n) {
                                    return (n || new t210).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsOperatorSetId(e, n) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (n || new t210).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                domain(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                version() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);
                                }
                                static startOperatorSetId(e) {
                                    e.startObject(2);
                                }
                                static addDomain(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addVersion(e, t) {
                                    e.addFieldInt64(1, t, e.createLong(0, 0));
                                }
                                static endOperatorSetId(e) {
                                    return e.endObject();
                                }
                                static createOperatorSetId(e, n, r) {
                                    return t210.startOperatorSetId(e), t210.addDomain(e, n), t210.addVersion(e, r), t210.endOperatorSetId(e);
                                }
                            }
                            e303.OperatorSetId = t210;
                        }(e302.fbs || (e302.fbs = {}));
                    }(e301.experimental || (e301.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e304) {
                    !function(t211) {
                        !function(t212) {
                            class n145 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsTensor(e, t) {
                                    return (t || new n145).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsTensor(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n145).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                name(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                docString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                dims(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);
                                }
                                dimsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 8);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                dataType() {
                                    let t = this.bb.__offset(this.bb_pos, 10);
                                    return t ? this.bb.readInt32(this.bb_pos + t) : e304.experimental.fbs.TensorDataType.UNDEFINED;
                                }
                                rawData(e) {
                                    let t = this.bb.__offset(this.bb_pos, 12);
                                    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
                                }
                                rawDataLength() {
                                    let e = this.bb.__offset(this.bb_pos, 12);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                rawDataArray() {
                                    let e = this.bb.__offset(this.bb_pos, 12);
                                    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
                                }
                                stringData(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 14);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                stringDataLength() {
                                    let e = this.bb.__offset(this.bb_pos, 14);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startTensor(e) {
                                    e.startObject(6);
                                }
                                static addName(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addDocString(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addDims(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static createDimsVector(e, t) {
                                    e.startVector(8, t.length, 8);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt64(t[n]);
                                    return e.endVector();
                                }
                                static startDimsVector(e, t) {
                                    e.startVector(8, t, 8);
                                }
                                static addDataType(t, n) {
                                    t.addFieldInt32(3, n, e304.experimental.fbs.TensorDataType.UNDEFINED);
                                }
                                static addRawData(e, t) {
                                    e.addFieldOffset(4, t, 0);
                                }
                                static createRawDataVector(e, t) {
                                    e.startVector(1, t.length, 1);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt8(t[n]);
                                    return e.endVector();
                                }
                                static startRawDataVector(e, t) {
                                    e.startVector(1, t, 1);
                                }
                                static addStringData(e, t) {
                                    e.addFieldOffset(5, t, 0);
                                }
                                static createStringDataVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startStringDataVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endTensor(e) {
                                    return e.endObject();
                                }
                                static createTensor(e, t, r, i, o, s, a) {
                                    return n145.startTensor(e), n145.addName(e, t), n145.addDocString(e, r), n145.addDims(e, i), n145.addDataType(e, o), n145.addRawData(e, s), n145.addStringData(e, a), n145.endTensor(e);
                                }
                            }
                            t212.Tensor = n145;
                        }(t211.fbs || (t211.fbs = {}));
                    }(e304.experimental || (e304.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e305) {
                    !function(t213) {
                        !function(t214) {
                            class n146 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsSparseTensor(e, t) {
                                    return (t || new n146).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsSparseTensor(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n146).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                values(t) {
                                    let n = this.bb.__offset(this.bb_pos, 4);
                                    return n ? (t || new e305.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                indices(t) {
                                    let n = this.bb.__offset(this.bb_pos, 6);
                                    return n ? (t || new e305.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                dims(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);
                                }
                                dimsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 8);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startSparseTensor(e) {
                                    e.startObject(3);
                                }
                                static addValues(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addIndices(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addDims(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static createDimsVector(e, t) {
                                    e.startVector(8, t.length, 8);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt64(t[n]);
                                    return e.endVector();
                                }
                                static startDimsVector(e, t) {
                                    e.startVector(8, t, 8);
                                }
                                static endSparseTensor(e) {
                                    return e.endObject();
                                }
                                static createSparseTensor(e, t, r, i) {
                                    return n146.startSparseTensor(e), n146.addValues(e, t), n146.addIndices(e, r), n146.addDims(e, i), n146.endSparseTensor(e);
                                }
                            }
                            t214.SparseTensor = n146;
                        }(t213.fbs || (t213.fbs = {}));
                    }(e305.experimental || (e305.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e306) {
                    !function(t215) {
                        !function(t216) {
                            class n147 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsAttribute(e, t) {
                                    return (t || new n147).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsAttribute(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n147).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                name(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                docString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                type() {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.readInt32(this.bb_pos + t) : e306.experimental.fbs.AttributeType.UNDEFINED;
                                }
                                f() {
                                    let e = this.bb.__offset(this.bb_pos, 10);
                                    return e ? this.bb.readFloat32(this.bb_pos + e) : 0;
                                }
                                i() {
                                    let e = this.bb.__offset(this.bb_pos, 12);
                                    return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);
                                }
                                s(e) {
                                    let t = this.bb.__offset(this.bb_pos, 14);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                t(t) {
                                    let n = this.bb.__offset(this.bb_pos, 16);
                                    return n ? (t || new e306.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                g(t) {
                                    let n = this.bb.__offset(this.bb_pos, 18);
                                    return n ? (t || new e306.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                floats(e) {
                                    let t = this.bb.__offset(this.bb_pos, 20);
                                    return t ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
                                }
                                floatsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 20);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                floatsArray() {
                                    let e = this.bb.__offset(this.bb_pos, 20);
                                    return e ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
                                }
                                ints(e) {
                                    let t = this.bb.__offset(this.bb_pos, 22);
                                    return t ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);
                                }
                                intsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 22);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                strings(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 24);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                stringsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 24);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                tensors(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 26);
                                    return r ? (n || new e306.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                tensorsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 26);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                graphs(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 28);
                                    return r ? (n || new e306.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                graphsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 28);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startAttribute(e) {
                                    e.startObject(13);
                                }
                                static addName(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addDocString(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addType(t, n) {
                                    t.addFieldInt32(2, n, e306.experimental.fbs.AttributeType.UNDEFINED);
                                }
                                static addF(e, t) {
                                    e.addFieldFloat32(3, t, 0);
                                }
                                static addI(e, t) {
                                    e.addFieldInt64(4, t, e.createLong(0, 0));
                                }
                                static addS(e, t) {
                                    e.addFieldOffset(5, t, 0);
                                }
                                static addT(e, t) {
                                    e.addFieldOffset(6, t, 0);
                                }
                                static addG(e, t) {
                                    e.addFieldOffset(7, t, 0);
                                }
                                static addFloats(e, t) {
                                    e.addFieldOffset(8, t, 0);
                                }
                                static createFloatsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addFloat32(t[n]);
                                    return e.endVector();
                                }
                                static startFloatsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addInts(e, t) {
                                    e.addFieldOffset(9, t, 0);
                                }
                                static createIntsVector(e, t) {
                                    e.startVector(8, t.length, 8);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt64(t[n]);
                                    return e.endVector();
                                }
                                static startIntsVector(e, t) {
                                    e.startVector(8, t, 8);
                                }
                                static addStrings(e, t) {
                                    e.addFieldOffset(10, t, 0);
                                }
                                static createStringsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startStringsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addTensors(e, t) {
                                    e.addFieldOffset(11, t, 0);
                                }
                                static createTensorsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startTensorsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addGraphs(e, t) {
                                    e.addFieldOffset(12, t, 0);
                                }
                                static createGraphsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startGraphsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endAttribute(e) {
                                    return e.endObject();
                                }
                                static createAttribute(e, t, r, i, o, s, a, u, l, c, p, d, f, h) {
                                    return n147.startAttribute(e), n147.addName(e, t), n147.addDocString(e, r), n147.addType(e, i), n147.addF(e, o), n147.addI(e, s), n147.addS(e, a), n147.addT(e, u), n147.addG(e, l), n147.addFloats(e, c), n147.addInts(e, p), n147.addStrings(e, d), n147.addTensors(e, f), n147.addGraphs(e, h), n147.endAttribute(e);
                                }
                            }
                            t216.Attribute = n147;
                        }(t215.fbs || (t215.fbs = {}));
                    }(e306.experimental || (e306.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e307) {
                    !function(t217) {
                        !function(t218) {
                            class n148 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsGraph(e, t) {
                                    return (t || new n148).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsGraph(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n148).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                initializers(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 4);
                                    return r ? (n || new e307.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                initializersLength() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                nodeArgs(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 6);
                                    return r ? (n || new e307.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                nodeArgsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                nodes(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 8);
                                    return r ? (n || new e307.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                nodesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 8);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                maxNodeIndex() {
                                    let e = this.bb.__offset(this.bb_pos, 10);
                                    return e ? this.bb.readUint32(this.bb_pos + e) : 0;
                                }
                                nodeEdges(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 12);
                                    return r ? (n || new e307.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                nodeEdgesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 12);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                inputs(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 14);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                inputsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 14);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                outputs(e, t) {
                                    let n = this.bb.__offset(this.bb_pos, 16);
                                    return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * e, t) : null;
                                }
                                outputsLength() {
                                    let e = this.bb.__offset(this.bb_pos, 16);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                sparseInitializers(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 18);
                                    return r ? (n || new e307.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                sparseInitializersLength() {
                                    let e = this.bb.__offset(this.bb_pos, 18);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startGraph(e) {
                                    e.startObject(8);
                                }
                                static addInitializers(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static createInitializersVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startInitializersVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addNodeArgs(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static createNodeArgsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startNodeArgsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addNodes(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static createNodesVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startNodesVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addMaxNodeIndex(e, t) {
                                    e.addFieldInt32(3, t, 0);
                                }
                                static addNodeEdges(e, t) {
                                    e.addFieldOffset(4, t, 0);
                                }
                                static createNodeEdgesVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startNodeEdgesVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addInputs(e, t) {
                                    e.addFieldOffset(5, t, 0);
                                }
                                static createInputsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startInputsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addOutputs(e, t) {
                                    e.addFieldOffset(6, t, 0);
                                }
                                static createOutputsVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startOutputsVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addSparseInitializers(e, t) {
                                    e.addFieldOffset(7, t, 0);
                                }
                                static createSparseInitializersVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startSparseInitializersVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endGraph(e) {
                                    return e.endObject();
                                }
                                static createGraph(e, t, r, i, o, s, a, u, l) {
                                    return n148.startGraph(e), n148.addInitializers(e, t), n148.addNodeArgs(e, r), n148.addNodes(e, i), n148.addMaxNodeIndex(e, o), n148.addNodeEdges(e, s), n148.addInputs(e, a), n148.addOutputs(e, u), n148.addSparseInitializers(e, l), n148.endGraph(e);
                                }
                            }
                            t218.Graph = n148;
                        }(t217.fbs || (t217.fbs = {}));
                    }(e307.experimental || (e307.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e308) {
                    !function(t219) {
                        !function(t220) {
                            class n149 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsModel(e, t) {
                                    return (t || new n149).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsModel(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n149).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                irVersion() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);
                                }
                                opsetImport(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 6);
                                    return r ? (n || new e308.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                opsetImportLength() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                producerName(e) {
                                    let t = this.bb.__offset(this.bb_pos, 8);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                producerVersion(e) {
                                    let t = this.bb.__offset(this.bb_pos, 10);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                domain(e) {
                                    let t = this.bb.__offset(this.bb_pos, 12);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                modelVersion() {
                                    let e = this.bb.__offset(this.bb_pos, 14);
                                    return e ? this.bb.readInt64(this.bb_pos + e) : this.bb.createLong(0, 0);
                                }
                                docString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 16);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                graph(t) {
                                    let n = this.bb.__offset(this.bb_pos, 18);
                                    return n ? (t || new e308.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                graphDocString(e) {
                                    let t = this.bb.__offset(this.bb_pos, 20);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                static startModel(e) {
                                    e.startObject(9);
                                }
                                static addIrVersion(e, t) {
                                    e.addFieldInt64(0, t, e.createLong(0, 0));
                                }
                                static addOpsetImport(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static createOpsetImportVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startOpsetImportVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addProducerName(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static addProducerVersion(e, t) {
                                    e.addFieldOffset(3, t, 0);
                                }
                                static addDomain(e, t) {
                                    e.addFieldOffset(4, t, 0);
                                }
                                static addModelVersion(e, t) {
                                    e.addFieldInt64(5, t, e.createLong(0, 0));
                                }
                                static addDocString(e, t) {
                                    e.addFieldOffset(6, t, 0);
                                }
                                static addGraph(e, t) {
                                    e.addFieldOffset(7, t, 0);
                                }
                                static addGraphDocString(e, t) {
                                    e.addFieldOffset(8, t, 0);
                                }
                                static endModel(e) {
                                    return e.endObject();
                                }
                                static createModel(e, t, r, i, o, s, a, u, l, c) {
                                    return n149.startModel(e), n149.addIrVersion(e, t), n149.addOpsetImport(e, r), n149.addProducerName(e, i), n149.addProducerVersion(e, o), n149.addDomain(e, s), n149.addModelVersion(e, a), n149.addDocString(e, u), n149.addGraph(e, l), n149.addGraphDocString(e, c), n149.endModel(e);
                                }
                            }
                            t220.Model = n149;
                        }(t219.fbs || (t219.fbs = {}));
                    }(e308.experimental || (e308.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e309) {
                    !function(e310) {
                        !function(e311) {
                            class t221 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsKernelCreateInfos(e, n) {
                                    return (n || new t221).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsKernelCreateInfos(e, n) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (n || new t221).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                nodeIndices(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
                                }
                                nodeIndicesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                nodeIndicesArray() {
                                    let e = this.bb.__offset(this.bb_pos, 4);
                                    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
                                }
                                kernelDefHashes(e) {
                                    let t = this.bb.__offset(this.bb_pos, 6);
                                    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : this.bb.createLong(0, 0);
                                }
                                kernelDefHashesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startKernelCreateInfos(e) {
                                    e.startObject(2);
                                }
                                static addNodeIndices(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static createNodeIndicesVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt32(t[n]);
                                    return e.endVector();
                                }
                                static startNodeIndicesVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static addKernelDefHashes(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static createKernelDefHashesVector(e, t) {
                                    e.startVector(8, t.length, 8);
                                    for(let n = t.length - 1; n >= 0; n--)e.addInt64(t[n]);
                                    return e.endVector();
                                }
                                static startKernelDefHashesVector(e, t) {
                                    e.startVector(8, t, 8);
                                }
                                static endKernelCreateInfos(e) {
                                    return e.endObject();
                                }
                                static createKernelCreateInfos(e, n, r) {
                                    return t221.startKernelCreateInfos(e), t221.addNodeIndices(e, n), t221.addKernelDefHashes(e, r), t221.endKernelCreateInfos(e);
                                }
                            }
                            e311.KernelCreateInfos = t221;
                        }(e310.fbs || (e310.fbs = {}));
                    }(e309.experimental || (e309.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e312) {
                    !function(t222) {
                        !function(t223) {
                            class n150 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsSubGraphSessionState(e, t) {
                                    return (t || new n150).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsSubGraphSessionState(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n150).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                graphId(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                sessionState(t) {
                                    let n = this.bb.__offset(this.bb_pos, 6);
                                    return n ? (t || new e312.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startSubGraphSessionState(e) {
                                    e.startObject(2);
                                }
                                static addGraphId(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addSessionState(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static endSubGraphSessionState(e) {
                                    let t = e.endObject();
                                    return e.requiredField(t, 4), t;
                                }
                                static createSubGraphSessionState(e, t, r) {
                                    return n150.startSubGraphSessionState(e), n150.addGraphId(e, t), n150.addSessionState(e, r), n150.endSubGraphSessionState(e);
                                }
                            }
                            t223.SubGraphSessionState = n150;
                        }(t222.fbs || (t222.fbs = {}));
                    }(e312.experimental || (e312.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e313) {
                    !function(t224) {
                        !function(t225) {
                            class n151 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsSessionState(e, t) {
                                    return (t || new n151).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsSessionState(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n151).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                kernels(t) {
                                    let n = this.bb.__offset(this.bb_pos, 4);
                                    return n ? (t || new e313.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                subGraphSessionStates(t, n) {
                                    let r = this.bb.__offset(this.bb_pos, 6);
                                    return r ? (n || new e313.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * t), this.bb) : null;
                                }
                                subGraphSessionStatesLength() {
                                    let e = this.bb.__offset(this.bb_pos, 6);
                                    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
                                }
                                static startSessionState(e) {
                                    e.startObject(2);
                                }
                                static addKernels(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addSubGraphSessionStates(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static createSubGraphSessionStatesVector(e, t) {
                                    e.startVector(4, t.length, 4);
                                    for(let n = t.length - 1; n >= 0; n--)e.addOffset(t[n]);
                                    return e.endVector();
                                }
                                static startSubGraphSessionStatesVector(e, t) {
                                    e.startVector(4, t, 4);
                                }
                                static endSessionState(e) {
                                    return e.endObject();
                                }
                                static createSessionState(e, t, r) {
                                    return n151.startSessionState(e), n151.addKernels(e, t), n151.addSubGraphSessionStates(e, r), n151.endSessionState(e);
                                }
                            }
                            t225.SessionState = n151;
                        }(t224.fbs || (t224.fbs = {}));
                    }(e313.experimental || (e313.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {})), function(e314) {
                    !function(t226) {
                        !function(t227) {
                            class n152 {
                                constructor(){
                                    this.bb = null, this.bb_pos = 0;
                                }
                                __init(e, t) {
                                    return this.bb_pos = e, this.bb = t, this;
                                }
                                static getRootAsInferenceSession(e, t) {
                                    return (t || new n152).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static getSizePrefixedRootAsInferenceSession(e, t) {
                                    return e.setPosition(e.position() + r77.flatbuffers.SIZE_PREFIX_LENGTH), (t || new n152).__init(e.readInt32(e.position()) + e.position(), e);
                                }
                                static bufferHasIdentifier(e) {
                                    return e.__has_identifier("ORTM");
                                }
                                ortVersion(e) {
                                    let t = this.bb.__offset(this.bb_pos, 4);
                                    return t ? this.bb.__string(this.bb_pos + t, e) : null;
                                }
                                model(t) {
                                    let n = this.bb.__offset(this.bb_pos, 6);
                                    return n ? (t || new e314.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                sessionState(t) {
                                    let n = this.bb.__offset(this.bb_pos, 8);
                                    return n ? (t || new e314.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;
                                }
                                static startInferenceSession(e) {
                                    e.startObject(3);
                                }
                                static addOrtVersion(e, t) {
                                    e.addFieldOffset(0, t, 0);
                                }
                                static addModel(e, t) {
                                    e.addFieldOffset(1, t, 0);
                                }
                                static addSessionState(e, t) {
                                    e.addFieldOffset(2, t, 0);
                                }
                                static endInferenceSession(e) {
                                    return e.endObject();
                                }
                                static finishInferenceSessionBuffer(e, t) {
                                    e.finish(t, "ORTM");
                                }
                                static finishSizePrefixedInferenceSessionBuffer(e, t) {
                                    e.finish(t, "ORTM", !0);
                                }
                                static createInferenceSession(e, t, r, i) {
                                    return n152.startInferenceSession(e), n152.addOrtVersion(e, t), n152.addModel(e, r), n152.addSessionState(e, i), n152.endInferenceSession(e);
                                }
                            }
                            t227.InferenceSession = n152;
                        }(t226.fbs || (t226.fbs = {}));
                    }(e314.experimental || (e314.experimental = {}));
                }(t189.onnxruntime || (t189.onnxruntime = {}));
            },
            7448: (e315, t229, n153)=>{
                "use strict";
                Object.defineProperty(t229, "__esModule", {
                    value: !0
                }), t229.OnnxjsSessionHandler = void 0;
                const r = n153(2174), i = n153(9162);
                t229.OnnxjsSessionHandler = class {
                    constructor(e){
                        this.session = e, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
                    }
                    async dispose() {}
                    async run(e316, t230, n) {
                        const o = new Map;
                        for(const t228 in e316)if (Object.hasOwnProperty.call(e316, t228)) {
                            const n = e316[t228];
                            o.set(t228, new i.Tensor(n.dims, n.type, void 0, void 0, n.data));
                        }
                        const s = await this.session.run(o), a = {};
                        return s.forEach((e, t)=>{
                            a[t] = new r.Tensor(e.type, e.data, e.dims);
                        }), a;
                    }
                    startProfiling() {
                        this.session.startProfiling();
                    }
                    endProfiling() {
                        this.session.endProfiling();
                    }
                };
            },
            6919: (e317, t231, n154)=>{
                "use strict";
                Object.defineProperty(t231, "__esModule", {
                    value: !0
                }), t231.Session = void 0;
                const r78 = n154(7067), i50 = n154(1296), o42 = n154(7091), s34 = n154(1036), a = n154(6231), u = n154(2644);
                t231.Session = class {
                    constructor(e = {}){
                        this._initialized = !1, this.backendHint = e.backendHint, this.profiler = a.Profiler.create(e.profiler), this.context = {
                            profiler: this.profiler,
                            graphInputTypes: [],
                            graphInputDims: []
                        };
                    }
                    get inputNames() {
                        return this._model.graph.getInputNames();
                    }
                    get outputNames() {
                        return this._model.graph.getOutputNames();
                    }
                    startProfiling() {
                        this.profiler.start();
                    }
                    endProfiling() {
                        this.profiler.stop();
                    }
                    async loadModel(e, t232, n155) {
                        await this.profiler.event("session", "Session.loadModel", async ()=>{
                            const s = await o42.resolveBackend(this.backendHint);
                            if (this.sessionHandler = s.createSessionHandler(this.context), this._model = new u.Model, "string" == typeof e) {
                                const t = e.endsWith(".ort");
                                if ("undefined" == typeof fetch) {
                                    const n = await i50.promisify(r78.readFile)(e);
                                    this.initialize(n, t);
                                } else {
                                    const n = await fetch(e), r = await n.arrayBuffer();
                                    this.initialize(new Uint8Array(r), t);
                                }
                            } else if (ArrayBuffer.isView(e)) this.initialize(e);
                            else {
                                const r = new Uint8Array(e, t232 || 0, n155 || e.byteLength);
                                this.initialize(r);
                            }
                        });
                    }
                    initialize(e, t) {
                        if (this._initialized) throw new Error("already initialized");
                        this.profiler.event("session", "Session.initialize", ()=>{
                            const n = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                            this._model.load(e, n, t), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new s34.ExecutionPlan(this._model.graph, this._ops, this.profiler);
                        }), this._initialized = !0;
                    }
                    async run(e) {
                        if (!this._initialized) throw new Error("session not initialized yet");
                        return this.profiler.event("session", "Session.run", async ()=>{
                            const t = this.normalizeAndValidateInputs(e), n = await this._executionPlan.execute(this.sessionHandler, t);
                            return this.createOutput(n);
                        });
                    }
                    normalizeAndValidateInputs(e) {
                        const t = this._model.graph.getInputNames();
                        if (Array.isArray(e)) {
                            if (e.length !== t.length) throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`);
                        } else {
                            if (e.size !== t.length) throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);
                            const n = new Array(e.size);
                            let r = 0;
                            for(let i = 0; i < t.length; ++i){
                                const o = e.get(t[i]);
                                if (!o) throw new Error(`missing input tensor for: '${name}'`);
                                n[r++] = o;
                            }
                            e = n;
                        }
                        if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, e, !1);
                        else {
                            const t = this._model.graph.getInputIndices(), n = this._model.graph.getValues(), r = new Array(t.length);
                            for(let i = 0; i < t.length; ++i){
                                const o = n[t[i]];
                                r[i] = o.type.shape.dims, this.context.graphInputTypes.push(o.type.tensorType), this.context.graphInputDims.push(e[i].dims);
                            }
                            this.validateInputTensorDims(r, e, !0);
                        }
                        return this.validateInputTensorTypes(this.context.graphInputTypes, e), e;
                    }
                    validateInputTensorTypes(e, t) {
                        for(let n = 0; n < t.length; n++){
                            const r = e[n], i = t[n].type;
                            if (r !== i) throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`);
                        }
                    }
                    validateInputTensorDims(e, t, n) {
                        for(let r = 0; r < t.length; r++){
                            const i = e[r], o = t[r].dims;
                            if (!this.compareTensorDims(i, o, n)) throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(",")}]' but got [${o.join(",")}]`);
                        }
                    }
                    compareTensorDims(e, t, n) {
                        if (e.length !== t.length) return !1;
                        for(let r = 0; r < e.length; ++r)if (e[r] !== t[r] && (!n || 0 !== e[r])) return !1;
                        return !0;
                    }
                    createOutput(e) {
                        const t = this._model.graph.getOutputNames();
                        if (e.length !== t.length) throw new Error("expected number of outputs do not match number of generated outputs");
                        const n = new Map;
                        for(let r = 0; r < t.length; ++r)n.set(t[r], e[r]);
                        return n;
                    }
                    initializeOps(e) {
                        const t = e.getNodes();
                        this._ops = new Array(t.length);
                        for(let n = 0; n < t.length; n++)this._ops[n] = this.sessionHandler.resolve(t[n], this._model.opsets, e);
                    }
                };
            },
            9162: function(e318, t233, n156) {
                "use strict";
                var r79 = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                };
                Object.defineProperty(t233, "__esModule", {
                    value: !0
                }), t233.Tensor = void 0;
                const i51 = n156(3442), o43 = r79(n156(3720)), s35 = n156(1446);
                var a30 = n156(9395).onnxruntime.experimental.fbs;
                const u = n156(2517);
                class l23 {
                    constructor(e319, t234, n, r, o, s = i51.Guid.create()){
                        this.dims = e319, this.type = t234, this.dataProvider = n, this.asyncDataProvider = r, this.cache = o, this.dataId = s, this.size = u.ShapeUtil.validateDimsAndCalcSize(e319);
                        const a = this.size, l = void 0 === n && void 0 === r && void 0 === o;
                        if (void 0 !== o && o.length !== a) throw new RangeError("Input dims doesn't match data length.");
                        if ("string" === t234) {
                            if (!(void 0 === o || Array.isArray(o) && o.every((e)=>"string" == typeof e
                            ))) throw new TypeError("cache should be a string array");
                            l && (this.cache = new Array(a));
                        } else {
                            if (void 0 !== o) {
                                const e = p(t234);
                                if (!(o instanceof e)) throw new TypeError(`cache should be type ${e.name}`);
                            }
                            if (l) {
                                const e320 = new ArrayBuffer(a * function(e) {
                                    switch(e){
                                        case "bool":
                                        case "int8":
                                        case "uint8":
                                            return 1;
                                        case "int16":
                                        case "uint16":
                                            return 2;
                                        case "int32":
                                        case "uint32":
                                        case "float32":
                                            return 4;
                                        case "float64":
                                            return 8;
                                        default:
                                            throw new Error(`cannot calculate sizeof() on type ${e}`);
                                    }
                                }(t234));
                                this.cache = function(e, t) {
                                    return new (p(t))(e);
                                }(e320, t234);
                            }
                        }
                    }
                    get data() {
                        if (void 0 === this.cache) {
                            const e = this.dataProvider(this.dataId);
                            if (e.length !== this.size) throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                            this.cache = e;
                        }
                        return this.cache;
                    }
                    get stringData() {
                        if ("string" !== this.type) throw new TypeError("data type is not string");
                        return this.data;
                    }
                    get integerData() {
                        switch(this.type){
                            case "uint8":
                            case "int8":
                            case "uint16":
                            case "int16":
                            case "int32":
                            case "uint32":
                            case "bool":
                                return this.data;
                            default:
                                throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
                        }
                    }
                    get floatData() {
                        switch(this.type){
                            case "float32":
                            case "float64":
                                return this.data;
                            default:
                                throw new TypeError("data type is not float (float32, float64)");
                        }
                    }
                    get numberData() {
                        if ("string" !== this.type) return this.data;
                        throw new TypeError("type cannot be non-number (string)");
                    }
                    get(e) {
                        return this.data[u.ShapeUtil.indicesToOffset(e, this.strides)];
                    }
                    set(e, t) {
                        this.data[u.ShapeUtil.indicesToOffset(e, this.strides)] = t;
                    }
                    async getData() {
                        return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
                    }
                    get strides() {
                        return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
                    }
                    static fromProto(e323) {
                        if (!e323) throw new Error("cannot construct Value from an empty tensor");
                        const t235 = u.ProtoUtil.tensorDataTypeFromProto(e323.dataType), n = u.ProtoUtil.tensorDimsFromProto(e323.dims), r = new l23(n, t235);
                        if ("string" === t235) e323.stringData.forEach((e, t)=>{
                            r.data[t] = u.decodeUtf8String(e);
                        });
                        else if (e323.rawData && "number" == typeof e323.rawData.byteLength && e323.rawData.byteLength > 0) {
                            const t = r.data, n = new DataView(e323.rawData.buffer, e323.rawData.byteOffset, e323.rawData.byteLength), i = c(e323.dataType), o = e323.rawData.byteLength / i;
                            if (e323.rawData.byteLength % i != 0) throw new Error("invalid buffer length");
                            if (t.length !== o) throw new Error("buffer length mismatch");
                            for(let r80 = 0; r80 < o; r80++){
                                const o = f(n, e323.dataType, r80 * i);
                                t[r80] = o;
                            }
                        } else {
                            let t;
                            switch(e323.dataType){
                                case s35.onnx.TensorProto.DataType.FLOAT:
                                    t = e323.floatData;
                                    break;
                                case s35.onnx.TensorProto.DataType.INT32:
                                case s35.onnx.TensorProto.DataType.INT16:
                                case s35.onnx.TensorProto.DataType.UINT16:
                                case s35.onnx.TensorProto.DataType.INT8:
                                case s35.onnx.TensorProto.DataType.UINT8:
                                case s35.onnx.TensorProto.DataType.BOOL:
                                    t = e323.int32Data;
                                    break;
                                case s35.onnx.TensorProto.DataType.INT64:
                                    t = e323.int64Data;
                                    break;
                                case s35.onnx.TensorProto.DataType.DOUBLE:
                                    t = e323.doubleData;
                                    break;
                                case s35.onnx.TensorProto.DataType.UINT32:
                                case s35.onnx.TensorProto.DataType.UINT64:
                                    t = e323.uint64Data;
                                    break;
                                default:
                                    throw new Error("unspecific error");
                            }
                            if (null == t) throw new Error("failed to populate data from a tensorproto value");
                            const n = r.data;
                            if (n.length !== t.length) throw new Error("array length mismatch");
                            for(let r81 = 0; r81 < t.length; r81++){
                                const i = t[r81];
                                o43.default.isLong(i) ? n[r81] = d(i, e323.dataType) : n[r81] = i;
                            }
                        }
                        return r;
                    }
                    static fromData(e, t, n) {
                        return new l23(t, n, void 0, void 0, e);
                    }
                    static fromOrtTensor(e) {
                        if (!e) throw new Error("cannot construct Value from an empty tensor");
                        const t = u.ProtoUtil.tensorDimsFromORTFormat(e), n = u.ProtoUtil.tensorDataTypeFromProto(e.dataType()), r = new l23(t, n);
                        if ("string" === n) for(let t236 = 0; t236 < e.stringDataLength(); t236++)r.data[t236] = e.stringData(t236);
                        else if (e.rawDataArray() && "number" == typeof e.rawDataLength() && e.rawDataLength() > 0) {
                            const t = r.data, n = new DataView(e.rawDataArray().buffer, e.rawDataArray().byteOffset, e.rawDataLength()), i = c(e.dataType()), o = e.rawDataLength() / i;
                            if (e.rawDataLength() % i != 0) throw new Error("invalid buffer length");
                            if (t.length !== o) throw new Error("buffer length mismatch");
                            for(let r82 = 0; r82 < o; r82++){
                                const o = f(n, e.dataType(), r82 * i);
                                t[r82] = o;
                            }
                        }
                        return r;
                    }
                }
                function c(e) {
                    switch(e){
                        case s35.onnx.TensorProto.DataType.UINT8:
                        case s35.onnx.TensorProto.DataType.INT8:
                        case s35.onnx.TensorProto.DataType.BOOL:
                            return 1;
                        case s35.onnx.TensorProto.DataType.UINT16:
                        case s35.onnx.TensorProto.DataType.INT16:
                            return 2;
                        case s35.onnx.TensorProto.DataType.FLOAT:
                        case s35.onnx.TensorProto.DataType.INT32:
                        case s35.onnx.TensorProto.DataType.UINT32:
                            return 4;
                        case s35.onnx.TensorProto.DataType.INT64:
                        case s35.onnx.TensorProto.DataType.DOUBLE:
                        case s35.onnx.TensorProto.DataType.UINT64:
                            return 8;
                        default:
                            throw new Error(`cannot calculate sizeof() on type ${s35.onnx.TensorProto.DataType[e]}`);
                    }
                }
                function p(e) {
                    switch(e){
                        case "bool":
                        case "uint8":
                            return Uint8Array;
                        case "int8":
                            return Int8Array;
                        case "int16":
                            return Int16Array;
                        case "uint16":
                            return Uint16Array;
                        case "int32":
                            return Int32Array;
                        case "uint32":
                            return Uint32Array;
                        case "float32":
                            return Float32Array;
                        case "float64":
                            return Float64Array;
                        default:
                            throw new Error("unspecified error");
                    }
                }
                function d(e, t) {
                    if (t === s35.onnx.TensorProto.DataType.INT64 || t === a30.TensorDataType.INT64) {
                        if (e.greaterThanOrEqual(2147483648) || e.lessThan(-2147483648)) throw new TypeError("int64 is not supported");
                    } else {
                        if (t !== s35.onnx.TensorProto.DataType.UINT32 && t !== a30.TensorDataType.UINT32 && t !== s35.onnx.TensorProto.DataType.UINT64 && t !== a30.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${s35.onnx.TensorProto.DataType[t]}`);
                        if (e.greaterThanOrEqual(4294967296) || e.lessThan(0)) throw new TypeError("uint64 is not supported");
                    }
                    return e.toNumber();
                }
                function f(e, t, n) {
                    switch(t){
                        case s35.onnx.TensorProto.DataType.BOOL:
                        case s35.onnx.TensorProto.DataType.UINT8:
                            return e.getUint8(n);
                        case s35.onnx.TensorProto.DataType.INT8:
                            return e.getInt8(n);
                        case s35.onnx.TensorProto.DataType.UINT16:
                            return e.getUint16(n, !0);
                        case s35.onnx.TensorProto.DataType.INT16:
                            return e.getInt16(n, !0);
                        case s35.onnx.TensorProto.DataType.FLOAT:
                            return e.getFloat32(n, !0);
                        case s35.onnx.TensorProto.DataType.INT32:
                            return e.getInt32(n, !0);
                        case s35.onnx.TensorProto.DataType.UINT32:
                            return e.getUint32(n, !0);
                        case s35.onnx.TensorProto.DataType.INT64:
                            return d(o43.default.fromBits(e.getUint32(n, !0), e.getUint32(n + 4, !0), !1), t);
                        case s35.onnx.TensorProto.DataType.DOUBLE:
                            return e.getFloat64(n, !0);
                        case s35.onnx.TensorProto.DataType.UINT64:
                            return d(o43.default.fromBits(e.getUint32(n, !0), e.getUint32(n + 4, !0), !0), t);
                        default:
                            throw new Error(`cannot read from DataView for type ${s35.onnx.TensorProto.DataType[t]}`);
                    }
                }
                t233.Tensor = l23;
            },
            2517: function(e324, t237, n157) {
                "use strict";
                var r83 = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                };
                Object.defineProperty(t237, "__esModule", {
                    value: !0
                }), t237.decodeUtf8String = t237.MAX_CLIP = t237.MIN_CLIP = t237.PoolConvUtil = t237.ReduceUtil = t237.SplitUtil = t237.MathUtil = t237.ShapeUtil = t237.LongUtil = t237.ProtoUtil = t237.GemmUtil = t237.arrayCopyHelper = t237.BroadcastUtil = t237.MatMulUtil = t237.ArrayUtil = t237.assert = t237.checkInputsShape = void 0;
                const i52 = n157(4819), o44 = r83(n157(3720)), s36 = n157(1446), a31 = n157(9162);
                t237.checkInputsShape = function(e, ...t) {
                    if (!e || e.length !== t.length) return !1;
                    for(let n = 0; n < e.length; n++)if (!e[n].dims || e[n].dims.length !== t[n]) return !1;
                    return !0;
                }, t237.assert = function(e, t) {
                    if (!e) throw new Error("string" == typeof t ? t : t());
                }, t237.ArrayUtil = class {
                    static arraysEqual(e, t) {
                        if (e.length !== t.length) return !1;
                        for(let n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1;
                        return !0;
                    }
                };
                class u28 {
                    static preprocessInputShapes(e, t) {
                        return [
                            1 === e.length ? [
                                1,
                                e[0]
                            ] : e,
                            1 === t.length ? [
                                t[0],
                                1
                            ] : t
                        ];
                    }
                    static postprocessOutputShape(e, t, n) {
                        1 === t && e.splice(e.length - 2, 1), 1 === n && e.pop();
                    }
                    static calcMatMulShape(e, t) {
                        return e[1] !== t[0] ? void 0 : [
                            e[0],
                            t[1]
                        ];
                    }
                }
                t237.MatMulUtil = u28;
                class l24 {
                    static calcShape(e, t, n = !1) {
                        const r = e.length, i = t.length;
                        if (0 === r) return t;
                        if (0 === i) return e;
                        const o = Math.max(e.length, t.length), s = new Array(o);
                        if (n) {
                            if (r < 2 || i < 2) return;
                            const n = u28.calcMatMulShape([
                                e[r - 2],
                                e[r - 1]
                            ], [
                                t[i - 2],
                                t[i - 1]
                            ]);
                            if (void 0 === n) return;
                            [s[o - 2], s[o - 1]] = n;
                        }
                        for(let a = n ? 3 : 1; a <= o; a++){
                            const n = r - a < 0 ? 1 : e[r - a], u = i - a < 0 ? 1 : t[i - a];
                            if (n !== u && n > 1 && u > 1) return;
                            s[o - a] = Math.max(n, u);
                        }
                        return s;
                    }
                    static index(e, t) {
                        const n = new Array(t.length);
                        return l24.fillIndex(e, t, n), n;
                    }
                    static fillIndex(e, t, n) {
                        const r = e.length - t.length;
                        for(let i = 0; i < t.length; i++)n[i] = e[r + i] % t[i];
                    }
                    static calc(e, t, n, r, i) {
                        const o = l24.calcShape(e.dims, t.dims);
                        if (o) {
                            if (r && !d10.areEqual(o, e.dims)) return;
                            const s = d10.size(o), u = r ? e : new a31.Tensor(o, i || e.type);
                            if (0 === o.length) u.set([], n(e.get([]), t.get([])));
                            else {
                                const r = new Array(o.length), i = new Array(e.dims.length), a = new Array(t.dims.length);
                                let c, p = 0, d = 0, f = !1, h = !1;
                                0 === e.dims.length && (p = e.get([]), f = !0), 0 === t.dims.length && (d = t.get([]), h = !0);
                                for(let g = 0; g < s; g++){
                                    c = g;
                                    for(let e325 = o.length - 1; e325 >= 0; e325--)r[e325] = c % o[e325], c = Math.floor(c / o[e325]);
                                    f || (l24.fillIndex(r, e.dims, i), p = e.get(i)), h || (l24.fillIndex(r, t.dims, a), d = t.get(a)), u.set(r, n(p, d));
                                }
                            }
                            return u;
                        }
                    }
                    static isValidBroadcast(e, t) {
                        const n = e.length, r = t.length;
                        if (n > r) return !1;
                        for(let i = 1; i <= n; i++)if (1 !== e[n - i] && e[n - i] !== t[r - i]) return !1;
                        return !0;
                    }
                    static getBroadcastDims(e, t) {
                        const n = e.length, r = [];
                        for(let i = 0; i < n; i++){
                            const o = n - 1 - i, s = e[o] || 1;
                            (t[t.length - 1 - i] || 1) > 1 && 1 === s && r.unshift(o);
                        }
                        return r;
                    }
                }
                t237.BroadcastUtil = l24, t237.arrayCopyHelper = function(e, t, n, r, i) {
                    if (r < 0 || r >= t.length) throw new Error("sourceIndex out of bounds");
                    if (n < 0 || n >= e.length) throw new Error("targetIndex out of bounds");
                    if (r + i > t.length) throw new Error("source indices to be copied are outside bounds");
                    if (n + i > e.length) throw new Error("target array is too small to hold result");
                    for(let o = 0; o < i; o++)e[n + o] = t[r + o];
                }, t237.GemmUtil = class {
                    static getShapeOfGemmResult(e, t, n, r, i) {
                        if (2 !== e.length || 2 !== n.length) throw new Error("shape need to be of size 2");
                        let o, s, a;
                        t ? (o = e[1], s = e[0]) : (o = e[0], s = e[1]);
                        let u = -1;
                        if (r ? (a = n[0], u = 1) : (a = n[1], u = 0), n[u] !== s) throw new Error("dimension mismatch");
                        if (o <= 0 || a <= 0 || s <= 0) throw new Error("invalid shape specified");
                        if (i && !l24.isValidBroadcast(i, [
                            o,
                            a
                        ])) throw new Error("gemm: invalid bias shape for broadcast");
                        return [
                            o,
                            a,
                            s
                        ];
                    }
                };
                class c15 {
                    static tensorDataTypeFromProto(e) {
                        switch(e){
                            case s36.onnx.TensorProto.DataType.INT8:
                                return "int8";
                            case s36.onnx.TensorProto.DataType.UINT8:
                                return "uint8";
                            case s36.onnx.TensorProto.DataType.BOOL:
                                return "bool";
                            case s36.onnx.TensorProto.DataType.INT16:
                                return "int16";
                            case s36.onnx.TensorProto.DataType.UINT16:
                                return "uint16";
                            case s36.onnx.TensorProto.DataType.INT32:
                                return "int32";
                            case s36.onnx.TensorProto.DataType.UINT32:
                                return "uint32";
                            case s36.onnx.TensorProto.DataType.FLOAT:
                                return "float32";
                            case s36.onnx.TensorProto.DataType.DOUBLE:
                                return "float64";
                            case s36.onnx.TensorProto.DataType.STRING:
                                return "string";
                            case s36.onnx.TensorProto.DataType.INT64:
                                return "int32";
                            case s36.onnx.TensorProto.DataType.UINT64:
                                return "uint32";
                            default:
                                throw new Error(`unsupported data type: ${s36.onnx.TensorProto.DataType[e]}`);
                        }
                    }
                    static tensorDataTypeStringToEnum(e) {
                        switch(e){
                            case "int8":
                                return s36.onnx.TensorProto.DataType.INT8;
                            case "uint8":
                                return s36.onnx.TensorProto.DataType.UINT8;
                            case "bool":
                                return s36.onnx.TensorProto.DataType.BOOL;
                            case "int16":
                                return s36.onnx.TensorProto.DataType.INT16;
                            case "uint16":
                                return s36.onnx.TensorProto.DataType.UINT16;
                            case "int32":
                                return s36.onnx.TensorProto.DataType.INT32;
                            case "uint32":
                                return s36.onnx.TensorProto.DataType.UINT32;
                            case "float32":
                                return s36.onnx.TensorProto.DataType.FLOAT;
                            case "float64":
                                return s36.onnx.TensorProto.DataType.DOUBLE;
                            case "string":
                                return s36.onnx.TensorProto.DataType.STRING;
                            case "int64":
                                return s36.onnx.TensorProto.DataType.INT64;
                            case "uint64":
                                return s36.onnx.TensorProto.DataType.UINT64;
                            default:
                                throw new Error(`unsupported data type: ${e}`);
                        }
                    }
                    static tensorDimsFromProto(e328) {
                        return e328.map((e)=>o44.default.isLong(e) ? e.toNumber() : e
                        );
                    }
                    static tensorValueTypeFromProto(e329) {
                        return {
                            tensorType: c15.tensorDataTypeFromProto(e329.elemType),
                            shape: {
                                dims: c15.tensorDimsFromProto(e329.shape.dim.map((e)=>e.dimValue
                                ))
                            }
                        };
                    }
                    static tensorDimsFromORTFormat(e) {
                        const t = [];
                        for(let n = 0; n < e.dimsLength(); n++)t.push(p14.longToNumber(e.dims(n)));
                        return t;
                    }
                    static tensorAttributesFromORTFormat(e) {
                        const t = [];
                        for(let n = 0; n < e.attributesLength(); n++)t.push(e.attributes(n));
                        return t;
                    }
                }
                t237.ProtoUtil = c15;
                class p14 {
                    static longToNumber(e, t) {
                        return o44.default.isLong(e) ? e.toNumber() : e instanceof i52.flatbuffers.Long ? o44.default.fromValue({
                            low: e.low,
                            high: e.high,
                            unsigned: null != t && t
                        }).toNumber() : e;
                    }
                    static isLong(e) {
                        return o44.default.isLong(e) || e instanceof i52.flatbuffers.Long;
                    }
                }
                t237.LongUtil = p14;
                class d10 {
                    static size(e) {
                        return d10.getSizeFromDimensionRange(e, 0, e.length);
                    }
                    static sizeFromDimension(e, t) {
                        if (t < 0 || t > e.length) throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);
                        return d10.getSizeFromDimensionRange(e, t, e.length);
                    }
                    static sizeToDimension(e, t) {
                        if (t < 0 || t > e.length) throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);
                        return d10.getSizeFromDimensionRange(e, 0, t);
                    }
                    static getSizeFromDimensionRange(e, t, n) {
                        let r = 1;
                        for(let i = t; i < n; i++){
                            if (e[i] <= 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                            r *= e[i];
                        }
                        return r;
                    }
                    static computeStrides(e) {
                        const t = e.length;
                        if (0 === t) return [];
                        if (1 === t) return [
                            1
                        ];
                        const n = new Array(t);
                        n[t - 1] = 1, n[t - 2] = e[t - 1];
                        for(let r = t - 3; r >= 0; --r)n[r] = n[r + 1] * e[r + 1];
                        return n;
                    }
                    static transpose(e) {
                        return e.slice().reverse();
                    }
                    static indicesToOffset(e, t, n) {
                        void 0 === n && (n = e.length);
                        let r = 0;
                        for(let i = 0; i < n; ++i)r += t[i] * e[i];
                        return r;
                    }
                    static offsetToIndices(e, t) {
                        const n = t.length;
                        if (0 === n) return [];
                        if (1 === n) return [
                            e * t[0]
                        ];
                        const r = new Array(t.length);
                        for(let n158 = 0; n158 < r.length - 1; ++n158)r[n158] = Math.floor(e / t[n158]), e -= r[n158] * t[n158];
                        return r[r.length - 1] = e, r;
                    }
                    static normalizeAxis(e, t) {
                        if (e < -t && e >= t) throw new Error("unsupported axis for this operation.");
                        return e < 0 ? e + t : e;
                    }
                    static normalizeAxes(e330, t) {
                        return e330.map((e)=>this.normalizeAxis(e, t)
                        );
                    }
                    static incrementIndex(e, t, n) {
                        if (0 === t.length || 0 === e.length) throw new Error("Index incrementing unsupported for scalar Tensor");
                        if (void 0 === n) n = t.length;
                        else if (n <= 0 || n > t.length) throw new Error("Incorrect axis to increment on");
                        for(let r = n - 1; r >= 0 && (e[r]++, !(e[r] < t[r])); --r)e[r] = 0;
                    }
                    static calculateReshapedDims(e, t) {
                        if (0 === t.length) {
                            if (0 === e.length || 1 === d10.size(e)) return [];
                            throw new Error("cannot reshape to a scalar Tensor");
                        }
                        const n = t.length, r = new Array(n);
                        let i = -1, o = 1;
                        for(let s = 0; s < n; s++){
                            if (t[s] < -1) throw new Error("a dimension in shape hints cannot be less than -1");
                            if (-1 === t[s]) {
                                if (-1 !== i) throw new Error("at most one dimension in shape hints can be -1");
                                i = s;
                            } else {
                                if (0 === t[s]) {
                                    if (s >= e.length) throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                                    r[s] = e[s];
                                } else r[s] = t[s];
                                o *= r[s];
                            }
                        }
                        const s37 = d10.size(e);
                        if (-1 !== i) {
                            if (s37 % o != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);
                            r[i] = s37 / o;
                        } else if (o !== s37) throw new Error("reshapedDims and originalDims don't have matching sizes");
                        return r;
                    }
                    static sortBasedOnPerm(e, t238) {
                        return t238 ? t238.map((t)=>e[t]
                        ) : e.slice().reverse();
                    }
                    static padShape(e331, t) {
                        const n = e331.length;
                        return e331.map((e, r)=>e + t[r] + t[r + n]
                        );
                    }
                    static areEqual(e332, t) {
                        return e332.length === t.length && e332.every((e, n)=>e === t[n]
                        );
                    }
                    static validateDimsAndCalcSize(e) {
                        if (e.length > 6) throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
                        let t = 1;
                        for (const n of e){
                            if (!Number.isInteger(n)) throw new TypeError(`Invalid shape: ${n} is not an integer`);
                            if (n < 0 || n > 2147483647) throw new TypeError(`Invalid shape: length ${n} is not allowed`);
                            t *= n;
                        }
                        return t;
                    }
                    static flattenShape(e333, t239) {
                        t239 < 0 && (t239 += e333.length);
                        const n = e333.reduce((e, t)=>e * t
                        , 1), r = e333.slice(t239).reduce((e, t)=>e * t
                        , 1);
                        return [
                            n / r,
                            r
                        ];
                    }
                    static squeezeShape(e, t) {
                        const n = new Array;
                        t = d10.normalizeAxes(t, e.length);
                        for(let r = 0; r < e.length; r++){
                            const i = t.indexOf(r) >= 0;
                            if (i && 1 !== e[r]) throw new Error("squeeze an axis of size different than 1");
                            (0 === t.length && e[r] > 1 || t.length > 0 && !i) && n.push(e[r]);
                        }
                        return n;
                    }
                    static unsqueezeShape(e, t) {
                        const n = new Array(e.length + t.length);
                        n.fill(0);
                        for(let r = 0; r < t.length; r++){
                            const i = d10.normalizeAxis(t[r], e.length);
                            if (i >= n.length) throw new Error("'axes' has an out of range axis");
                            if (0 !== n[i]) throw new Error("'axes' has a duplicate axis");
                            n[i] = 1;
                        }
                        let r84 = 0;
                        for(let t240 = 0; t240 < n.length; t240++)0 === n[t240] && (n[t240] = e[r84++]);
                        if (r84 !== e.length) throw new Error("the unsqueezed dimension could not be established");
                        return n;
                    }
                }
                t237.ShapeUtil = d10, t237.MathUtil = class {
                    static sqr(e, t, n, r, i) {
                        if (r < 0 || r >= t.length) throw new Error("sourceIndex out of bounds");
                        if (n < 0 || n >= e.length) throw new Error("targetIndex out of bounds");
                        if (r + i > t.length) throw new Error("source indices to be copied are outside bounds");
                        if (n + i > e.length) throw new Error("target array is too small to hold result");
                        for(let o = 0; o < i; o++)e[n + o] += Math.pow(t[r + o], 2);
                    }
                    static axpy(e, t, n, r, i, o) {
                        if (r < 0 || r >= t.length) throw new Error("sourceIndex out of bounds");
                        if (n < 0 || n >= e.length) throw new Error("targetIndex out of bounds");
                        if (r + i > t.length) throw new Error("source indices to be copied are outside bounds");
                        if (n + i > e.length) throw new Error("target array is too small to hold result");
                        for(let s = 0; s < i; s++)e[n + s] += o * t[r + s];
                    }
                    static powx(e, t, n, r, i, o) {
                        if (r < 0 || r >= t.length) throw new Error("sourceIndex out of bounds");
                        if (n < 0 || n >= e.length) throw new Error("targetIndex out of bounds");
                        if (r + i > t.length) throw new Error("source indices to be copied are outside bounds");
                        if (n + i > e.length) throw new Error("target array is too small to hold result");
                        for(let s = 0; s < i; s++)e[n + s] = Math.pow(t[r + s], o);
                    }
                    static mul(e, t, n, r, i) {
                        if (r < 0 || r >= t.length) throw new Error("sourceIndex out of bounds");
                        if (n < 0 || n >= e.length) throw new Error("targetIndex out of bounds");
                        if (r + i > t.length) throw new Error("source indices to be copied are outside bounds");
                        if (n + i > e.length) throw new Error("target array is too small to hold result");
                        for(let o = 0; o < i; o++)e[n + o] = t[r + o] * e[n + o];
                    }
                };
                class f7 {
                    static splitShape(e, t, n, r) {
                        if (0 === n.length) {
                            if (!r) throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                            f7.determineSplit(e[t], r, n);
                        }
                        const i = [], o = [
                            0
                        ];
                        for(let r85 = 0; r85 < n.length; ++r85){
                            0 !== r85 && o.push(o[r85 - 1] + n[r85 - 1]);
                            const s = e.slice();
                            s[t] = n[r85], i.push(s);
                        }
                        return [
                            i,
                            o
                        ];
                    }
                    static determineSplit(e, t, n) {
                        if (e % t != 0) throw new Error("cannot split tensor to equal sized parts");
                        for(let r = 0; r < t; ++r)n.push(e / t);
                    }
                }
                t237.SplitUtil = f7;
                class h6 {
                    static calcReduce(e, t, n160, r, i) {
                        const o = e.dims.slice(0);
                        0 === t.length && o.forEach((e, n)=>t.push(n)
                        );
                        const s = h6.calcReduceShape(o, t, !0), u = d10.size(s), c = new a31.Tensor(s, e.type), p = d10.computeStrides(s), f = d10.computeStrides(o), g = new Array(o.length);
                        for(let n159 = 0; n159 < u; n159++){
                            const s = d10.offsetToIndices(n159, p);
                            l24.fillIndex(s, o, g), c.set(s, h6.calcReduceByAxis(e.numberData, t, o, 0, d10.indicesToOffset(g, f), r, i));
                        }
                        return n160 ? c : new a31.Tensor(h6.calcReduceShape(o, t, n160), c.type, void 0, void 0, c.data, c.dataId);
                    }
                    static calcReduceByAxis(e, t, n, r, i, o, s) {
                        let a = 0;
                        if (r >= t.length) return o(e[i]);
                        const u = t[r], l = u >= n.length ? 1 : d10.size(n.slice(u + 1));
                        for(let c = 0; c < n[u]; c++)a = 0 === c ? h6.calcReduceByAxis(e, t, n, r + 1, i, o, s) : s(a, h6.calcReduceByAxis(e, t, n, r + 1, i, o, s)), i += l;
                        return a;
                    }
                    static calcReduceShape(e335, t, n) {
                        const r = e335.slice();
                        for(let e334 = 0; e334 < t.length; e334++)r[t[e334]] = n ? 1 : 0;
                        return r.filter((e)=>0 !== e
                        );
                    }
                }
                t237.ReduceUtil = h6;
                class g4 {
                    static adjustPoolAttributes(e, t, n, r, i, o) {
                        if (!e && n.length !== t.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
                        if (e) for(let e336 = 0; e336 < t.length - 2; e336++)e336 >= n.length ? n.push(t[e336 + 2]) : n[e336] = t[e336 + 2];
                        for(let e337 = 0; e337 < n.length; e337++)if (e337 < r.length) {
                            if (r[e337] < 0) throw new Error("strides should be greater than or equal to 1");
                        } else r.push(1);
                        for(let e338 = 0; e338 < n.length; e338++)if (e338 < i.length) {
                            if (i[e338] < 0) throw new Error("dilations should be greater than or equal to 1");
                        } else i.push(1);
                        for(let e339 = 0; e339 < 2 * n.length; e339++)if (e339 < o.length) {
                            if (o[e339] < 0) throw new Error("pad should be greater than or equal to 1");
                        } else o.push(0);
                        for(let e340 = 0; e340 < n.length; e340++){
                            if (n[e340] <= 0) throw new Error("kernel shapes need to be greater than 0");
                            if (o[e340] >= n[e340] || o[e340 + n.length] >= n[e340]) throw new Error("pads should be smaller than kernel");
                        }
                    }
                    static adjustPadsBasedOnAutoPad(e, t, n, r, i, o) {
                        if (o) {
                            if (i.length !== 2 * (e.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
                            if (t.length !== e.length - 2) throw new Error("length of strides should be the length of data dimensions");
                            if (r.length !== e.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
                            for(let s = 0; s < e.length - 2; s++)g4.adjustPadAndReturnShape(e[s + 2], t[s], n[s], r[s], i, s, s + e.length - 2, o);
                        }
                    }
                    static computePoolOutputShape(e, t, n, r, i, o, s) {
                        if (t.length <= 0) throw new Error("input shape must be of size greater than 0");
                        const a = [
                            t[0],
                            t[1]
                        ];
                        return g4.computeShapeHelper(e, t, a, n, r, i, o, s), a;
                    }
                    static computeConvOutputShape(e, t, n, r, i, o, s) {
                        if (e.length <= 0 || t.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
                        const a = [
                            e[0],
                            t[0]
                        ];
                        return g4.computeShapeHelper(!1, e, a, n, r, i, o, s), a;
                    }
                    static computeShapeHelper(e, t, n, r, i, o, s, a) {
                        if (e) for(let e341 = 0; e341 < t.length - 2; e341++)n.push(1);
                        else for(let e342 = 0; e342 < t.length - 2; e342++)n.push(g4.adjustPadAndReturnShape(t[e342 + 2], r[e342], i[e342], o[e342], s, e342, e342 + t.length - 2, a));
                    }
                    static adjustPadAndReturnShape(e, t, n, r, i, o, s, a) {
                        const u = n * (r - 1) + 1;
                        if (!a || "NOTSET" === a) return Math.floor((e + i[o] + i[s] - u) / t + 1);
                        switch(a){
                            case "VALID":
                                return i[o] = 0, i[s] = 0, Math.floor((e - u) / t + 1);
                            case "SAME_LOWER":
                            case "SAME_UPPER":
                                if (1 !== n) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                                {
                                    const n = ((e + t - 1) / t - 1) * t + r - e;
                                    return i[o] = "SAME_LOWER" === a ? Math.floor((n + 1) / 2) : Math.floor(n / 2), i[s] = n - i[o], Math.floor((e + n - r) / t + 1);
                                }
                            default:
                                throw new Error("Unsupported AutoPad type");
                        }
                    }
                }
                t237.PoolConvUtil = g4, t237.MIN_CLIP = -340282346638528860000000000000000000000, t237.MAX_CLIP = 34028234663852886e22, t237.decodeUtf8String = function(e) {
                    return (new TextDecoder).decode(e);
                };
            },
            7967: (e343, t)=>{
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.iterateExtraOptions = void 0, t.iterateExtraOptions = (e344, n, r, i)=>{
                    if ("object" == typeof e344 && null !== e344) {
                        if (r.has(e344)) throw new Error("Circular reference in options");
                        r.add(e344);
                    }
                    Object.entries(e344).forEach(([e, o])=>{
                        const s = n ? n + e : e;
                        if ("object" == typeof o) t.iterateExtraOptions(o, s + ".", r, i);
                        else if ("string" == typeof o || "number" == typeof o) i(s, o.toString());
                        else {
                            if ("boolean" != typeof o) throw new Error("Can't handle extra config type: " + typeof o);
                            i(s, o ? "1" : "0");
                        }
                    });
                };
            },
            2157: function(e345, t241, n161) {
                "use strict";
                var r86, i53 = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), o45 = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    });
                } : function(e, t) {
                    e.default = t;
                }), s38 = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e) for(var n in e)"default" !== n && Object.prototype.hasOwnProperty.call(e, n) && i53(t, e, n);
                    return o45(t, e), t;
                };
                Object.defineProperty(t241, "__esModule", {
                    value: !0
                }), t241.endProfiling = t241.run = t241.releaseSession = t241.createSession = t241.initOrt = t241.initWasm = void 0;
                const a32 = n161(2174), u = s38(n161(349)), l = n161(6361), c = ()=>!!a32.env.wasm.proxy && "undefined" != typeof document
                ;
                let p, d, f, h = !1, g = !1, m = !1;
                const b = [], y = [], _ = [], v = [], w = ()=>{
                    if (h || !g || m || !p) throw new Error("worker not ready");
                }, x = (e)=>{
                    switch(e.data.type){
                        case "init-wasm":
                            h = !1, e.data.err ? (m = !0, d[1](e.data.err)) : (g = !0, d[0]());
                            break;
                        case "init-ort":
                            e.data.err ? f[1](e.data.err) : f[0]();
                            break;
                        case "create":
                            e.data.err ? b.shift()[1](e.data.err) : b.shift()[0](e.data.out);
                            break;
                        case "release":
                            e.data.err ? y.shift()[1](e.data.err) : y.shift()[0]();
                            break;
                        case "run":
                            e.data.err ? _.shift()[1](e.data.err) : _.shift()[0](e.data.out);
                            break;
                        case "end-profiling":
                            e.data.err ? v.shift()[1](e.data.err) : v.shift()[0]();
                    }
                }, T = "undefined" != typeof document ? null === (r86 = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r86 ? void 0 : r86.src : void 0;
                t241.initWasm = async ()=>{
                    if (c()) {
                        if (g) return;
                        if (h) throw new Error("multiple calls to 'initWasm()' detected.");
                        if (m) throw new Error("previous call to 'initWasm()' failed.");
                        return h = !0, void 0 === a32.env.wasm.wasmPaths && T && 0 !== T.indexOf("blob:") && (a32.env.wasm.wasmPaths = T.substr(0, T.lastIndexOf("/") + 1)), new Promise((e, t)=>{
                            null == p || p.terminate(), p = n161(9710).Z(), p.onmessage = x, d = [
                                e,
                                t
                            ];
                            const r = {
                                type: "init-wasm",
                                in: a32.env.wasm
                            };
                            p.postMessage(r);
                        });
                    }
                    return l.initializeWebAssembly(a32.env.wasm);
                }, t241.initOrt = async (e, t)=>{
                    if (c()) return w(), new Promise((n, r)=>{
                        f = [
                            n,
                            r
                        ];
                        const i = {
                            type: "init-ort",
                            in: {
                                numThreads: e,
                                loggingLevel: t
                            }
                        };
                        p.postMessage(i);
                    });
                    u.initOrt(e, t);
                }, t241.createSession = async (e, t)=>c() ? (w(), new Promise((n, r)=>{
                        b.push([
                            n,
                            r
                        ]);
                        const i = {
                            type: "create",
                            in: {
                                model: e,
                                options: t
                            }
                        };
                        p.postMessage(i, [
                            e.buffer
                        ]);
                    })) : u.createSession(e, t)
                , t241.releaseSession = async (e)=>{
                    if (c()) return w(), new Promise((t, n)=>{
                        y.push([
                            t,
                            n
                        ]);
                        const r = {
                            type: "release",
                            in: e
                        };
                        p.postMessage(r);
                    });
                    u.releaseSession(e);
                }, t241.run = async (e, t, n, r, i)=>c() ? (w(), new Promise((o, s)=>{
                        _.push([
                            o,
                            s
                        ]);
                        const a = {
                            type: "run",
                            in: {
                                sessionId: e,
                                inputIndices: t,
                                inputs: n,
                                outputIndices: r,
                                options: i
                            }
                        };
                        p.postMessage(a, u.extractTransferableBuffers(n));
                    })) : u.run(e, t, n, r, i)
                , t241.endProfiling = async (e)=>{
                    if (c()) return w(), new Promise((t, n)=>{
                        v.push([
                            t,
                            n
                        ]);
                        const r = {
                            type: "end-profiling",
                            in: e
                        };
                        p.postMessage(r);
                    });
                    u.endProfiling(e);
                };
            },
            586: (e346, t242, n162)=>{
                "use strict";
                Object.defineProperty(t242, "__esModule", {
                    value: !0
                }), t242.setRunOptions = void 0;
                const r87 = n162(7967), i = n162(4983), o46 = n162(6361);
                t242.setRunOptions = (e347)=>{
                    const t = o46.getInstance();
                    let n = 0;
                    const s = [], a33 = e347 || {};
                    try {
                        if (void 0 === (null == e347 ? void 0 : e347.logSeverityLevel)) a33.logSeverityLevel = 2;
                        else if ("number" != typeof e347.logSeverityLevel || !Number.isInteger(e347.logSeverityLevel) || e347.logSeverityLevel < 0 || e347.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e347.logSeverityLevel}`);
                        if (void 0 === (null == e347 ? void 0 : e347.logVerbosityLevel)) a33.logVerbosityLevel = 0;
                        else if ("number" != typeof e347.logVerbosityLevel || !Number.isInteger(e347.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e347.logVerbosityLevel}`);
                        void 0 === (null == e347 ? void 0 : e347.terminate) && (a33.terminate = !1);
                        let o47 = 0;
                        if (void 0 !== (null == e347 ? void 0 : e347.tag) && (o47 = i.allocWasmString(e347.tag, s)), n = t._OrtCreateRunOptions(a33.logSeverityLevel, a33.logVerbosityLevel, !!a33.terminate, o47), 0 === n) throw new Error("Can't create run options");
                        return void 0 !== (null == e347 ? void 0 : e347.extra) && r87.iterateExtraOptions(e347.extra, "", new WeakSet, (e, r)=>{
                            const o = i.allocWasmString(e, s), a = i.allocWasmString(r, s);
                            if (0 !== t._OrtAddRunConfigEntry(n, o, a)) throw new Error(`Can't set a run config entry: ${e} - ${r}`);
                        }), [
                            n,
                            s
                        ];
                    } catch (e) {
                        throw 0 !== n && t._OrtReleaseRunOptions(n), s.forEach(t._free), e;
                    }
                };
            },
            2306: (e348, t243, n163)=>{
                "use strict";
                Object.defineProperty(t243, "__esModule", {
                    value: !0
                }), t243.OnnxruntimeWebAssemblySessionHandler = void 0;
                const r88 = n163(2174), i = n163(2157);
                let o49;
                t243.OnnxruntimeWebAssemblySessionHandler = class {
                    async loadModel(e349, t) {
                        o49 || (await i.initOrt(r88.env.wasm.numThreads, ((e)=>{
                            switch(e){
                                case "verbose":
                                    return 0;
                                case "info":
                                    return 1;
                                case "warning":
                                    return 2;
                                case "error":
                                    return 3;
                                case "fatal":
                                    return 4;
                                default:
                                    throw new Error(`unsupported logging level: ${e}`);
                            }
                        })(r88.env.logLevel)), o49 = !0), [this.sessionId, this.inputNames, this.outputNames] = await i.createSession(e349, t);
                    }
                    async dispose() {
                        return i.releaseSession(this.sessionId);
                    }
                    async run(e351, t244, n164) {
                        const o = [], s = [];
                        Object.entries(e351).forEach((e)=>{
                            const t = e[0], n = e[1], r = this.inputNames.indexOf(t);
                            if (-1 === r) throw new Error(`invalid input '${t}'`);
                            o.push(n), s.push(r);
                        });
                        const a = [];
                        Object.entries(t244).forEach((e)=>{
                            const t = e[0], n = this.outputNames.indexOf(t);
                            if (-1 === n) throw new Error(`invalid output '${t}'`);
                            a.push(n);
                        });
                        const u = await i.run(this.sessionId, s, o.map((e)=>[
                                e.type,
                                e.dims,
                                e.data
                            ]
                        ), a, n164), l = {};
                        for(let e350 = 0; e350 < u.length; e350++)l[this.outputNames[a[e350]]] = new r88.Tensor(u[e350][0], u[e350][2], u[e350][1]);
                        return l;
                    }
                    startProfiling() {}
                    endProfiling() {
                        i.endProfiling(this.sessionId);
                    }
                };
            },
            4919: (e352, t245, n165)=>{
                "use strict";
                Object.defineProperty(t245, "__esModule", {
                    value: !0
                }), t245.setSessionOptions = void 0;
                const r89 = n165(7967), i = n165(4983), o50 = n165(6361);
                t245.setSessionOptions = (e353)=>{
                    const t246 = o50.getInstance();
                    let n = 0;
                    const s = [], a34 = e353 || {};
                    ((e)=>{
                        e.extra || (e.extra = {}), e.extra.session || (e.extra.session = {});
                        const t = e.extra.session;
                        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = "1");
                    })(a34);
                    try {
                        void 0 === (null == e353 ? void 0 : e353.graphOptimizationLevel) && (a34.graphOptimizationLevel = "all");
                        const o51 = ((e)=>{
                            switch(e){
                                case "disabled":
                                    return 0;
                                case "basic":
                                    return 1;
                                case "extended":
                                    return 2;
                                case "all":
                                    return 99;
                                default:
                                    throw new Error(`unsupported graph optimization level: ${e}`);
                            }
                        })(a34.graphOptimizationLevel);
                        void 0 === (null == e353 ? void 0 : e353.enableCpuMemArena) && (a34.enableCpuMemArena = !0), void 0 === (null == e353 ? void 0 : e353.enableMemPattern) && (a34.enableMemPattern = !0), void 0 === (null == e353 ? void 0 : e353.executionMode) && (a34.executionMode = "sequential");
                        const u = ((e)=>{
                            switch(e){
                                case "sequential":
                                    return 0;
                                case "parallel":
                                    return 1;
                                default:
                                    throw new Error(`unsupported execution mode: ${e}`);
                            }
                        })(a34.executionMode);
                        let l = 0;
                        if (void 0 !== (null == e353 ? void 0 : e353.logId) && (l = i.allocWasmString(e353.logId, s)), void 0 === (null == e353 ? void 0 : e353.logSeverityLevel)) a34.logSeverityLevel = 2;
                        else if ("number" != typeof e353.logSeverityLevel || !Number.isInteger(e353.logSeverityLevel) || e353.logSeverityLevel < 0 || e353.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e353.logSeverityLevel}`);
                        if (void 0 === (null == e353 ? void 0 : e353.logVerbosityLevel)) a34.logVerbosityLevel = 0;
                        else if ("number" != typeof e353.logVerbosityLevel || !Number.isInteger(e353.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e353.logVerbosityLevel}`);
                        if (void 0 === (null == e353 ? void 0 : e353.enableProfiling) && (a34.enableProfiling = !1), n = t246._OrtCreateSessionOptions(o51, !!a34.enableCpuMemArena, !!a34.enableMemPattern, u, !!a34.enableProfiling, 0, l, a34.logSeverityLevel, a34.logVerbosityLevel), 0 === n) throw new Error("Can't create session options");
                        return void 0 !== (null == e353 ? void 0 : e353.extra) && r89.iterateExtraOptions(e353.extra, "", new WeakSet, (e, r)=>{
                            const o = i.allocWasmString(e, s), a = i.allocWasmString(r, s);
                            if (0 !== t246._OrtAddSessionConfigEntry(n, o, a)) throw new Error(`Can't set a session config entry: ${e} - ${r}`);
                        }), [
                            n,
                            s
                        ];
                    } catch (e) {
                        throw 0 !== n && t246._OrtReleaseSessionOptions(n), s.forEach(t246._free), e;
                    }
                };
            },
            4983: (e354, t247, n166)=>{
                "use strict";
                Object.defineProperty(t247, "__esModule", {
                    value: !0
                }), t247.allocWasmString = void 0;
                const r = n166(6361);
                t247.allocWasmString = (e, t)=>{
                    const n = r.getInstance(), i = n.lengthBytesUTF8(e) + 1, o = n._malloc(i);
                    return n.stringToUTF8(e, o, i), t.push(o), o;
                };
            },
            349: (e355, t248, n167)=>{
                "use strict";
                Object.defineProperty(t248, "__esModule", {
                    value: !0
                }), t248.extractTransferableBuffers = t248.endProfiling = t248.run = t248.releaseSession = t248.createSession = t248.initOrt = void 0;
                const r90 = n167(586), i54 = n167(4919), o53 = n167(4983), s39 = n167(6361);
                t248.initOrt = (e, t)=>{
                    const n = s39.getInstance()._OrtInit(e, t);
                    if (0 !== n) throw new Error(`Can't initialize onnxruntime. error code = ${n}`);
                };
                const a35 = new Map;
                t248.createSession = (e, t)=>{
                    const n = s39.getInstance(), r = n._malloc(e.byteLength);
                    let o = 0, u = 0, l = [];
                    try {
                        if ([u, l] = i54.setSessionOptions(t), n.HEAPU8.set(e, r), o = n._OrtCreateSession(r, e.byteLength, u), 0 === o) throw new Error("Can't create a session");
                    } finally{
                        n._free(r), n._OrtReleaseSessionOptions(u), l.forEach(n._free);
                    }
                    const c = n._OrtGetInputCount(o), p = n._OrtGetOutputCount(o), d = [], f = [], h = [], g = [];
                    for(let e356 = 0; e356 < c; e356++){
                        const t = n._OrtGetInputName(o, e356);
                        if (0 === t) throw new Error("Can't get an input name");
                        f.push(t), d.push(n.UTF8ToString(t));
                    }
                    for(let e357 = 0; e357 < p; e357++){
                        const t = n._OrtGetOutputName(o, e357);
                        if (0 === t) throw new Error("Can't get an output name");
                        g.push(t), h.push(n.UTF8ToString(t));
                    }
                    return a35.set(o, [
                        o,
                        f,
                        g
                    ]), [
                        o,
                        d,
                        h
                    ];
                }, t248.releaseSession = (e)=>{
                    const t = s39.getInstance(), n = a35.get(e);
                    if (!n) throw new Error("invalid session id");
                    const r = n[0], i = n[1], o = n[2];
                    i.forEach(t._OrtFree), o.forEach(t._OrtFree), t._OrtReleaseSession(r), a35.delete(e);
                };
                const u29 = (e)=>{
                    switch(e){
                        case "int8":
                            return 3;
                        case "uint8":
                            return 2;
                        case "bool":
                            return 9;
                        case "int16":
                            return 5;
                        case "uint16":
                            return 4;
                        case "int32":
                            return 6;
                        case "uint32":
                            return 12;
                        case "float32":
                            return 1;
                        case "float64":
                            return 11;
                        case "string":
                            return 8;
                        case "int64":
                            return 7;
                        case "uint64":
                            return 13;
                        default:
                            throw new Error(`unsupported data type: ${e}`);
                    }
                }, l25 = (e)=>{
                    switch(e){
                        case 3:
                            return "int8";
                        case 2:
                            return "uint8";
                        case 9:
                            return "bool";
                        case 5:
                            return "int16";
                        case 4:
                            return "uint16";
                        case 6:
                        case 7:
                            return "int32";
                        case 12:
                        case 13:
                            return "uint32";
                        case 1:
                            return "float32";
                        case 11:
                            return "float64";
                        case 8:
                            return "string";
                        default:
                            throw new Error(`unsupported data type: ${e}`);
                    }
                }, c16 = (e)=>{
                    switch(e){
                        case "float32":
                            return Float32Array;
                        case "uint8":
                        case "bool":
                            return Uint8Array;
                        case "int8":
                            return Int8Array;
                        case "uint16":
                            return Uint16Array;
                        case "int16":
                            return Int16Array;
                        case "int32":
                            return Int32Array;
                        case "float64":
                            return Float64Array;
                        case "uint32":
                            return Uint32Array;
                        case "int64":
                            return BigInt64Array;
                        case "uint64":
                            return BigUint64Array;
                        default:
                            throw new Error(`unsupported type: ${e}`);
                    }
                };
                t248.run = (e, t, n, i, p)=>{
                    const d = s39.getInstance(), f = a35.get(e);
                    if (!f) throw new Error("invalid session id");
                    const h = f[0], g = f[1], m = f[2], b = t.length, y = i.length;
                    let _ = 0, v = [];
                    const w = [], x = [];
                    try {
                        [_, v] = r90.setRunOptions(p);
                        for(let e = 0; e < b; e++){
                            const t249 = n[e][0], r = n[e][1], i = n[e][2];
                            let s, a;
                            if (Array.isArray(i)) {
                                a = 4 * i.length, s = d._malloc(a), x.push(s);
                                let e = s / 4;
                                for(let t = 0; t < i.length; t++){
                                    if ("string" != typeof i[t]) throw new TypeError(`tensor data at index ${t} is not a string`);
                                    d.HEAPU32[e++] = o53.allocWasmString(i[t], x);
                                }
                            } else a = i.byteLength, s = d._malloc(a), x.push(s), d.HEAPU8.set(new Uint8Array(i.buffer, i.byteOffset, a), s);
                            const l = d.stackSave(), c = d.stackAlloc(4 * r.length);
                            try {
                                let e = c / 4;
                                r.forEach((t)=>d.HEAP32[e++] = t
                                );
                                const n = d._OrtCreateTensor(u29(t249), s, a, c, r.length);
                                if (0 === n) throw new Error("Can't create a tensor");
                                w.push(n);
                            } finally{
                                d.stackRestore(l);
                            }
                        }
                        const e358 = d.stackSave(), s = d.stackAlloc(4 * b), a = d.stackAlloc(4 * b), f = d.stackAlloc(4 * y), T = d.stackAlloc(4 * y);
                        try {
                            let n = s / 4, r = a / 4, o = f / 4, u = T / 4;
                            for(let e = 0; e < b; e++)d.HEAPU32[n++] = w[e], d.HEAPU32[r++] = g[t[e]];
                            for(let e359 = 0; e359 < y; e359++)d.HEAPU32[o++] = 0, d.HEAPU32[u++] = m[i[e359]];
                            let p = d._OrtRun(h, a, s, b, T, y, f, _);
                            const v = [];
                            if (0 === p) for(let e360 = 0; e360 < y; e360++){
                                const t251 = d.HEAPU32[f / 4 + e360], n = d.stackSave(), r = d.stackAlloc(16);
                                let i, o = 0;
                                try {
                                    if (p = d._OrtGetTensorData(t251, r, r + 4, r + 8, r + 12), 0 !== p) throw new Error(`Can't get a tensor data. error code = ${p}`);
                                    let e362 = r / 4;
                                    const s = d.HEAPU32[e362++];
                                    o = d.HEAPU32[e362++];
                                    const a = d.HEAPU32[e362++], u = d.HEAPU32[e362++], f = [];
                                    for(let e361 = 0; e361 < u; e361++)f.push(d.HEAPU32[a / 4 + e361]);
                                    d._OrtFree(a);
                                    const h = 0 === f.length ? 1 : f.reduce((e, t)=>e * t
                                    );
                                    if (i = l25(s), "string" === i) {
                                        const e = [];
                                        let t = o / 4;
                                        for(let n = 0; n < h; n++){
                                            const r = d.HEAPU32[t++], i = n === h - 1 ? void 0 : d.HEAPU32[t] - r;
                                            e.push(d.UTF8ToString(r, i));
                                        }
                                        v.push([
                                            i,
                                            f,
                                            e
                                        ]);
                                    } else {
                                        const e = new (c16(i))(h);
                                        new Uint8Array(e.buffer, e.byteOffset, e.byteLength).set(d.HEAPU8.subarray(o, o + e.byteLength)), v.push([
                                            i,
                                            f,
                                            e
                                        ]);
                                    }
                                } finally{
                                    d.stackRestore(n), "string" === i && o && d._free(o), d._OrtReleaseTensor(t251);
                                }
                            }
                            if (0 === p) return v;
                            throw new Error(`failed to call OrtRun(). error code = ${p}.`);
                        } finally{
                            d.stackRestore(e358);
                        }
                    } finally{
                        w.forEach(d._OrtReleaseTensor), x.forEach(d._free), d._OrtReleaseRunOptions(_), v.forEach(d._free);
                    }
                }, t248.endProfiling = (e)=>{
                    const t = s39.getInstance(), n = a35.get(e);
                    if (!n) throw new Error("invalid session id");
                    const r = n[0], i = t._OrtEndProfiling(r);
                    if (0 === i) throw new Error("Can't get an profile file name");
                    t._OrtFree(i);
                }, t248.extractTransferableBuffers = (e)=>{
                    const t = [];
                    for (const n of e){
                        const e = n[2];
                        !Array.isArray(e) && e.buffer && t.push(e.buffer);
                    }
                    return t;
                };
            },
            6361: function(e364, t254, n168) {
                "use strict";
                var r91 = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                    void 0 === r && (r = n), Object.defineProperty(e, r, {
                        enumerable: !0,
                        get: function() {
                            return t[n];
                        }
                    });
                } : function(e, t, n, r) {
                    void 0 === r && (r = n), e[r] = t[n];
                }), i55 = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    });
                } : function(e, t) {
                    e.default = t;
                }), o54 = this && this.__importStar || function(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e) for(var n in e)"default" !== n && Object.prototype.hasOwnProperty.call(e, n) && r91(t, e, n);
                    return i55(t, e), t;
                }, s40 = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    };
                };
                Object.defineProperty(t254, "__esModule", {
                    value: !0
                }), t254.dispose = t254.getInstance = t254.initializeWebAssembly = void 0;
                const a = o54(n168(6449)), u = s40(n168(932)), l = n168(3474);
                let c, p = !1, d = !1, f = !1;
                const h = (e, t)=>t ? e ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : e ? "ort-wasm-simd.wasm" : "ort-wasm.wasm"
                ;
                t254.initializeWebAssembly = async (e365)=>{
                    if (p) return Promise.resolve();
                    if (d) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
                    if (f) throw new Error("previous call to 'initializeWebAssembly()' failed.");
                    d = !0;
                    const t255 = e365.initTimeout, r92 = e365.numThreads, i56 = e365.simd, o = r92 > 1 && (()=>{
                        try {
                            return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && (new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
                                0,
                                97,
                                115,
                                109,
                                1,
                                0,
                                0,
                                0,
                                1,
                                4,
                                1,
                                96,
                                0,
                                0,
                                3,
                                2,
                                1,
                                0,
                                5,
                                4,
                                1,
                                3,
                                1,
                                1,
                                10,
                                11,
                                1,
                                9,
                                0,
                                65,
                                0,
                                254,
                                16,
                                2,
                                0,
                                26,
                                11
                            ])));
                        } catch (e) {
                            return !1;
                        }
                    })(), s = i56 && (()=>{
                        try {
                            return WebAssembly.validate(new Uint8Array([
                                0,
                                97,
                                115,
                                109,
                                1,
                                0,
                                0,
                                0,
                                1,
                                4,
                                1,
                                96,
                                0,
                                0,
                                3,
                                2,
                                1,
                                0,
                                10,
                                30,
                                1,
                                28,
                                0,
                                65,
                                0,
                                253,
                                15,
                                253,
                                12,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                253,
                                186,
                                1,
                                26,
                                11
                            ]));
                        } catch (e) {
                            return !1;
                        }
                    })(), g = "string" == typeof e365.wasmPaths ? e365.wasmPaths : void 0, m = h(!1, o), b = h(s, o), y = "object" == typeof e365.wasmPaths ? e365.wasmPaths[b] : void 0;
                    let _ = !1;
                    const v = [];
                    if (t255 > 0 && v.push(new Promise((e)=>{
                        setTimeout(()=>{
                            _ = !0, e();
                        }, t255);
                    })), v.push(new Promise((e366, t256)=>{
                        const r = o ? l : u.default, i = {
                            locateFile: (e, t)=>{
                                if (o && e.endsWith(".worker.js") && "undefined" != typeof Blob) return URL.createObjectURL(new Blob([
                                    n168(5118)
                                ], {
                                    type: "text/javascript"
                                }));
                                if (e === m) {
                                    const e = null != g ? g : t;
                                    return null != y ? y : e + b;
                                }
                                return t + e;
                            }
                        };
                        if (o) {
                            if ("undefined" == typeof Blob) i.mainScriptUrlOrBlob = a.join("/", "ort-wasm-threaded.js");
                            else {
                                const e = `var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;
                                i.mainScriptUrlOrBlob = new Blob([
                                    e
                                ], {
                                    type: "text/javascript"
                                });
                            }
                        }
                        r(i).then((t)=>{
                            d = !1, p = !0, c = t, e366();
                        }, (e)=>{
                            d = !1, f = !0, t256(e);
                        });
                    })), await Promise.race(v), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t255}ms`);
                }, t254.getInstance = ()=>{
                    if (p && c) return c;
                    throw new Error("WebAssembly is not initialized yet.");
                }, t254.dispose = ()=>{
                    var e;
                    !p || d || f || (d = !0, null === (e = c.PThread) || void 0 === e || e.terminateAllThreads(), c = void 0, d = !1, p = !1, f = !0);
                };
            },
            9710: (e, t, n)=>{
                "use strict";
                n.d(t, {
                    Z: ()=>o
                });
                var r = n(477), i = n.n(r);
                function o() {
                    return i()('/*!\n* ONNX Runtime Web v1.11.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return C.buffer!=U&&$(C.buffer),W}function r(){return C.buffer!=U&&$(C.buffer),L}function a(){return C.buffer!=U&&$(C.buffer),H}function o(){return C.buffer!=U&&$(C.buffer),Y}var i;e=e||{},i||(i=void 0!==e?e:{});var s,u,c=Object.assign;i.ready=new Promise((function(e,t){s=e,u=t}));var l,f,p,d,m,g,h=c({},i),y="./this.program",b=(e,t)=>{throw t},v="object"==typeof window,_="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=i.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(e){return i.locateFile?i.locateFile(e,A):A+e}if(w){let t;A=_?n(908).dirname(A)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?null:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof xt))throw e})),process.on("unhandledRejection",(function(e){throw e})),b=(e,t)=>{if(te())throw process.exitCode=e,t;t instanceof xt||x("exiting due to exception: "+t),process.exit(e)},i.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(v||_)&&(_?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},_&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var E=console.log.bind(console),T=console.warn.bind(console);w&&(g(),E=e=>d.writeSync(1,e+"\\n"),T=e=>d.writeSync(2,e+"\\n"));var M,D,R=i.print||E,x=i.printErr||T;c(i,h),h=null,i.thisProgram&&(y=i.thisProgram),i.quit&&(b=i.quit),i.wasmBinary&&(D=i.wasmBinary);var k=i.noExitRuntime||!1;"object"!=typeof WebAssembly&&se("no native wasm support detected");var C,F,P=!1;function I(e){var t=new TextDecoder(e);this.decode=e=>(e.buffer instanceof SharedArrayBuffer&&(e=new Uint8Array(e)),t.decode.call(t,e))}var U,W,L,H,Y,j="undefined"!=typeof TextDecoder?new I("utf8"):void 0;function B(e,t,n){var r=t+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.subarray&&j)return j.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function N(e,t){return e?B(r(),e,t):""}function G(e,t,n,r){if(!(0<r))return 0;var a=n;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++]=i}else{if(2047>=i){if(n+1>=r)break;t[n++]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++]=224|i>>12}else{if(n+3>=r)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63}t[n++]=128|i>>6&63}t[n++]=128|63&i}}return t[n]=0,n-a}function z(e,t,n){return G(e,r(),t,n)}function V(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),127>=r?++t:t=2047>=r?t+2:65535>=r?t+3:t+4}return t}function q(e){var n=V(e)+1,r=dt(n);return r&&G(e,t(),r,n),r}function $(e){U=e,i.HEAP8=W=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAP32=H=new Int32Array(e),i.HEAPU8=L=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAPU32=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=Y=new Float64Array(e)}"undefined"!=typeof TextDecoder&&new I("utf-16le"),O&&(U=i.buffer);var X=i.INITIAL_MEMORY||16777216;if(O)C=i.wasmMemory,U=i.buffer;else if(i.wasmMemory)C=i.wasmMemory;else if(!((C=new WebAssembly.Memory({initial:X/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");C&&(U=C.buffer),X=U.byteLength,$(U);var Q,J=[],Z=[],K=[],ee=[];function te(){return k||!1}function ne(){var e=i.preRun.shift();J.unshift(e)}var re,ae=0,oe=null,ie=null;function se(e){throw O?postMessage({cmd:"onAbort",arg:e}):i.onAbort&&i.onAbort(e),x(e="Aborted("+e+")"),P=!0,e=new WebAssembly.RuntimeError(e+". Build with -s ASSERTIONS=1 for more info."),u(e),e}function ue(){return re.startsWith("data:application/octet-stream;base64,")}function ce(){var e=re;try{if(e==re&&D)return new Uint8Array(D);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){se(e)}}i.preloadedImages={},i.preloadedAudios={},re="ort-wasm-threaded.wasm",ue()||(re=S(re));var le={};function fe(e){for(;0<e.length;){var t=e.shift();if("function"==typeof t)t(i);else{var n=t.Tb;"number"==typeof n?void 0===t.Sa?be(n)():be(n)(t.Sa):n(void 0===t.Sa?null:t.Sa)}}}function pe(e){var t=Et();return e=e(),Tt(t),e}function de(e){var t=me.Oa[e];t&&(a()[e>>2]=0,me.jb(t.worker))}var me={Pa:[],Va:[],fb:[],Wb:function(){},ub:function(){me.receiveObjectTransfer=me.zb,me.threadInit=me.lb,me.setExitStatus=me.Bb},Oa:{},Bb:function(){},kb:function(){for(var e in me.Oa){var t=me.Oa[e];t&&t.worker&&me.jb(t.worker)}for(e=0;e<me.Pa.length;++e)me.Pa[e].terminate();me.Pa=[]},jb:function(e){me.Ab((function(){delete me.Oa[e.Qa.eb],me.Pa.push(e),me.Va.splice(me.Va.indexOf(e),1),wt(e.Qa.eb),e.Qa=void 0}))},Ab:function(e){a()[Rt>>2]=0;try{e()}finally{a()[Rt>>2]=1}},zb:function(){},lb:function(){for(var e in me.fb)me.fb[e]()},wb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Qa&&(me.pb=e.Qa.eb),n.targetThread&&n.targetThread!=pt()){var o=me.Oa[n.bc];o?o.worker.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processQueuedMainThreadWork"===r?ht():"spawnThread"===r?_e(n):"cleanupThread"===r?de(n.thread):"killThread"===r?(n=n.thread,a()[n>>2]=0,r=me.Oa[n],delete me.Oa[n],r.worker.terminate(),wt(n),me.Va.splice(me.Va.indexOf(r.worker),1),r.worker.Qa=void 0):"cancelThread"===r?me.Oa[n.thread].worker.postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Ua&&(e.Ua(),delete e.Ua)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?i.onAbort&&i.onAbort(n.arg):x("worker sent an unknown command "+r);me.pb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},w&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:i.mainScriptUrlOrBlob||_scriptDir,wasmMemory:C,wasmModule:F})},mb:function(){var e=S("ort-wasm-threaded.worker.js");me.Pa.push(new Worker(e))},rb:function(){return 0==me.Pa.length&&(me.mb(),me.wb(me.Pa[0])),me.Pa.pop()}};function ge(e){if(O)return je(1,0,e);try{Ct(e)}catch(e){e instanceof xt||"unwind"==e||b(1,e)}}i.establishStackSpace=function(){var e=pt(),t=a()[e+44>>2];e=a()[e+48>>2],St(t,t-e),Tt(t)};var he,ye=[];function be(e){var t=ye[e];return t||(e>=ye.length&&(ye.length=e+1),ye[e]=t=Q.get(e)),t}function ve(e){this.Ta=e-16,this.Gb=function(e){a()[this.Ta+4>>2]=e},this.Db=function(e){a()[this.Ta+8>>2]=e},this.Eb=function(){a()[this.Ta>>2]=0},this.Cb=function(){t()[this.Ta+12>>0]=0},this.Fb=function(){t()[this.Ta+13>>0]=0},this.sb=function(e,t){this.Gb(e),this.Db(t),this.Eb(),this.Cb(),this.Fb()}}function _e(e){var t=me.rb();if(!t)return 6;me.Va.push(t);var n=me.Oa[e.cb]={worker:t,eb:e.cb};t.Qa=n;var r={cmd:"run",start_routine:e.Hb,arg:e.Sa,threadInfoStruct:e.cb};return t.Ua=()=>{r.time=performance.now(),t.postMessage(r,e.Mb)},t.loaded&&(t.Ua(),delete t.Ua),0}i.invokeEntryPoint=function(e,t){return be(e)(t)},he=w?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-i.__performance_now_clock_drift:()=>performance.now();var we={},Oe=[null,[],[]];function Ae(e,t){var n=Oe[e];0===t||10===t?((1===e?R:x)(B(n,0)),n.length=0):n.push(t)}var Se={};function Ee(e,t,n){return O?je(2,1,e,t,n):0}function Te(e,t){if(O)return je(3,1,e,t)}function Me(e,t,n,r){if(O)return je(4,1,e,t,n,r)}function De(e,t){if(O)return je(5,1,e,t)}function Re(e,t,n){if(O)return je(6,1,e,t,n)}function xe(e,t,n){return O?je(7,1,e,t,n):0}function ke(e,t){if(O)return je(8,1,e,t)}function Ce(e,t){return O?je(9,1,e,t):(e=N(e),Se.Qb(e,t))}function Fe(e,t,n,a,o,i){if(O)t=je(10,1,e,t,n,a,o,i);else if(i<<=12,0!=(16&a)&&0!=e%65536)t=-28;else if(0!=(32&a)){var s=65536*Math.ceil(t/65536);(e=At(65536,s))?r().fill(0,e,e+s):e=0,e?(we[e]={yb:e,vb:t,nb:!0,fd:o,Zb:n,flags:a,offset:i},t=e):t=-48}else t=-52;return t}function Pe(e,t){if(O)e=je(11,1,e,t);else{var n=we[e];0!==t&&n?(t===n.vb&&(we[e]=null,n.nb&&mt(n.yb)),e=0):e=-28}return e}function Ie(e,t,n){if(O)return je(12,1,e,t,n)}function Ue(e,t,n){return O?je(13,1,e,t,n):(e=N(e),Se.Rb(e,t,n))}function We(e){if(O)return je(14,1,e)}function Le(e,t){if(O)return je(15,1,e,t)}function He(e){if(O)return je(16,1,e)}function Ye(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return je(17,1,e,t,n);var o=(new Date).getFullYear(),i=new Date(o,0,1),s=new Date(o,6,1);o=i.getTimezoneOffset();var u=s.getTimezoneOffset(),c=Math.max(o,u);a()[e>>2]=60*c,a()[t>>2]=Number(o!=u),e=r(i),t=r(s),e=q(e),t=q(t),u<o?(a()[n>>2]=e,a()[n+4>>2]=t):(a()[n>>2]=t,a()[n+4>>2]=e)}function je(e,t){var n=arguments.length-2,r=arguments;return pe((function(){for(var a=Mt(8*n),i=a>>3,s=0;s<n;s++){var u=r[2+s];o()[i+s]=u}return vt(e,n,a,t)}))}var Be=[],Ne=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function Ge(e){return e=2<e?N(e):e,Ne[e]||("undefined"!=typeof document?document.querySelector(e):void 0)}function ze(e,t,n){var r=Ge(e);return r?(r.Za&&(a()[r.Za>>2]=t,a()[r.Za+4>>2]=n),!r.ib&&r.Ob?r.Za?(function(e,t,n,r){pe((function(){var o=Mt(12),i=0;if(t){i=V(t)+1;var s=dt(i);z(t,s,i),i=s}a()[o>>2]=i,a()[o+4>>2]=n,a()[o+8>>2]=r,_t(e,657457152,0,i,o)}))}(r=a()[r.Za+8>>2],e=e?N(e):"",t,n),1):-4:(r.ib&&(r=r.ib),e=!1,r.Ya&&r.Ya.Xa&&(e=0===(e=r.Ya.Xa.getParameter(2978))[0]&&0===e[1]&&e[2]===r.width&&e[3]===r.height),r.width=t,r.height=n,e&&r.Ya.Xa.viewport(0,0,t,n),0)):-4}function Ve(e,t,n){return O?je(18,1,e,t,n):ze(e,t,n)}var qe,$e=["default","low-power","high-performance"],Xe={};function Qe(){if(!qe){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var n=[];for(e in t)n.push(e+"="+t[e]);qe=n}return qe}function Je(e,n){if(O)return je(19,1,e,n);var r=0;return Qe().forEach((function(o,i){var s=n+r;for(i=a()[e+4*i>>2]=s,s=0;s<o.length;++s)t()[i++>>0]=o.charCodeAt(s);t()[i>>0]=0,r+=o.length+1})),0}function Ze(e,t){if(O)return je(20,1,e,t);var n=Qe();a()[e>>2]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),a()[t>>2]=r,0}function Ke(e){return O?je(21,1,e):0}function et(e,t,n,r){return O?je(22,1,e,t,n,r):(e=Se.Ub(e),t=Se.Sb(e,t,n),a()[r>>2]=t,0)}function tt(e,t,n,r,a){if(O)return je(23,1,e,t,n,r,a)}function nt(e,t,n,o){if(O)return je(24,1,e,t,n,o);for(var i=0,s=0;s<n;s++){var u=a()[t>>2],c=a()[t+4>>2];t+=8;for(var l=0;l<c;l++)Ae(e,r()[u+l]);i+=c}return a()[o>>2]=i,0}function rt(e){return 0==e%4&&(0!=e%100||0==e%400)}function at(e,t){for(var n=0,r=0;r<=t;n+=e[r++]);return n}var ot=[31,29,31,30,31,30,31,31,30,31,30,31],it=[31,28,31,30,31,30,31,31,30,31,30,31];function st(e,t){for(e=new Date(e.getTime());0<t;){var n=e.getMonth(),r=(rt(e.getFullYear())?ot:it)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return e}function ut(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){e=st(new Date(e.Na+1900,0,1),e.bb);var t=new Date(e.getFullYear()+1,0,4),n=c(new Date(e.getFullYear(),0,4));return t=c(t),0>=u(n,e)?0>=u(t,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2];for(var p in o={Kb:a()[o>>2],Jb:a()[o+4>>2],$a:a()[o+8>>2],Wa:a()[o+12>>2],Ra:a()[o+16>>2],Na:a()[o+20>>2],ab:a()[o+24>>2],bb:a()[o+28>>2],cc:a()[o+32>>2],Ib:a()[o+36>>2],Lb:f?N(f):""},r=N(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.ab].substring(0,3)},"%A":function(e){return d[e.ab]},"%b":function(e){return m[e.Ra].substring(0,3)},"%B":function(e){return m[e.Ra]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Wa,2)},"%e":function(e){return i(e.Wa,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.$a,2)},"%I":function(e){return 0==(e=e.$a)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){return s(e.Wa+at(rt(e.Na+1900)?ot:it,e.Ra-1),3)},"%m":function(e){return s(e.Ra+1,2)},"%M":function(e){return s(e.Jb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.$a&&12>e.$a?"AM":"PM"},"%S":function(e){return s(e.Kb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.ab||7},"%U":function(e){var t=new Date(e.Na+1900,0,1),n=0===t.getDay()?t:st(t,7-t.getDay());return 0>u(n,e=new Date(e.Na+1900,e.Ra,e.Wa))?s(Math.ceil((31-n.getDate()+(at(rt(e.getFullYear())?ot:it,e.getMonth()-1)-31)+e.getDate())/7),2):0===u(n,t)?"01":"00"},"%V":function(e){var t=new Date(e.Na+1901,0,4),n=c(new Date(e.Na+1900,0,4));t=c(t);var r=st(new Date(e.Na+1900,0,1),e.bb);return 0>u(r,n)?"53":0>=u(t,r)?"01":s(Math.ceil((n.getFullYear()<e.Na+1900?e.bb+32-n.getDate():e.bb+1-n.getDate())/7),2)},"%w":function(e){return e.ab},"%W":function(e){var t=new Date(e.Na,0,1),n=1===t.getDay()?t:st(t,0===t.getDay()?1:7-t.getDay()+1);return 0>u(n,e=new Date(e.Na+1900,e.Ra,e.Wa))?s(Math.ceil((31-n.getDate()+(at(rt(e.getFullYear())?ot:it,e.getMonth()-1)-31)+e.getDate())/7),2):0===u(n,t)?"01":"00"},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.Ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Lb},"%%":function(){return"%"}})r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(V(e)+1);return G(e,t,0,t.length),t}(r),p.length>n?0:(function(e,n){t().set(e,n)}(p,e),p.length-1)}var ct=[null,ge,Ee,Te,Me,De,Re,xe,ke,Ce,Fe,Pe,Ie,Ue,We,Le,He,Ye,Ve,Je,Ze,Ke,et,tt,nt],lt={b:function(e){return dt(e+16)+16},c:function(e,t,n){throw new ve(e).sb(t,n),e},M:function(e){yt(e,!_,1,!v),me.lb()},n:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):de(e)},p:function(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?bt(687865856,e,t,n,r):(e={Hb:n,cb:e,Sa:r,Mb:a},O?(e.Nb="spawnThread",postMessage(e,a),0):_e(e))},i:Ee,U:Te,R:Me,y:De,A:Re,t:xe,S:ke,H:Ce,G:Fe,F:Pe,o:Ie,z:Ue,w:We,T:Le,x:He,j:function(){se("To use dlopen, you need to use Emscripten\'s linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")},_:function(){se("To use dlopen, you need to use Emscripten\'s linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")},E:function(){return 2097152},Z:function(e,t,n){var r=performance.now();for(n=r+n,Atomics.exchange(a(),Dt>>2,e);;){if((r=performance.now())>n)return Atomics.exchange(a(),Dt>>2,0),-73;if(0==(r=Atomics.exchange(a(),Dt>>2,0)))break;if(ht(),Atomics.load(a(),e>>2)!=t)return-6;Atomics.exchange(a(),Dt>>2,e)}return 0},N:function(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(O)postMessage({targetThread:e,cmd:"processThreadQueue"});else{if(!(e=(e=me.Oa[e])&&e.worker))return;e.postMessage({cmd:"processThreadQueue"})}return 1},V:function(e,t){e=new Date(1e3*a()[e>>2]),a()[t>>2]=e.getUTCSeconds(),a()[t+4>>2]=e.getUTCMinutes(),a()[t+8>>2]=e.getUTCHours(),a()[t+12>>2]=e.getUTCDate(),a()[t+16>>2]=e.getUTCMonth(),a()[t+20>>2]=e.getUTCFullYear()-1900,a()[t+24>>2]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2]=e},W:function(e,t){e=new Date(1e3*a()[e>>2]),a()[t>>2]=e.getSeconds(),a()[t+4>>2]=e.getMinutes(),a()[t+8>>2]=e.getHours(),a()[t+12>>2]=e.getDate(),a()[t+16>>2]=e.getMonth(),a()[t+20>>2]=e.getFullYear()-1900,a()[t+24>>2]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2]=r,a()[t+36>>2]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2]=e},X:function(e){var t=new Date(a()[e+20>>2]+1900,a()[e+16>>2],a()[e+12>>2],a()[e+8>>2],a()[e+4>>2],a()[e>>2],0),n=a()[e+32>>2],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2]=n,a()[e>>2]=t.getSeconds(),a()[e+4>>2]=t.getMinutes(),a()[e+8>>2]=t.getHours(),a()[e+12>>2]=t.getDate(),a()[e+16>>2]=t.getMonth(),t.getTime()/1e3|0},Y:function e(t,n,r){e.ob||(e.ob=!0,Ye(t,n,r))},d:function(){se("")},q:function(e,t){if(0===e)e=Date.now();else{if(1!==e&&4!==e)return a()[ft()>>2]=28,-1;e=he()}return a()[t>>2]=e/1e3|0,a()[t+4>>2]=e%1e3*1e6|0,0},B:function(e,t){return e-t},m:function(){w||_||(M||(M={}),M["Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread"]||(M["Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread"]=1,x("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")))},v:function(){return 2147483648},f:he,Q:function(e,t,n){r().copyWithin(e,t,t+n)},g:function(){return w?n(993).cpus().length:navigator.hardwareConcurrency},I:function(e,t,n){Be.length=t,n>>=3;for(var r=0;r<t;r++)Be[r]=o()[n+r];return(0>e?le[-e-1]:ct[e]).apply(null,Be)},u:function(e){var t=r().length;if((e>>>=0)<=t||2147483648<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296),0<(a=Math.max(e,a))%65536&&(a+=65536-a%65536);e:{try{C.grow(Math.min(2147483648,a)-U.byteLength+65535>>>16),$(C.buffer);var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},K:function(e,t,n){return Ge(e)?ze(e,t,n):Ve(e,t,n)},C:function(){throw"unwind"},L:function(e,t){t>>=2;var n=a()[t+6];return t={alpha:!!a()[t],depth:!!a()[t+1],stencil:!!a()[t+2],antialias:!!a()[t+3],premultipliedAlpha:!!a()[t+4],preserveDrawingBuffer:!!a()[t+5],powerPreference:$e[n],failIfMajorPerformanceCaveat:!!a()[t+7],xb:a()[t+8],Xb:a()[t+9],gb:a()[t+10],qb:a()[t+11],$b:a()[t+12],ac:a()[t+13]},!(e=Ge(e))||t.qb?0:function(e,t){e.hb||(e.hb=e.getContext,e.getContext=function(t,n){return"webgl"==t==(n=e.hb(t,n))instanceof WebGLRenderingContext?n:null});var n=e.getContext("webgl",t);return n?function(e,t){var n=dt(8);a()[n+4>>2]=pt();var r={Vb:n,attributes:t,version:t.xb,Xa:e};return e.canvas&&(e.canvas.Ya=r),(void 0===t.gb||t.gb)&&function(e){if(e||(e=void 0),!e.tb){e.tb=!0;var t=e.Xa;!function(e){var t=e.getExtension("ANGLE_instanced_arrays");t&&(e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,r,a){t.drawArraysInstancedANGLE(e,n,r,a)},e.drawElementsInstanced=function(e,n,r,a,o){t.drawElementsInstancedANGLE(e,n,r,a,o)})}(t),function(e){var t=e.getExtension("OES_vertex_array_object");t&&(e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)})}(t),function(e){var t=e.getExtension("WEBGL_draw_buffers");t&&(e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)})}(t),t.Pb=t.getExtension("EXT_disjoint_timer_query"),t.Yb=t.getExtension("WEBGL_multi_draw"),(t.getSupportedExtensions()||[]).forEach((function(e){e.includes("lose_context")||e.includes("debug")||t.getExtension(e)}))}}(r),n}(n,t):0}(e,t)},O:Je,P:Ze,D:function(e){Ct(e)},h:Ke,l:et,s:tt,k:nt,J:function(e){var t=Date.now();return a()[e>>2]=t/1e3|0,a()[e+4>>2]=t%1e3*1e3|0,0},a:C||i.wasmMemory,r:ut,e:function(e,t,n,r){return ut(e,t,n,r)}};!function(){function e(e,t){i.asm=e.exports,me.fb.push(i.asm.xa),Q=i.asm.Ba,Z.unshift(i.asm.$),F=t,O||(ae--,i.monitorRunDependencies&&i.monitorRunDependencies(ae),0==ae&&(null!==oe&&(clearInterval(oe),oe=null),ie&&(e=ie,ie=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!D&&(v||_)){if("function"==typeof fetch&&!re.startsWith("file://"))return fetch(re,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+re+"\'";return e.arrayBuffer()})).catch((function(){return ce()}));if(f)return new Promise((function(e,t){f(re,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ce()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),se(e)}))}var r={a:lt};if(O||(ae++,i.monitorRunDependencies&&i.monitorRunDependencies(ae)),i.instantiateWasm)try{return i.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(D||"function"!=typeof WebAssembly.instantiateStreaming||ue()||re.startsWith("file://")||"function"!=typeof fetch?n(t):fetch(re,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(u)}(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.$).apply(null,arguments)},i._OrtInit=function(){return(i._OrtInit=i.asm.aa).apply(null,arguments)},i._OrtCreateSessionOptions=function(){return(i._OrtCreateSessionOptions=i.asm.ba).apply(null,arguments)},i._OrtAddSessionConfigEntry=function(){return(i._OrtAddSessionConfigEntry=i.asm.ca).apply(null,arguments)},i._OrtReleaseSessionOptions=function(){return(i._OrtReleaseSessionOptions=i.asm.da).apply(null,arguments)},i._OrtCreateSession=function(){return(i._OrtCreateSession=i.asm.ea).apply(null,arguments)},i._OrtReleaseSession=function(){return(i._OrtReleaseSession=i.asm.fa).apply(null,arguments)},i._OrtGetInputCount=function(){return(i._OrtGetInputCount=i.asm.ga).apply(null,arguments)},i._OrtGetOutputCount=function(){return(i._OrtGetOutputCount=i.asm.ha).apply(null,arguments)},i._OrtGetInputName=function(){return(i._OrtGetInputName=i.asm.ia).apply(null,arguments)},i._OrtGetOutputName=function(){return(i._OrtGetOutputName=i.asm.ja).apply(null,arguments)},i._OrtFree=function(){return(i._OrtFree=i.asm.ka).apply(null,arguments)},i._OrtCreateTensor=function(){return(i._OrtCreateTensor=i.asm.la).apply(null,arguments)},i._OrtGetTensorData=function(){return(i._OrtGetTensorData=i.asm.ma).apply(null,arguments)},i._OrtReleaseTensor=function(){return(i._OrtReleaseTensor=i.asm.na).apply(null,arguments)},i._OrtCreateRunOptions=function(){return(i._OrtCreateRunOptions=i.asm.oa).apply(null,arguments)},i._OrtAddRunConfigEntry=function(){return(i._OrtAddRunConfigEntry=i.asm.pa).apply(null,arguments)},i._OrtReleaseRunOptions=function(){return(i._OrtReleaseRunOptions=i.asm.qa).apply(null,arguments)},i._OrtRun=function(){return(i._OrtRun=i.asm.ra).apply(null,arguments)},i._OrtEndProfiling=function(){return(i._OrtEndProfiling=i.asm.sa).apply(null,arguments)};var ft=i.___errno_location=function(){return(ft=i.___errno_location=i.asm.ta).apply(null,arguments)},pt=i._pthread_self=function(){return(pt=i._pthread_self=i.asm.ua).apply(null,arguments)},dt=i._malloc=function(){return(dt=i._malloc=i.asm.va).apply(null,arguments)},mt=i._free=function(){return(mt=i._free=i.asm.wa).apply(null,arguments)};i._emscripten_tls_init=function(){return(i._emscripten_tls_init=i.asm.xa).apply(null,arguments)};var gt=i.___funcs_on_exit=function(){return(gt=i.___funcs_on_exit=i.asm.ya).apply(null,arguments)},ht=i._emscripten_main_thread_process_queued_calls=function(){return(ht=i._emscripten_main_thread_process_queued_calls=i.asm.za).apply(null,arguments)},yt=i.__emscripten_thread_init=function(){return(yt=i.__emscripten_thread_init=i.asm.Aa).apply(null,arguments)};i._emscripten_current_thread_process_queued_calls=function(){return(i._emscripten_current_thread_process_queued_calls=i.asm.Ca).apply(null,arguments)};var bt=i._emscripten_sync_run_in_main_thread_4=function(){return(bt=i._emscripten_sync_run_in_main_thread_4=i.asm.Da).apply(null,arguments)},vt=i._emscripten_run_in_main_runtime_thread_js=function(){return(vt=i._emscripten_run_in_main_runtime_thread_js=i.asm.Ea).apply(null,arguments)},_t=i._emscripten_dispatch_to_thread_=function(){return(_t=i._emscripten_dispatch_to_thread_=i.asm.Fa).apply(null,arguments)},wt=i.__emscripten_thread_free_data=function(){return(wt=i.__emscripten_thread_free_data=i.asm.Ga).apply(null,arguments)};i.__emscripten_thread_exit=function(){return(i.__emscripten_thread_exit=i.asm.Ha).apply(null,arguments)};var Ot,At=i._memalign=function(){return(At=i._memalign=i.asm.Ia).apply(null,arguments)},St=i._emscripten_stack_set_limits=function(){return(St=i._emscripten_stack_set_limits=i.asm.Ja).apply(null,arguments)},Et=i.stackSave=function(){return(Et=i.stackSave=i.asm.Ka).apply(null,arguments)},Tt=i.stackRestore=function(){return(Tt=i.stackRestore=i.asm.La).apply(null,arguments)},Mt=i.stackAlloc=function(){return(Mt=i.stackAlloc=i.asm.Ma).apply(null,arguments)},Dt=i.__emscripten_main_thread_futex=687896,Rt=i.__emscripten_allow_main_runtime_queued_calls=683012;function xt(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function kt(){function e(){if(!Ot&&(Ot=!0,i.calledRun=!0,!P)&&(O||fe(Z),s(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),!O)){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;){var e=i.postRun.shift();ee.unshift(e)}fe(ee)}}if(!(0<ae))if(O)s(i),O||fe(Z),postMessage({cmd:"loaded"});else{if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)ne();fe(J),0<ae||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),e()}),1)):e())}}function Ct(e){if(O)throw ge(e),"unwind";te()||O||(gt(),fe(K),Oe[1].length&&Ae(1,10),Oe[2].length&&Ae(2,10),me.kb()),te()||(me.kb(),i.onExit&&i.onExit(e),P=!0),b(e,new xt(e))}if(i.UTF8ToString=N,i.stringToUTF8=z,i.lengthBytesUTF8=V,i.keepRuntimeAlive=te,i.PThread=me,i.stackSave=Et,i.stackRestore=Tt,i.stackAlloc=Mt,i.PThread=me,i.wasmMemory=C,i.ExitStatus=xt,ie=function e(){Ot||kt(),Ot||(ie=e)},i.run=kt,i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);0<i.preInit.length;)i.preInit.pop()();return O&&(k=!1,me.ub()),kt(),e.ready});e.exports=r},118:e=>{"use strict";e.exports=\'"use strict";var e={};if("object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node){var t=require("worker_threads"),r=t.parentPort;r.on("message",(function(e){onmessage({data:e})}));var a=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:t.Worker,importScripts:function(e){(0,eval)(a.readFileSync(e,"utf8"))},postMessage:function(e){r.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=function(){var e=Array.prototype.slice.call(arguments).join(" ");console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.threadInfoStruct,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInit();try{var a=e.invokeEntryPoint(t.data.start_routine,t.data.arg);e.keepRuntimeAlive()?e.PThread.setExitStatus(a):e.__emscripten_thread_exit(a)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processThreadQueue"===t.data.cmd?e._pthread_self()&&e._emscripten_current_thread_process_queued_calls():(s("worker.js received unknown command "+t.data.cmd),s(t.data)))}catch(e){throw s("worker.js onmessage() captured an uncaught exception: "+e),e&&e.stack&&s(e.stack),e}};\\n\'},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t;e=e||{},t||(t=void 0!==e?e:{});var r,a,o=Object.assign;t.ready=new Promise((function(e,t){r=e,a=t}));var i,s,u,c,l,f,p=o({},t),d="./this.program",m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",f=()=>{l||(c=n(384),l=n(908))},i=function(e,t){return f(),e=l.normalize(e),c.readFileSync(e,t?null:"utf8")},u=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),s=(e,t,n)=>{f(),e=l.normalize(e),c.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(d=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){throw e})),process.on("unhandledRejection",(function(e){throw e})),t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(u=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),s=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var b,v=t.print||console.log.bind(console),_=t.printErr||console.warn.bind(console);o(t,p),p=null,t.thisProgram&&(d=t.thisProgram),t.wasmBinary&&(b=t.wasmBinary),t.noExitRuntime,"object"!=typeof WebAssembly&&N("no native wasm support detected");var w,O,A,S,E,T=!1,M="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function D(e,t,n){var r=t+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.subarray&&M)return M.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function R(e,t){return e?D(S,e,t):""}function x(e,t,n,r){if(!(0<r))return 0;var a=n;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++]=i}else{if(2047>=i){if(n+1>=r)break;t[n++]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++]=224|i>>12}else{if(n+3>=r)break;t[n++]=240|i>>18,t[n++]=128|i>>12&63}t[n++]=128|i>>6&63}t[n++]=128|63&i}}return t[n]=0,n-a}function k(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),127>=r?++t:t=2047>=r?t+2:65535>=r?t+3:t+4}return t}function C(e){var t=k(e)+1,n=de(t);return n&&x(e,A,n,t),n}function F(){var e=w.buffer;O=e,t.HEAP8=A=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=S=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var P,I=[],U=[],W=[];function L(){var e=t.preRun.shift();I.unshift(e)}var H,Y=0,j=null,B=null;function N(e){throw t.onAbort&&t.onAbort(e),_(e="Aborted("+e+")"),T=!0,e=new WebAssembly.RuntimeError(e+". Build with -s ASSERTIONS=1 for more info."),a(e),e}function G(){return H.startsWith("data:application/octet-stream;base64,")}if(t.preloadedImages={},t.preloadedAudios={},H="ort-wasm.wasm",!G()){var z=H;H=t.locateFile?t.locateFile(z,y):y+z}function V(){var e=H;try{if(e==H&&b)return new Uint8Array(b);if(u)return u(e);throw"both async and sync fetching of the wasm failed"}catch(e){N(e)}}function q(e){for(;0<e.length;){var n=e.shift();if("function"==typeof n)n(t);else{var r=n.Na;"number"==typeof r?void 0===n.va?X(r)():X(r)(n.va):r(void 0===n.va?null:n.va)}}}var $=[];function X(e){var t=$[e];return t||(e>=$.length&&($.length=e+1),$[e]=t=P.get(e)),t}function Q(e){this.qa=e-16,this.Fa=function(e){E[this.qa+4>>2]=e},this.Ca=function(e){E[this.qa+8>>2]=e},this.Da=function(){E[this.qa>>2]=0},this.Ba=function(){A[this.qa+12>>0]=0},this.Ea=function(){A[this.qa+13>>0]=0},this.ya=function(e,t){this.Fa(e),this.Ca(t),this.Da(),this.Ba(),this.Ea()}}var J,Z,K={},ee=[null,[],[]],te={},ne={};function re(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:d||"./this.program"};for(e in ne)void 0===ne[e]?delete t[e]:t[e]=ne[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}function ae(e){return 0==e%4&&(0!=e%100||0==e%400)}function oe(e,t){for(var n=0,r=0;r<=t;n+=e[r++]);return n}var ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t){for(e=new Date(e.getTime());0<t;){var n=e.getMonth(),r=(ae(e.getFullYear())?ie:se)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return e}function ce(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){e=ue(new Date(e.oa+1900,0,1),e.ua);var t=new Date(e.getFullYear()+1,0,4),n=s(new Date(e.getFullYear(),0,4));return t=s(t),0>=i(n,e)?0>=i(t,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2];for(var l in r={Ia:E[r>>2],Ha:E[r+4>>2],sa:E[r+8>>2],ra:E[r+12>>2],pa:E[r+16>>2],oa:E[r+20>>2],ta:E[r+24>>2],ua:E[r+28>>2],Qa:E[r+32>>2],Ga:E[r+36>>2],Ja:c?R(c):""},n=R(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.ta].substring(0,3)},"%A":function(e){return f[e.ta]},"%b":function(e){return p[e.pa].substring(0,3)},"%B":function(e){return p[e.pa]},"%C":function(e){return o((e.oa+1900)/100|0,2)},"%d":function(e){return o(e.ra,2)},"%e":function(e){return a(e.ra,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.sa,2)},"%I":function(e){return 0==(e=e.sa)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){return o(e.ra+oe(ae(e.oa+1900)?ie:se,e.pa-1),3)},"%m":function(e){return o(e.pa+1,2)},"%M":function(e){return o(e.Ha,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.sa&&12>e.sa?"AM":"PM"},"%S":function(e){return o(e.Ia,2)},"%t":function(){return"\\t"},"%u":function(e){return e.ta||7},"%U":function(e){var t=new Date(e.oa+1900,0,1),n=0===t.getDay()?t:ue(t,7-t.getDay());return 0>i(n,e=new Date(e.oa+1900,e.pa,e.ra))?o(Math.ceil((31-n.getDate()+(oe(ae(e.getFullYear())?ie:se,e.getMonth()-1)-31)+e.getDate())/7),2):0===i(n,t)?"01":"00"},"%V":function(e){var t=new Date(e.oa+1901,0,4),n=s(new Date(e.oa+1900,0,4));t=s(t);var r=ue(new Date(e.oa+1900,0,1),e.ua);return 0>i(r,n)?"53":0>=i(t,r)?"01":o(Math.ceil((n.getFullYear()<e.oa+1900?e.ua+32-n.getDate():e.ua+1-n.getDate())/7),2)},"%w":function(e){return e.ta},"%W":function(e){var t=new Date(e.oa,0,1),n=1===t.getDay()?t:ue(t,0===t.getDay()?1:7-t.getDay()+1);return 0>i(n,e=new Date(e.oa+1900,e.pa,e.ra))?o(Math.ceil((31-n.getDate()+(oe(ae(e.getFullYear())?ie:se,e.getMonth()-1)-31)+e.getDate())/7),2):0===i(n,t)?"01":"00"},"%y":function(e){return(e.oa+1900).toString().substring(2)},"%Y":function(e){return e.oa+1900},"%z":function(e){var t=0<=(e=e.Ga);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Ja},"%%":function(){return"%"}})n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(k(e)+1);return x(e,t,0,t.length),t}(n),l.length>t?0:(A.set(l,e),l.length-1)}var le={a:function(e){return de(e+16)+16},b:function(e,t,n){throw new Q(e).ya(t,n),e},g:function(){return 0},I:function(){},F:function(){},v:function(){},y:function(){},r:function(){return 0},G:function(){},B:function(e,t){return e=R(e),te.Ka(e,t)},A:function(e,t,n,r,a,o){if(o<<=12,0!=(16&r)&&0!=e%65536)t=-28;else if(0!=(32&r)){e=65536*Math.ceil(t/65536);var i=ge(65536,e);i?(S.fill(0,i,i+e),e=i):e=0,e?(K[e]={Aa:e,za:t,wa:!0,fd:a,Pa:n,flags:r,offset:o},t=e):t=-48}else t=-52;return t},z:function(e,t){var n=K[e];return 0!==t&&n?(t===n.za&&(K[e]=null,n.wa&&me(n.Aa)),e=0):e=-28,e},k:function(){},x:function(e,t,n){return e=R(e),te.La(e,t,n)},t:function(){},H:function(){},u:function(){},h:function(){N("To use dlopen, you need to use Emscripten\'s linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")},n:function(){N("To use dlopen, you need to use Emscripten\'s linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")},J:function(e,t){e=new Date(1e3*E[e>>2]),E[t>>2]=e.getUTCSeconds(),E[t+4>>2]=e.getUTCMinutes(),E[t+8>>2]=e.getUTCHours(),E[t+12>>2]=e.getUTCDate(),E[t+16>>2]=e.getUTCMonth(),E[t+20>>2]=e.getUTCFullYear()-1900,E[t+24>>2]=e.getUTCDay(),E[t+28>>2]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},K:function(e,t){e=new Date(1e3*E[e>>2]),E[t>>2]=e.getSeconds(),E[t+4>>2]=e.getMinutes(),E[t+8>>2]=e.getHours(),E[t+12>>2]=e.getDate(),E[t+16>>2]=e.getMonth(),E[t+20>>2]=e.getFullYear()-1900,E[t+24>>2]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},L:function(e){var t=new Date(E[e+20>>2]+1900,E[e+16>>2],E[e+12>>2],E[e+8>>2],E[e+4>>2],E[e>>2],0),n=E[e+32>>2],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2]=t.getDay(),E[e+28>>2]=(t.getTime()-a.getTime())/864e5|0,E[e>>2]=t.getSeconds(),E[e+4>>2]=t.getMinutes(),E[e+8>>2]=t.getHours(),E[e+12>>2]=t.getDate(),E[e+16>>2]=t.getMonth(),t.getTime()/1e3|0},M:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2]=60*Math.max(a,s),E[t>>2]=Number(a!=s),e=r(o),t=r(i),e=C(e),t=C(t),s<a?(E[n>>2]=e,E[n+4>>2]=t):(E[n>>2]=t,E[n+4>>2]=e)}(t,n,r))},d:function(){N("")},m:function(e,t){if(0===e)e=Date.now();else{if(1!==e&&4!==e)return E[pe()>>2]=28,-1;e=J()}return E[t>>2]=e/1e3|0,E[t+4>>2]=e%1e3*1e6|0,0},p:function(e,t){return e-t},s:function(){return 2147483648},l:J=h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),E:function(e,t,n){S.copyWithin(e,t,t+n)},f:function(e){var t=S.length;if(2147483648<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296),0<(r=Math.max(e,r))%65536&&(r+=65536-r%65536);e:{try{w.grow(Math.min(2147483648,r)-O.byteLength+65535>>>16),F();var a=1;break e}catch(e){}a=void 0}if(a)return!0}return!1},C:function(e,t){var n=0;return re().forEach((function(r,a){var o=t+n;for(a=E[e+4*a>>2]=o,o=0;o<r.length;++o)A[a++>>0]=r.charCodeAt(o);A[a>>0]=0,n+=r.length+1})),0},D:function(e,t){var n=re();E[e>>2]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),E[t>>2]=r,0},e:function(){return 0},j:function(e,t,n,r){return e=te.Oa(e),t=te.Ma(e,t,n),E[r>>2]=t,0},q:function(){},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=E[t>>2],s=E[t+4>>2];t+=8;for(var u=0;u<s;u++){var c=S[i+u],l=ee[e];0===c||10===c?((1===e?v:_)(D(l,0)),l.length=0):l.push(c)}a+=s}return E[r>>2]=a,0},w:function(e){var t=Date.now();return E[e>>2]=t/1e3|0,E[e+4>>2]=t%1e3*1e3|0,0},o:ce,c:function(e,t,n,r){return ce(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,w=t.asm.N,F(),P=t.asm.ja,U.unshift(t.asm.O),Y--,t.monitorRunDependencies&&t.monitorRunDependencies(Y),0==Y&&(null!==j&&(clearInterval(j),j=null),B&&(e=B,B=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!b&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return V()}));if(s)return new Promise((function(e,t){s(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return V()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){_("failed to asynchronously prepare wasm: "+e),N(e)}))}var o={a:le};if(Y++,t.monitorRunDependencies&&t.monitorRunDependencies(Y),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return _("Module.instantiateWasm callback failed with error: "+e),!1}(b||"function"!=typeof WebAssembly.instantiateStreaming||G()||H.startsWith("file://")||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return _("wasm streaming compile failed: "+e),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.O).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.P).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.Q).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.R).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.S).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.T).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.U).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.V).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.W).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.X).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.Y).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.Z).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm._).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.$).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.aa).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ba).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.ca).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.da).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ea).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.fa).apply(null,arguments)};var fe,pe=t.___errno_location=function(){return(pe=t.___errno_location=t.asm.ga).apply(null,arguments)},de=t._malloc=function(){return(de=t._malloc=t.asm.ha).apply(null,arguments)},me=t._free=function(){return(me=t._free=t.asm.ia).apply(null,arguments)},ge=t._memalign=function(){return(ge=t._memalign=t.asm.ka).apply(null,arguments)},he=t.stackSave=function(){return(he=t.stackSave=t.asm.la).apply(null,arguments)},ye=t.stackRestore=function(){return(ye=t.stackRestore=t.asm.ma).apply(null,arguments)},be=t.stackAlloc=function(){return(be=t.stackAlloc=t.asm.na).apply(null,arguments)};function ve(){function e(){if(!fe&&(fe=!0,t.calledRun=!0,!T)){if(q(U),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}q(W)}}if(!(0<Y)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)L();q(I),0<Y||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.UTF8ToString=R,t.stringToUTF8=function(e,t,n){return x(e,S,t,n)},t.lengthBytesUTF8=k,t.stackSave=he,t.stackRestore=ye,t.stackAlloc=be,B=function e(){fe||ve(),fe||(B=e)},t.run=ve,t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ve(),e.ready});e.exports=r},967:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)t.iterateExtraOptions(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},586:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(967),a=n(983),o=n(361);t.setRunOptions=e=>{const t=o.getInstance();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=a.allocWasmString(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&r.iterateExtraOptions(e.extra,"",new WeakSet,((e,r)=>{const o=a.allocWasmString(e,i),s=a.allocWasmString(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},919:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(967),a=n(983),o=n(361);t.setSessionOptions=e=>{const t=o.getInstance();let n=0;const i=[],s=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1")})(s);try{void 0===(null==e?void 0:e.graphOptimizationLevel)&&(s.graphOptimizationLevel="all");const o=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(s.graphOptimizationLevel);void 0===(null==e?void 0:e.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==e?void 0:e.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==e?void 0:e.executionMode)&&(s.executionMode="sequential");const u=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(s.executionMode);let c=0;if(void 0!==(null==e?void 0:e.logId)&&(c=a.allocWasmString(e.logId,i)),void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);if(void 0===(null==e?void 0:e.enableProfiling)&&(s.enableProfiling=!1),n=t._OrtCreateSessionOptions(o,!!s.enableCpuMemArena,!!s.enableMemPattern,u,!!s.enableProfiling,0,c,s.logSeverityLevel,s.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return void 0!==(null==e?void 0:e.extra)&&r.iterateExtraOptions(e.extra,"",new WeakSet,((e,r)=>{const o=a.allocWasmString(e,i),s=a.allocWasmString(r,i);if(0!==t._OrtAddSessionConfigEntry(n,o,s))throw new Error(`Can\'t set a session config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseSessionOptions(n),i.forEach(t._free),e}}},983:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(361);t.allocWasmString=(e,t)=>{const n=r.getInstance(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},349:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.initOrt=void 0;const r=n(586),a=n(919),o=n(983),i=n(361);t.initOrt=(e,t)=>{const n=i.getInstance()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const s=new Map;t.createSession=(e,t)=>{const n=i.getInstance(),r=n._malloc(e.byteLength);let o=0,u=0,c=[];try{if([u,c]=a.setSessionOptions(t),n.HEAPU8.set(e,r),o=n._OrtCreateSession(r,e.byteLength,u),0===o)throw new Error("Can\'t create a session")}finally{n._free(r),n._OrtReleaseSessionOptions(u),c.forEach(n._free)}const l=n._OrtGetInputCount(o),f=n._OrtGetOutputCount(o),p=[],d=[],m=[],g=[];for(let e=0;e<l;e++){const t=n._OrtGetInputName(o,e);if(0===t)throw new Error("Can\'t get an input name");d.push(t),p.push(n.UTF8ToString(t))}for(let e=0;e<f;e++){const t=n._OrtGetOutputName(o,e);if(0===t)throw new Error("Can\'t get an output name");g.push(t),m.push(n.UTF8ToString(t))}return s.set(o,[o,d,g]),[o,p,m]},t.releaseSession=e=>{const t=i.getInstance(),n=s.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),s.delete(e)};const u=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},c=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:case 7:return"int32";case 12:case 13:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";default:throw new Error(`unsupported data type: ${e}`)}},l=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}};t.run=(e,t,n,a,f)=>{const p=i.getInstance(),d=s.get(e);if(!d)throw new Error("invalid session id");const m=d[0],g=d[1],h=d[2],y=t.length,b=a.length;let v=0,_=[];const w=[],O=[];try{[v,_]=r.setRunOptions(f);for(let e=0;e<y;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let i,s;if(Array.isArray(a)){s=4*a.length,i=p._malloc(s),O.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);p.HEAPU32[e++]=o.allocWasmString(a[t],O)}}else s=a.byteLength,i=p._malloc(s),O.push(i),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,s),i);const c=p.stackSave(),l=p.stackAlloc(4*r.length);try{let e=l/4;r.forEach((t=>p.HEAP32[e++]=t));const n=p._OrtCreateTensor(u(t),i,s,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");w.push(n)}finally{p.stackRestore(c)}}const e=p.stackSave(),i=p.stackAlloc(4*y),s=p.stackAlloc(4*y),d=p.stackAlloc(4*b),A=p.stackAlloc(4*b);try{let n=i/4,r=s/4,o=d/4,u=A/4;for(let e=0;e<y;e++)p.HEAPU32[n++]=w[e],p.HEAPU32[r++]=g[t[e]];for(let e=0;e<b;e++)p.HEAPU32[o++]=0,p.HEAPU32[u++]=h[a[e]];let f=p._OrtRun(m,s,i,y,A,b,d,v);const _=[];if(0===f)for(let e=0;e<b;e++){const t=p.HEAPU32[d/4+e],n=p.stackSave(),r=p.stackAlloc(16);let a,o=0;try{if(f=p._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t get a tensor data. error code = ${f}`);let e=r/4;const i=p.HEAPU32[e++];o=p.HEAPU32[e++];const s=p.HEAPU32[e++],u=p.HEAPU32[e++],d=[];for(let e=0;e<u;e++)d.push(p.HEAPU32[s/4+e]);p._OrtFree(s);const m=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=c(i),"string"===a){const e=[];let t=o/4;for(let n=0;n<m;n++){const r=p.HEAPU32[t++],a=n===m-1?void 0:p.HEAPU32[t]-r;e.push(p.UTF8ToString(r,a))}_.push([a,d,e])}else{const e=new(l(a))(m);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(p.HEAPU8.subarray(o,o+e.byteLength)),_.push([a,d,e])}}finally{p.stackRestore(n),"string"===a&&o&&p._free(o),p._OrtReleaseTensor(t)}}if(0===f)return _;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(e)}}finally{w.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),_.forEach(p._free)}},t.endProfiling=e=>{const t=i.getInstance(),n=s.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},361:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n),Object.defineProperty(e,r,{enumerable:!0,get:function(){return t[n]}})}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const s=o(n(449)),u=i(n(932)),c=n(474);let l,f=!1,p=!1,d=!1;const m=(e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm";t.initializeWebAssembly=async e=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),i=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g="string"==typeof e.wasmPaths?e.wasmPaths:void 0,h=m(!1,o),y=m(i,o),b="object"==typeof e.wasmPaths?e.wasmPaths[y]:void 0;let v=!1;const _=[];if(t>0&&_.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),_.push(new Promise(((e,t)=>{const r=o?c:u.default,a={locateFile:(e,t)=>{if(o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob)return URL.createObjectURL(new Blob([n(118)],{type:"text/javascript"}));if(e===h){const e=null!=g?g:t;return null!=b?b:e+y}return t+e}};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{p=!1,f=!0,l=t,e()}),(e=>{p=!1,d=!0,t(e)}))}))),await Promise.race(_),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!f||p||d||(p=!0,null===(e=l.PThread)||void 0===e||e.terminateAllThreads(),l=void 0,p=!1,f=!1,d=!0)}},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(349),t=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":t.initializeWebAssembly(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;e.initOrt(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=e.createSession(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;e.releaseSession(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in,s=e.run(t,r,a,o,i);postMessage({type:"run",out:s},e.extractTransferableBuffers(s))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;e.endProfiling(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n', "Worker", void 0, void 0);
                }
            },
            477: (e367)=>{
                "use strict";
                e367.exports = function(e, t, n, r) {
                    var i = self || window;
                    try {
                        try {
                            var o;
                            try {
                                o = new i.Blob([
                                    e
                                ]);
                            } catch (t257) {
                                (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)).append(e), o = o.getBlob();
                            }
                            var s = i.URL || i.webkitURL, a = s.createObjectURL(o), u = new i[t](a, n);
                            return s.revokeObjectURL(a), u;
                        } catch (r) {
                            return new i[t]("data:application/javascript,".concat(encodeURIComponent(e)), n);
                        }
                    } catch (e368) {
                        if (!r) throw Error("Inline worker is not supported");
                        return new i[t](r, n);
                    }
                };
            },
            2174: (e)=>{
                "use strict";
                e.exports = __WEBPACK_EXTERNAL_MODULE__2174__;
            },
            7067: ()=>{},
            1296: ()=>{},
            1384: ()=>{},
            3993: ()=>{},
            908: ()=>{},
            6953: ()=>{},
            9925: ()=>{},
            6449: ()=>{},
            2203: ()=>{},
            5381: ()=>{},
            8022: ()=>{}
        }, __webpack_module_cache__ = {};
        function __webpack_require__(e) {
            var t = __webpack_module_cache__[e];
            if (void 0 !== t) return t.exports;
            var n = __webpack_module_cache__[e] = {
                exports: {}
            };
            return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports;
        }
        __webpack_require__.n = (e)=>{
            var t = e && e.__esModule ? ()=>e.default
             : ()=>e
            ;
            return __webpack_require__.d(t, {
                a: t
            }), t;
        }, __webpack_require__.d = (e, t)=>{
            for(var n in t)__webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            });
        }, __webpack_require__.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if ("object" == typeof window) return window;
            }
        }(), __webpack_require__.o = (e, t)=>Object.prototype.hasOwnProperty.call(e, t)
        , __webpack_require__.r = (e)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            });
        };
        var __webpack_exports__ = __webpack_require__(6018);
        return __webpack_exports__;
    })();
});

});
parcelRequire.register("3tEm6", function(module, exports) {
// shim for using process in browser
var $2883624cce9f1464$var$process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var $2883624cce9f1464$var$cachedSetTimeout;
var $2883624cce9f1464$var$cachedClearTimeout;
function $2883624cce9f1464$var$defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function $2883624cce9f1464$var$defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') $2883624cce9f1464$var$cachedSetTimeout = setTimeout;
        else $2883624cce9f1464$var$cachedSetTimeout = $2883624cce9f1464$var$defaultSetTimout;
    } catch (e) {
        $2883624cce9f1464$var$cachedSetTimeout = $2883624cce9f1464$var$defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') $2883624cce9f1464$var$cachedClearTimeout = clearTimeout;
        else $2883624cce9f1464$var$cachedClearTimeout = $2883624cce9f1464$var$defaultClearTimeout;
    } catch (e1) {
        $2883624cce9f1464$var$cachedClearTimeout = $2883624cce9f1464$var$defaultClearTimeout;
    }
})();
function $2883624cce9f1464$var$runTimeout(fun) {
    if ($2883624cce9f1464$var$cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if (($2883624cce9f1464$var$cachedSetTimeout === $2883624cce9f1464$var$defaultSetTimout || !$2883624cce9f1464$var$cachedSetTimeout) && setTimeout) {
        $2883624cce9f1464$var$cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $2883624cce9f1464$var$cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return $2883624cce9f1464$var$cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return $2883624cce9f1464$var$cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function $2883624cce9f1464$var$runClearTimeout(marker) {
    if ($2883624cce9f1464$var$cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if (($2883624cce9f1464$var$cachedClearTimeout === $2883624cce9f1464$var$defaultClearTimeout || !$2883624cce9f1464$var$cachedClearTimeout) && clearTimeout) {
        $2883624cce9f1464$var$cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return $2883624cce9f1464$var$cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return $2883624cce9f1464$var$cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return $2883624cce9f1464$var$cachedClearTimeout.call(this, marker);
        }
    }
}
var $2883624cce9f1464$var$queue = [];
var $2883624cce9f1464$var$draining = false;
var $2883624cce9f1464$var$currentQueue;
var $2883624cce9f1464$var$queueIndex = -1;
function $2883624cce9f1464$var$cleanUpNextTick() {
    if (!$2883624cce9f1464$var$draining || !$2883624cce9f1464$var$currentQueue) return;
    $2883624cce9f1464$var$draining = false;
    if ($2883624cce9f1464$var$currentQueue.length) $2883624cce9f1464$var$queue = $2883624cce9f1464$var$currentQueue.concat($2883624cce9f1464$var$queue);
    else $2883624cce9f1464$var$queueIndex = -1;
    if ($2883624cce9f1464$var$queue.length) $2883624cce9f1464$var$drainQueue();
}
function $2883624cce9f1464$var$drainQueue() {
    if ($2883624cce9f1464$var$draining) return;
    var timeout = $2883624cce9f1464$var$runTimeout($2883624cce9f1464$var$cleanUpNextTick);
    $2883624cce9f1464$var$draining = true;
    var len = $2883624cce9f1464$var$queue.length;
    while(len){
        $2883624cce9f1464$var$currentQueue = $2883624cce9f1464$var$queue;
        $2883624cce9f1464$var$queue = [];
        while(++$2883624cce9f1464$var$queueIndex < len)if ($2883624cce9f1464$var$currentQueue) $2883624cce9f1464$var$currentQueue[$2883624cce9f1464$var$queueIndex].run();
        $2883624cce9f1464$var$queueIndex = -1;
        len = $2883624cce9f1464$var$queue.length;
    }
    $2883624cce9f1464$var$currentQueue = null;
    $2883624cce9f1464$var$draining = false;
    $2883624cce9f1464$var$runClearTimeout(timeout);
}
$2883624cce9f1464$var$process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    $2883624cce9f1464$var$queue.push(new $2883624cce9f1464$var$Item(fun, args));
    if ($2883624cce9f1464$var$queue.length === 1 && !$2883624cce9f1464$var$draining) $2883624cce9f1464$var$runTimeout($2883624cce9f1464$var$drainQueue);
};
// v8 likes predictible objects
function $2883624cce9f1464$var$Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
$2883624cce9f1464$var$Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
$2883624cce9f1464$var$process.title = 'browser';
$2883624cce9f1464$var$process.browser = true;
$2883624cce9f1464$var$process.env = {};
$2883624cce9f1464$var$process.argv = [];
$2883624cce9f1464$var$process.version = ''; // empty string to avoid regexp issues
$2883624cce9f1464$var$process.versions = {};
function $2883624cce9f1464$var$noop() {}
$2883624cce9f1464$var$process.on = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.addListener = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.once = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.off = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.removeListener = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.removeAllListeners = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.emit = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.prependListener = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.prependOnceListener = $2883624cce9f1464$var$noop;
$2883624cce9f1464$var$process.listeners = function(name) {
    return [];
};
$2883624cce9f1464$var$process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
$2883624cce9f1464$var$process.cwd = function() {
    return '/';
};
$2883624cce9f1464$var$process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
$2883624cce9f1464$var$process.umask = function() {
    return 0;
};

});

parcelRequire.register("kUnTQ", function(module, exports) {

var $in9LP = parcelRequire("in9LP");

var $bHL7h = parcelRequire("bHL7h");

var $f0ozy = parcelRequire("f0ozy");

var $gCuEI = parcelRequire("gCuEI");

var $gG3Vy = parcelRequire("gG3Vy");
$parcel$exportWildcard(module.exports, $in9LP);
$parcel$exportWildcard(module.exports, $bHL7h);
$parcel$exportWildcard(module.exports, $f0ozy);
$parcel$exportWildcard(module.exports, $gCuEI);
$parcel$exportWildcard(module.exports, $gG3Vy);

});
parcelRequire.register("in9LP", function(module, exports) {

$parcel$export(module.exports, "registerBackend", function () { return (parcelRequire("dLRZE")).registerBackend; });

var $dLRZE = parcelRequire("dLRZE");

});
parcelRequire.register("dLRZE", function(module, exports) {

$parcel$export(module.exports, "registerBackend", function () { return $a0698c1765489456$export$1ac8c3a90eff05d; });
$parcel$export(module.exports, "resolveBackend", function () { return $a0698c1765489456$export$abf9298c1fe23677; });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const $a0698c1765489456$var$backends = {};
const $a0698c1765489456$var$backendsSortedByPriority = [];
const $a0698c1765489456$export$1ac8c3a90eff05d = (name, backend, priority)=>{
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = $a0698c1765489456$var$backends[name];
        if (currentBackend === undefined) $a0698c1765489456$var$backends[name] = {
            backend: backend,
            priority: priority
        };
        else if (currentBackend.backend === backend) return;
        else throw new Error(`backend "${name}" is already registered`);
        if (priority >= 0) {
            for(let i = 0; i < $a0698c1765489456$var$backendsSortedByPriority.length; i++)if ($a0698c1765489456$var$backends[$a0698c1765489456$var$backendsSortedByPriority[i]].priority <= priority) {
                $a0698c1765489456$var$backendsSortedByPriority.splice(i, 0, name);
                return;
            }
            $a0698c1765489456$var$backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
const $a0698c1765489456$export$abf9298c1fe23677 = async (backendHints)=>{
    const backendNames = backendHints.length === 0 ? $a0698c1765489456$var$backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames){
        const backendInfo = $a0698c1765489456$var$backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) return backendInfo.backend;
            else if (backendInfo.aborted) continue; // current backend is unavailable; try next
            const isInitializing = !!backendInfo.initPromise;
            try {
                if (!isInitializing) backendInfo.initPromise = backendInfo.backend.init();
                await backendInfo.initPromise;
                backendInfo.initialized = true;
                return backendInfo.backend;
            } catch (e) {
                if (!isInitializing) errors.push({
                    name: backendName,
                    err: e
                });
                backendInfo.aborted = true;
            } finally{
                delete backendInfo.initPromise;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`
    ).join(', ')}`);
};

});


parcelRequire.register("bHL7h", function(module, exports) {

$parcel$export(module.exports, "env", function () { return $8858422dfd092bdb$export$a7b6bc01c63cdfc3; });

var $9keKU = parcelRequire("9keKU");
const $8858422dfd092bdb$export$a7b6bc01c63cdfc3 = new $9keKU.EnvImpl();

});
parcelRequire.register("9keKU", function(module, exports) {

$parcel$export(module.exports, "EnvImpl", function () { return $6ca16d78ef45d821$export$c6d8d33eaf68923d; });
class $6ca16d78ef45d821$export$c6d8d33eaf68923d {
    constructor(){
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) return;
        if (typeof value !== 'string' || [
            'verbose',
            'info',
            'warning',
            'error',
            'fatal'
        ].indexOf(value) === -1) throw new Error(`Unsupported logging level: ${value}`);
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
}

});


parcelRequire.register("f0ozy", function(module, exports) {

$parcel$export(module.exports, "InferenceSession", function () { return $aec9eaa969a5cfc2$export$bd3e0bdae4766ffd; });

var $41Vd0 = parcelRequire("41Vd0");
const $aec9eaa969a5cfc2$export$bd3e0bdae4766ffd = $41Vd0.InferenceSession;

});
parcelRequire.register("41Vd0", function(module, exports) {

$parcel$export(module.exports, "InferenceSession", function () { return $2ef3a1dd82fea858$export$bd3e0bdae4766ffd; });

var $dLRZE = parcelRequire("dLRZE");

var $gCuEI = parcelRequire("gCuEI");
class $2ef3a1dd82fea858$export$bd3e0bdae4766ffd {
    constructor(handler){
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof $gCuEI.Tensor || Array.isArray(feeds)) throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) throw new TypeError('Unexpected argument[1]: cannot be null.');
            if (arg1 instanceof $gCuEI.Tensor) throw new TypeError('\'fetches\' cannot be a Tensor');
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) throw new TypeError('\'fetches\' cannot be an empty array.');
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') throw new TypeError('\'fetches\' must be a string array or an object.');
                    if (this.outputNames.indexOf(name) === -1) throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) options = arg2;
                else if (typeof arg2 !== 'undefined') throw new TypeError('\'options\' must be an object.');
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames)if (arg1Keys.indexOf(name) !== -1) {
                    const v = arg1[name];
                    if (v === null || v instanceof $gCuEI.Tensor) {
                        isFetches = true;
                        isFetchesEmpty = false;
                        fetches[name] = v;
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) options = arg2;
                    else if (typeof arg2 !== 'undefined') throw new TypeError('\'options\' must be an object.');
                } else options = arg1;
            }
        } else if (typeof arg1 !== 'undefined') throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        // check if all inputs are in feed
        for (const name of this.inputNames){
            if (typeof feeds[name] === 'undefined') throw new Error(`input '${name}' is missing in 'feeds'.`);
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) for (const name1 of this.outputNames)fetches[name1] = null;
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for(const key in results)if (Object.hasOwnProperty.call(results, key)) returnValue[key] = new $gCuEI.Tensor(results[key].type, results[key].data, results[key].dims);
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) options = arg1;
            else if (typeof arg1 !== 'undefined') throw new TypeError('\'options\' must be an object.');
        } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) options = arg1;
            else if (typeof arg1 !== 'undefined') throw new TypeError('\'options\' must be an object.');
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) options = arg1;
            else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) throw new RangeError('\'byteOffset\' must be an integer.');
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) throw new RangeError('\'byteLength\' must be an integer.');
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    if (typeof arg3 === 'object' && arg3 !== null) options = arg3;
                    else if (typeof arg3 !== 'undefined') throw new TypeError('\'options\' must be an object.');
                } else if (typeof arg2 !== 'undefined') throw new TypeError('\'byteLength\' must be a number.');
            } else if (typeof arg1 !== 'undefined') throw new TypeError('\'options\' must be an object.');
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i)=>typeof i === 'string' ? i : i.name
        );
        const backend = await $dLRZE.resolveBackend(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new $2ef3a1dd82fea858$export$bd3e0bdae4766ffd(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
}

});
parcelRequire.register("gCuEI", function(module, exports) {

$parcel$export(module.exports, "Tensor", function () { return $c197f982c22d0cd4$export$7b6b8d90402f8814; });

var $db4rg = parcelRequire("db4rg");
const $c197f982c22d0cd4$export$7b6b8d90402f8814 = $db4rg.Tensor;

});
parcelRequire.register("db4rg", function(module, exports) {

$parcel$export(module.exports, "Tensor", function () { return $997fbedfbf71d185$export$7b6b8d90402f8814; });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const $997fbedfbf71d185$var$isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const $997fbedfbf71d185$var$isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    [
        'float32',
        Float32Array
    ],
    [
        'uint8',
        Uint8Array
    ],
    [
        'int8',
        Int8Array
    ],
    [
        'uint16',
        Uint16Array
    ],
    [
        'int16',
        Int16Array
    ],
    [
        'int32',
        Int32Array
    ],
    [
        'bool',
        Uint8Array
    ],
    [
        'float64',
        Float64Array
    ],
    [
        'uint32',
        Uint32Array
    ], 
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [
        Float32Array,
        'float32'
    ],
    [
        Uint8Array,
        'uint8'
    ],
    [
        Int8Array,
        'int8'
    ],
    [
        Uint16Array,
        'uint16'
    ],
    [
        Int16Array,
        'int16'
    ],
    [
        Int32Array,
        'int32'
    ],
    [
        Float64Array,
        'float64'
    ],
    [
        Uint32Array,
        'uint32'
    ], 
]);
if ($997fbedfbf71d185$var$isBigInt64ArrayAvailable) {
    $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if ($997fbedfbf71d185$var$isBigUint64ArrayAvailable) {
    $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */ const $997fbedfbf71d185$var$calculateSize = (dims)=>{
    let size = 1;
    for(let i = 0; i < dims.length; i++){
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        if (dim < 0) throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        size *= dim;
    }
    return size;
};
class $997fbedfbf71d185$export$7b6b8d90402f8814 {
    constructor(arg0, arg1, arg2){
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) throw new TypeError('A string tensor\'s data must be a string array.');
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            } else {
                // numeric tensor
                const typedArrayConstructor = $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                if (Array.isArray(arg1)) // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                // incorrect results.
                // 'typedArrayConstructor' should be one of the typed array prototype objects.
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                data = typedArrayConstructor.from(arg1);
                else if (arg1 instanceof typedArrayConstructor) data = arg1;
                else throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
            }
        } else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) throw new TypeError('Tensor type cannot be inferred from an empty array.');
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                } else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                } else throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
            } else {
                // get tensor type from TypedArray
                const mappedType = $997fbedfbf71d185$var$NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) // assume 1-D tensor if dims omitted
        dims = [
            data.length
        ];
        else if (!Array.isArray(dims)) throw new TypeError('A tensor\'s dims must be a number array');
        // perform check
        const size = $997fbedfbf71d185$var$calculateSize(dims);
        if (size !== data.length) throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    //#endregion
    //#region tensor utilities
    reshape(dims) {
        return new $997fbedfbf71d185$export$7b6b8d90402f8814(this.type, this.data, dims);
    }
}

});




parcelRequire.register("gG3Vy", function(module, exports) {

});



var $00144ecb6b7ad3a8$exports = {};

(parcelRequire("82BEU")).register(JSON.parse("{\"dO7if\":\"index.694d99a1.js\",\"cG2dQ\":\"tfjs-backend-wasm.194156f4.wasm\",\"8uft9\":\"tfjs-backend-wasm-simd.5e8e429d.wasm\",\"knRc6\":\"tfjs-backend-wasm-threaded-simd.4bc04b6e.wasm\",\"8WkUN\":\"ort-wasm.c89b39ec.wasm\",\"7tQQV\":\"ort-wasm-simd.30603b2c.wasm\",\"iFOoy\":\"ort-wasm-threaded.41baccc6.wasm\",\"2QKLs\":\"ort-wasm-simd-threaded.63e715cf.wasm\",\"jbhSP\":\"model.fb943c7b.onnx\"}"));

const $fc3e518cb31152af$export$76e53a66c52b6d4d = 1e-7;
const $fc3e518cb31152af$export$49716d145771e6a2 = 1e-4;
class $fc3e518cb31152af$export$e95767ffe2e60cec {
    constructor(backend, dataMover){
        this.backend = backend;
        this.dataMover = dataMover;
        this.data = new WeakMap();
        this.dataIdsCount = 0;
    }
    get(dataId) {
        if (!this.data.has(dataId)) this.dataMover.moveData(this.backend, dataId);
        return this.data.get(dataId);
    }
    set(dataId, value) {
        this.dataIdsCount++;
        this.data.set(dataId, value);
    }
    has(dataId) {
        return this.data.has(dataId);
    }
    delete(dataId) {
        this.dataIdsCount--;
        return this.data.delete(dataId);
    }
    numDataIds() {
        return this.dataIdsCount;
    }
}
class $fc3e518cb31152af$export$543916c62202b50a {
    refCount(dataId) {
        return $fc3e518cb31152af$var$notYetImplemented('refCount');
    }
    incRef(dataId) {
        return $fc3e518cb31152af$var$notYetImplemented('incRef');
    }
    timerAvailable() {
        return true;
    }
    time(f) {
        return $fc3e518cb31152af$var$notYetImplemented('time');
    }
    read(dataId) {
        return $fc3e518cb31152af$var$notYetImplemented('read');
    }
    readSync(dataId) {
        return $fc3e518cb31152af$var$notYetImplemented('readSync');
    }
    readToGPU(dataId, options) {
        return $fc3e518cb31152af$var$notYetImplemented('readToGPU');
    }
    numDataIds() {
        return $fc3e518cb31152af$var$notYetImplemented('numDataIds');
    }
    disposeData(dataId, force) {
        return $fc3e518cb31152af$var$notYetImplemented('disposeData');
    }
    write(values, shape, dtype) {
        return $fc3e518cb31152af$var$notYetImplemented('write');
    }
    move(dataId, values, shape, dtype, refCount) {
        return $fc3e518cb31152af$var$notYetImplemented('move');
    }
    memory() {
        return $fc3e518cb31152af$var$notYetImplemented('memory');
    }
    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */ floatPrecision() {
        return $fc3e518cb31152af$var$notYetImplemented('floatPrecision');
    }
    /** Returns the smallest representable number.  */ epsilon() {
        return this.floatPrecision() === 32 ? $fc3e518cb31152af$export$76e53a66c52b6d4d : $fc3e518cb31152af$export$49716d145771e6a2;
    }
    dispose() {
        return $fc3e518cb31152af$var$notYetImplemented('dispose');
    }
}
function $fc3e518cb31152af$var$notYetImplemented(kernelName) {
    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` + `This kernel may not be supported by the tfjs backend you have chosen`);
}


var $904921ed29eeae0f$exports = {};

$parcel$export($904921ed29eeae0f$exports, "shuffle", function () { return $904921ed29eeae0f$export$448332262467e042; });
$parcel$export($904921ed29eeae0f$exports, "swap", function () { return $904921ed29eeae0f$export$b0e76d9850c64156; });
$parcel$export($904921ed29eeae0f$exports, "shuffleCombo", function () { return $904921ed29eeae0f$export$ae1498b5fd31a179; });
$parcel$export($904921ed29eeae0f$exports, "clamp", function () { return $904921ed29eeae0f$export$7d15b64cf5a3a4c4; });
$parcel$export($904921ed29eeae0f$exports, "nearestLargerEven", function () { return $904921ed29eeae0f$export$ece2fd7300c99d1f; });
$parcel$export($904921ed29eeae0f$exports, "sum", function () { return $904921ed29eeae0f$export$8a63f25cc62965f1; });
$parcel$export($904921ed29eeae0f$exports, "randUniform", function () { return $904921ed29eeae0f$export$1c2519d52242937; });
$parcel$export($904921ed29eeae0f$exports, "distSquared", function () { return $904921ed29eeae0f$export$499eb56409f6cbc2; });
$parcel$export($904921ed29eeae0f$exports, "assert", function () { return $904921ed29eeae0f$export$a7a9523472993e97; });
$parcel$export($904921ed29eeae0f$exports, "assertShapesMatch", function () { return $904921ed29eeae0f$export$e08b27e7f37e2782; });
$parcel$export($904921ed29eeae0f$exports, "arraysEqual", function () { return $904921ed29eeae0f$export$234180f8206db11b; });
$parcel$export($904921ed29eeae0f$exports, "assertNonNull", function () { return $904921ed29eeae0f$export$44a06cc2759dd036; });
$parcel$export($904921ed29eeae0f$exports, "flatten", function () { return $904921ed29eeae0f$export$bffa455ba8c619a6; });
$parcel$export($904921ed29eeae0f$exports, "isTypedArray", function () { return $904921ed29eeae0f$export$b119cc7e1840e59c; });
$parcel$export($904921ed29eeae0f$exports, "sizeFromShape", function () { return $904921ed29eeae0f$export$b4c3214a70a0e73f; });
$parcel$export($904921ed29eeae0f$exports, "isScalarShape", function () { return $904921ed29eeae0f$export$d58b8d1ec2129064; });
$parcel$export($904921ed29eeae0f$exports, "isInt", function () { return $904921ed29eeae0f$export$357fc28f6427af8b; });
$parcel$export($904921ed29eeae0f$exports, "tanh", function () { return $904921ed29eeae0f$export$7128670e45beef9a; });
$parcel$export($904921ed29eeae0f$exports, "sizeToSquarishShape", function () { return $904921ed29eeae0f$export$55bdc5631791c247; });
$parcel$export($904921ed29eeae0f$exports, "createShuffledIndices", function () { return $904921ed29eeae0f$export$49070d702e17365; });
$parcel$export($904921ed29eeae0f$exports, "rightPad", function () { return $904921ed29eeae0f$export$390245bab32fb60f; });
$parcel$export($904921ed29eeae0f$exports, "repeatedTry", function () { return $904921ed29eeae0f$export$aa345f93372ddb7b; });
$parcel$export($904921ed29eeae0f$exports, "inferFromImplicitShape", function () { return $904921ed29eeae0f$export$e9459a51c182ffc2; });
$parcel$export($904921ed29eeae0f$exports, "parseAxisParam", function () { return $904921ed29eeae0f$export$72b84eb9fe1f482; });
$parcel$export($904921ed29eeae0f$exports, "squeezeShape", function () { return $904921ed29eeae0f$export$3106ace2a3b5396d; });
$parcel$export($904921ed29eeae0f$exports, "getTypedArrayFromDType", function () { return $904921ed29eeae0f$export$3b783bdb77632623; });
$parcel$export($904921ed29eeae0f$exports, "getArrayFromDType", function () { return $904921ed29eeae0f$export$24f13f6206df8f7c; });
$parcel$export($904921ed29eeae0f$exports, "checkConversionForErrors", function () { return $904921ed29eeae0f$export$579cf7b8ff0a87a3; });
$parcel$export($904921ed29eeae0f$exports, "isValidDtype", function () { return $904921ed29eeae0f$export$a6a3df2178ac9529; });
$parcel$export($904921ed29eeae0f$exports, "hasEncodingLoss", function () { return $904921ed29eeae0f$export$9130d84b35fa7b98; });
$parcel$export($904921ed29eeae0f$exports, "bytesPerElement", function () { return $904921ed29eeae0f$export$3f355ce86503b89f; });
$parcel$export($904921ed29eeae0f$exports, "bytesFromStringArray", function () { return $904921ed29eeae0f$export$c474902e1102282d; });
$parcel$export($904921ed29eeae0f$exports, "isString", function () { return $904921ed29eeae0f$export$844ec244b1367d54; });
$parcel$export($904921ed29eeae0f$exports, "isBoolean", function () { return $904921ed29eeae0f$export$f9ce7b637dfbe238; });
$parcel$export($904921ed29eeae0f$exports, "isNumber", function () { return $904921ed29eeae0f$export$7e4aa119212bc614; });
$parcel$export($904921ed29eeae0f$exports, "inferDtype", function () { return $904921ed29eeae0f$export$2005775d905d2dc2; });
$parcel$export($904921ed29eeae0f$exports, "isFunction", function () { return $904921ed29eeae0f$export$f6e2535fb5126e54; });
$parcel$export($904921ed29eeae0f$exports, "nearestDivisor", function () { return $904921ed29eeae0f$export$c0ff3276320ddb5e; });
$parcel$export($904921ed29eeae0f$exports, "computeStrides", function () { return $904921ed29eeae0f$export$6ad0292cf4d50f79; });
$parcel$export($904921ed29eeae0f$exports, "toNestedArray", function () { return $904921ed29eeae0f$export$3983c25181aa68cc; });
$parcel$export($904921ed29eeae0f$exports, "makeOnesTypedArray", function () { return $904921ed29eeae0f$export$b915f681a907ae99; });
$parcel$export($904921ed29eeae0f$exports, "makeZerosTypedArray", function () { return $904921ed29eeae0f$export$edbc8aedac4e036f; });
$parcel$export($904921ed29eeae0f$exports, "makeZerosNestedTypedArray", function () { return $904921ed29eeae0f$export$eef638260c005c74; });
$parcel$export($904921ed29eeae0f$exports, "assertNonNegativeIntegerDimensions", function () { return $904921ed29eeae0f$export$3d8b7619bac22cf5; });
$parcel$export($904921ed29eeae0f$exports, "locToIndex", function () { return $904921ed29eeae0f$export$a14b009c502dc3b4; });
$parcel$export($904921ed29eeae0f$exports, "indexToLoc", function () { return $904921ed29eeae0f$export$2d1ada4c755a8699; });
$parcel$export($904921ed29eeae0f$exports, "isPromise", function () { return $904921ed29eeae0f$export$4369c812aac99591; });
function $904921ed29eeae0f$export$448332262467e042(array) {
    let counter = array.length;
    let index = 0;
    // While there are elements in the array
    while(counter > 0){
        // Pick a random index
        index = Math.random() * counter | 0;
        // Decrease counter by 1
        counter--;
        // And swap the last element with it
        $904921ed29eeae0f$export$b0e76d9850c64156(array, counter, index);
    }
}
function $904921ed29eeae0f$export$ae1498b5fd31a179(// tslint:disable-next-line:no-any
array, // tslint:disable-next-line:no-any
array2) {
    if (array.length !== array2.length) throw new Error(`Array sizes must match to be shuffled together ` + `First array length was ${array.length}` + `Second array length was ${array2.length}`);
    let counter = array.length;
    let index = 0;
    // While there are elements in the array
    while(counter > 0){
        // Pick a random index
        index = Math.random() * counter | 0;
        // Decrease counter by 1
        counter--;
        // And swap the last element of each array with it
        $904921ed29eeae0f$export$b0e76d9850c64156(array, counter, index);
        $904921ed29eeae0f$export$b0e76d9850c64156(array2, counter, index);
    }
}
function $904921ed29eeae0f$export$7d15b64cf5a3a4c4(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
function $904921ed29eeae0f$export$ece2fd7300c99d1f(val) {
    return val % 2 === 0 ? val : val + 1;
}
function $904921ed29eeae0f$export$b0e76d9850c64156(object, left, right) {
    const temp = object[left];
    object[left] = object[right];
    object[right] = temp;
}
function $904921ed29eeae0f$export$8a63f25cc62965f1(arr) {
    let $904921ed29eeae0f$export$8a63f25cc62965f1 = 0;
    for(let i = 0; i < arr.length; i++)$904921ed29eeae0f$export$8a63f25cc62965f1 += arr[i];
    return $904921ed29eeae0f$export$8a63f25cc62965f1;
}
function $904921ed29eeae0f$export$1c2519d52242937(a, b) {
    const r = Math.random();
    return b * r + (1 - r) * a;
}
function $904921ed29eeae0f$export$499eb56409f6cbc2(a, b) {
    let result = 0;
    for(let i = 0; i < a.length; i++){
        const diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
function $904921ed29eeae0f$export$a7a9523472993e97(expr, msg) {
    if (!expr) throw new Error(typeof msg === 'string' ? msg : msg());
}
function $904921ed29eeae0f$export$e08b27e7f37e2782(shapeA, shapeB, errorMessagePrefix = '') {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$234180f8206db11b(shapeA, shapeB), ()=>errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`
    );
}
function $904921ed29eeae0f$export$44a06cc2759dd036(a) {
    $904921ed29eeae0f$export$a7a9523472993e97(a != null, ()=>`The input to the tensor constructor must be a non-null value.`
    );
}
function $904921ed29eeae0f$export$bffa455ba8c619a6(arr, result = [], skipTypedArray = false) {
    if (result == null) result = [];
    if (Array.isArray(arr) || $904921ed29eeae0f$export$b119cc7e1840e59c(arr) && !skipTypedArray) for(let i = 0; i < arr.length; ++i)$904921ed29eeae0f$export$bffa455ba8c619a6(arr[i], result, skipTypedArray);
    else result.push(arr);
    return result;
}
function $904921ed29eeae0f$export$b4c3214a70a0e73f(shape) {
    if (shape.length === 0) // Scalar.
    return 1;
    let size = shape[0];
    for(let i = 1; i < shape.length; i++)size *= shape[i];
    return size;
}
function $904921ed29eeae0f$export$d58b8d1ec2129064(shape) {
    return shape.length === 0;
}
function $904921ed29eeae0f$export$234180f8206db11b(n1, n2) {
    if (n1 === n2) return true;
    if (n1 == null || n2 == null) return false;
    if (n1.length !== n2.length) return false;
    for(let i = 0; i < n1.length; i++){
        if (n1[i] !== n2[i]) return false;
    }
    return true;
}
function $904921ed29eeae0f$export$357fc28f6427af8b(a) {
    return a % 1 === 0;
}
function $904921ed29eeae0f$export$7128670e45beef9a(x) {
    // tslint:disable-next-line:no-any
    if (Math.tanh != null) // tslint:disable-next-line:no-any
    return Math.tanh(x);
    if (x === Infinity) return 1;
    else if (x === -Infinity) return -1;
    else {
        const e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
function $904921ed29eeae0f$export$55bdc5631791c247(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [
        width,
        Math.ceil(size / width)
    ];
}
function $904921ed29eeae0f$export$49070d702e17365(n) {
    const shuffledIndices = new Uint32Array(n);
    for(let i = 0; i < n; ++i)shuffledIndices[i] = i;
    $904921ed29eeae0f$export$448332262467e042(shuffledIndices);
    return shuffledIndices;
}
function $904921ed29eeae0f$export$390245bab32fb60f(a, size) {
    if (size <= a.length) return a;
    return a + ' '.repeat(size - a.length);
}
function $904921ed29eeae0f$export$aa345f93372ddb7b(checkFn, delayFn = (counter)=>0
, maxCounter) {
    return new Promise((resolve, reject)=>{
        let tryCount = 0;
        const tryFn = ()=>{
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            const nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        tryFn();
    });
}
function $904921ed29eeae0f$export$e9459a51c182ffc2(shape, size) {
    let shapeProd = 1;
    let implicitIdx = -1;
    for(let i = 0; i < shape.length; ++i){
        if (shape[i] >= 0) shapeProd *= shape[i];
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) throw Error(`Shapes can only have 1 implicit size. ` + `Found -1 at dim ${implicitIdx} and dim ${i}`);
            implicitIdx = i;
        } else if (shape[i] < 0) throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) throw Error(`Size(${size}) must match the product of shape ${shape}`);
        return shape;
    }
    if (shapeProd === 0) throw Error(`Cannot infer the missing size in [${shape}] when ` + `there are 0 elements`);
    if (size % shapeProd !== 0) throw Error(`The implicit shape can't be a fractional number. ` + `Got ${size} / ${shapeProd}`);
    const newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
function $904921ed29eeae0f$export$72b84eb9fe1f482(axis, shape) {
    const rank = shape.length;
    // Normalize input
    axis = axis == null ? shape.map((s, i)=>i
    ) : [].concat(axis);
    // Check for valid range
    $904921ed29eeae0f$export$a7a9523472993e97(axis.every((ax)=>ax >= -rank && ax < rank
    ), ()=>`All values in axis param must be in range [-${rank}, ${rank}) but ` + `got axis ${axis}`
    );
    // Check for only integers
    $904921ed29eeae0f$export$a7a9523472993e97(axis.every((ax)=>$904921ed29eeae0f$export$357fc28f6427af8b(ax)
    ), ()=>`All values in axis param must be integers but ` + `got axis ${axis}`
    );
    // Handle negative axis.
    return axis.map((a)=>a < 0 ? rank + a : a
    );
}
function $904921ed29eeae0f$export$3106ace2a3b5396d(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : $904921ed29eeae0f$export$72b84eb9fe1f482(axis, shape).sort();
    let j = 0;
    for(let i = 0; i < shape.length; ++i){
        if (axes != null) {
            if (axes[j] === i && shape[i] !== 1) throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axes[j] <= i) j++;
        }
        if (shape[i] !== 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return {
        newShape: newShape,
        keptDims: keptDims
    };
}
function $904921ed29eeae0f$export$3b783bdb77632623(dtype, size) {
    let values = null;
    if (dtype == null || dtype === 'float32') values = new Float32Array(size);
    else if (dtype === 'int32') values = new Int32Array(size);
    else if (dtype === 'bool') values = new Uint8Array(size);
    else throw new Error(`Unknown data type ${dtype}`);
    return values;
}
function $904921ed29eeae0f$export$24f13f6206df8f7c(dtype, size) {
    let values = null;
    if (dtype == null || dtype === 'float32') values = new Float32Array(size);
    else if (dtype === 'int32') values = new Int32Array(size);
    else if (dtype === 'bool') values = new Uint8Array(size);
    else if (dtype === 'string') values = new Array(size);
    else throw new Error(`Unknown data type ${dtype}`);
    return values;
}
function $904921ed29eeae0f$export$579cf7b8ff0a87a3(vals, dtype) {
    for(let i = 0; i < vals.length; i++){
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
    }
}
function $904921ed29eeae0f$export$a6a3df2178ac9529(dtype) {
    return dtype === 'bool' || dtype === 'complex64' || dtype === 'float32' || dtype === 'int32' || dtype === 'string';
}
function $904921ed29eeae0f$export$9130d84b35fa7b98(oldType, newType) {
    if (newType === 'complex64') return false;
    if (newType === 'float32' && oldType !== 'complex64') return false;
    if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') return false;
    if (newType === 'bool' && oldType === 'bool') return false;
    return true;
}
function $904921ed29eeae0f$export$b119cc7e1840e59c(a) {
    return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array || a instanceof Uint8ClampedArray;
}
function $904921ed29eeae0f$export$3f355ce86503b89f(dtype) {
    if (dtype === 'float32' || dtype === 'int32') return 4;
    else if (dtype === 'complex64') return 8;
    else if (dtype === 'bool') return 1;
    else throw new Error(`Unknown dtype ${dtype}`);
}
function $904921ed29eeae0f$export$c474902e1102282d(arr) {
    if (arr == null) return 0;
    let bytes = 0;
    arr.forEach((x)=>bytes += x.length
    );
    return bytes;
}
function $904921ed29eeae0f$export$844ec244b1367d54(value) {
    return typeof value === 'string' || value instanceof String;
}
function $904921ed29eeae0f$export$f9ce7b637dfbe238(value) {
    return typeof value === 'boolean';
}
function $904921ed29eeae0f$export$7e4aa119212bc614(value) {
    return typeof value === 'number';
}
function $904921ed29eeae0f$export$2005775d905d2dc2(values) {
    if (Array.isArray(values)) return $904921ed29eeae0f$export$2005775d905d2dc2(values[0]);
    if (values instanceof Float32Array) return 'float32';
    else if (values instanceof Int32Array || values instanceof Uint8Array || values instanceof Uint8ClampedArray) return 'int32';
    else if ($904921ed29eeae0f$export$7e4aa119212bc614(values)) return 'float32';
    else if ($904921ed29eeae0f$export$844ec244b1367d54(values)) return 'string';
    else if ($904921ed29eeae0f$export$f9ce7b637dfbe238(values)) return 'bool';
    return 'float32';
}
function $904921ed29eeae0f$export$f6e2535fb5126e54(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
function $904921ed29eeae0f$export$c0ff3276320ddb5e(size, start) {
    for(let i = start; i < size; ++i){
        if (size % i === 0) return i;
    }
    return size;
}
function $904921ed29eeae0f$export$6ad0292cf4d50f79(shape) {
    const rank = shape.length;
    if (rank < 2) return [];
    // Last dimension has implicit stride of 1, thus having D-1 (instead of D)
    // strides.
    const strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for(let i = rank - 3; i >= 0; --i)strides[i] = strides[i + 1] * shape[i + 1];
    return strides;
}
function $904921ed29eeae0f$var$createNestedArray(offset, shape, a, isComplex = false) {
    const ret = new Array();
    if (shape.length === 1) {
        const d = shape[0] * (isComplex ? 2 : 1);
        for(let i = 0; i < d; i++)ret[i] = a[offset + i];
    } else {
        const d = shape[0];
        const rest = shape.slice(1);
        const len = rest.reduce((acc, c)=>acc * c
        ) * (isComplex ? 2 : 1);
        for(let i = 0; i < d; i++)ret[i] = $904921ed29eeae0f$var$createNestedArray(offset + i * len, rest, a, isComplex);
    }
    return ret;
}
function $904921ed29eeae0f$export$3983c25181aa68cc(shape, a, isComplex = false) {
    if (shape.length === 0) // Scalar type should return a single number.
    return a[0];
    const size = shape.reduce((acc, c)=>acc * c
    ) * (isComplex ? 2 : 1);
    if (size === 0) // A tensor with shape zero should be turned into empty list.
    return [];
    if (size !== a.length) throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? ' for a complex tensor' : ''}.`);
    return $904921ed29eeae0f$var$createNestedArray(0, shape, a, isComplex);
}
function $904921ed29eeae0f$export$b915f681a907ae99(size, dtype) {
    const array = $904921ed29eeae0f$export$edbc8aedac4e036f(size, dtype);
    for(let i = 0; i < array.length; i++)array[i] = 1;
    return array;
}
function $904921ed29eeae0f$export$edbc8aedac4e036f(size, dtype) {
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') return new Float32Array(size);
    else if (dtype === 'int32') return new Int32Array(size);
    else if (dtype === 'bool') return new Uint8Array(size);
    else throw new Error(`Unknown data type ${dtype}`);
}
function $904921ed29eeae0f$export$eef638260c005c74(shape, dtype) {
    const size = shape.reduce((prev, curr)=>prev * curr
    , 1);
    if (dtype == null || dtype === 'float32') return $904921ed29eeae0f$export$3983c25181aa68cc(shape, new Float32Array(size));
    else if (dtype === 'int32') return $904921ed29eeae0f$export$3983c25181aa68cc(shape, new Int32Array(size));
    else if (dtype === 'bool') return $904921ed29eeae0f$export$3983c25181aa68cc(shape, new Uint8Array(size));
    else throw new Error(`Unknown data type ${dtype}`);
}
function $904921ed29eeae0f$export$3d8b7619bac22cf5(shape) {
    shape.forEach((dimSize)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(Number.isInteger(dimSize) && dimSize >= 0, ()=>`Tensor must have a shape comprised of positive integers but got ` + `shape [${shape}].`
        );
    });
}
function $904921ed29eeae0f$export$a14b009c502dc3b4(locs, rank, strides) {
    if (rank === 0) return 0;
    else if (rank === 1) return locs[0];
    let index = locs[locs.length - 1];
    for(let i = 0; i < locs.length - 1; ++i)index += strides[i] * locs[i];
    return index;
}
function $904921ed29eeae0f$export$2d1ada4c755a8699(index, rank, strides) {
    if (rank === 0) return [];
    else if (rank === 1) return [
        index
    ];
    const locs = new Array(rank);
    for(let i = 0; i < locs.length - 1; ++i){
        locs[i] = Math.floor(index / strides[i]);
        index -= locs[i] * strides[i];
    }
    locs[locs.length - 1] = index;
    return locs;
}
function $904921ed29eeae0f$export$4369c812aac99591(object) {
    //  We chose to not use 'obj instanceOf Promise' for two reasons:
    //  1. It only reliably works for es6 Promise, not other Promise
    //  implementations.
    //  2. It doesn't work with framework that uses zone.js. zone.js monkey patch
    //  the async calls, so it is possible the obj (patched) is comparing to a
    //  pre-patched Promise.
    return object && object.then && typeof object.then === 'function';
}


// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.
const $78e7329b437d1e00$var$TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';
class $78e7329b437d1e00$export$7dc6752a22ab011a {
    // tslint:disable-next-line: no-any
    constructor($parcel$global){
        this.global = $parcel$global;
        this.flags = {};
        this.flagRegistry = {};
        this.urlFlags = {};
        // Jasmine spies on this in 'environment_test.ts'
        this.getQueryParams = $78e7329b437d1e00$export$e2de15bbd9edf9c6;
        this.populateURLFlags();
    }
    setPlatform(platformName, platform) {
        if (this.platform != null) {
            if (!($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_TEST') || $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('PROD'))) console.warn(`Platform ${this.platformName} has already been set. ` + `Overwriting the platform with ${platformName}.`);
        }
        this.platformName = platformName;
        this.platform = platform;
    }
    registerFlag(flagName, evaluationFn, setHook) {
        this.flagRegistry[flagName] = {
            evaluationFn: evaluationFn,
            setHook: setHook
        };
        // Override the flag value from the URL. This has to happen here because
        // the environment is initialized before flags get registered.
        if (this.urlFlags[flagName] != null) {
            const flagValue = this.urlFlags[flagName];
            if (!($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_TEST') || $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('PROD'))) console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
            this.set(flagName, flagValue);
        }
    }
    async getAsync(flagName) {
        if (flagName in this.flags) return this.flags[flagName];
        this.flags[flagName] = await this.evaluateFlag(flagName);
        return this.flags[flagName];
    }
    get(flagName) {
        if (flagName in this.flags) return this.flags[flagName];
        const flagValue = this.evaluateFlag(flagName);
        if ($904921ed29eeae0f$export$4369c812aac99591(flagValue)) throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` + `Please use getAsync() instead.`);
        this.flags[flagName] = flagValue;
        return this.flags[flagName];
    }
    getNumber(flagName) {
        return this.get(flagName);
    }
    getBool(flagName) {
        return this.get(flagName);
    }
    getFlags() {
        return this.flags;
    }
    // For backwards compatibility.
    get features() {
        return this.flags;
    }
    set(flagName, value) {
        if (this.flagRegistry[flagName] == null) throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
        this.flags[flagName] = value;
        if (this.flagRegistry[flagName].setHook != null) this.flagRegistry[flagName].setHook(value);
    }
    evaluateFlag(flagName) {
        if (this.flagRegistry[flagName] == null) throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
        return this.flagRegistry[flagName].evaluationFn();
    }
    setFlags(flags) {
        this.flags = Object.assign({}, flags);
    }
    reset() {
        this.flags = {};
        this.urlFlags = {};
        this.populateURLFlags();
    }
    populateURLFlags() {
        if (typeof this.global === 'undefined' || typeof this.global.location === 'undefined' || typeof this.global.location.search === 'undefined') return;
        const urlParams = this.getQueryParams(this.global.location.search);
        if ($78e7329b437d1e00$var$TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
            const keyValues = urlParams[$78e7329b437d1e00$var$TENSORFLOWJS_FLAGS_PREFIX].split(',');
            keyValues.forEach((keyValue)=>{
                const [key, value] = keyValue.split(':');
                this.urlFlags[key] = $78e7329b437d1e00$var$parseValue(key, value);
            });
        }
    }
}
function $78e7329b437d1e00$export$e2de15bbd9edf9c6(queryString) {
    const params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t)=>{
        $78e7329b437d1e00$var$decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
function $78e7329b437d1e00$var$decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function $78e7329b437d1e00$var$parseValue(flagName, value) {
    value = value.toLowerCase();
    if (value === 'true' || value === 'false') return value === 'true';
    else if (`${+value}` === value) return +value;
    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
}
function $78e7329b437d1e00$export$a7b6bc01c63cdfc3() {
    return $78e7329b437d1e00$export$83401e34d5e11bf4;
}
let $78e7329b437d1e00$export$83401e34d5e11bf4 = null;
function $78e7329b437d1e00$export$3ef32a49eeda04cc(environment) {
    $78e7329b437d1e00$export$83401e34d5e11bf4 = environment;
}



var $3tEm6 = parcelRequire("3tEm6");
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ // Note that the identifier globalNameSpace is scoped to this module, but will
// always resolve to the same global object regardless of how the module is
// resolved.
// tslint:disable-next-line:no-any
let $95bbaab90b583097$var$globalNameSpace;
function $95bbaab90b583097$export$5054b240ae6849b7() {
    if ($95bbaab90b583097$var$globalNameSpace == null) {
        // tslint:disable-next-line:no-any
        let ns;
        if (typeof window !== 'undefined') ns = window;
        else if (typeof $parcel$global !== 'undefined') ns = $parcel$global;
        else if (typeof $3tEm6 !== 'undefined') ns = $3tEm6;
        else if (typeof self !== 'undefined') ns = self;
        else throw new Error('Could not find a global object');
        $95bbaab90b583097$var$globalNameSpace = ns;
    }
    return $95bbaab90b583097$var$globalNameSpace;
}
// tslint:disable-next-line:no-any
function $95bbaab90b583097$var$getGlobalMap() {
    const ns = $95bbaab90b583097$export$5054b240ae6849b7();
    if (ns._tfGlobals == null) ns._tfGlobals = new Map();
    return ns._tfGlobals;
}
function $95bbaab90b583097$export$a4e55266d2135a7f(key, init) {
    const globalMap = $95bbaab90b583097$var$getGlobalMap();
    if (globalMap.has(key)) return globalMap.get(key);
    else {
        const singleton = init();
        globalMap.set(key, singleton);
        return globalMap.get(key);
    }
}


const $2b76be1e72a8c1db$export$b73c596ee8758a66 = 'Abs';
const $2b76be1e72a8c1db$export$3b952c9980dac550 = 'Acos';
const $2b76be1e72a8c1db$export$987da490b7c2e7dd = 'Acosh';
const $2b76be1e72a8c1db$export$d0265b2c425512d6 = 'Add';
const $2b76be1e72a8c1db$export$eef235ad06d3226a = 'AddN';
const $2b76be1e72a8c1db$export$5dceb1ab650a1776 = 'All';
const $2b76be1e72a8c1db$export$b24b633b1364b94b = 'Any';
const $2b76be1e72a8c1db$export$17612294a1503e1c = 'ArgMax';
const $2b76be1e72a8c1db$export$baabd09270cbbd94 = 'ArgMin';
const $2b76be1e72a8c1db$export$664c8ca7e7e5c126 = 'Asin';
const $2b76be1e72a8c1db$export$847c88940cb7dcb5 = 'Asinh';
const $2b76be1e72a8c1db$export$bac667d46ac043ae = 'Atan';
const $2b76be1e72a8c1db$export$98981a86fa2b1366 = 'Atanh';
const $2b76be1e72a8c1db$export$3bf4c619ce589f4b = 'Atan2';
const $2b76be1e72a8c1db$export$37f2cc7be1add88c = 'AvgPool';
const $2b76be1e72a8c1db$export$9873fd6046cd6951 = 'AvgPoolGrad';
const $2b76be1e72a8c1db$export$390ecb697af103f6 = 'AvgPool3D';
const $2b76be1e72a8c1db$export$7163112adf28c062 = 'AvgPool3DGrad';
const $2b76be1e72a8c1db$export$9a3bf60b23f63c8 = 'BatchMatMul';
const $2b76be1e72a8c1db$export$e2743f47f61cca1f = 'BatchToSpaceND';
const $2b76be1e72a8c1db$export$45dfbbff595c32aa = 'Bincount';
const $2b76be1e72a8c1db$export$ea5eeb875a7c4dd1 = 'BroadcastTo';
const $2b76be1e72a8c1db$export$32877b1d6d497805 = 'BroadcastArgs';
const $2b76be1e72a8c1db$export$107ecfb3d1ccbd77 = 'Cast';
const $2b76be1e72a8c1db$export$d4a1bccfd52ebd3 = 'Ceil';
const $2b76be1e72a8c1db$export$611c0e357ac37f7d = 'ClipByValue';
const $2b76be1e72a8c1db$export$50ceb3fb9926e63e = 'Complex';
const $2b76be1e72a8c1db$export$32902e58f1b48f4b = 'ComplexAbs';
const $2b76be1e72a8c1db$export$936bbfc007425eea = 'Concat';
const $2b76be1e72a8c1db$export$57742e605d475795 = 'Conv2D';
const $2b76be1e72a8c1db$export$32a8943c0f1ca5a7 = 'Conv2DBackpropFilter';
const $2b76be1e72a8c1db$export$e26961e8ed0eb404 = 'Conv2DBackpropInput';
const $2b76be1e72a8c1db$export$9d3874201dd21933 = 'Conv3D';
const $2b76be1e72a8c1db$export$dd2885efe6043eee = 'Conv3DBackpropFilterV2';
const $2b76be1e72a8c1db$export$a54f552d6d7d521f = 'Conv3DBackpropInputV2';
const $2b76be1e72a8c1db$export$ddfd0a983d257666 = 'Cos';
const $2b76be1e72a8c1db$export$5e311a1c57b0d27c = 'Cosh';
const $2b76be1e72a8c1db$export$e581acc6014c47a = 'Cumprod';
const $2b76be1e72a8c1db$export$706617d894ad63da = 'Cumsum';
const $2b76be1e72a8c1db$export$50bc9557793c2e04 = 'CropAndResize';
const $2b76be1e72a8c1db$export$5bab6834954299c5 = 'DenseBincount';
const $2b76be1e72a8c1db$export$fb0ee52d0cd6f233 = 'DepthToSpace';
const $2b76be1e72a8c1db$export$7c0fc590ff9e156f = 'DepthwiseConv2dNative';
const $2b76be1e72a8c1db$export$c99f139e0d4d1833 = 'DepthwiseConv2dNativeBackpropFilter';
const $2b76be1e72a8c1db$export$8649ca3b17033a24 = 'DepthwiseConv2dNativeBackpropInput';
const $2b76be1e72a8c1db$export$ca73a25315ddeb7f = 'Diag';
const $2b76be1e72a8c1db$export$dbbb7830c6497701 = 'Dilation2D';
const $2b76be1e72a8c1db$export$5dd675a6b0f37e17 = 'Dilation2DBackpropInput';
const $2b76be1e72a8c1db$export$91add972be69d592 = 'Dilation2DBackpropFilter';
const $2b76be1e72a8c1db$export$b9880b86e1014bb8 = 'RealDiv';
const $2b76be1e72a8c1db$export$2541d8be32f3c641 = 'Einsum';
const $2b76be1e72a8c1db$export$64636e173424d83d = 'Elu';
const $2b76be1e72a8c1db$export$9906be4699a73c53 = 'EluGrad';
const $2b76be1e72a8c1db$export$c2ee2551ce71f1d0 = 'Erf';
const $2b76be1e72a8c1db$export$8dcf9f58ce5cdfc = 'Equal';
const $2b76be1e72a8c1db$export$f908be7a96fb3363 = 'Exp';
const $2b76be1e72a8c1db$export$2391750b1d901146 = 'ExpandDims';
const $2b76be1e72a8c1db$export$261f26143a1ff3 = 'Expm1';
const $2b76be1e72a8c1db$export$677347237c014ba = 'FFT';
const $2b76be1e72a8c1db$export$ffffe40bfa0649a3 = 'Fill';
const $2b76be1e72a8c1db$export$34e7296fc8558df5 = 'FlipLeftRight';
const $2b76be1e72a8c1db$export$4880b0ae5643c62b = 'Floor';
const $2b76be1e72a8c1db$export$d79b5692ede26c2f = 'FloorDiv';
const $2b76be1e72a8c1db$export$3821a0416660aaa2 = 'FusedBatchNorm';
const $2b76be1e72a8c1db$export$ccd988942e5c0181 = 'GatherV2';
const $2b76be1e72a8c1db$export$4ef6e37a23721703 = 'GatherNd';
const $2b76be1e72a8c1db$export$d0a25eac5ee3f515 = 'Greater';
const $2b76be1e72a8c1db$export$3b7d21bc9aee0851 = 'GreaterEqual';
const $2b76be1e72a8c1db$export$544bf02140fa9a77 = 'Identity';
const $2b76be1e72a8c1db$export$21c6f576ae8100e8 = 'IFFT';
const $2b76be1e72a8c1db$export$303b4473993a24f = 'Imag';
const $2b76be1e72a8c1db$export$b9fcc0946d7d485e = 'IsFinite';
const $2b76be1e72a8c1db$export$74b5a3bc735b152 = 'IsInf';
const $2b76be1e72a8c1db$export$9912dc4fc649dbec = 'IsNan';
const $2b76be1e72a8c1db$export$f0c7162bb7af1a2d = 'LeakyRelu';
const $2b76be1e72a8c1db$export$728c50f1c88ac779 = 'Less';
const $2b76be1e72a8c1db$export$84afd0d8f7fb8c5d = 'LessEqual';
const $2b76be1e72a8c1db$export$34f0ab8eba543ee6 = 'LinSpace';
const $2b76be1e72a8c1db$export$ce30dbb46644d06c = 'Log';
const $2b76be1e72a8c1db$export$70f05bf9ddcfca68 = 'Log1p';
const $2b76be1e72a8c1db$export$8a27ff10dff4d6e5 = 'LogicalAnd';
const $2b76be1e72a8c1db$export$4393bee5596c68c2 = 'LogicalNot';
const $2b76be1e72a8c1db$export$c49f9f5ffc6f678c = 'LogicalOr';
const $2b76be1e72a8c1db$export$85b5bcbd60848a10 = 'LogSoftmax';
const $2b76be1e72a8c1db$export$eb2f713fc3e1ca9a = 'LRN';
const $2b76be1e72a8c1db$export$73ba43cd0ce95b10 = 'LRNGrad';
const $2b76be1e72a8c1db$export$d36c09e5d02927e7 = 'Max';
const $2b76be1e72a8c1db$export$d8d02ac92d161004 = 'Maximum';
const $2b76be1e72a8c1db$export$39ea33024ddd5cf = 'MaxPool';
const $2b76be1e72a8c1db$export$f0f010b1d1db8a46 = 'MaxPoolGrad';
const $2b76be1e72a8c1db$export$88fdc64af890fc53 = 'MaxPool3D';
const $2b76be1e72a8c1db$export$52be2c00371a1350 = 'MaxPool3DGrad';
const $2b76be1e72a8c1db$export$deac4b7497b4047f = 'MaxPoolWithArgmax';
const $2b76be1e72a8c1db$export$1c2d59c4b681fbd8 = 'Mean';
const $2b76be1e72a8c1db$export$dfed19fabc75a31d = 'Min';
const $2b76be1e72a8c1db$export$23cb308301e89d6b = 'Minimum';
const $2b76be1e72a8c1db$export$f4c0e95fd7fd31e5 = 'MirrorPad';
const $2b76be1e72a8c1db$export$e4835a5e3f3674d5 = 'Mod';
const $2b76be1e72a8c1db$export$ee0a8cfb693e0e3f = 'Multinomial';
const $2b76be1e72a8c1db$export$f14f83b3b531d498 = 'Multiply';
const $2b76be1e72a8c1db$export$c07c549000872073 = 'Neg';
const $2b76be1e72a8c1db$export$385ebe9945cae0c5 = 'NotEqual';
const $2b76be1e72a8c1db$export$5e11788439c2f04 = 'NonMaxSuppressionV3';
const $2b76be1e72a8c1db$export$7df908154366fe7f = 'NonMaxSuppressionV4';
const $2b76be1e72a8c1db$export$cb45d3fcefce2ef0 = 'NonMaxSuppressionV5';
const $2b76be1e72a8c1db$export$a2962e735c809d91 = 'OnesLike';
const $2b76be1e72a8c1db$export$18982b43ba8c02e9 = 'OneHot';
const $2b76be1e72a8c1db$export$c26f40b29201e5b7 = 'Pack';
const $2b76be1e72a8c1db$export$5d47ba206577f0f2 = 'PadV2';
const $2b76be1e72a8c1db$export$14963ee5c8637e11 = 'Pool';
const $2b76be1e72a8c1db$export$ce28d653ec559ee = 'Pow';
const $2b76be1e72a8c1db$export$a42f35f308fc2fa3 = 'Prelu';
const $2b76be1e72a8c1db$export$b8a16d526a791fb0 = 'Prod';
const $2b76be1e72a8c1db$export$9a58ef0d7ad3278c = 'Range';
const $2b76be1e72a8c1db$export$f41305719b94e675 = 'Real';
const $2b76be1e72a8c1db$export$c6e4a23ed5e0415b = 'Reciprocal';
const $2b76be1e72a8c1db$export$9a6ff968bf961432 = 'Relu';
const $2b76be1e72a8c1db$export$755ddd847e5abe03 = 'Reshape';
const $2b76be1e72a8c1db$export$6c8d8ec26192bb18 = 'ResizeNearestNeighbor';
const $2b76be1e72a8c1db$export$b84ac31c55aa023b = 'ResizeNearestNeighborGrad';
const $2b76be1e72a8c1db$export$24f2f15d869e0fd = 'ResizeBilinear';
const $2b76be1e72a8c1db$export$2d3cf759f1538c13 = 'ResizeBilinearGrad';
const $2b76be1e72a8c1db$export$3be9e924f629054e = 'Relu6';
const $2b76be1e72a8c1db$export$53c81f36b32e1bba = 'Reverse';
const $2b76be1e72a8c1db$export$c5ed3eef16c0612f = 'Round';
const $2b76be1e72a8c1db$export$7cc53aa09f5f3a2d = 'Rsqrt';
const $2b76be1e72a8c1db$export$28eef6f0168af686 = 'ScatterNd';
const $2b76be1e72a8c1db$export$ef9b1a59e592288f = 'Select';
const $2b76be1e72a8c1db$export$6760d858e6f2594a = 'Selu';
const $2b76be1e72a8c1db$export$b3f2e2de3a8baa1e = 'Slice';
const $2b76be1e72a8c1db$export$75be1b631f7687 = 'Sin';
const $2b76be1e72a8c1db$export$b8c187376329d79b = 'Sinh';
const $2b76be1e72a8c1db$export$1db683ad541682f6 = 'Sign';
const $2b76be1e72a8c1db$export$fde18c826dda6b1b = 'Sigmoid';
const $2b76be1e72a8c1db$export$c5af433747f1fd0a = 'Softplus';
const $2b76be1e72a8c1db$export$21ab404ab9d512a6 = 'Sqrt';
const $2b76be1e72a8c1db$export$534760f50726d5 = 'Sum';
const $2b76be1e72a8c1db$export$f63ac5409312707c = 'SpaceToBatchND';
const $2b76be1e72a8c1db$export$8dffabb4071f05aa = 'SplitV';
const $2b76be1e72a8c1db$export$350a526055d3ca6e = 'Softmax';
const $2b76be1e72a8c1db$export$8f1933853a5c8cca = 'SparseFillEmptyRows';
const $2b76be1e72a8c1db$export$f08f0dca44fa542 = 'SparseReshape';
const $2b76be1e72a8c1db$export$610b077aecc2447b = 'SparseSegmentMean';
const $2b76be1e72a8c1db$export$68351c28d7116b56 = 'SparseSegmentSum';
const $2b76be1e72a8c1db$export$2c426709a9332421 = 'SparseToDense';
const $2b76be1e72a8c1db$export$2f922d20d66089c6 = 'SquaredDifference';
const $2b76be1e72a8c1db$export$b09fb900337259de = 'Square';
const $2b76be1e72a8c1db$export$60c7f9ac271417a9 = 'StridedSlice';
const $2b76be1e72a8c1db$export$11a7f4af7d96ad41 = 'StringNGrams';
const $2b76be1e72a8c1db$export$7e266f7223b9d396 = 'StringSplit';
const $2b76be1e72a8c1db$export$a5639899909bc8ae = 'StringToHashBucketFast';
const $2b76be1e72a8c1db$export$d7a01e11500dfb6f = 'Sub';
const $2b76be1e72a8c1db$export$115b2d5263ba5985 = 'Tan';
const $2b76be1e72a8c1db$export$893b6e865e352c83 = 'Tanh';
const $2b76be1e72a8c1db$export$235cb65c20ad2b7 = 'Tile';
const $2b76be1e72a8c1db$export$c593cd1ea0d02ebd = 'TopK';
const $2b76be1e72a8c1db$export$563a914cafbdc389 = 'Transform';
const $2b76be1e72a8c1db$export$7e714455f9a1f8f7 = 'Transpose';
const $2b76be1e72a8c1db$export$8e3adf126971a183 = 'Unique';
const $2b76be1e72a8c1db$export$441ad6bfc5db8ab4 = 'Unpack';
const $2b76be1e72a8c1db$export$af810663cded5fe2 = 'UnsortedSegmentSum';
const $2b76be1e72a8c1db$export$430969a37eda1e88 = 'ZerosLike';
const $2b76be1e72a8c1db$export$fd55ce593607084a = 'Step';
const $2b76be1e72a8c1db$export$d0eb4e7054966c48 = 'FromPixels';
const $2b76be1e72a8c1db$export$c5a44649815d1c3 = 'RotateWithOffset';
const $2b76be1e72a8c1db$export$8d1af0f7c2a4da9e = '_FusedMatMul';
const $2b76be1e72a8c1db$export$86f8a8e3a8f2a8f2 = 'FusedConv2D';
const $2b76be1e72a8c1db$export$5a249e8f498c02c1 = 'FusedDepthwiseConv2D';




var $35abfa9829a48523$exports = {};

$parcel$export($35abfa9829a48523$exports, "warn", function () { return $35abfa9829a48523$export$c106dd0671a0fc2d; });
$parcel$export($35abfa9829a48523$exports, "log", function () { return $35abfa9829a48523$export$bef1f36f5486a6a3; });

function $35abfa9829a48523$export$c106dd0671a0fc2d(...msg) {
    if (!($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_TEST') || $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('PROD'))) console.warn(...msg);
}
function $35abfa9829a48523$export$bef1f36f5486a6a3(...msg) {
    if (!($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_TEST') || $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('PROD'))) console.log(...msg);
}


const $18a84b897e201316$var$kernelRegistry = $95bbaab90b583097$export$a4e55266d2135a7f('kernelRegistry', ()=>new Map()
);
const $18a84b897e201316$var$gradRegistry = $95bbaab90b583097$export$a4e55266d2135a7f('gradRegistry', ()=>new Map()
);
function $18a84b897e201316$export$1b85808c967cc434(kernelName, backendName) {
    const key = $18a84b897e201316$var$makeKey(kernelName, backendName);
    return $18a84b897e201316$var$kernelRegistry.get(key);
}
function $18a84b897e201316$export$e14995d3ec1747ee(kernelName) {
    return $18a84b897e201316$var$gradRegistry.get(kernelName);
}
function $18a84b897e201316$export$e4b8d76e176eaecc(backendName) {
    const it = $18a84b897e201316$var$kernelRegistry.entries();
    const result = [];
    while(true){
        const { done: done , value: value  } = it.next();
        if (done) break;
        const [key, config] = value;
        const [backend, ] = key.split('_');
        if (backend === backendName) result.push(config);
    }
    return result;
}
function $18a84b897e201316$export$f3f7c443f3a606e6(config) {
    const { kernelName: kernelName , backendName: backendName  } = config;
    const key = $18a84b897e201316$var$makeKey(kernelName, backendName);
    if ($18a84b897e201316$var$kernelRegistry.has(key)) $35abfa9829a48523$export$c106dd0671a0fc2d(`The kernel '${kernelName}' for backend ` + `'${backendName}' is already registered`);
    $18a84b897e201316$var$kernelRegistry.set(key, config);
}
function $18a84b897e201316$export$de9396b872fdfcc3(config) {
    const { kernelName: kernelName  } = config;
    if ($18a84b897e201316$var$gradRegistry.has(kernelName)) // TODO (yassogba) after 3.0 assess whether we need to keep this gated
    // to debug mode.
    {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) $35abfa9829a48523$export$c106dd0671a0fc2d(`Overriding the gradient for '${kernelName}'`);
    }
    $18a84b897e201316$var$gradRegistry.set(kernelName, config);
}
function $18a84b897e201316$export$1c3fb41896379a12(kernelName, backendName) {
    const key = $18a84b897e201316$var$makeKey(kernelName, backendName);
    if (!$18a84b897e201316$var$kernelRegistry.has(key)) throw new Error(`The kernel '${kernelName}' for backend ` + `'${backendName}' is not registered`);
    $18a84b897e201316$var$kernelRegistry.delete(key);
}
function $18a84b897e201316$export$41b3e24402efeb81(kernelName) {
    if (!$18a84b897e201316$var$gradRegistry.has(kernelName)) throw new Error(`The gradient '${kernelName}' for backend is not registered`);
    $18a84b897e201316$var$gradRegistry.delete(kernelName);
}
function $18a84b897e201316$export$fb249e95c44186e6(registeredBackendName, newBackendName) {
    const kernels = $18a84b897e201316$export$e4b8d76e176eaecc(registeredBackendName);
    kernels.forEach((kernelConfig)=>{
        const newKernelConfig = Object.assign({}, kernelConfig, {
            backendName: newBackendName
        });
        $18a84b897e201316$export$f3f7c443f3a606e6(newKernelConfig);
    });
}
function $18a84b897e201316$var$makeKey(kernelName, backendName) {
    return `${backendName}_${kernelName}`;
}




var $f6b55a2021b78f0d$exports = {};

$parcel$export($f6b55a2021b78f0d$exports, "createScalarValue", function () { return $f6b55a2021b78f0d$export$cd3f28d8002ec2a2; });
$parcel$export($f6b55a2021b78f0d$exports, "encodeString", function () { return $f6b55a2021b78f0d$export$8146d2e653b87d6a; });
$parcel$export($f6b55a2021b78f0d$exports, "toTypedArray", function () { return $f6b55a2021b78f0d$export$965adc581230795c; });
$parcel$export($f6b55a2021b78f0d$exports, "now", function () { return $f6b55a2021b78f0d$export$461939dd4422153; });
$parcel$export($f6b55a2021b78f0d$exports, "fetch", function () { return $f6b55a2021b78f0d$export$e7aa7bc5c1b3cfb3; });
$parcel$export($f6b55a2021b78f0d$exports, "decodeString", function () { return $f6b55a2021b78f0d$export$a0fb664af7d0cc44; });



var $b59b9fd1888db600$exports = {};

$parcel$export($b59b9fd1888db600$exports, "hexToLong", function () { return $b59b9fd1888db600$export$20e49d17901a85a5; });
$parcel$export($b59b9fd1888db600$exports, "fingerPrint64", function () { return $b59b9fd1888db600$export$919ee948dc019032; });
var $24b68728542942b6$exports = {};
$24b68728542942b6$exports = $24b68728542942b6$var$Long;
/**
 * wasm optimizations, to do native i64 multiplication and divide
 */ var $24b68728542942b6$var$wasm = null;
try {
    $24b68728542942b6$var$wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
    ])), {}).exports;
} catch (e) {
// no wasm support :(
}
/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */ function $24b68728542942b6$var$Long(low, high, unsigned) {
    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */ this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */ this.high = high | 0;
    /**
     * Whether unsigned or not.
     * @type {boolean}
     */ this.unsigned = !!unsigned;
}
// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.
/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */ $24b68728542942b6$var$Long.prototype.__isLong__;
Object.defineProperty($24b68728542942b6$var$Long.prototype, "__isLong__", {
    value: true
});
/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */ function $24b68728542942b6$var$isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}
/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */ $24b68728542942b6$var$Long.isLong = $24b68728542942b6$var$isLong;
/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */ var $24b68728542942b6$var$INT_CACHE = {};
/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */ var $24b68728542942b6$var$UINT_CACHE = {};
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function $24b68728542942b6$var$fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
            cachedObj = $24b68728542942b6$var$UINT_CACHE[value];
            if (cachedObj) return cachedObj;
        }
        obj = $24b68728542942b6$var$fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache) $24b68728542942b6$var$UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
            cachedObj = $24b68728542942b6$var$INT_CACHE[value];
            if (cachedObj) return cachedObj;
        }
        obj = $24b68728542942b6$var$fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) $24b68728542942b6$var$INT_CACHE[value] = obj;
        return obj;
    }
}
/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromInt = $24b68728542942b6$var$fromInt;
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function $24b68728542942b6$var$fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? $24b68728542942b6$var$UZERO : $24b68728542942b6$var$ZERO;
    if (unsigned) {
        if (value < 0) return $24b68728542942b6$var$UZERO;
        if (value >= $24b68728542942b6$var$TWO_PWR_64_DBL) return $24b68728542942b6$var$MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -$24b68728542942b6$var$TWO_PWR_63_DBL) return $24b68728542942b6$var$MIN_VALUE;
        if (value + 1 >= $24b68728542942b6$var$TWO_PWR_63_DBL) return $24b68728542942b6$var$MAX_VALUE;
    }
    if (value < 0) return $24b68728542942b6$var$fromNumber(-value, unsigned).neg();
    return $24b68728542942b6$var$fromBits(value % $24b68728542942b6$var$TWO_PWR_32_DBL | 0, value / $24b68728542942b6$var$TWO_PWR_32_DBL | 0, unsigned);
}
/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromNumber = $24b68728542942b6$var$fromNumber;
/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function $24b68728542942b6$var$fromBits(lowBits, highBits, unsigned) {
    return new $24b68728542942b6$var$Long(lowBits, highBits, unsigned);
}
/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromBits = $24b68728542942b6$var$fromBits;
/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */ var $24b68728542942b6$var$pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */ function $24b68728542942b6$var$fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return $24b68728542942b6$var$ZERO;
    if (typeof unsigned === 'number') // For goog.math.long compatibility
    radix = unsigned, unsigned = false;
    else unsigned = !!unsigned;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    var p;
    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');
    else if (p === 0) return $24b68728542942b6$var$fromString(str.substring(1), unsigned, radix).neg();
    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = $24b68728542942b6$var$fromNumber($24b68728542942b6$var$pow_dbl(radix, 8));
    var result = $24b68728542942b6$var$ZERO;
    for(var i = 0; i < str.length; i += 8){
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = $24b68728542942b6$var$fromNumber($24b68728542942b6$var$pow_dbl(radix, size));
            result = result.mul(power).add($24b68728542942b6$var$fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add($24b68728542942b6$var$fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}
/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromString = $24b68728542942b6$var$fromString;
/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function $24b68728542942b6$var$fromValue(val, unsigned) {
    if (typeof val === 'number') return $24b68728542942b6$var$fromNumber(val, unsigned);
    if (typeof val === 'string') return $24b68728542942b6$var$fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return $24b68728542942b6$var$fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}
/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */ $24b68728542942b6$var$Long.fromValue = $24b68728542942b6$var$fromValue;
// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.
/**
 * @type {number}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_16_DBL = 65536;
/**
 * @type {number}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_24_DBL = 16777216;
/**
 * @type {number}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_32_DBL = $24b68728542942b6$var$TWO_PWR_16_DBL * $24b68728542942b6$var$TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_64_DBL = $24b68728542942b6$var$TWO_PWR_32_DBL * $24b68728542942b6$var$TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_63_DBL = $24b68728542942b6$var$TWO_PWR_64_DBL / 2;
/**
 * @type {!Long}
 * @const
 * @inner
 */ var $24b68728542942b6$var$TWO_PWR_24 = $24b68728542942b6$var$fromInt($24b68728542942b6$var$TWO_PWR_24_DBL);
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$ZERO = $24b68728542942b6$var$fromInt(0);
/**
 * Signed zero.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.ZERO = $24b68728542942b6$var$ZERO;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$UZERO = $24b68728542942b6$var$fromInt(0, true);
/**
 * Unsigned zero.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.UZERO = $24b68728542942b6$var$UZERO;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$ONE = $24b68728542942b6$var$fromInt(1);
/**
 * Signed one.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.ONE = $24b68728542942b6$var$ONE;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$UONE = $24b68728542942b6$var$fromInt(1, true);
/**
 * Unsigned one.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.UONE = $24b68728542942b6$var$UONE;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$NEG_ONE = $24b68728542942b6$var$fromInt(-1);
/**
 * Signed negative one.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.NEG_ONE = $24b68728542942b6$var$NEG_ONE;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$MAX_VALUE = $24b68728542942b6$var$fromBits(-1, 2147483647, false);
/**
 * Maximum signed value.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.MAX_VALUE = $24b68728542942b6$var$MAX_VALUE;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$MAX_UNSIGNED_VALUE = $24b68728542942b6$var$fromBits(-1, -1, true);
/**
 * Maximum unsigned value.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.MAX_UNSIGNED_VALUE = $24b68728542942b6$var$MAX_UNSIGNED_VALUE;
/**
 * @type {!Long}
 * @inner
 */ var $24b68728542942b6$var$MIN_VALUE = $24b68728542942b6$var$fromBits(0, -2147483648, false);
/**
 * Minimum signed value.
 * @type {!Long}
 */ $24b68728542942b6$var$Long.MIN_VALUE = $24b68728542942b6$var$MIN_VALUE;
/**
 * @alias Long.prototype
 * @inner
 */ var $24b68728542942b6$var$LongPrototype = $24b68728542942b6$var$Long.prototype;
/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */ $24b68728542942b6$var$LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};
/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */ $24b68728542942b6$var$LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * $24b68728542942b6$var$TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * $24b68728542942b6$var$TWO_PWR_32_DBL + (this.low >>> 0);
};
/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */ $24b68728542942b6$var$LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError('radix');
    if (this.isZero()) return '0';
    if (this.isNegative()) {
        if (this.eq($24b68728542942b6$var$MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = $24b68728542942b6$var$fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else return '-' + this.neg().toString(radix);
    }
    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = $24b68728542942b6$var$fromNumber($24b68728542942b6$var$pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = '';
    while(true){
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result;
        else {
            while(digits.length < 6)digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};
/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */ $24b68728542942b6$var$LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};
/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */ $24b68728542942b6$var$LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};
/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */ $24b68728542942b6$var$LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};
/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */ $24b68728542942b6$var$LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};
/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */ $24b68728542942b6$var$LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) return this.eq($24b68728542942b6$var$MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;
    return this.high != 0 ? bit + 33 : bit + 1;
};
/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};
/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.eqz = $24b68728542942b6$var$LongPrototype.isZero;
/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};
/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};
/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};
/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};
/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.equals = function equals(other) {
    if (!$24b68728542942b6$var$isLong(other)) other = $24b68728542942b6$var$fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
};
/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.eq = $24b68728542942b6$var$LongPrototype.equals;
/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};
/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.neq = $24b68728542942b6$var$LongPrototype.notEquals;
/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.ne = $24b68728542942b6$var$LongPrototype.notEquals;
/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};
/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.lt = $24b68728542942b6$var$LongPrototype.lessThan;
/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};
/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.lte = $24b68728542942b6$var$LongPrototype.lessThanOrEqual;
/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.le = $24b68728542942b6$var$LongPrototype.lessThanOrEqual;
/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};
/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.gt = $24b68728542942b6$var$LongPrototype.greaterThan;
/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};
/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.gte = $24b68728542942b6$var$LongPrototype.greaterThanOrEqual;
/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */ $24b68728542942b6$var$LongPrototype.ge = $24b68728542942b6$var$LongPrototype.greaterThanOrEqual;
/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */ $24b68728542942b6$var$LongPrototype.compare = function compare(other) {
    if (!$24b68728542942b6$var$isLong(other)) other = $24b68728542942b6$var$fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1;
    // At this point the sign bits are the same
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */ $24b68728542942b6$var$LongPrototype.comp = $24b68728542942b6$var$LongPrototype.compare;
/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */ $24b68728542942b6$var$LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq($24b68728542942b6$var$MIN_VALUE)) return $24b68728542942b6$var$MIN_VALUE;
    return this.not().add($24b68728542942b6$var$ONE);
};
/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */ $24b68728542942b6$var$LongPrototype.neg = $24b68728542942b6$var$LongPrototype.negate;
/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */ $24b68728542942b6$var$LongPrototype.add = function add(addend) {
    if (!$24b68728542942b6$var$isLong(addend)) addend = $24b68728542942b6$var$fromValue(addend);
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return $24b68728542942b6$var$fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */ $24b68728542942b6$var$LongPrototype.subtract = function subtract(subtrahend) {
    if (!$24b68728542942b6$var$isLong(subtrahend)) subtrahend = $24b68728542942b6$var$fromValue(subtrahend);
    return this.add(subtrahend.neg());
};
/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */ $24b68728542942b6$var$LongPrototype.sub = $24b68728542942b6$var$LongPrototype.subtract;
/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */ $24b68728542942b6$var$LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return $24b68728542942b6$var$ZERO;
    if (!$24b68728542942b6$var$isLong(multiplier)) multiplier = $24b68728542942b6$var$fromValue(multiplier);
    // use wasm support if present
    if ($24b68728542942b6$var$wasm) {
        var low = $24b68728542942b6$var$wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return $24b68728542942b6$var$fromBits(low, $24b68728542942b6$var$wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero()) return $24b68728542942b6$var$ZERO;
    if (this.eq($24b68728542942b6$var$MIN_VALUE)) return multiplier.isOdd() ? $24b68728542942b6$var$MIN_VALUE : $24b68728542942b6$var$ZERO;
    if (multiplier.eq($24b68728542942b6$var$MIN_VALUE)) return this.isOdd() ? $24b68728542942b6$var$MIN_VALUE : $24b68728542942b6$var$ZERO;
    if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
    // If both longs are small, use float multiplication
    if (this.lt($24b68728542942b6$var$TWO_PWR_24) && multiplier.lt($24b68728542942b6$var$TWO_PWR_24)) return $24b68728542942b6$var$fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return $24b68728542942b6$var$fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */ $24b68728542942b6$var$LongPrototype.mul = $24b68728542942b6$var$LongPrototype.multiply;
/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */ $24b68728542942b6$var$LongPrototype.divide = function divide(divisor) {
    if (!$24b68728542942b6$var$isLong(divisor)) divisor = $24b68728542942b6$var$fromValue(divisor);
    if (divisor.isZero()) throw Error('division by zero');
    // use wasm support if present
    if ($24b68728542942b6$var$wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) // be consistent with non-wasm code path
        return this;
        var low = (this.unsigned ? $24b68728542942b6$var$wasm.div_u : $24b68728542942b6$var$wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return $24b68728542942b6$var$fromBits(low, $24b68728542942b6$var$wasm.get_high(), this.unsigned);
    }
    if (this.isZero()) return this.unsigned ? $24b68728542942b6$var$UZERO : $24b68728542942b6$var$ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq($24b68728542942b6$var$MIN_VALUE)) {
            if (divisor.eq($24b68728542942b6$var$ONE) || divisor.eq($24b68728542942b6$var$NEG_ONE)) return $24b68728542942b6$var$MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq($24b68728542942b6$var$MIN_VALUE)) return $24b68728542942b6$var$ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq($24b68728542942b6$var$ZERO)) return divisor.isNegative() ? $24b68728542942b6$var$ONE : $24b68728542942b6$var$NEG_ONE;
                else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq($24b68728542942b6$var$MIN_VALUE)) return this.unsigned ? $24b68728542942b6$var$UZERO : $24b68728542942b6$var$ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = $24b68728542942b6$var$ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return $24b68728542942b6$var$UZERO;
        if (divisor.gt(this.shru(1))) return $24b68728542942b6$var$UONE;
        res = $24b68728542942b6$var$UZERO;
    }
    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while(rem.gte(divisor)){
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : $24b68728542942b6$var$pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
        approxRes = $24b68728542942b6$var$fromNumber(approx), approxRem = approxRes.mul(divisor);
        while(approxRem.isNegative() || approxRem.gt(rem)){
            approx -= delta;
            approxRes = $24b68728542942b6$var$fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }
        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero()) approxRes = $24b68728542942b6$var$ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};
/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */ $24b68728542942b6$var$LongPrototype.div = $24b68728542942b6$var$LongPrototype.divide;
/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */ $24b68728542942b6$var$LongPrototype.modulo = function modulo(divisor) {
    if (!$24b68728542942b6$var$isLong(divisor)) divisor = $24b68728542942b6$var$fromValue(divisor);
    // use wasm support if present
    if ($24b68728542942b6$var$wasm) {
        var low = (this.unsigned ? $24b68728542942b6$var$wasm.rem_u : $24b68728542942b6$var$wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return $24b68728542942b6$var$fromBits(low, $24b68728542942b6$var$wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
};
/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */ $24b68728542942b6$var$LongPrototype.mod = $24b68728542942b6$var$LongPrototype.modulo;
/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */ $24b68728542942b6$var$LongPrototype.rem = $24b68728542942b6$var$LongPrototype.modulo;
/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */ $24b68728542942b6$var$LongPrototype.not = function not() {
    return $24b68728542942b6$var$fromBits(~this.low, ~this.high, this.unsigned);
};
/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */ $24b68728542942b6$var$LongPrototype.and = function and(other) {
    if (!$24b68728542942b6$var$isLong(other)) other = $24b68728542942b6$var$fromValue(other);
    return $24b68728542942b6$var$fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */ $24b68728542942b6$var$LongPrototype.or = function or(other) {
    if (!$24b68728542942b6$var$isLong(other)) other = $24b68728542942b6$var$fromValue(other);
    return $24b68728542942b6$var$fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */ $24b68728542942b6$var$LongPrototype.xor = function xor(other) {
    if (!$24b68728542942b6$var$isLong(other)) other = $24b68728542942b6$var$fromValue(other);
    return $24b68728542942b6$var$fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if ($24b68728542942b6$var$isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32) return $24b68728542942b6$var$fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else return $24b68728542942b6$var$fromBits(0, this.low << numBits - 32, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shl = $24b68728542942b6$var$LongPrototype.shiftLeft;
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shiftRight = function shiftRight(numBits) {
    if ($24b68728542942b6$var$isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32) return $24b68728542942b6$var$fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else return $24b68728542942b6$var$fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shr = $24b68728542942b6$var$LongPrototype.shiftRight;
/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if ($24b68728542942b6$var$isLong(numBits)) numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0) return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return $24b68728542942b6$var$fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32) return $24b68728542942b6$var$fromBits(high, 0, this.unsigned);
        else return $24b68728542942b6$var$fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
};
/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shru = $24b68728542942b6$var$LongPrototype.shiftRightUnsigned;
/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ $24b68728542942b6$var$LongPrototype.shr_u = $24b68728542942b6$var$LongPrototype.shiftRightUnsigned;
/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */ $24b68728542942b6$var$LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return $24b68728542942b6$var$fromBits(this.low, this.high, false);
};
/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */ $24b68728542942b6$var$LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return $24b68728542942b6$var$fromBits(this.low, this.high, true);
};
/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */ $24b68728542942b6$var$LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};
/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */ $24b68728542942b6$var$LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
        lo & 0xff,
        lo >>> 8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24,
        hi & 0xff,
        hi >>> 8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};
/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */ $24b68728542942b6$var$LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
        hi >>> 24,
        hi >>> 16 & 0xff,
        hi >>> 8 & 0xff,
        hi & 0xff,
        lo >>> 24,
        lo >>> 16 & 0xff,
        lo >>> 8 & 0xff,
        lo & 0xff
    ];
};
/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? $24b68728542942b6$var$Long.fromBytesLE(bytes, unsigned) : $24b68728542942b6$var$Long.fromBytesBE(bytes, unsigned);
};
/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new $24b68728542942b6$var$Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
};
/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */ $24b68728542942b6$var$Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new $24b68728542942b6$var$Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
};


// tslint:disable-next-line
const $b59b9fd1888db600$var$Long = // tslint:disable-next-line
$24b68728542942b6$exports.default || $24b68728542942b6$exports;
function $b59b9fd1888db600$export$20e49d17901a85a5(hex) {
    return $b59b9fd1888db600$var$Long.fromString(hex, true, 16);
}
// Some primes between 2^63 and 2^64 for various uses.
// Hex 0xc3a5c85c97cb3127
const $b59b9fd1888db600$var$k0 = $b59b9fd1888db600$export$20e49d17901a85a5('c3a5c85c97cb3127');
// Hex 0xb492b66fbe98f273
const $b59b9fd1888db600$var$k1 = $b59b9fd1888db600$export$20e49d17901a85a5('b492b66fbe98f273');
// Hex 0x9ae16a3b2f90404f
const $b59b9fd1888db600$var$k2 = $b59b9fd1888db600$export$20e49d17901a85a5('9ae16a3b2f90404f');
function $b59b9fd1888db600$var$shiftMix(val) {
    return val.xor(val.shru(47));
}
function $b59b9fd1888db600$var$fetch(s, offset, numBytes) {
    const bytes = s.slice(offset, offset + numBytes);
    return $b59b9fd1888db600$var$Long.fromBytes(Array.from(bytes), true, true);
}
function $b59b9fd1888db600$var$fetch64(s, offset) {
    return $b59b9fd1888db600$var$fetch(s, offset, 8);
}
function $b59b9fd1888db600$var$fetch32(s, offset) {
    return $b59b9fd1888db600$var$fetch(s, offset, 4);
}
function $b59b9fd1888db600$var$rotate64(val, shift) {
    // Avoid shifting by 64: doing so yields an undefined result.
    return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
}
function $b59b9fd1888db600$var$hashLen16(u, v, mul = $b59b9fd1888db600$export$20e49d17901a85a5('9ddfea08eb382d69')) {
    // Murmur-inspired hashing.
    let a = u.xor(v).mul(mul);
    a = a.xor(a.shru(47));
    let b = v.xor(a).mul(mul);
    b = b.xor(b.shru(47));
    b = b.mul(mul);
    return b;
}
// Return a 16-byte hash for 48 bytes.  Quick and dirty.
// Callers do best to use "random-looking" values for a and b.
function $b59b9fd1888db600$var$weakHashLen32WithSeeds(w, x, y, z, a, b) {
    a = a.add(w);
    b = $b59b9fd1888db600$var$rotate64(b.add(a).add(z), 21);
    const c = a;
    a = a.add(x);
    a = a.add(y);
    b = b.add($b59b9fd1888db600$var$rotate64(a, 44));
    return [
        a.add(z),
        b.add(c)
    ];
}
function $b59b9fd1888db600$var$weakHashLen32WithSeedsStr(s, offset, a, b) {
    return $b59b9fd1888db600$var$weakHashLen32WithSeeds($b59b9fd1888db600$var$fetch64(s, offset), $b59b9fd1888db600$var$fetch64(s, offset + 8), $b59b9fd1888db600$var$fetch64(s, offset + 16), $b59b9fd1888db600$var$fetch64(s, offset + 24), a, b);
}
function $b59b9fd1888db600$var$hashLen0to16(s, len = s.length) {
    if (len >= 8) {
        const mul = $b59b9fd1888db600$var$k2.add(len * 2);
        const a = $b59b9fd1888db600$var$fetch64(s, 0).add($b59b9fd1888db600$var$k2);
        const b = $b59b9fd1888db600$var$fetch64(s, len - 8);
        const c = $b59b9fd1888db600$var$rotate64(b, 37).mul(mul).add(a);
        const d = $b59b9fd1888db600$var$rotate64(a, 25).add(b).mul(mul);
        return $b59b9fd1888db600$var$hashLen16(c, d, mul);
    }
    if (len >= 4) {
        const mul = $b59b9fd1888db600$var$k2.add(len * 2);
        const a = $b59b9fd1888db600$var$fetch32(s, 0);
        return $b59b9fd1888db600$var$hashLen16(a.shl(3).add(len), $b59b9fd1888db600$var$fetch32(s, len - 4), mul);
    }
    if (len > 0) {
        const a = s[0];
        const b = s[len >> 1];
        const c = s[len - 1];
        const y = a + (b << 8);
        const z = len + (c << 2);
        return $b59b9fd1888db600$var$shiftMix($b59b9fd1888db600$var$k2.mul(y).xor($b59b9fd1888db600$var$k0.mul(z))).mul($b59b9fd1888db600$var$k2);
    }
    return $b59b9fd1888db600$var$k2;
}
function $b59b9fd1888db600$var$hashLen17to32(s, len = s.length) {
    const mul = $b59b9fd1888db600$var$k2.add(len * 2);
    const a = $b59b9fd1888db600$var$fetch64(s, 0).mul($b59b9fd1888db600$var$k1);
    const b = $b59b9fd1888db600$var$fetch64(s, 8);
    const c = $b59b9fd1888db600$var$fetch64(s, len - 8).mul(mul);
    const d = $b59b9fd1888db600$var$fetch64(s, len - 16).mul($b59b9fd1888db600$var$k2);
    return $b59b9fd1888db600$var$hashLen16($b59b9fd1888db600$var$rotate64(a.add(b), 43).add($b59b9fd1888db600$var$rotate64(c, 30)).add(d), a.add($b59b9fd1888db600$var$rotate64(b.add($b59b9fd1888db600$var$k2), 18)).add(c), mul);
}
function $b59b9fd1888db600$var$hashLen33to64(s, len = s.length) {
    const mul = $b59b9fd1888db600$var$k2.add(len * 2);
    const a = $b59b9fd1888db600$var$fetch64(s, 0).mul($b59b9fd1888db600$var$k2);
    const b = $b59b9fd1888db600$var$fetch64(s, 8);
    const c = $b59b9fd1888db600$var$fetch64(s, len - 8).mul(mul);
    const d = $b59b9fd1888db600$var$fetch64(s, len - 16).mul($b59b9fd1888db600$var$k2);
    const y = $b59b9fd1888db600$var$rotate64(a.add(b), 43).add($b59b9fd1888db600$var$rotate64(c, 30)).add(d);
    const z = $b59b9fd1888db600$var$hashLen16(y, a.add($b59b9fd1888db600$var$rotate64(b.add($b59b9fd1888db600$var$k2), 18)).add(c), mul);
    const e = $b59b9fd1888db600$var$fetch64(s, 16).mul(mul);
    const f = $b59b9fd1888db600$var$fetch64(s, 24);
    const g = y.add($b59b9fd1888db600$var$fetch64(s, len - 32)).mul(mul);
    const h = z.add($b59b9fd1888db600$var$fetch64(s, len - 24)).mul(mul);
    return $b59b9fd1888db600$var$hashLen16($b59b9fd1888db600$var$rotate64(e.add(f), 43).add($b59b9fd1888db600$var$rotate64(g, 30)).add(h), e.add($b59b9fd1888db600$var$rotate64(f.add(a), 18)).add(g), mul);
}
function $b59b9fd1888db600$export$919ee948dc019032(s, len = s.length) {
    const seed = $b59b9fd1888db600$var$Long.fromNumber(81, true);
    if (len <= 32) {
        if (len <= 16) return $b59b9fd1888db600$var$hashLen0to16(s, len);
        else return $b59b9fd1888db600$var$hashLen17to32(s, len);
    } else if (len <= 64) return $b59b9fd1888db600$var$hashLen33to64(s, len);
    // For strings over 64 bytes we loop.  Internal state consists of
    // 56 bytes: v, w, x, y, and z.
    let x = seed;
    let y = seed.mul($b59b9fd1888db600$var$k1).add(113);
    let z = $b59b9fd1888db600$var$shiftMix(y.mul($b59b9fd1888db600$var$k2).add(113)).mul($b59b9fd1888db600$var$k2);
    let v = [
        $b59b9fd1888db600$var$Long.UZERO,
        $b59b9fd1888db600$var$Long.UZERO
    ];
    let w = [
        $b59b9fd1888db600$var$Long.UZERO,
        $b59b9fd1888db600$var$Long.UZERO
    ];
    x = x.mul($b59b9fd1888db600$var$k2).add($b59b9fd1888db600$var$fetch64(s, 0));
    let offset = 0;
    // Set end so that after the loop we have 1 to 64 bytes left to process.
    const end = (len - 1 >> 6) * 64;
    const last64 = end + (len - 1 & 63) - 63;
    do {
        x = $b59b9fd1888db600$var$rotate64(x.add(y).add(v[0]).add($b59b9fd1888db600$var$fetch64(s, offset + 8)), 37).mul($b59b9fd1888db600$var$k1);
        y = $b59b9fd1888db600$var$rotate64(y.add(v[1]).add($b59b9fd1888db600$var$fetch64(s, offset + 48)), 42).mul($b59b9fd1888db600$var$k1);
        x = x.xor(w[1]);
        y = y.add(v[0]).add($b59b9fd1888db600$var$fetch64(s, offset + 40));
        z = $b59b9fd1888db600$var$rotate64(z.add(w[0]), 33).mul($b59b9fd1888db600$var$k1);
        v = $b59b9fd1888db600$var$weakHashLen32WithSeedsStr(s, offset, v[1].mul($b59b9fd1888db600$var$k1), x.add(w[0]));
        w = $b59b9fd1888db600$var$weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add($b59b9fd1888db600$var$fetch64(s, offset + 16)));
        [z, x] = [
            x,
            z
        ];
        offset += 64;
    }while (offset !== end)
    const mul = $b59b9fd1888db600$var$k1.add(z.and(0xff).shl(1));
    // Point to the last 64 bytes of input.
    offset = last64;
    w[0] = w[0].add(len - 1 & 63);
    v[0] = v[0].add(w[0]);
    w[0] = w[0].add(v[0]);
    x = $b59b9fd1888db600$var$rotate64(x.add(y).add(v[0]).add($b59b9fd1888db600$var$fetch64(s, offset + 8)), 37).mul(mul);
    y = $b59b9fd1888db600$var$rotate64(y.add(v[1]).add($b59b9fd1888db600$var$fetch64(s, offset + 48)), 42).mul(mul);
    x = x.xor(w[1].mul(9));
    y = y.add(v[0].mul(9).add($b59b9fd1888db600$var$fetch64(s, offset + 40)));
    z = $b59b9fd1888db600$var$rotate64(z.add(w[0]), 33).mul(mul);
    v = $b59b9fd1888db600$var$weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul), x.add(w[0]));
    w = $b59b9fd1888db600$var$weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add($b59b9fd1888db600$var$fetch64(s, offset + 16)));
    [z, x] = [
        x,
        z
    ];
    return $b59b9fd1888db600$var$hashLen16($b59b9fd1888db600$var$hashLen16(v[0], w[0], mul).add($b59b9fd1888db600$var$shiftMix(y).mul($b59b9fd1888db600$var$k0)).add(z), $b59b9fd1888db600$var$hashLen16(v[1], w[1], mul).add(x), mul);
}


function $f6b55a2021b78f0d$export$cd3f28d8002ec2a2(value, dtype) {
    if (dtype === 'string') return $f6b55a2021b78f0d$export$8146d2e653b87d6a(value);
    return $f6b55a2021b78f0d$export$965adc581230795c([
        value
    ], dtype);
}
function $f6b55a2021b78f0d$var$noConversionNeeded(a, dtype) {
    return a instanceof Float32Array && dtype === 'float32' || a instanceof Int32Array && dtype === 'int32' || a instanceof Uint8Array && dtype === 'bool';
}
function $f6b55a2021b78f0d$export$965adc581230795c(a, dtype) {
    if (dtype === 'string') throw new Error('Cannot convert a string[] to a TypedArray');
    if (Array.isArray(a)) a = $904921ed29eeae0f$export$bffa455ba8c619a6(a);
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) $904921ed29eeae0f$export$579cf7b8ff0a87a3(a, dtype);
    if ($f6b55a2021b78f0d$var$noConversionNeeded(a, dtype)) return a;
    if (dtype == null || dtype === 'float32' || dtype === 'complex64') return new Float32Array(a);
    else if (dtype === 'int32') return new Int32Array(a);
    else if (dtype === 'bool') {
        const bool = new Uint8Array(a.length);
        for(let i = 0; i < bool.length; ++i)if (Math.round(a[i]) !== 0) bool[i] = 1;
        return bool;
    } else throw new Error(`Unknown data type ${dtype}`);
}
function $f6b55a2021b78f0d$export$461939dd4422153() {
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.now();
}
function $f6b55a2021b78f0d$export$e7aa7bc5c1b3cfb3(path, requestInits) {
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.fetch(path, requestInits);
}
function $f6b55a2021b78f0d$export$8146d2e653b87d6a(s, encoding = 'utf-8') {
    encoding = encoding || 'utf-8';
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.encode(s, encoding);
}
function $f6b55a2021b78f0d$export$a0fb664af7d0cc44(bytes, encoding = 'utf-8') {
    encoding = encoding || 'utf-8';
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.decode(bytes, encoding);
}
$parcel$exportWildcard($f6b55a2021b78f0d$exports, $904921ed29eeae0f$exports);
$parcel$exportWildcard($f6b55a2021b78f0d$exports, $b59b9fd1888db600$exports);


class $544508912355211a$export$e2c29f18771995cb {
    constructor(backendTimer, logger){
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) this.logger = new $544508912355211a$export$efa9a398d6368992();
    }
    profileKernel(kernelName, inputs, f) {
        let outputs;
        const holdResultWrapperFn = ()=>{
            outputs = f();
        };
        let timer;
        const start = $f6b55a2021b78f0d$export$461939dd4422153();
        if (this.backendTimer.timerAvailable()) timer = this.backendTimer.time(holdResultWrapperFn);
        else {
            holdResultWrapperFn();
            for (const output of outputs)output.dataSync();
            timer = Promise.resolve({
                kernelMs: $f6b55a2021b78f0d$export$461939dd4422153() - start
            });
        }
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('CHECK_COMPUTATION_FOR_ERRORS')) for(let i = 0; i < outputs.length; i++){
            const output = outputs[i];
            // Dangling promise here because we don't want to propagate up
            // asynchronicity.
            output.data().then((tensorVals)=>{
                $544508912355211a$export$7f6e9a47e989eedc(tensorVals, output.dtype, kernelName);
            });
        }
        const kernelProfile = {
            kernelName: kernelName,
            outputs: outputs,
            inputs: inputs,
            timeMs: timer.then((timing)=>timing.kernelMs
            ),
            extraInfo: timer.then((timing)=>timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : ''
            )
        };
        return kernelProfile;
    }
    logKernelProfile(kernelProfile) {
        const { kernelName: kernelName , outputs: outputs , timeMs: timeMs , inputs: inputs , extraInfo: extraInfo  } = kernelProfile;
        outputs.forEach((result)=>{
            Promise.all([
                result.data(),
                timeMs,
                extraInfo
            ]).then((valueContainer)=>{
                this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
            });
        });
    }
}
function $544508912355211a$export$7f6e9a47e989eedc(vals, dtype, kernelName) {
    if (dtype !== 'float32') // Only floating point computations will generate NaN values
    return false;
    for(let i = 0; i < vals.length; i++){
        const num = vals[i];
        if (isNaN(num) || !isFinite(num)) {
            // Throwing custom exception so behavior is testable.
            console.warn(`Found ${num} in the result of '${kernelName}'`);
            return true;
        }
    }
    return false;
}
class $544508912355211a$export$efa9a398d6368992 {
    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
        const time = typeof timeMs === 'number' ? $904921ed29eeae0f$export$390245bab32fb60f(`${timeMs}ms`, 9) : timeMs['error'];
        const paddedName = $904921ed29eeae0f$export$390245bab32fb60f(name, 25);
        const rank = result.rank;
        const size = result.size;
        const shape = $904921ed29eeae0f$export$390245bab32fb60f(result.shape.toString(), 14);
        let inputShapesDescription = '';
        for(const name1 in inputs){
            const input = inputs[name1];
            if (input != null) {
                // The input might be a non-tensor (e.g HTMLImageElement), in which case
                // we claim the output shape as input shape.
                const inputShape = input.shape || result.shape;
                const inputRank = inputShape.length;
                inputShapesDescription += `${name1}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;
            }
        }
        console.log(`%c${paddedName}\t%c${time}\t%c${rank}D ${shape}\t%c${size}\t%c${inputShapesDescription}\t%c${extraInfo}`, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange', 'color: green', 'color: steelblue');
    }
}



function $2931d251acbb4515$export$13eebbb952f0db02(tape, xs, y) {
    // Forward pass to compute all the nodes and Tensors that are transitively a
    // function of x.
    const tensorsFromX = {};
    const nodesFromX = {};
    for(let i = 0; i < xs.length; i++)tensorsFromX[xs[i].id] = true;
    for(let i1 = 0; i1 < tape.length; i1++){
        const node = tape[i1];
        const nodeInputs = node.inputs;
        for(const inputName in nodeInputs){
            const input = nodeInputs[inputName];
            let anyInputFromX = false;
            for(let j = 0; j < xs.length; j++)if (tensorsFromX[input.id]) {
                node.outputs.forEach((output)=>tensorsFromX[output.id] = true
                );
                anyInputFromX = true;
                nodesFromX[node.id] = true;
                break;
            }
            if (anyInputFromX) break;
        }
    }
    // Backward pass to find all of the nodes and Tensors that lead to y.
    const tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    const nodesToY = {};
    for(let i2 = tape.length - 1; i2 >= 0; i2--){
        const node = tape[i2];
        const nodeInputs = node.inputs;
        // If any of the outputs lead to y, mark all of the inputs as leading to y.
        for(let j = 0; j < node.outputs.length; j++)if (tensorsLeadToY[node.outputs[j].id]) {
            for(const inputName in nodeInputs){
                tensorsLeadToY[nodeInputs[inputName].id] = true;
                nodesToY[node.id] = true;
            }
            break;
        }
    }
    // Return the paths that come from x and lead to y.
    const filteredTape = [];
    for(let i3 = 0; i3 < tape.length; i3++){
        const node = tape[i3];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            // Prune the inputs from the node that aren't a function of x.
            const prunedInputs = {};
            for(const inputName in node.inputs){
                const nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) prunedInputs[inputName] = nodeInput;
            }
            // Copy the node and overwrite inputsAndArgs to the pruned version.
            const prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.outputs = node.outputs;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
function $2931d251acbb4515$export$2992958ba0a8790d(tensorAccumulatedGradientMap, filteredTape, tidy, add) {
    // Walk the tape backward and keep a map of Tensor to its gradient.
    for(let i = filteredTape.length - 1; i >= 0; i--){
        const node = filteredTape[i];
        const dys = [];
        node.outputs.forEach((o)=>{
            const gradTensor = tensorAccumulatedGradientMap[o.id];
            if (gradTensor != null) dys.push(gradTensor);
            else // This particular output is not in the back-propagation subgraph, so it
            // does not affect the final output, thus we put null for its dy.
            dys.push(null);
        });
        if (node.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found ` + `for ${node.kernelName}.`);
        // Backprop dy through this node and accumulate gradients over the inputs.
        const inputGradients = node.gradient(dys);
        for(const inputName in node.inputs){
            if (!(inputName in inputGradients)) throw new Error(`Cannot backprop through input ${inputName}. ` + `Available gradients found: ${Object.keys(inputGradients)}.`);
            // Call the gradient function.
            const dx = tidy(()=>inputGradients[inputName]()
            );
            if (dx.dtype !== 'float32') throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` + `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
            const x = node.inputs[inputName];
            if (!$904921ed29eeae0f$export$234180f8206db11b(dx.shape, x.shape)) throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` + `'${inputName}' has shape '${dx.shape}', which does not match ` + `the shape of the input '${x.shape}'`);
            if (tensorAccumulatedGradientMap[x.id] == null) tensorAccumulatedGradientMap[x.id] = dx;
            else {
                const curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);
                curGradient.dispose();
            }
        }
    }
}




// Maximum number of values before we decide to show ellipsis.
const $0c8772fea1b31389$var$FORMAT_LIMIT_NUM_VALS = 20;
// Number of first and last values to show when displaying a, b,...,y, z.
const $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS = 3;
// Number of significant digits to show.
const $0c8772fea1b31389$var$FORMAT_NUM_SIG_DIGITS = 7;
function $0c8772fea1b31389$export$7febe2c78b16daa7(vals, shape, dtype, verbose) {
    const strides = $904921ed29eeae0f$export$6ad0292cf4d50f79(shape);
    const padPerCol = $0c8772fea1b31389$var$computeMaxSizePerColumn(vals, shape, dtype, strides);
    const rank = shape.length;
    const valsLines = $0c8772fea1b31389$var$subTensorToString(vals, shape, dtype, strides, padPerCol);
    const lines = [
        'Tensor'
    ];
    if (verbose) {
        lines.push(`  dtype: ${dtype}`);
        lines.push(`  rank: ${rank}`);
        lines.push(`  shape: [${shape}]`);
        lines.push(`  values:`);
    }
    lines.push(valsLines.map((l)=>'    ' + l
    ).join('\n'));
    return lines.join('\n');
}
function $0c8772fea1b31389$var$computeMaxSizePerColumn(vals, shape, dtype, strides) {
    const n = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
    const numCols = strides[strides.length - 1];
    const padPerCol = new Array(numCols).fill(0);
    const rank = shape.length;
    const valuesOrTuples = dtype === 'complex64' ? $0c8772fea1b31389$var$createComplexTuples(vals) : vals;
    if (rank > 1) for(let row = 0; row < n / numCols; row++){
        const offset = row * numCols;
        for(let j = 0; j < numCols; j++)padPerCol[j] = Math.max(padPerCol[j], $0c8772fea1b31389$var$valToString(valuesOrTuples[offset + j], 0, dtype).length);
    }
    return padPerCol;
}
function $0c8772fea1b31389$var$valToString(val, pad, dtype) {
    let valStr;
    if (Array.isArray(val)) valStr = `${parseFloat(val[0].toFixed($0c8772fea1b31389$var$FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed($0c8772fea1b31389$var$FORMAT_NUM_SIG_DIGITS))}j`;
    else if ($904921ed29eeae0f$export$844ec244b1367d54(val)) valStr = `'${val}'`;
    else if (dtype === 'bool') valStr = $0c8772fea1b31389$var$boolNumToString(val);
    else valStr = parseFloat(val.toFixed($0c8772fea1b31389$var$FORMAT_NUM_SIG_DIGITS)).toString();
    return $904921ed29eeae0f$export$390245bab32fb60f(valStr, pad);
}
function $0c8772fea1b31389$var$boolNumToString(v) {
    return v === 0 ? 'false' : 'true';
}
function $0c8772fea1b31389$var$subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
    const storagePerElement = dtype === 'complex64' ? 2 : 1;
    const size = shape[0];
    const rank = shape.length;
    if (rank === 0) {
        if (dtype === 'complex64') {
            const complexTuple = $0c8772fea1b31389$var$createComplexTuples(vals);
            return [
                $0c8772fea1b31389$var$valToString(complexTuple[0], 0, dtype)
            ];
        }
        if (dtype === 'bool') return [
            $0c8772fea1b31389$var$boolNumToString(vals[0])
        ];
        return [
            vals[0].toString()
        ];
    }
    if (rank === 1) {
        if (size > $0c8772fea1b31389$var$FORMAT_LIMIT_NUM_VALS) {
            const firstValsSize = $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
            let firstVals = Array.from(vals.slice(0, firstValsSize));
            let lastVals = Array.from(vals.slice((size - $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
            if (dtype === 'complex64') {
                firstVals = $0c8772fea1b31389$var$createComplexTuples(firstVals);
                lastVals = $0c8772fea1b31389$var$createComplexTuples(lastVals);
            }
            return [
                '[' + firstVals.map((x, i)=>$0c8772fea1b31389$var$valToString(x, padPerCol[i], dtype)
                ).join(', ') + ', ..., ' + lastVals.map((x, i)=>$0c8772fea1b31389$var$valToString(x, padPerCol[size - $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS + i], dtype)
                ).join(', ') + ']'
            ];
        }
        const displayVals = dtype === 'complex64' ? $0c8772fea1b31389$var$createComplexTuples(vals) : Array.from(vals);
        return [
            '[' + displayVals.map((x, i)=>$0c8772fea1b31389$var$valToString(x, padPerCol[i], dtype)
            ).join(', ') + ']'
        ];
    }
    // The array is rank 2 or more.
    const subshape = shape.slice(1);
    const substrides = strides.slice(1);
    const stride = strides[0] * storagePerElement;
    const lines = [];
    if (size > $0c8772fea1b31389$var$FORMAT_LIMIT_NUM_VALS) {
        for(let i = 0; i < $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS; i++){
            const start = i * stride;
            const end = start + stride;
            lines.push(...$0c8772fea1b31389$var$subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
        }
        lines.push('...');
        for(let i4 = size - $0c8772fea1b31389$var$FORMAT_NUM_FIRST_LAST_VALS; i4 < size; i4++){
            const start = i4 * stride;
            const end = start + stride;
            lines.push(...$0c8772fea1b31389$var$subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i4 === size - 1 /* isLast */ ));
        }
    } else for(let i3 = 0; i3 < size; i3++){
        const start = i3 * stride;
        const end = start + stride;
        lines.push(...$0c8772fea1b31389$var$subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i3 === size - 1 /* isLast */ ));
    }
    const sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for(let i1 = 1; i1 < lines.length - 1; i1++)lines[i1] = ' ' + lines[i1] + sep;
    let newLineSep = ',\n';
    for(let i2 = 2; i2 < rank; i2++)newLineSep += '\n';
    lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}
function $0c8772fea1b31389$var$createComplexTuples(vals) {
    const complexTuples = [];
    for(let i = 0; i < vals.length; i += 2)complexTuples.push([
        vals[i],
        vals[i + 1]
    ]);
    return complexTuples;
}




class $c341eb4171cc0419$export$350df26cd52e08e1 {
    constructor(shape, dtype, values){
        this.dtype = dtype;
        this.shape = shape.slice();
        this.size = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
        if (values != null) {
            const n = values.length;
            $904921ed29eeae0f$export$a7a9523472993e97(n === this.size, ()=>`Length of values '${n}' does not match the size ` + `inferred by the shape '${this.size}'.`
            );
        }
        if (dtype === 'complex64') throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` + `a TensorBuffer for the real and imaginary parts separately and ` + `call tf.complex(real, imag).`);
        this.values = values || $904921ed29eeae0f$export$24f13f6206df8f7c(dtype, this.size);
        this.strides = $904921ed29eeae0f$export$6ad0292cf4d50f79(shape);
    }
    /**
     * Sets a value in the buffer at a given location.
     *
     * @param value The value to set.
     * @param locs  The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */ set(value, ...locs) {
        if (locs.length === 0) locs = [
            0
        ];
        $904921ed29eeae0f$export$a7a9523472993e97(locs.length === this.rank, ()=>`The number of provided coordinates (${locs.length}) must ` + `match the rank (${this.rank})`
        );
        const index = this.locToIndex(locs);
        this.values[index] = value;
    }
    /**
     * Returns the value in the buffer at the provided location.
     *
     * @param locs The location indices.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */ get(...locs) {
        if (locs.length === 0) locs = [
            0
        ];
        let i = 0;
        for (const loc of locs){
            if (loc < 0 || loc >= this.shape[i]) {
                const msg = `Requested out of range element at ${locs}. ` + `  Buffer shape=${this.shape}`;
                throw new Error(msg);
            }
            i++;
        }
        let index = locs[locs.length - 1];
        for(let i1 = 0; i1 < locs.length - 1; ++i1)index += this.strides[i1] * locs[i1];
        return this.values[index];
    }
    locToIndex(locs) {
        if (this.rank === 0) return 0;
        else if (this.rank === 1) return locs[0];
        let index = locs[locs.length - 1];
        for(let i = 0; i < locs.length - 1; ++i)index += this.strides[i] * locs[i];
        return index;
    }
    indexToLoc(index) {
        if (this.rank === 0) return [];
        else if (this.rank === 1) return [
            index
        ];
        const locs = new Array(this.shape.length);
        for(let i = 0; i < locs.length - 1; ++i){
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    }
    get rank() {
        return this.shape.length;
    }
    /**
     * Creates an immutable `tf.Tensor` object from the buffer.
     *
     * @doc {heading: 'Tensors', subheading: 'Creation'}
     */ toTensor() {
        return $c341eb4171cc0419$var$trackerFn().makeTensor(this.values, this.shape, this.dtype);
    }
}
// For tracking tensor creation and disposal.
let $c341eb4171cc0419$var$trackerFn = null;
// Used by chaining methods to call into ops.
let $c341eb4171cc0419$var$opHandler = null;
// Used to warn about deprecated methods.
let $c341eb4171cc0419$var$deprecationWarningFn = null;
function $c341eb4171cc0419$export$b1e34d2f0ffbbd85(fn) {
    $c341eb4171cc0419$var$trackerFn = fn;
}
function $c341eb4171cc0419$export$1efe8d8b4884ad31(handler) {
    $c341eb4171cc0419$var$opHandler = handler;
}
function $c341eb4171cc0419$export$ca605c1d8919649f(fn) {
    $c341eb4171cc0419$var$deprecationWarningFn = fn;
}
class $c341eb4171cc0419$export$7b6b8d90402f8814 {
    constructor(shape, dtype, dataId, id){
        /** Whether this tensor has been globally kept. */ this.kept = false;
        this.isDisposedInternal = false;
        this.shape = shape.slice();
        this.dtype = dtype || 'float32';
        this.size = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
        this.strides = $904921ed29eeae0f$export$6ad0292cf4d50f79(shape);
        this.dataId = dataId;
        this.id = id;
        this.rankType = this.rank < 5 ? this.rank.toString() : 'higher';
    }
    get rank() {
        return this.shape.length;
    }
    /**
     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ async buffer() {
        const vals = await this.data();
        return $c341eb4171cc0419$var$opHandler.buffer(this.shape, this.dtype, vals);
    }
    /**
     * Returns a `tf.TensorBuffer` that holds the underlying data.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ bufferSync() {
        return $c341eb4171cc0419$var$opHandler.buffer(this.shape, this.dtype, this.dataSync());
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * asynchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ async array() {
        const vals = await this.data();
        return $904921ed29eeae0f$export$3983c25181aa68cc(this.shape, vals, this.dtype === 'complex64');
    }
    /**
     * Returns the tensor data as a nested array. The transfer of data is done
     * synchronously.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ arraySync() {
        return $904921ed29eeae0f$export$3983c25181aa68cc(this.shape, this.dataSync(), this.dtype === 'complex64');
    }
    /**
     * Asynchronously downloads the values from the `tf.Tensor`. Returns a
     * promise of `TypedArray` that resolves when the computation has finished.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ async data() {
        this.throwIfDisposed();
        const data = $c341eb4171cc0419$var$trackerFn().read(this.dataId);
        if (this.dtype === 'string') {
            const bytes = await data;
            try {
                return bytes.map((b)=>$f6b55a2021b78f0d$export$a0fb664af7d0cc44(b)
                );
            } catch (_a) {
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
        }
        return data;
    }
    /**
     * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
     * and `data()`, this method prevents data from being downloaded to CPU.
     *
     * For WebGL backend, the data will be stored on a densely packed texture.
     * This means that the texture will use the RGBA channels to store value.
     *
     * @param options:
     *     For WebGL,
     *         - customTexShape: Optional. If set, will use the user defined
     *     texture shape to create the texture.
     *
     * @returns For WebGL backend, a GPUData contains the new texture and
     *     its information.
     *     {
     *        tensorRef: The tensor that is associated with this texture,
     *        texture: WebGLTexture,
     *        texShape: [number, number] // [height, width]
     *     }
     *     Remember to dispose the GPUData after it is used by
     *     `res.tensorRef.dispose()`.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ dataToGPU(options) {
        this.throwIfDisposed();
        return $c341eb4171cc0419$var$trackerFn().readToGPU(this.dataId, options);
    }
    /**
     * Synchronously downloads the values from the `tf.Tensor`. This blocks the
     * UI thread until the values are ready, which can cause performance issues.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ dataSync() {
        this.throwIfDisposed();
        const data = $c341eb4171cc0419$var$trackerFn().readSync(this.dataId);
        if (this.dtype === 'string') try {
            return data.map((b)=>$f6b55a2021b78f0d$export$a0fb664af7d0cc44(b)
            );
        } catch (_a) {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
        return data;
    }
    /** Returns the underlying bytes of the tensor's data. */ async bytes() {
        this.throwIfDisposed();
        const data = await $c341eb4171cc0419$var$trackerFn().read(this.dataId);
        if (this.dtype === 'string') return data;
        else return new Uint8Array(data.buffer);
    }
    /**
     * Disposes `tf.Tensor` from memory.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ dispose() {
        if (this.isDisposed) return;
        $c341eb4171cc0419$var$trackerFn().disposeTensor(this);
        this.isDisposedInternal = true;
    }
    get isDisposed() {
        return this.isDisposedInternal;
    }
    throwIfDisposed() {
        if (this.isDisposed) throw new Error(`Tensor is disposed.`);
    }
    /**
     * Prints the `tf.Tensor`. See `tf.print` for details.
     *
     * @param verbose Whether to print verbose information about the tensor,
     *    including dtype and size.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ print(verbose = false) {
        return $c341eb4171cc0419$var$opHandler.print(this, verbose);
    }
    /**
     * Returns a copy of the tensor. See `tf.clone` for details.
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ clone() {
        this.throwIfDisposed();
        return $c341eb4171cc0419$var$opHandler.clone(this);
    }
    /**
     * Returns a human-readable description of the tensor. Useful for logging.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ toString(verbose = false) {
        const vals = this.dataSync();
        return $0c8772fea1b31389$export$7febe2c78b16daa7(vals, this.shape, this.dtype, verbose);
    }
    cast(dtype) {
        this.throwIfDisposed();
        return $c341eb4171cc0419$var$opHandler.cast(this, dtype);
    }
    variable(trainable = true, name, dtype) {
        this.throwIfDisposed();
        return $c341eb4171cc0419$var$trackerFn().makeVariable(this, trainable, name, dtype);
    }
}
Object.defineProperty($c341eb4171cc0419$export$7b6b8d90402f8814, Symbol.hasInstance, {
    value: (instance)=>{
        // Implementation note: we should use properties of the object that will be
        // defined before the constructor body has finished executing (methods).
        // This is because when this code is transpiled by babel, babel will call
        // classCallCheck before the constructor body is run.
        // See https://github.com/tensorflow/tfjs/issues/3384 for backstory.
        return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
    }
});
function $c341eb4171cc0419$export$3cbd87e9d6a9b7ac() {
    // Use getGlobal so that we can augment the Tensor class across package
    // boundaries becase the node resolution alg may result in different modules
    // being returned for this file depending on the path they are loaded from.
    return $95bbaab90b583097$export$a4e55266d2135a7f('Tensor', ()=>{
        return $c341eb4171cc0419$export$7b6b8d90402f8814;
    });
}
// Global side effect. Cache global reference to Tensor class
$c341eb4171cc0419$export$3cbd87e9d6a9b7ac();
class $c341eb4171cc0419$export$c867a5c9595a1350 extends $c341eb4171cc0419$export$7b6b8d90402f8814 {
    constructor(initialValue, trainable, name, tensorId){
        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
        this.trainable = trainable;
        this.name = name;
    }
    /**
     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
     * the same shape and dtype as the old `tf.Tensor`.
     *
     * @param newValue New tensor to be assigned to this variable.
     *
     * @doc {heading: 'Tensors', subheading: 'Classes'}
     */ assign(newValue) {
        if (newValue.dtype !== this.dtype) throw new Error(`dtype of the new value (${newValue.dtype}) and ` + `previous value (${this.dtype}) must match`);
        if (!$904921ed29eeae0f$export$234180f8206db11b(newValue.shape, this.shape)) throw new Error(`shape of the new value (${newValue.shape}) and ` + `previous value (${this.shape}) must match`);
        $c341eb4171cc0419$var$trackerFn().disposeTensor(this);
        this.dataId = newValue.dataId;
        $c341eb4171cc0419$var$trackerFn().incRef(this, null);
    }
    dispose() {
        $c341eb4171cc0419$var$trackerFn().disposeVariable(this);
        this.isDisposedInternal = true;
    }
}
Object.defineProperty($c341eb4171cc0419$export$c867a5c9595a1350, Symbol.hasInstance, {
    value: (instance)=>{
        return instance instanceof $c341eb4171cc0419$export$7b6b8d90402f8814 && instance.assign != null && instance.assign instanceof Function;
    }
});



var $993b52a5dd76e458$export$c36edca8f8f0427a;
(function($993b52a5dd76e458$export$c36edca8f8f0427a) {
    $993b52a5dd76e458$export$c36edca8f8f0427a["R0"] = "R0";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R1"] = "R1";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R2"] = "R2";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R3"] = "R3";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R4"] = "R4";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R5"] = "R5";
    $993b52a5dd76e458$export$c36edca8f8f0427a["R6"] = "R6";
})($993b52a5dd76e458$export$c36edca8f8f0427a || ($993b52a5dd76e458$export$c36edca8f8f0427a = {}));
// Looks for upcasting types. Used, for example, in operations with mixed dtype
// inputs.
var $993b52a5dd76e458$var$UpcastInt32AndMap;
(function(UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
    UpcastInt32AndMap["complex64"] = "complex64";
})($993b52a5dd76e458$var$UpcastInt32AndMap || ($993b52a5dd76e458$var$UpcastInt32AndMap = {}));
var $993b52a5dd76e458$var$UpcastBoolAndMap;
(function(UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
    UpcastBoolAndMap["complex64"] = "complex64";
})($993b52a5dd76e458$var$UpcastBoolAndMap || ($993b52a5dd76e458$var$UpcastBoolAndMap = {}));
var $993b52a5dd76e458$var$UpcastFloat32AndMap;
(function(UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
    UpcastFloat32AndMap["complex64"] = "complex64";
})($993b52a5dd76e458$var$UpcastFloat32AndMap || ($993b52a5dd76e458$var$UpcastFloat32AndMap = {}));
var $993b52a5dd76e458$var$UpcastComplex64AndMap;
(function(UpcastComplex64AndMap) {
    UpcastComplex64AndMap["float32"] = "complex64";
    UpcastComplex64AndMap["int32"] = "complex64";
    UpcastComplex64AndMap["bool"] = "complex64";
    UpcastComplex64AndMap["complex64"] = "complex64";
})($993b52a5dd76e458$var$UpcastComplex64AndMap || ($993b52a5dd76e458$var$UpcastComplex64AndMap = {}));
const $993b52a5dd76e458$var$upcastTypeMap = {
    'float32': $993b52a5dd76e458$var$UpcastFloat32AndMap,
    'int32': $993b52a5dd76e458$var$UpcastInt32AndMap,
    'bool': $993b52a5dd76e458$var$UpcastBoolAndMap,
    'complex64': $993b52a5dd76e458$var$UpcastComplex64AndMap
};
function $993b52a5dd76e458$export$7bcca02d1a156bdf(typeA, typeB) {
    if (typeA === 'string' || typeB === 'string') {
        if (typeA === 'string' && typeB === 'string') return 'string';
        throw new Error(`Can not upcast ${typeA} with ${typeB}`);
    }
    return $993b52a5dd76e458$var$upcastTypeMap[typeA][typeB];
}
function $993b52a5dd76e458$export$3479b4fbed3c0d8d(type) {
    return $993b52a5dd76e458$export$7bcca02d1a156bdf(type, 'int32');
}



function $f5b489dcdac9fd38$export$8b0e24c749a224d7(a, b) {
    if (a.dtype === b.dtype) return [
        a,
        b
    ];
    const dtype = $993b52a5dd76e458$export$7bcca02d1a156bdf(a.dtype, b.dtype);
    return [
        a.cast(dtype),
        b.cast(dtype)
    ];
}
function $f5b489dcdac9fd38$export$8a66522456343d17(a, b) {
    $904921ed29eeae0f$export$a7a9523472993e97(a.dtype === b.dtype, ()=>`The dtypes of the first(${a.dtype}) and` + ` second(${b.dtype}) input must match`
    );
}
function $f5b489dcdac9fd38$export$537d2ee9de90a490(tensor, tensorList) {
    return tensorList.some((x)=>x.id === tensor.id
    );
}
function $f5b489dcdac9fd38$export$888c106d343989f5(result) {
    const list = [];
    const seen = new Set();
    $f5b489dcdac9fd38$var$walkTensorContainer(result, list, seen);
    return list;
}
function $f5b489dcdac9fd38$var$walkTensorContainer(container, list, seen) {
    if (container == null) return;
    if (container instanceof $c341eb4171cc0419$export$7b6b8d90402f8814) {
        list.push(container);
        return;
    }
    if (!$f5b489dcdac9fd38$var$isIterable(container)) return;
    // Iteration over keys works also for arrays.
    const iterable = container;
    for(const k in iterable){
        const val = iterable[k];
        if (!seen.has(val)) {
            seen.add(val);
            $f5b489dcdac9fd38$var$walkTensorContainer(val, list, seen);
        }
    }
}
// tslint:disable-next-line:no-any
function $f5b489dcdac9fd38$var$isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}




function $a6bde3769fa0d8b5$var$isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
}
class $a6bde3769fa0d8b5$var$EngineState {
    constructor(){
        // Public since optimizers will use it.
        this.registeredVariables = {};
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numStringTensors = 0;
        this.numDataBuffers = 0;
        // Number of nested tf.grad() statements when computing higher-order
        // gradients. E.g. `1` for first-order gradients and `2` for second-order
        // gradients. Used to track if the tape should be removed after a backprop.
        this.gradientDepth = 0;
        // Number of nested kernel calls. When kernel depth is greater than 1, we turn
        // off the tape.
        this.kernelDepth = 0;
        this.scopeStack = [];
        /**
         * Keeps track of the number of data moves during a kernel execution. We
         * maintain a stack since kernels can call other kernels, recursively.
         */ this.numDataMovesStack = [];
        this.nextScopeId = 0;
        this.tensorInfo = new WeakMap();
        this.profiling = false;
        this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null,
            get kernelNames () {
                return Array.from(new Set(this.kernels.map((k)=>k.name
                )));
            }
        };
    }
    dispose() {
        for(const variableName in this.registeredVariables)this.registeredVariables[variableName].dispose();
    }
}
class $a6bde3769fa0d8b5$export$2c3b404bf3a77a1f {
    constructor(ENV){
        this.ENV = ENV;
        this.registry = {};
        this.registryFactory = {};
        this.pendingBackendInitId = 0;
        this.state = new $a6bde3769fa0d8b5$var$EngineState();
    }
    async ready() {
        if (this.pendingBackendInit != null) return this.pendingBackendInit.then(()=>{});
        if (this.backendInstance != null) return;
        const sortedBackends = this.getSortedBackends();
        for(let i = 0; i < sortedBackends.length; i++){
            const backendName = sortedBackends[i];
            const success = await this.initializeBackend(backendName).success;
            if (success) {
                await this.setBackend(backendName);
                return;
            }
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` + `failed.`);
    }
    get backend() {
        if (this.pendingBackendInit != null) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` + `sure to await tf.ready() or await tf.setBackend() before calling ` + `other methods`);
        if (this.backendInstance == null) {
            const { name: name , asyncInit: asyncInit  } = this.initializeBackendsAndReturnBest();
            if (asyncInit) throw new Error(`The highest priority backend '${name}' has not yet been ` + `initialized. Make sure to await tf.ready() or ` + `await tf.setBackend() before calling other methods`);
            this.setBackend(name);
        }
        return this.backendInstance;
    }
    backendNames() {
        return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
        if (!(backendName in this.registry)) {
            // If the backend hasn't been initialized but we have a registry entry for
            // it, initialize it and return it.
            if (backendName in this.registryFactory) {
                const { asyncInit: asyncInit  } = this.initializeBackend(backendName);
                if (asyncInit) // Backend is not ready yet.
                return null;
            } else return null;
        }
        return this.registry[backendName];
    }
    findBackendFactory(backendName) {
        if (!(backendName in this.registryFactory)) return null;
        return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
        if (backendName in this.registryFactory) {
            $35abfa9829a48523$export$c106dd0671a0fc2d(`${backendName} backend was already registered. ` + `Reusing existing backend factory.`);
            return false;
        }
        this.registryFactory[backendName] = {
            factory: factory,
            priority: priority
        };
        return true;
    }
    async setBackend(backendName) {
        if (this.registryFactory[backendName] == null) throw new Error(`Backend name '${backendName}' not found in registry`);
        this.backendName = backendName;
        if (this.registry[backendName] == null) {
            this.backendInstance = null;
            const { success: success , asyncInit: asyncInit  } = this.initializeBackend(backendName);
            const result = asyncInit ? await success : success;
            if (!result) return false;
        }
        this.backendInstance = this.registry[backendName];
        this.setupRegisteredKernels();
        // Reset the profiler.
        this.profiler = new $544508912355211a$export$e2c29f18771995cb(this.backendInstance);
        return true;
    }
    setupRegisteredKernels() {
        const kernels = $18a84b897e201316$export$e4b8d76e176eaecc(this.backendName);
        kernels.forEach((kernel)=>{
            if (kernel.setupFunc != null) kernel.setupFunc(this.backendInstance);
        });
    }
    disposeRegisteredKernels(backendName) {
        const kernels = $18a84b897e201316$export$e4b8d76e176eaecc(backendName);
        kernels.forEach((kernel)=>{
            if (kernel.disposeFunc != null) kernel.disposeFunc(this.registry[backendName]);
        });
    }
    /**
     * Initializes a backend by looking up the backend name in the factory
     * registry and calling the factory method. Returns a boolean representing
     * whether the initialization of the backend suceeded. Throws an error if
     * there is no backend in the factory registry.
     */ initializeBackend(backendName) {
        const registryFactoryEntry = this.registryFactory[backendName];
        if (registryFactoryEntry == null) throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
        try {
            const backend = registryFactoryEntry.factory();
            /* Test if the factory returns a promise.
            Done in a more liberal way than
            previous 'Promise.resolve(backend)===backend'
            as we needed to account for custom Promise
            implementations (e.g. Angular) */ if (backend && !(backend instanceof $fc3e518cb31152af$export$543916c62202b50a) && typeof backend.then === 'function') {
                const promiseId = ++this.pendingBackendInitId;
                const success = backend.then((backendInstance)=>{
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) return false;
                    this.registry[backendName] = backendInstance;
                    this.pendingBackendInit = null;
                    return true;
                }).catch((err)=>{
                    // Outdated promise. Another backend was set in the meantime.
                    if (promiseId < this.pendingBackendInitId) return false;
                    this.pendingBackendInit = null;
                    $35abfa9829a48523$export$c106dd0671a0fc2d(`Initialization of backend ${backendName} failed`);
                    $35abfa9829a48523$export$c106dd0671a0fc2d(err.stack || err.message);
                    return false;
                });
                this.pendingBackendInit = success;
                return {
                    success: success,
                    asyncInit: true
                };
            } else {
                this.registry[backendName] = backend;
                return {
                    success: true,
                    asyncInit: false
                };
            }
        } catch (err) {
            $35abfa9829a48523$export$c106dd0671a0fc2d(`Initialization of backend ${backendName} failed`);
            $35abfa9829a48523$export$c106dd0671a0fc2d(err.stack || err.message);
            return {
                success: false,
                asyncInit: false
            };
        }
    }
    removeBackend(backendName) {
        if (!(backendName in this.registryFactory)) throw new Error(`${backendName} backend not found in registry`);
        if (this.backendName === backendName && this.pendingBackendInit != null) // There is a pending promise of the backend we want to remove. Make it
        // obsolete.
        this.pendingBackendInitId++;
        if (backendName in this.registry) {
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        delete this.registryFactory[backendName];
        // Unset the backend if it is active.
        if (this.backendName === backendName) {
            this.pendingBackendInit = null;
            this.backendName = null;
            this.backendInstance = null;
        }
    }
    getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) throw new Error('No backend found in registry.');
        return Object.keys(this.registryFactory).sort((a, b)=>{
            // Highest priority comes first.
            return this.registryFactory[b].priority - this.registryFactory[a].priority;
        });
    }
    initializeBackendsAndReturnBest() {
        const sortedBackends = this.getSortedBackends();
        for(let i = 0; i < sortedBackends.length; i++){
            const backendName = sortedBackends[i];
            const { success: success , asyncInit: asyncInit  } = this.initializeBackend(backendName);
            if (asyncInit || success) return {
                name: backendName,
                asyncInit: asyncInit
            };
        }
        throw new Error(`Could not initialize any backends, all backend initializations ` + `failed.`);
    }
    moveData(backend, dataId) {
        const info = this.state.tensorInfo.get(dataId);
        const srcBackend = info.backend;
        const values = this.readSync(dataId);
        const refCount = srcBackend.refCount(dataId);
        // Delete the tensor from the old backend and move it to the new
        // backend.
        srcBackend.disposeData(dataId, true);
        info.backend = backend;
        backend.move(dataId, values, info.shape, info.dtype, refCount);
        if (this.shouldCheckForMemLeaks()) // Track the number of moves during a kernel execution to correctly
        // detect memory leaks.
        this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(nameOrFn, fn) {
        let name = null;
        if (fn == null) {
            // Called with only 1 argument.
            if (typeof nameOrFn !== 'function') throw new Error('Please provide a function to tidy()');
            fn = nameOrFn;
        } else {
            // Called with 2 arguments.
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
            if (typeof fn !== 'function') throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
            name = nameOrFn;
        // TODO(nsthorat,smilkov): Do operation logging and performance
        // profiling.
        }
        let result;
        return this.scopedRun(()=>this.startScope(name)
        , ()=>this.endScope(result)
        , ()=>{
            result = fn();
            if (result instanceof Promise) console.error('Cannot return a Promise inside of tidy.');
            return result;
        });
    }
    scopedRun(start, end, f) {
        start();
        try {
            const res = f();
            end();
            return res;
        } catch (ex) {
            end();
            throw ex;
        }
    }
    nextTensorId() {
        return $a6bde3769fa0d8b5$export$2c3b404bf3a77a1f.nextTensorId++;
    }
    nextVariableId() {
        return $a6bde3769fa0d8b5$export$2c3b404bf3a77a1f.nextVariableId++;
    }
    /**
     * This method is called instead of the public-facing tensor.clone() when
     * saving a tensor for backwards pass. It makes sure to add the clone
     * operation to the tape regardless of being called inside a kernel
     * execution.
     */ clone(x) {
        const y = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$544bf02140fa9a77, {
            x: x
        });
        const inputs = {
            x: x
        };
        const grad = (dy)=>({
                x: ()=>{
                    const dtype = 'float32';
                    const gradInputs = {
                        x: dy
                    };
                    const attrs = {
                        dtype: dtype
                    };
                    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$107ecfb3d1ccbd77, gradInputs, // tslint:disable-next-line: no-unnecessary-type-assertion
                    attrs);
                }
            })
        ;
        const saved = [];
        this.addTapeNode(this.state.activeScope.name, inputs, [
            y
        ], grad, saved, {});
        return y;
    }
    /**
     * Execute a kernel with the given name and return the output tensor.
     *
     * @param kernelName The name of the kernel to execute.
     * @param inputs A map of input names to tensors.
     * @param attrs A map of attribute names to their values. An attribute is a
     *     primitive (non-tensor) input to the kernel.
     * @param inputsToSave A list of tensors, inputs to save for the backprop
     *     computation.
     * @param outputsToSave A list of booleans, specifying which output to save
     *     for the backprop computation. These are booleans since the output
     * tensors are not visible to the user.
     */ runKernel(kernelName, inputs, attrs) {
        if (this.backendName == null) // backend has not been initialized yet (backend initialization is lazy
        // can be deferred until an op/ kernel is run).
        // The below getter has side effects that will try to initialize the
        // backend and set properties like this.backendName
        // tslint:disable-next-line: no-unused-expression
        this.backend;
        const hasKernel = $18a84b897e201316$export$1b85808c967cc434(kernelName, this.backendName) != null;
        if (!hasKernel) throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
        return this.runKernelFunc({
            kernelName: kernelName,
            inputs: inputs,
            attrs: attrs
        });
    }
    shouldCheckForMemLeaks() {
        return this.ENV.getBool('IS_TEST');
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
        const numDataIdsAfter = this.backend.numDataIds();
        // Count the number of data ids associated with the result of the kernel.
        let numOutputDataIds = 0;
        outInfos.forEach((info)=>{
            // Complex numbers allocate 3 data ids, one for 'real', one for
            // 'imaginary', and one for the container that holds the former two.
            numOutputDataIds += info.dtype === 'complex64' ? 3 : 1;
        });
        // Account for the number of moves during kernel execution. A "data move"
        // can happen in the middle of a kernel execution, placing a new (key,value)
        // pair in the data storage. Since data moves have net zero effect (we
        // always remove the data from the old backend), we have to cancel them out
        // when detecting memory leaks.
        const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
        const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
        if (dataIdsLeaked > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak ` + `(${dataIdsLeaked} data ids) after running '${kernelName}'`);
    }
    /**
     * Internal helper method to execute a kernel Func
     *
     * Use `runKernel` to execute kernels from outside of engine.
     */ runKernelFunc(kernelParams) {
        let outputs;
        let saved = [];
        const isTapeOn = this.isTapeOn();
        const startingBytecount = this.state.numBytes;
        const startingNumTensors = this.state.numTensors;
        if (this.shouldCheckForMemLeaks()) this.state.numDataMovesStack.push(0);
        let kernelFunc;
        if (this.backendName == null) // backend has not been initialized yet (backend initialization is lazy
        // can be deferred until an op/ kernel is run).
        // The below getter has side effects that will try to initialize the
        // backend and set properties like this.backendName
        // tslint:disable-next-line: no-unused-expression
        this.backend;
        let out;
        const kernelOrScopeName = $a6bde3769fa0d8b5$var$isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : '';
        // Create the kernelFunc from either a registered kernel OR passed in
        // forward/backward functions (used by custom grad). In this context a
        // kernelFunc wraps a kernel implementation with some bookkeeping.
        if ($a6bde3769fa0d8b5$var$isRegisteredKernelInvocation(kernelParams)) {
            const { kernelName: kernelName , inputs: inputs , attrs: attrs  } = kernelParams;
            if (this.backendName == null) // backend has not been initialized yet (backend initialization is lazy
            // can be deferred until an op/ kernel is run).
            // The below getter has side effects that will try to initialize the
            // backend and set properties like this.backendName
            // tslint:disable-next-line: no-unused-expression
            this.backend;
            const kernel = $18a84b897e201316$export$1b85808c967cc434(kernelName, this.backendName);
            $904921ed29eeae0f$export$a7a9523472993e97(kernel != null, ()=>`Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`
            );
            kernelFunc = ()=>{
                const numDataIdsBefore = this.backend.numDataIds();
                out = kernel.kernelFunc({
                    inputs: inputs,
                    attrs: attrs,
                    backend: this.backend
                });
                const outInfos = Array.isArray(out) ? out : [
                    out
                ];
                if (this.shouldCheckForMemLeaks()) this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
                const outTensors = outInfos.map((outInfo)=>{
                    // todo (yassogba) remove this option (Tensor) when node backend
                    // methods have been modularized and they all return tensorInfo.
                    // TensorInfos do not have a rank attribute.
                    if (outInfo.rank != null) return outInfo;
                    const { dataId: dataId , shape: shape , dtype: dtype  } = outInfo;
                    return this.makeTensorFromDataId(dataId, shape, dtype);
                });
                // Save any required inputs and outputs.
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since there would be no backprop for these tensors
                // (which would otherwise dispose them).
                if (isTapeOn) {
                    const tensorsToSave = this.getTensorsForGradient(kernelName, inputs, outTensors);
                    saved = this.saveTensorsForBackwardMode(tensorsToSave);
                }
                return outTensors;
            };
        } else {
            const { forwardFunc: forwardFunc  } = kernelParams;
            // Running a customGrad op.
            const saveFunc = (tensors)=>{
                // Do not save unless we are recording to the tape. Otherwise it would
                // cause a mem leak since we would never run backprop, which disposes
                // the kept tensors.
                if (!isTapeOn) return;
                saved = tensors.map((tensor)=>this.keep(this.clone(tensor))
                );
            };
            kernelFunc = ()=>{
                const numDataIdsBefore = this.backend.numDataIds();
                out = this.tidy(()=>forwardFunc(this.backend, saveFunc)
                );
                const outs = Array.isArray(out) ? out : [
                    out
                ];
                if (this.shouldCheckForMemLeaks()) // Scope name is used to print a more helpful error message if needed.
                this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
                return outs;
            };
        }
        //
        // Run the kernelFunc. Optionally profiling it.
        //
        const { inputs: inputs , attrs: attrs  } = kernelParams;
        const backwardsFunc = $a6bde3769fa0d8b5$var$isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
        let kernelProfile;
        this.scopedRun(// Stop recording to a tape when running a kernel.
        ()=>this.state.kernelDepth++
        , ()=>this.state.kernelDepth--
        , ()=>{
            if (!this.ENV.getBool('DEBUG') && !this.state.profiling) outputs = kernelFunc();
            else {
                kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, ()=>kernelFunc()
                );
                if (this.ENV.getBool('DEBUG')) this.profiler.logKernelProfile(kernelProfile);
                outputs = kernelProfile.outputs;
            }
        });
        if (isTapeOn) this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
        if (this.state.profiling) this.state.activeProfile.kernels.push({
            name: kernelOrScopeName,
            bytesAdded: this.state.numBytes - startingBytecount,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - startingNumTensors,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(inputs).map((key)=>inputs[key] != null ? inputs[key].shape : null
            ),
            outputShapes: outputs.map((item)=>item.shape
            ),
            kernelTimeMs: kernelProfile.timeMs,
            extraInfo: kernelProfile.extraInfo
        });
        return Array.isArray(out) ? outputs : outputs[0];
    }
    /**
     * Saves tensors used in forward mode for use in backward mode.
     *
     * @param tensors the list of tensors to save.
     */ saveTensorsForBackwardMode(tensors) {
        const saved = tensors.map((tensor)=>this.keep(this.clone(tensor))
        );
        return saved;
    }
    /**
     * Returns a list of tensors to save for a given gradient calculation.
     *
     * @param kernelName name of kernel to look up gradient for.
     * @param inputs a map of input tensors.
     * @param outputs an array of output tensors from forward mode of kernel.
     */ getTensorsForGradient(kernelName, inputs, outputs) {
        const gradConfig = $18a84b897e201316$export$e14995d3ec1747ee(kernelName);
        if (gradConfig != null) {
            const inputsToSave = gradConfig.inputsToSave || [];
            const outputsToSave = gradConfig.outputsToSave || [];
            // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs
            // specified in inputsToSave will be saved.
            let inputTensorsToSave;
            if (gradConfig.saveAllInputs) {
                $904921ed29eeae0f$export$a7a9523472993e97(Array.isArray(inputs), ()=>'saveAllInputs is true, expected inputs to be an array.'
                );
                inputTensorsToSave = Object.keys(inputs).map((key)=>inputs[key]
                );
            } else inputTensorsToSave = inputsToSave.map((inputName)=>inputs[inputName]
            );
            const outputTensorsToSave = outputs.filter((_, i)=>outputsToSave[i]
            );
            return inputTensorsToSave.concat(outputTensorsToSave);
        }
        // We return an empty list rather than throw an error because the kernel we
        // are looking up may not actually be relevant to backproping through the
        // overall function
        //
        // See 'does not error if irrelevant (pruned) ops are missing grads' test
        // in gradients_test.ts for an example.
        return [];
    }
    /**
     * Internal method used by public APIs for tensor creation. Makes a new
     * tensor with the provided shape, dtype and values. It always
     * creates a new data id and writes the values to the underlying backend.
     */ makeTensor(values, shape, dtype, backend) {
        if (values == null) throw new Error('Values passed to engine.makeTensor() are null');
        dtype = dtype || 'float32';
        backend = backend || this.backend;
        let backendVals = values;
        if (dtype === 'string' && $904921ed29eeae0f$export$844ec244b1367d54(values[0])) backendVals = values.map((d)=>$f6b55a2021b78f0d$export$8146d2e653b87d6a(d)
        );
        const dataId = backend.write(backendVals, shape, dtype);
        const t = new $c341eb4171cc0419$export$7b6b8d90402f8814(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        // Count bytes for string tensors.
        if (dtype === 'string') {
            const info = this.state.tensorInfo.get(dataId);
            const newBytes = $904921ed29eeae0f$export$c474902e1102282d(backendVals);
            this.state.numBytes += newBytes - info.bytes;
            info.bytes = newBytes;
        }
        return t;
    }
    /**
     * Internal method used by backends. Makes a new tensor
     * that is a wrapper around an existing data id. It doesn't create
     * a new data id, only increments the ref count used in memory tracking.
     */ makeTensorFromDataId(dataId, shape, dtype, backend) {
        dtype = dtype || 'float32';
        const t = new $c341eb4171cc0419$export$7b6b8d90402f8814(shape, dtype, dataId, this.nextTensorId());
        this.trackTensor(t, backend);
        return t;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
        name = name || this.nextVariableId().toString();
        if (dtype != null && dtype !== initialValue.dtype) initialValue = initialValue.cast(dtype);
        const v = new $c341eb4171cc0419$export$c867a5c9595a1350(initialValue, trainable, name, this.nextTensorId());
        if (this.state.registeredVariables[v.name] != null) throw new Error(`Variable with name ${v.name} was already registered`);
        this.state.registeredVariables[v.name] = v;
        this.incRef(v, this.backend);
        return v;
    }
    trackTensor(a, backend) {
        this.state.numTensors++;
        if (a.dtype === 'string') this.state.numStringTensors++;
        // Bytes for complex numbers are counted by their components. Bytes for
        // string tensors are counted when writing values.
        let bytes = 0;
        if (a.dtype !== 'complex64' && a.dtype !== 'string') bytes = a.size * $904921ed29eeae0f$export$3f355ce86503b89f(a.dtype);
        this.state.numBytes += bytes;
        if (!this.state.tensorInfo.has(a.dataId)) {
            this.state.numDataBuffers++;
            this.state.tensorInfo.set(a.dataId, {
                backend: backend || this.backend,
                dtype: a.dtype,
                shape: a.shape,
                bytes: bytes
            });
        }
        if (!(a instanceof $c341eb4171cc0419$export$c867a5c9595a1350)) this.track(a);
    }
    // Track the tensor by dataId and increase the refCount for the dataId in the
    // backend.
    // TODO(pyu10055): This is currently used by makeVariable method, to increase
    // refCount on the backend for the dataId. It can potentially be replaced with
    // Identity op indead of calling backend directly.
    incRef(a, backend) {
        this.trackTensor(a, backend);
        this.backend.incRef(a.dataId);
    }
    removeDataId(dataId, backend) {
        if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend) {
            this.state.tensorInfo.delete(dataId);
            this.state.numDataBuffers--;
        }
    }
    disposeTensor(a) {
        if (!this.state.tensorInfo.has(a.dataId)) return;
        const info = this.state.tensorInfo.get(a.dataId);
        this.state.numTensors--;
        if (a.dtype === 'string') {
            this.state.numStringTensors--;
            this.state.numBytes -= info.bytes;
        }
        // Don't count bytes for complex numbers as they are counted by their
        // components.
        if (a.dtype !== 'complex64' && a.dtype !== 'string') {
            const bytes = a.size * $904921ed29eeae0f$export$3f355ce86503b89f(a.dtype);
            this.state.numBytes -= bytes;
        }
        // Remove the reference to dataId if backend dispose the data successfully
        if (info.backend.disposeData(a.dataId)) this.removeDataId(a.dataId, info.backend);
    // TODO(nsthorat): Construct an error and save the stack trace for
    // debugging when in debug mode. Creating a stack trace is too expensive
    // to do unconditionally.
    }
    disposeVariables() {
        for(const varName in this.state.registeredVariables){
            const v = this.state.registeredVariables[varName];
            this.disposeVariable(v);
        }
    }
    disposeVariable(v) {
        this.disposeTensor(v);
        if (this.state.registeredVariables[v.name] != null) delete this.state.registeredVariables[v.name];
    }
    memory() {
        const info = this.backend.memory();
        info.numTensors = this.state.numTensors;
        info.numDataBuffers = this.state.numDataBuffers;
        info.numBytes = this.state.numBytes;
        if (this.state.numStringTensors > 0) {
            info.unreliable = true;
            if (info.reasons == null) info.reasons = [];
            info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
        }
        return info;
    }
    async profile(query) {
        this.state.profiling = true;
        const startBytes = this.state.numBytes;
        const startNumTensors = this.state.numTensors;
        this.state.activeProfile.kernels = [];
        this.state.activeProfile.result = await query();
        this.state.profiling = false;
        this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d)=>d.totalBytesSnapshot
        ));
        this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
        this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
        for (const kernel of this.state.activeProfile.kernels){
            kernel.kernelTimeMs = await kernel.kernelTimeMs;
            kernel.extraInfo = await kernel.extraInfo;
        }
        return this.state.activeProfile;
    }
    isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
        const tapeNode = {
            id: this.state.nextTapeNodeId++,
            kernelName: kernelName,
            inputs: inputs,
            outputs: outputs,
            saved: saved
        };
        const gradConfig = $18a84b897e201316$export$e14995d3ec1747ee(kernelName);
        if (gradConfig != null) gradientsFunc = gradConfig.gradFunc;
        if (gradientsFunc != null) tapeNode.gradient = (dys)=>{
            // TODO(smilkov): To optimize back-prop, pass dys that are not used in
            // the backprop graph to the user as null instead of zeros
            dys = dys.map((dy, i)=>{
                if (dy == null) {
                    const output = outputs[i];
                    const vals = $904921ed29eeae0f$export$edbc8aedac4e036f(output.size, output.dtype);
                    return this.makeTensor(vals, output.shape, output.dtype);
                }
                return dy;
            });
            // Grad functions of ops with single outputs expect a dy, while ops
            // with multiple outputs expect dys (array of dy).
            return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
        };
        this.state.activeTape.push(tapeNode);
    }
    keep(result) {
        result.kept = true;
        return result;
    }
    startTape() {
        if (this.state.gradientDepth === 0) this.state.activeTape = [];
        this.state.gradientDepth++;
    }
    endTape() {
        this.state.gradientDepth--;
    }
    /**
     * Start a scope. Use this with endScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */ startScope(name) {
        const scopeInfo = {
            track: [],
            name: 'unnamed scope',
            id: this.state.nextScopeId++
        };
        if (name) scopeInfo.name = name;
        this.state.scopeStack.push(scopeInfo);
        this.state.activeScope = scopeInfo;
    }
    /**
     * End a scope. Use this with startScope() to achieve the same functionality
     * as scope() without the need for a function closure.
     */ endScope(result) {
        const tensorsToTrackInParent = $f5b489dcdac9fd38$export$888c106d343989f5(result);
        const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t)=>t.id
        ));
        // Dispose the arrays tracked in this scope.
        for(let i = 0; i < this.state.activeScope.track.length; i++){
            const tensor = this.state.activeScope.track[i];
            if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) tensor.dispose();
        }
        const oldScope = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
        // Track the current result in the parent scope.
        tensorsToTrackInParent.forEach((tensor)=>{
            // Only track the tensor if was allocated in the inner scope and is not
            // globally kept.
            if (!tensor.kept && tensor.scopeId === oldScope.id) this.track(tensor);
        });
    }
    /**
     * Returns gradients of `f` with respect to each of the `xs`. The gradients
     * returned are of the same length as `xs`, but some might be null if `f`
     * was not a function of that `x`. It also takes optional dy to multiply the
     * gradient, which defaults to `1`.
     */ gradients(f1, xs, dy, allowNoGradients = false) {
        $904921ed29eeae0f$export$a7a9523472993e97(xs.length > 0, ()=>'gradients() received an empty list of xs.'
        );
        if (dy != null && dy.dtype !== 'float32') throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
        const y = this.scopedRun(()=>this.startTape()
        , ()=>this.endTape()
        , ()=>this.tidy('forward', f1)
        );
        $904921ed29eeae0f$export$a7a9523472993e97(y instanceof $c341eb4171cc0419$export$7b6b8d90402f8814, ()=>'The result y returned by f() must be a tensor.'
        );
        // Filter out the nodes that don't connect x => y.
        const filteredTape = $2931d251acbb4515$export$13eebbb952f0db02(this.state.activeTape, xs, y);
        if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy('backward', ()=>{
            const accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = dy == null ? $a6bde3769fa0d8b5$var$ones(y.shape) : dy;
            // Backprop gradients through the filtered nodes.
            $2931d251acbb4515$export$2992958ba0a8790d(accumulatedGradientMap, filteredTape, // Pass the tidy function to avoid circular dep with `tape.ts`.
            (f)=>this.tidy(f)
            , // Pass an add function to avoide a circular dep with `tape.ts`.
            $a6bde3769fa0d8b5$export$e16d8520af44a096);
            const grads = xs.map((x)=>accumulatedGradientMap[x.id]
            );
            if (this.state.gradientDepth === 0) {
                // This means that we are not computing higher-order gradients
                // and can clean up the tape.
                this.state.activeTape.forEach((node)=>{
                    for (const tensor of node.saved)tensor.dispose();
                });
                this.state.activeTape = null;
            }
            return {
                value: y,
                grads: grads
            };
        });
    }
    customGrad(f) {
        $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in customGrad(f) must be a function.'
        );
        return (...inputs)=>{
            $904921ed29eeae0f$export$a7a9523472993e97(inputs.every((t)=>t instanceof $c341eb4171cc0419$export$7b6b8d90402f8814
            ), ()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"
            );
            let res;
            const inputMap = {};
            inputs.forEach((input, i)=>{
                inputMap[i] = input;
            });
            const forwardFunc = (_, save)=>{
                res = f(...[
                    ...inputs,
                    save
                ]);
                $904921ed29eeae0f$export$a7a9523472993e97(res.value instanceof $c341eb4171cc0419$export$7b6b8d90402f8814, ()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
                );
                $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(res.gradFunc), ()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
                );
                return res.value;
            };
            const backwardsFunc = (dy, saved)=>{
                const gradRes = res.gradFunc(dy, saved);
                const grads = Array.isArray(gradRes) ? gradRes : [
                    gradRes
                ];
                $904921ed29eeae0f$export$a7a9523472993e97(grads.length === inputs.length, ()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
                );
                $904921ed29eeae0f$export$a7a9523472993e97(grads.every((t)=>t instanceof $c341eb4171cc0419$export$7b6b8d90402f8814
                ), ()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
                );
                const gradMap = {};
                grads.forEach((grad, i)=>{
                    gradMap[i] = ()=>grad
                    ;
                });
                return gradMap;
            };
            return this.runKernelFunc({
                forwardFunc: forwardFunc,
                backwardsFunc: backwardsFunc,
                inputs: inputMap
            });
        };
    }
    readSync(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readSync(dataId);
    }
    read(dataId) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.read(dataId);
    }
    readToGPU(dataId, options) {
        // Route the read to the correct backend.
        const info = this.state.tensorInfo.get(dataId);
        return info.backend.readToGPU(dataId, options);
    }
    async time(query) {
        const start = $f6b55a2021b78f0d$export$461939dd4422153();
        const timingInfo = await this.backend.time(query);
        timingInfo.wallMs = $f6b55a2021b78f0d$export$461939dd4422153() - start;
        return timingInfo;
    }
    /**
     * Tracks a Tensor in the current scope to be automatically cleaned up
     * when the current scope ends, and returns the value.
     *
     * @param result The Tensor to track in the current scope.
     */ track(result) {
        if (this.state.activeScope != null) {
            result.scopeId = this.state.activeScope.id;
            this.state.activeScope.track.push(result);
        }
        return result;
    }
    get registeredVariables() {
        return this.state.registeredVariables;
    }
    /**
     * Resets the engine state. Removes all backends but does not remove
     * registered backend factories.
     */ reset() {
        // Make any pending promise obsolete.
        this.pendingBackendInitId++;
        this.state.dispose();
        this.ENV.reset();
        this.state = new $a6bde3769fa0d8b5$var$EngineState();
        for(const backendName in this.registry){
            this.disposeRegisteredKernels(backendName);
            this.registry[backendName].dispose();
            delete this.registry[backendName];
        }
        this.backendName = null;
        this.backendInstance = null;
        this.pendingBackendInit = null;
    }
}
$a6bde3769fa0d8b5$export$2c3b404bf3a77a1f.nextTensorId = 0;
$a6bde3769fa0d8b5$export$2c3b404bf3a77a1f.nextVariableId = 0;
function $a6bde3769fa0d8b5$var$ones(shape) {
    const values = $904921ed29eeae0f$export$b915f681a907ae99($904921ed29eeae0f$export$b4c3214a70a0e73f(shape), 'float32');
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.makeTensor(values, shape, 'float32');
}
function $a6bde3769fa0d8b5$export$ca8737f6c8c212b8() {
    const ns = $95bbaab90b583097$export$5054b240ae6849b7();
    if (ns._tfengine == null) {
        const environment = new $78e7329b437d1e00$export$7dc6752a22ab011a(ns);
        ns._tfengine = new $a6bde3769fa0d8b5$export$2c3b404bf3a77a1f(environment);
    }
    $78e7329b437d1e00$export$3ef32a49eeda04cc(ns._tfengine.ENV);
    // Tell the current tensor interface that the global engine is responsible
    // for tracking.
    $c341eb4171cc0419$export$b1e34d2f0ffbbd85(()=>ns._tfengine
    );
    return ns._tfengine;
}
const $a6bde3769fa0d8b5$export$33b63313cc511a3b = $a6bde3769fa0d8b5$export$ca8737f6c8c212b8();
function $a6bde3769fa0d8b5$export$e16d8520af44a096(a, b) {
    // We duplicate Add here to avoid a circular dependency with add.ts.
    const inputs = {
        a: a,
        b: b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d0265b2c425512d6, inputs);
}



var $20e2f2a589b22510$exports = {};

$parcel$export($20e2f2a589b22510$exports, "mockIsMobile", function () { return $20e2f2a589b22510$export$f55f7bd5cb259cb2; });
$parcel$export($20e2f2a589b22510$exports, "isMobile", function () { return $20e2f2a589b22510$export$d0a8044dce8ff2fc; });
$parcel$export($20e2f2a589b22510$exports, "isBrowser", function () { return $20e2f2a589b22510$export$4e09c449d6c407f7; });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ // tslint:disable-next-line:no-any
function $20e2f2a589b22510$var$_isNavigatorDefined() {
    return typeof navigator !== 'undefined' && navigator != null;
}
let $20e2f2a589b22510$var$isMobileMockValue;
function $20e2f2a589b22510$export$f55f7bd5cb259cb2(value) {
    $20e2f2a589b22510$var$isMobileMockValue = value;
}
function $20e2f2a589b22510$export$d0a8044dce8ff2fc(nav) {
    if ($20e2f2a589b22510$var$isMobileMockValue !== undefined) return $20e2f2a589b22510$var$isMobileMockValue;
    if (nav || $20e2f2a589b22510$var$_isNavigatorDefined()) {
        if (!nav) nav = navigator;
        if (nav.product === 'ReactNative') return true;
        const a = nav.userAgent || nav.vendor || (typeof window !== 'undefined' ? window.opera : '');
        // Use `navigator.userAgentData.mobile` as fallback.
        if (!a) {
            // tslint:disable-next-line:no-any
            const navAny = nav;
            return navAny.userAgentData && navAny.userAgentData.mobile;
        }
        // tslint:disable-next-line:max-line-length
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || // tslint:disable-next-line:max-line-length
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
    }
    return false;
}
function $20e2f2a589b22510$export$4e09c449d6c407f7() {
    return typeof window !== 'undefined' && window.document != null || typeof WorkerGlobalScope !== 'undefined';
}




var $3tEm6 = parcelRequire("3tEm6");
const $e98bee10b3e286ee$var$ENV = $78e7329b437d1e00$export$a7b6bc01c63cdfc3();
/**
 * This file contains environment-related flag registrations.
 */ /** Whether to enable debug mode. */ $e98bee10b3e286ee$var$ENV.registerFlag('DEBUG', ()=>false
, (debugValue)=>{
    if (debugValue) console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
});
/** Whether we are in a browser (as versus, say, node.js) environment. */ $e98bee10b3e286ee$var$ENV.registerFlag('IS_BROWSER', ()=>$20e2f2a589b22510$export$4e09c449d6c407f7()
);
/** Whether we are in a browser (as versus, say, node.js) environment. */ $e98bee10b3e286ee$var$ENV.registerFlag('IS_NODE', ()=>typeof $3tEm6 !== 'undefined' && typeof $3tEm6.versions !== 'undefined' && typeof $3tEm6.versions.node !== 'undefined'
);
/** Whether this browser is Chrome. */ $e98bee10b3e286ee$var$ENV.registerFlag('IS_CHROME', ()=>typeof navigator !== 'undefined' && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
);
/**
 * True when the environment is "production" where we disable safety checks
 * to gain performance.
 */ $e98bee10b3e286ee$var$ENV.registerFlag('PROD', ()=>false
);
/**
 * Whether to do sanity checks when inferring a shape from user-provided
 * values, used when creating a new tensor.
 */ $e98bee10b3e286ee$var$ENV.registerFlag('TENSORLIKE_CHECK_SHAPE_CONSISTENCY', ()=>$e98bee10b3e286ee$var$ENV.getBool('DEBUG')
);
/** Whether deprecation warnings are enabled. */ $e98bee10b3e286ee$var$ENV.registerFlag('DEPRECATION_WARNINGS_ENABLED', ()=>true
);
/** True if running unit tests. */ $e98bee10b3e286ee$var$ENV.registerFlag('IS_TEST', ()=>false
);
/** Whether to check computation result for errors. */ $e98bee10b3e286ee$var$ENV.registerFlag('CHECK_COMPUTATION_FOR_ERRORS', ()=>true
);
/** Whether the backend needs to wrap input to imageBitmap. */ $e98bee10b3e286ee$var$ENV.registerFlag('WRAP_TO_IMAGEBITMAP', ()=>false
);
/** Experimental flag, whether enter compile only phase. */ $e98bee10b3e286ee$var$ENV.registerFlag('ENGINE_COMPILE_ONLY', ()=>false
);












function $d7ebc35f1f4a180c$export$467a8ad638b9ad20(val, dtype) {
    let firstElem = val;
    if ($904921ed29eeae0f$export$b119cc7e1840e59c(val)) return dtype === 'string' ? [] : [
        val.length
    ];
    if (!Array.isArray(val)) return []; // Scalar.
    const shape = [];
    while(Array.isArray(firstElem) || $904921ed29eeae0f$export$b119cc7e1840e59c(firstElem) && dtype !== 'string'){
        shape.push(firstElem.length);
        firstElem = firstElem[0];
    }
    if (Array.isArray(val) && $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) $d7ebc35f1f4a180c$var$deepAssertShapeConsistency(val, shape, []);
    return shape;
}
function $d7ebc35f1f4a180c$var$deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!Array.isArray(val) && !$904921ed29eeae0f$export$b119cc7e1840e59c(val)) {
        $904921ed29eeae0f$export$a7a9523472993e97(shape.length === 0, ()=>`Element arr[${indices.join('][')}] is a primitive, ` + `but should be an array/TypedArray of ${shape[0]} elements`
        );
        return;
    }
    $904921ed29eeae0f$export$a7a9523472993e97(shape.length > 0, ()=>`Element arr[${indices.join('][')}] should be a primitive, ` + `but is an array of ${val.length} elements`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(val.length === shape[0], ()=>`Element arr[${indices.join('][')}] should have ${shape[0]} ` + `elements, but has ${val.length} elements`
    );
    const subShape = shape.slice(1);
    for(let i = 0; i < val.length; ++i)$d7ebc35f1f4a180c$var$deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
}
function $d7ebc35f1f4a180c$var$assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === 'string_or_numeric') return;
    if (expectedDtype == null) throw new Error(`Expected dtype cannot be null.`);
    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType || expectedDtype === 'numeric' && actualDType === 'string') throw new Error(`Argument '${argName}' passed to '${functionName}' must ` + `be ${expectedDtype} tensor, but got ${actualDType} tensor`);
}
function $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, argName, functionName, parseAsDtype = 'numeric') {
    if (x instanceof $c341eb4171cc0419$export$7b6b8d90402f8814) {
        $d7ebc35f1f4a180c$var$assertDtype(parseAsDtype, x.dtype, argName, functionName);
        return x;
    }
    let inferredDtype = $904921ed29eeae0f$export$2005775d905d2dc2(x);
    // If the user expects a bool/int/float, use that info to update the
    // inferredDtype when it is not a string.
    if (inferredDtype !== 'string' && [
        'bool',
        'int32',
        'float32'
    ].indexOf(parseAsDtype) >= 0) inferredDtype = parseAsDtype;
    $d7ebc35f1f4a180c$var$assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if (x == null || !$904921ed29eeae0f$export$b119cc7e1840e59c(x) && !Array.isArray(x) && typeof x !== 'number' && typeof x !== 'boolean' && typeof x !== 'string') {
        const type = x == null ? 'null' : x.constructor.name;
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` + `Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = $d7ebc35f1f4a180c$export$467a8ad638b9ad20(x, inferredDtype);
    if (!$904921ed29eeae0f$export$b119cc7e1840e59c(x) && !Array.isArray(x)) x = [
        x
    ];
    const skipTypedArray = true;
    const values = inferredDtype !== 'string' ? $f6b55a2021b78f0d$export$965adc581230795c(x, inferredDtype) : $904921ed29eeae0f$export$bffa455ba8c619a6(x, [], skipTypedArray);
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.makeTensor(values, inferredShape, inferredDtype);
}
function $d7ebc35f1f4a180c$export$758e66616b4d410b(arg, argName, functionName, parseAsDtype = 'numeric') {
    if (!Array.isArray(arg)) throw new Error(`Argument ${argName} passed to ${functionName} must be a ` + '`Tensor[]` or `TensorLike[]`');
    const tensors = arg;
    return tensors.map((t, i)=>$d7ebc35f1f4a180c$export$ede379c4c939d71a(t, `${argName}[${i}]`, functionName, parseAsDtype)
    );
}





const $9e60b70ce0353b32$export$93114f1494faf9bb = '__op';
function $9e60b70ce0353b32$export$f59964a629598e2(f) {
    const keys = Object.keys(f);
    if (keys.length !== 1) throw new Error(`Please provide an object with a single key ` + `(operation name) mapping to a function. Got an object with ` + `${keys.length} keys.`);
    let opName = keys[0];
    const fn = f[opName];
    // Strip the underscore from the end of the function name.
    if (opName.endsWith('_')) opName = opName.substring(0, opName.length - 1);
    // add an __op suffix to distinguish ops from kernels in tf.profile
    opName = opName + $9e60b70ce0353b32$export$93114f1494faf9bb;
    // tslint:disable-next-line:no-any
    const f2 = (...args)=>{
        $a6bde3769fa0d8b5$export$33b63313cc511a3b.startScope(opName);
        try {
            const result = fn(...args);
            if ($904921ed29eeae0f$export$4369c812aac99591(result)) console.error('Cannot return a Promise inside of tidy.');
            $a6bde3769fa0d8b5$export$33b63313cc511a3b.endScope(result);
            return result;
        } catch (ex) {
            $a6bde3769fa0d8b5$export$33b63313cc511a3b.endScope(null);
            throw ex;
        }
    };
    Object.defineProperty(f2, 'name', {
        value: opName,
        configurable: true
    });
    // tslint:disable-next-line:no-any
    return f2;
}


/**
 * Converts two real numbers to a complex number.
 *
 * Given a tensor `real` representing the real part of a complex number, and a
 * tensor `imag` representing the imaginary part of a complex number, this
 * operation returns complex numbers elementwise of the form [r0, i0, r1, i1],
 * where r represents the real part and i represents the imag part.
 *
 * The input tensors real and imag must have the same shape.
 *
 * ```js
 * const real = tf.tensor1d([2.25, 3.25]);
 * const imag = tf.tensor1d([4.75, 5.75]);
 * const complex = tf.complex(real, imag);
 *
 * complex.print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $b2f39045a9ff3425$var$complex_(real, imag) {
    const $real = $d7ebc35f1f4a180c$export$ede379c4c939d71a(real, 'real', 'complex');
    const $imag = $d7ebc35f1f4a180c$export$ede379c4c939d71a(imag, 'imag', 'complex');
    $904921ed29eeae0f$export$e08b27e7f37e2782($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, ` + `must match in call to tf.complex().`);
    const inputs = {
        real: $real,
        imag: $imag
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$50ceb3fb9926e63e, inputs);
}
const $b2f39045a9ff3425$export$83a0e34f1302825b = $9e60b70ce0353b32$export$f59964a629598e2({
    complex_: $b2f39045a9ff3425$var$complex_
});





function $ca9108fe9b0ad943$export$f41686c891d7ebce(values, shape, inferredShape, dtype) {
    if (dtype == null) dtype = $904921ed29eeae0f$export$2005775d905d2dc2(values);
    if (dtype === 'complex64') throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);
    if (!$904921ed29eeae0f$export$b119cc7e1840e59c(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (shape != null) {
        $904921ed29eeae0f$export$3d8b7619bac22cf5(shape);
        const providedSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
        const inferredSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(inferredShape);
        $904921ed29eeae0f$export$a7a9523472993e97(providedSize === inferredSize, ()=>`Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`
        );
        for(let i = 0; i < inferredShape.length; ++i){
            const inferred = inferredShape[i];
            const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== $904921ed29eeae0f$export$b4c3214a70a0e73f(shape.slice(i)) : true;
            $904921ed29eeae0f$export$a7a9523472993e97(inferredShape[i] === shape[i] || !flatDimsDontMatch, ()=>`Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `
            );
        }
    }
    if (!$904921ed29eeae0f$export$b119cc7e1840e59c(values) && !Array.isArray(values)) values = [
        values
    ];
    shape = shape || inferredShape;
    values = dtype !== 'string' ? $f6b55a2021b78f0d$export$965adc581230795c(values, dtype) : $904921ed29eeae0f$export$bffa455ba8c619a6(values, [], true);
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.makeTensor(values, shape, dtype);
}


function $b61ddc0946231fbd$export$65df3ad1ad888abb(values, shape, dtype) {
    const inferredShape = $d7ebc35f1f4a180c$export$467a8ad638b9ad20(values, dtype);
    return $ca9108fe9b0ad943$export$f41686c891d7ebce(values, shape, inferredShape, dtype);
}



const $72b38f44e03c9113$export$8103dee73e5eaa46 = {
    'float32': 4,
    'float16': 2,
    'int32': 4,
    'uint16': 2,
    'uint8': 1,
    'bool': 1,
    'complex64': 8
};


var $24024ac79e1737d3$export$a143d493d941bafc;
var $24024ac79e1737d3$export$e4cf37d7f6fb9e0a;
var $24024ac79e1737d3$export$f99ded8fe4b79145;
var $24024ac79e1737d3$export$599f31c3813fae4d;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var $1606da4451f0ed63$export$a48f0734ac7c2329;
var $1606da4451f0ed63$export$d622b2ad8d90c771;
var $1606da4451f0ed63$export$6100ba28696e12de;
'use strict';
$1606da4451f0ed63$export$a48f0734ac7c2329 = $1606da4451f0ed63$var$byteLength;
$1606da4451f0ed63$export$d622b2ad8d90c771 = $1606da4451f0ed63$var$toByteArray;
$1606da4451f0ed63$export$6100ba28696e12de = $1606da4451f0ed63$var$fromByteArray;
var $1606da4451f0ed63$var$lookup = [];
var $1606da4451f0ed63$var$revLookup = [];
var $1606da4451f0ed63$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var $1606da4451f0ed63$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var $1606da4451f0ed63$var$i = 0, $1606da4451f0ed63$var$len = $1606da4451f0ed63$var$code.length; $1606da4451f0ed63$var$i < $1606da4451f0ed63$var$len; ++$1606da4451f0ed63$var$i){
    $1606da4451f0ed63$var$lookup[$1606da4451f0ed63$var$i] = $1606da4451f0ed63$var$code[$1606da4451f0ed63$var$i];
    $1606da4451f0ed63$var$revLookup[$1606da4451f0ed63$var$code.charCodeAt($1606da4451f0ed63$var$i)] = $1606da4451f0ed63$var$i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
$1606da4451f0ed63$var$revLookup['-'.charCodeAt(0)] = 62;
$1606da4451f0ed63$var$revLookup['_'.charCodeAt(0)] = 63;
function $1606da4451f0ed63$var$getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function $1606da4451f0ed63$var$byteLength(b64) {
    var lens = $1606da4451f0ed63$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $1606da4451f0ed63$var$_byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function $1606da4451f0ed63$var$toByteArray(b64) {
    var tmp;
    var lens = $1606da4451f0ed63$var$getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new $1606da4451f0ed63$var$Arr($1606da4451f0ed63$var$_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i)] << 18 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i)] << 2 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i)] << 10 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $1606da4451f0ed63$var$revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function $1606da4451f0ed63$var$tripletToBase64(num) {
    return $1606da4451f0ed63$var$lookup[num >> 18 & 0x3F] + $1606da4451f0ed63$var$lookup[num >> 12 & 0x3F] + $1606da4451f0ed63$var$lookup[num >> 6 & 0x3F] + $1606da4451f0ed63$var$lookup[num & 0x3F];
}
function $1606da4451f0ed63$var$encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push($1606da4451f0ed63$var$tripletToBase64(tmp));
    }
    return output.join('');
}
function $1606da4451f0ed63$var$fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($1606da4451f0ed63$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push($1606da4451f0ed63$var$lookup[tmp >> 2] + $1606da4451f0ed63$var$lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push($1606da4451f0ed63$var$lookup[tmp >> 10] + $1606da4451f0ed63$var$lookup[tmp >> 4 & 0x3F] + $1606da4451f0ed63$var$lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}


/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $dc2dc61742b7dd42$export$aafa59e2e03f2942;
var $dc2dc61742b7dd42$export$68d8715fc104d294;
$dc2dc61742b7dd42$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
$dc2dc61742b7dd42$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};


const $24024ac79e1737d3$var$customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
$24024ac79e1737d3$export$a143d493d941bafc = $24024ac79e1737d3$var$Buffer;
$24024ac79e1737d3$export$e4cf37d7f6fb9e0a = $24024ac79e1737d3$var$SlowBuffer;
$24024ac79e1737d3$export$f99ded8fe4b79145 = 50;
const $24024ac79e1737d3$var$K_MAX_LENGTH = 0x7fffffff;
$24024ac79e1737d3$export$599f31c3813fae4d = $24024ac79e1737d3$var$K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ $24024ac79e1737d3$var$Buffer.TYPED_ARRAY_SUPPORT = $24024ac79e1737d3$var$typedArraySupport();
if (!$24024ac79e1737d3$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function $24024ac79e1737d3$var$typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty($24024ac79e1737d3$var$Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!$24024ac79e1737d3$var$Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty($24024ac79e1737d3$var$Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!$24024ac79e1737d3$var$Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function $24024ac79e1737d3$var$createBuffer(length) {
    if (length > $24024ac79e1737d3$var$K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, $24024ac79e1737d3$var$Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function $24024ac79e1737d3$var$Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return $24024ac79e1737d3$var$allocUnsafe(arg);
    }
    return $24024ac79e1737d3$var$from(arg, encodingOrOffset, length);
}
$24024ac79e1737d3$var$Buffer.poolSize = 8192 // not used by this implementation
;
function $24024ac79e1737d3$var$from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return $24024ac79e1737d3$var$fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return $24024ac79e1737d3$var$fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if ($24024ac79e1737d3$var$isInstance(value, ArrayBuffer) || value && $24024ac79e1737d3$var$isInstance(value.buffer, ArrayBuffer)) return $24024ac79e1737d3$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && ($24024ac79e1737d3$var$isInstance(value, SharedArrayBuffer) || value && $24024ac79e1737d3$var$isInstance(value.buffer, SharedArrayBuffer))) return $24024ac79e1737d3$var$fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return $24024ac79e1737d3$var$Buffer.from(valueOf, encodingOrOffset, length);
    const b = $24024ac79e1737d3$var$fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return $24024ac79e1737d3$var$Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ $24024ac79e1737d3$var$Buffer.from = function(value, encodingOrOffset, length) {
    return $24024ac79e1737d3$var$from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf($24024ac79e1737d3$var$Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf($24024ac79e1737d3$var$Buffer, Uint8Array);
function $24024ac79e1737d3$var$assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function $24024ac79e1737d3$var$alloc(size, fill, encoding) {
    $24024ac79e1737d3$var$assertSize(size);
    if (size <= 0) return $24024ac79e1737d3$var$createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? $24024ac79e1737d3$var$createBuffer(size).fill(fill, encoding) : $24024ac79e1737d3$var$createBuffer(size).fill(fill);
    return $24024ac79e1737d3$var$createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ $24024ac79e1737d3$var$Buffer.alloc = function(size, fill, encoding) {
    return $24024ac79e1737d3$var$alloc(size, fill, encoding);
};
function $24024ac79e1737d3$var$allocUnsafe(size) {
    $24024ac79e1737d3$var$assertSize(size);
    return $24024ac79e1737d3$var$createBuffer(size < 0 ? 0 : $24024ac79e1737d3$var$checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ $24024ac79e1737d3$var$Buffer.allocUnsafe = function(size) {
    return $24024ac79e1737d3$var$allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ $24024ac79e1737d3$var$Buffer.allocUnsafeSlow = function(size) {
    return $24024ac79e1737d3$var$allocUnsafe(size);
};
function $24024ac79e1737d3$var$fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!$24024ac79e1737d3$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = $24024ac79e1737d3$var$byteLength(string, encoding) | 0;
    let buf = $24024ac79e1737d3$var$createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function $24024ac79e1737d3$var$fromArrayLike(array) {
    const length = array.length < 0 ? 0 : $24024ac79e1737d3$var$checked(array.length) | 0;
    const buf = $24024ac79e1737d3$var$createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function $24024ac79e1737d3$var$fromArrayView(arrayView) {
    if ($24024ac79e1737d3$var$isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return $24024ac79e1737d3$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return $24024ac79e1737d3$var$fromArrayLike(arrayView);
}
function $24024ac79e1737d3$var$fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, $24024ac79e1737d3$var$Buffer.prototype);
    return buf;
}
function $24024ac79e1737d3$var$fromObject(obj) {
    if ($24024ac79e1737d3$var$Buffer.isBuffer(obj)) {
        const len = $24024ac79e1737d3$var$checked(obj.length) | 0;
        const buf = $24024ac79e1737d3$var$createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || $24024ac79e1737d3$var$numberIsNaN(obj.length)) return $24024ac79e1737d3$var$createBuffer(0);
        return $24024ac79e1737d3$var$fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return $24024ac79e1737d3$var$fromArrayLike(obj.data);
}
function $24024ac79e1737d3$var$checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= $24024ac79e1737d3$var$K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $24024ac79e1737d3$var$K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function $24024ac79e1737d3$var$SlowBuffer(length) {
    if (+length != length) length = 0;
    return $24024ac79e1737d3$var$Buffer.alloc(+length);
}
$24024ac79e1737d3$var$Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== $24024ac79e1737d3$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
$24024ac79e1737d3$var$Buffer.compare = function compare(a, b) {
    if ($24024ac79e1737d3$var$isInstance(a, Uint8Array)) a = $24024ac79e1737d3$var$Buffer.from(a, a.offset, a.byteLength);
    if ($24024ac79e1737d3$var$isInstance(b, Uint8Array)) b = $24024ac79e1737d3$var$Buffer.from(b, b.offset, b.byteLength);
    if (!$24024ac79e1737d3$var$Buffer.isBuffer(a) || !$24024ac79e1737d3$var$Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
$24024ac79e1737d3$var$Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
$24024ac79e1737d3$var$Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return $24024ac79e1737d3$var$Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = $24024ac79e1737d3$var$Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if ($24024ac79e1737d3$var$isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!$24024ac79e1737d3$var$Buffer.isBuffer(buf)) buf = $24024ac79e1737d3$var$Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!$24024ac79e1737d3$var$Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function $24024ac79e1737d3$var$byteLength(string, encoding) {
    if ($24024ac79e1737d3$var$Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || $24024ac79e1737d3$var$isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return $24024ac79e1737d3$var$utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return $24024ac79e1737d3$var$base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : $24024ac79e1737d3$var$utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
$24024ac79e1737d3$var$Buffer.byteLength = $24024ac79e1737d3$var$byteLength;
function $24024ac79e1737d3$var$slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return $24024ac79e1737d3$var$hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return $24024ac79e1737d3$var$utf8Slice(this, start, end);
        case 'ascii':
            return $24024ac79e1737d3$var$asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return $24024ac79e1737d3$var$latin1Slice(this, start, end);
        case 'base64':
            return $24024ac79e1737d3$var$base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return $24024ac79e1737d3$var$utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
$24024ac79e1737d3$var$Buffer.prototype._isBuffer = true;
function $24024ac79e1737d3$var$swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
$24024ac79e1737d3$var$Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)$24024ac79e1737d3$var$swap(this, i, i + 1);
    return this;
};
$24024ac79e1737d3$var$Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        $24024ac79e1737d3$var$swap(this, i, i + 3);
        $24024ac79e1737d3$var$swap(this, i + 1, i + 2);
    }
    return this;
};
$24024ac79e1737d3$var$Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        $24024ac79e1737d3$var$swap(this, i, i + 7);
        $24024ac79e1737d3$var$swap(this, i + 1, i + 6);
        $24024ac79e1737d3$var$swap(this, i + 2, i + 5);
        $24024ac79e1737d3$var$swap(this, i + 3, i + 4);
    }
    return this;
};
$24024ac79e1737d3$var$Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return $24024ac79e1737d3$var$utf8Slice(this, 0, length);
    return $24024ac79e1737d3$var$slowToString.apply(this, arguments);
};
$24024ac79e1737d3$var$Buffer.prototype.toLocaleString = $24024ac79e1737d3$var$Buffer.prototype.toString;
$24024ac79e1737d3$var$Buffer.prototype.equals = function equals(b) {
    if (!$24024ac79e1737d3$var$Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return $24024ac79e1737d3$var$Buffer.compare(this, b) === 0;
};
$24024ac79e1737d3$var$Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = $24024ac79e1737d3$export$f99ded8fe4b79145;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if ($24024ac79e1737d3$var$customInspectSymbol) $24024ac79e1737d3$var$Buffer.prototype[$24024ac79e1737d3$var$customInspectSymbol] = $24024ac79e1737d3$var$Buffer.prototype.inspect;
$24024ac79e1737d3$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if ($24024ac79e1737d3$var$isInstance(target, Uint8Array)) target = $24024ac79e1737d3$var$Buffer.from(target, target.offset, target.byteLength);
    if (!$24024ac79e1737d3$var$Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function $24024ac79e1737d3$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if ($24024ac79e1737d3$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = $24024ac79e1737d3$var$Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if ($24024ac79e1737d3$var$Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return $24024ac79e1737d3$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return $24024ac79e1737d3$var$arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function $24024ac79e1737d3$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i1;
    if (dir) {
        let foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
$24024ac79e1737d3$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
$24024ac79e1737d3$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return $24024ac79e1737d3$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
$24024ac79e1737d3$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return $24024ac79e1737d3$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function $24024ac79e1737d3$var$hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if ($24024ac79e1737d3$var$numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function $24024ac79e1737d3$var$utf8Write(buf, string, offset, length) {
    return $24024ac79e1737d3$var$blitBuffer($24024ac79e1737d3$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function $24024ac79e1737d3$var$asciiWrite(buf, string, offset, length) {
    return $24024ac79e1737d3$var$blitBuffer($24024ac79e1737d3$var$asciiToBytes(string), buf, offset, length);
}
function $24024ac79e1737d3$var$base64Write(buf, string, offset, length) {
    return $24024ac79e1737d3$var$blitBuffer($24024ac79e1737d3$var$base64ToBytes(string), buf, offset, length);
}
function $24024ac79e1737d3$var$ucs2Write(buf, string, offset, length) {
    return $24024ac79e1737d3$var$blitBuffer($24024ac79e1737d3$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
$24024ac79e1737d3$var$Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return $24024ac79e1737d3$var$hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return $24024ac79e1737d3$var$utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return $24024ac79e1737d3$var$asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return $24024ac79e1737d3$var$base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return $24024ac79e1737d3$var$ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
$24024ac79e1737d3$var$Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function $24024ac79e1737d3$var$base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return $1606da4451f0ed63$export$6100ba28696e12de(buf);
    else return $1606da4451f0ed63$export$6100ba28696e12de(buf.slice(start, end));
}
function $24024ac79e1737d3$var$utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return $24024ac79e1737d3$var$decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const $24024ac79e1737d3$var$MAX_ARGUMENTS_LENGTH = 0x1000;
function $24024ac79e1737d3$var$decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= $24024ac79e1737d3$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $24024ac79e1737d3$var$MAX_ARGUMENTS_LENGTH));
    return res;
}
function $24024ac79e1737d3$var$asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function $24024ac79e1737d3$var$latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function $24024ac79e1737d3$var$hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += $24024ac79e1737d3$var$hexSliceLookupTable[buf[i]];
    return out;
}
function $24024ac79e1737d3$var$utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
$24024ac79e1737d3$var$Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, $24024ac79e1737d3$var$Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function $24024ac79e1737d3$var$checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
$24024ac79e1737d3$var$Buffer.prototype.readUintLE = $24024ac79e1737d3$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
$24024ac79e1737d3$var$Buffer.prototype.readUintBE = $24024ac79e1737d3$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
$24024ac79e1737d3$var$Buffer.prototype.readUint8 = $24024ac79e1737d3$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 1, this.length);
    return this[offset];
};
$24024ac79e1737d3$var$Buffer.prototype.readUint16LE = $24024ac79e1737d3$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
$24024ac79e1737d3$var$Buffer.prototype.readUint16BE = $24024ac79e1737d3$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
$24024ac79e1737d3$var$Buffer.prototype.readUint32LE = $24024ac79e1737d3$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
$24024ac79e1737d3$var$Buffer.prototype.readUint32BE = $24024ac79e1737d3$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
$24024ac79e1737d3$var$Buffer.prototype.readBigUInt64LE = $24024ac79e1737d3$var$defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    $24024ac79e1737d3$var$validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $24024ac79e1737d3$var$boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
$24024ac79e1737d3$var$Buffer.prototype.readBigUInt64BE = $24024ac79e1737d3$var$defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    $24024ac79e1737d3$var$validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $24024ac79e1737d3$var$boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
$24024ac79e1737d3$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$24024ac79e1737d3$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
$24024ac79e1737d3$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
$24024ac79e1737d3$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$24024ac79e1737d3$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
$24024ac79e1737d3$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
$24024ac79e1737d3$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
$24024ac79e1737d3$var$Buffer.prototype.readBigInt64LE = $24024ac79e1737d3$var$defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    $24024ac79e1737d3$var$validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $24024ac79e1737d3$var$boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
$24024ac79e1737d3$var$Buffer.prototype.readBigInt64BE = $24024ac79e1737d3$var$defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    $24024ac79e1737d3$var$validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) $24024ac79e1737d3$var$boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
$24024ac79e1737d3$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return $dc2dc61742b7dd42$export$aafa59e2e03f2942(this, offset, true, 23, 4);
};
$24024ac79e1737d3$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 4, this.length);
    return $dc2dc61742b7dd42$export$aafa59e2e03f2942(this, offset, false, 23, 4);
};
$24024ac79e1737d3$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 8, this.length);
    return $dc2dc61742b7dd42$export$aafa59e2e03f2942(this, offset, true, 52, 8);
};
$24024ac79e1737d3$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkOffset(offset, 8, this.length);
    return $dc2dc61742b7dd42$export$aafa59e2e03f2942(this, offset, false, 52, 8);
};
function $24024ac79e1737d3$var$checkInt(buf, value, offset, ext, max, min) {
    if (!$24024ac79e1737d3$var$Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
$24024ac79e1737d3$var$Buffer.prototype.writeUintLE = $24024ac79e1737d3$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $24024ac79e1737d3$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUintBE = $24024ac79e1737d3$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        $24024ac79e1737d3$var$checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUint8 = $24024ac79e1737d3$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUint16LE = $24024ac79e1737d3$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUint16BE = $24024ac79e1737d3$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUint32LE = $24024ac79e1737d3$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
$24024ac79e1737d3$var$Buffer.prototype.writeUint32BE = $24024ac79e1737d3$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function $24024ac79e1737d3$var$wrtBigUInt64LE(buf, value, offset, min, max) {
    $24024ac79e1737d3$var$checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function $24024ac79e1737d3$var$wrtBigUInt64BE(buf, value, offset, min, max) {
    $24024ac79e1737d3$var$checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
$24024ac79e1737d3$var$Buffer.prototype.writeBigUInt64LE = $24024ac79e1737d3$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return $24024ac79e1737d3$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
$24024ac79e1737d3$var$Buffer.prototype.writeBigUInt64BE = $24024ac79e1737d3$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return $24024ac79e1737d3$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
$24024ac79e1737d3$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        $24024ac79e1737d3$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$24024ac79e1737d3$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        $24024ac79e1737d3$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
$24024ac79e1737d3$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
$24024ac79e1737d3$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
$24024ac79e1737d3$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
$24024ac79e1737d3$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
$24024ac79e1737d3$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
$24024ac79e1737d3$var$Buffer.prototype.writeBigInt64LE = $24024ac79e1737d3$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return $24024ac79e1737d3$var$wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
$24024ac79e1737d3$var$Buffer.prototype.writeBigInt64BE = $24024ac79e1737d3$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return $24024ac79e1737d3$var$wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function $24024ac79e1737d3$var$checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function $24024ac79e1737d3$var$writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    $dc2dc61742b7dd42$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
$24024ac79e1737d3$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return $24024ac79e1737d3$var$writeFloat(this, value, offset, true, noAssert);
};
$24024ac79e1737d3$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return $24024ac79e1737d3$var$writeFloat(this, value, offset, false, noAssert);
};
function $24024ac79e1737d3$var$writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) $24024ac79e1737d3$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    $dc2dc61742b7dd42$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
$24024ac79e1737d3$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return $24024ac79e1737d3$var$writeDouble(this, value, offset, true, noAssert);
};
$24024ac79e1737d3$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return $24024ac79e1737d3$var$writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
$24024ac79e1737d3$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!$24024ac79e1737d3$var$Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
$24024ac79e1737d3$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !$24024ac79e1737d3$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = $24024ac79e1737d3$var$Buffer.isBuffer(val) ? val : $24024ac79e1737d3$var$Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const $24024ac79e1737d3$var$errors = {};
function $24024ac79e1737d3$var$E(sym, getMessage, Base) {
    $24024ac79e1737d3$var$errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value: value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
$24024ac79e1737d3$var$E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
$24024ac79e1737d3$var$E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
$24024ac79e1737d3$var$E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $24024ac79e1737d3$var$addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $24024ac79e1737d3$var$addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function $24024ac79e1737d3$var$addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function $24024ac79e1737d3$var$checkBounds(buf, offset, byteLength) {
    $24024ac79e1737d3$var$validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $24024ac79e1737d3$var$boundsError(offset, buf.length - (byteLength + 1));
}
function $24024ac79e1737d3$var$checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new $24024ac79e1737d3$var$errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    $24024ac79e1737d3$var$checkBounds(buf, offset, byteLength);
}
function $24024ac79e1737d3$var$validateNumber(value, name) {
    if (typeof value !== 'number') throw new $24024ac79e1737d3$var$errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function $24024ac79e1737d3$var$boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        $24024ac79e1737d3$var$validateNumber(value, type);
        throw new $24024ac79e1737d3$var$errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new $24024ac79e1737d3$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new $24024ac79e1737d3$var$errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const $24024ac79e1737d3$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function $24024ac79e1737d3$var$base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace($24024ac79e1737d3$var$INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function $24024ac79e1737d3$var$utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function $24024ac79e1737d3$var$asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function $24024ac79e1737d3$var$utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function $24024ac79e1737d3$var$base64ToBytes(str) {
    return $1606da4451f0ed63$export$d622b2ad8d90c771($24024ac79e1737d3$var$base64clean(str));
}
function $24024ac79e1737d3$var$blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function $24024ac79e1737d3$var$isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function $24024ac79e1737d3$var$numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const $24024ac79e1737d3$var$hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function $24024ac79e1737d3$var$defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? $24024ac79e1737d3$var$BufferBigIntNotDefined : fn;
}
function $24024ac79e1737d3$var$BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}


var $c03b6edda16b69f8$require$Buffer = $24024ac79e1737d3$export$a143d493d941bafc;
/** Number of bytes reserved for the length of the string. (32bit integer). */ const $c03b6edda16b69f8$var$NUM_BYTES_STRING_LENGTH = 4;
async function $c03b6edda16b69f8$export$6c50c12dbd6168b(tensors, group) {
    // TODO(adarob, cais): Support quantization.
    const specs = [];
    const dataPromises = [];
    const names = Array.isArray(tensors) ? tensors.map((tensor)=>tensor.name
    ) : Object.keys(tensors);
    for(let i1 = 0; i1 < names.length; ++i1){
        const name = names[i1];
        const t = Array.isArray(tensors) ? tensors[i1].tensor : tensors[name];
        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool' && t.dtype !== 'string' && t.dtype !== 'complex64') throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
        const spec = {
            name: name,
            shape: t.shape,
            dtype: t.dtype
        };
        if (t.dtype === 'string') {
            const utf8bytes = new Promise(async (resolve)=>{
                const vals = await t.bytes();
                const totalNumBytes = vals.reduce((p, c)=>p + c.length
                , 0) + $c03b6edda16b69f8$var$NUM_BYTES_STRING_LENGTH * vals.length;
                const bytes = new Uint8Array(totalNumBytes);
                let offset = 0;
                for(let i = 0; i < vals.length; i++){
                    const val = vals[i];
                    const bytesOfLength = new Uint8Array(new Uint32Array([
                        val.length
                    ]).buffer);
                    bytes.set(bytesOfLength, offset);
                    offset += $c03b6edda16b69f8$var$NUM_BYTES_STRING_LENGTH;
                    bytes.set(val, offset);
                    offset += val.length;
                }
                resolve(bytes);
            });
            dataPromises.push(utf8bytes);
        } else dataPromises.push(t.data());
        if (group != null) spec.group = group;
        specs.push(spec);
    }
    const tensorValues = await Promise.all(dataPromises);
    return {
        data: $c03b6edda16b69f8$export$b9f790e5e2031778(tensorValues),
        specs: specs
    };
}
function $c03b6edda16b69f8$export$7a14c2428d4f4a2e(buffer, specs) {
    // TODO(adarob, cais): Support quantization.
    const out = {};
    let float16Decode;
    let offset = 0;
    for (const spec of specs){
        const name = spec.name;
        const dtype = spec.dtype;
        const shape = spec.shape;
        const size = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
        let values;
        if ('quantization' in spec) {
            const quantization = spec.quantization;
            if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {
                if (!('min' in quantization && 'scale' in quantization)) throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} ` + `doesn't have corresponding metadata min and scale.`);
            } else if (quantization.dtype === 'float16') {
                if (dtype !== 'float32') throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} ` + `which only supports weights of type float32 not ${dtype}.`);
            } else throw new Error(`Weight ${spec.name} has unknown ` + `quantization dtype ${quantization.dtype}. ` + `Supported quantization dtypes are: ` + `'uint8', 'uint16', and 'float16'.`);
            const quantizationSizeFactor = $72b38f44e03c9113$export$8103dee73e5eaa46[quantization.dtype];
            const byteBuffer = buffer.slice(offset, offset + size * quantizationSizeFactor);
            const quantizedArray = quantization.dtype === 'uint8' ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
            if (dtype === 'float32') {
                if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {
                    values = new Float32Array(quantizedArray.length);
                    for(let i = 0; i < quantizedArray.length; i++){
                        const v = quantizedArray[i];
                        values[i] = v * quantization.scale + quantization.min;
                    }
                } else if (quantization.dtype === 'float16') {
                    if (float16Decode === undefined) float16Decode = $c03b6edda16b69f8$export$6f94974d2b5810f7();
                    values = float16Decode(quantizedArray);
                } else throw new Error(`Unsupported quantization type ${quantization.dtype} ` + `for weight type float32.`);
            } else if (dtype === 'int32') {
                if (quantization.dtype !== 'uint8' && quantization.dtype !== 'uint16') throw new Error(`Unsupported quantization type ${quantization.dtype} ` + `for weight type int32.`);
                values = new Int32Array(quantizedArray.length);
                for(let i = 0; i < quantizedArray.length; i++){
                    const v = quantizedArray[i];
                    values[i] = Math.round(v * quantization.scale + quantization.min);
                }
            } else throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
            offset += size * quantizationSizeFactor;
        } else if (dtype === 'string') {
            const size = $904921ed29eeae0f$export$b4c3214a70a0e73f(spec.shape);
            values = [];
            for(let i = 0; i < size; i++){
                const byteLength = new Uint32Array(buffer.slice(offset, offset + $c03b6edda16b69f8$var$NUM_BYTES_STRING_LENGTH))[0];
                offset += $c03b6edda16b69f8$var$NUM_BYTES_STRING_LENGTH;
                const bytes = new Uint8Array(buffer.slice(offset, offset + byteLength));
                values.push(bytes);
                offset += byteLength;
            }
        } else {
            const dtypeFactor = $72b38f44e03c9113$export$8103dee73e5eaa46[dtype];
            const byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);
            if (dtype === 'float32') values = new Float32Array(byteBuffer);
            else if (dtype === 'int32') values = new Int32Array(byteBuffer);
            else if (dtype === 'bool') values = new Uint8Array(byteBuffer);
            else if (dtype === 'complex64') {
                values = new Float32Array(byteBuffer);
                const real = new Float32Array(values.length / 2);
                const image = new Float32Array(values.length / 2);
                for(let i = 0; i < real.length; i++){
                    real[i] = values[i * 2];
                    image[i] = values[i * 2 + 1];
                }
                const realTensor = $b61ddc0946231fbd$export$65df3ad1ad888abb(real, shape, 'float32');
                const imageTensor = $b61ddc0946231fbd$export$65df3ad1ad888abb(image, shape, 'float32');
                out[name] = $b2f39045a9ff3425$export$83a0e34f1302825b(realTensor, imageTensor);
                realTensor.dispose();
                imageTensor.dispose();
            } else throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
            offset += size * dtypeFactor;
        }
        if (dtype !== 'complex64') out[name] = $b61ddc0946231fbd$export$65df3ad1ad888abb(values, shape, dtype);
    }
    return out;
}
function $c03b6edda16b69f8$export$b9f790e5e2031778(xs) {
    // TODO(adarob, cais): Support quantization.
    if (xs === null) throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
    let totalByteLength = 0;
    // `normalizedXs` is here for this reason: a `TypedArray`'s `buffer'
    // can have a different byte length from that of the `TypedArray` itself,
    // for example, when the `TypedArray` is created from an offset in an
    // `ArrayBuffer`. `normliazedXs` holds `TypedArray`s whose `buffer`s match
    // the `TypedArray` in byte length. If an element of `xs` does not show
    // this property, a new `TypedArray` that satisfy this property will be
    // constructed and pushed into `normalizedXs`.
    const normalizedXs = [];
    xs.forEach((x)=>{
        totalByteLength += x.byteLength;
        // tslint:disable:no-any
        normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
        if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
    // tslint:enable:no-any
    });
    const y = new Uint8Array(totalByteLength);
    let offset = 0;
    normalizedXs.forEach((x)=>{
        y.set(new Uint8Array(x.buffer), offset);
        offset += x.byteLength;
    });
    return y.buffer;
}
// Use Buffer on Node.js instead of Blob/atob/btoa
const $c03b6edda16b69f8$var$useNodeBuffer = typeof $c03b6edda16b69f8$require$Buffer !== 'undefined' && (typeof Blob === 'undefined' || typeof atob === 'undefined' || typeof btoa === 'undefined');
function $c03b6edda16b69f8$export$42600be9c932993b(str) {
    if ($c03b6edda16b69f8$var$useNodeBuffer) return $c03b6edda16b69f8$require$Buffer.byteLength(str);
    return new Blob([
        str
    ]).size;
}
function $c03b6edda16b69f8$export$28e753ea3e93cabf(buffer) {
    if ($c03b6edda16b69f8$var$useNodeBuffer) return $c03b6edda16b69f8$require$Buffer.from(buffer).toString('base64');
    const buf = new Uint8Array(buffer);
    let s = '';
    for(let i = 0, l = buf.length; i < l; i++)s += String.fromCharCode(buf[i]);
    return btoa(s);
}
function $c03b6edda16b69f8$export$aa941b9d243f1be4(str) {
    if ($c03b6edda16b69f8$var$useNodeBuffer) {
        const buf = $c03b6edda16b69f8$require$Buffer.from(str, 'base64');
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    const s = atob(str);
    const buffer = new Uint8Array(s.length);
    for(let i = 0; i < s.length; ++i)buffer.set([
        s.charCodeAt(i)
    ], i);
    return buffer.buffer;
}
function $c03b6edda16b69f8$export$9a3e9c78eb778da8(buffers) {
    if (buffers.length === 1) return buffers[0];
    let totalByteLength = 0;
    buffers.forEach((buffer)=>{
        totalByteLength += buffer.byteLength;
    });
    const temp = new Uint8Array(totalByteLength);
    let offset = 0;
    buffers.forEach((buffer)=>{
        temp.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    });
    return temp.buffer;
}
function $c03b6edda16b69f8$export$9bf319d8f74f51d1(path) {
    const SEPARATOR = '/';
    path = path.trim();
    while(path.endsWith(SEPARATOR))path = path.slice(0, path.length - 1);
    const items = path.split(SEPARATOR);
    return items[items.length - 1];
}
function $c03b6edda16b69f8$export$a725daa2cfaa7bd5(artifacts, manifest) {
    const result = {
        modelTopology: artifacts.modelTopology,
        format: artifacts.format,
        generatedBy: artifacts.generatedBy,
        convertedBy: artifacts.convertedBy,
        weightsManifest: manifest
    };
    if (artifacts.signature != null) result.signature = artifacts.signature;
    if (artifacts.userDefinedMetadata != null) result.userDefinedMetadata = artifacts.userDefinedMetadata;
    if (artifacts.modelInitializer != null) result.modelInitializer = artifacts.modelInitializer;
    if (artifacts.trainingConfig != null) result.trainingConfig = artifacts.trainingConfig;
    return result;
}
async function $c03b6edda16b69f8$export$b867c14eedd5b8a2(modelJSON, loadWeights) {
    const modelArtifacts = {
        modelTopology: modelJSON.modelTopology,
        format: modelJSON.format,
        generatedBy: modelJSON.generatedBy,
        convertedBy: modelJSON.convertedBy
    };
    if (modelJSON.trainingConfig != null) modelArtifacts.trainingConfig = modelJSON.trainingConfig;
    if (modelJSON.weightsManifest != null) {
        const [weightSpecs, weightData] = await loadWeights(modelJSON.weightsManifest);
        modelArtifacts.weightSpecs = weightSpecs;
        modelArtifacts.weightData = weightData;
    }
    if (modelJSON.signature != null) modelArtifacts.signature = modelJSON.signature;
    if (modelJSON.userDefinedMetadata != null) modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
    if (modelJSON.modelInitializer != null) modelArtifacts.modelInitializer = modelJSON.modelInitializer;
    return modelArtifacts;
}
function $c03b6edda16b69f8$export$ece8b449d7d29272(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) throw new Error('Expected JSON model topology, received ArrayBuffer.');
    return {
        dateSaved: new Date(),
        modelTopologyType: 'JSON',
        modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : $c03b6edda16b69f8$export$42600be9c932993b(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : $c03b6edda16b69f8$export$42600be9c932993b(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
    };
}
/**
 * Computes mantisa table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 2048 mantissa lookup values.
 */ function $c03b6edda16b69f8$var$computeFloat16MantisaTable() {
    const convertMantissa = (i)=>{
        let m = i << 13;
        let e = 0;
        while((m & 0x00800000) === 0){
            e -= 0x00800000;
            m <<= 1;
        }
        m &= -8388609;
        e += 0x38800000;
        return m | e;
    };
    const mantisaTable = new Uint32Array(2048);
    mantisaTable[0] = 0;
    for(let i3 = 1; i3 < 1024; i3++)mantisaTable[i3] = convertMantissa(i3);
    for(let i2 = 1024; i2 < 2048; i2++)mantisaTable[i2] = 0x38000000 + (i2 - 1024 << 13);
    return mantisaTable;
}
/**
 * Computes exponent table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 64 exponent lookup values.
 */ function $c03b6edda16b69f8$var$computeFloat16ExponentTable() {
    const exponentTable = new Uint32Array(64);
    exponentTable[0] = 0;
    exponentTable[31] = 0x47800000;
    exponentTable[32] = 0x80000000;
    exponentTable[63] = 0xc7800000;
    for(let i = 1; i < 31; i++)exponentTable[i] = i << 23;
    for(let i4 = 33; i4 < 63; i4++)exponentTable[i4] = 0x80000000 + (i4 - 32 << 23);
    return exponentTable;
}
/**
 * Computes offset table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 6d offset values.
 */ function $c03b6edda16b69f8$var$computeFloat16OffsetTable() {
    const offsetTable = new Uint32Array(64);
    for(let i = 0; i < 64; i++)offsetTable[i] = 1024;
    offsetTable[0] = offsetTable[32] = 0;
    return offsetTable;
}
function $c03b6edda16b69f8$export$6f94974d2b5810f7() {
    // Algorithm is based off of
    // http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    // Cache lookup tables
    const mantisaTable = $c03b6edda16b69f8$var$computeFloat16MantisaTable();
    const exponentTable = $c03b6edda16b69f8$var$computeFloat16ExponentTable();
    const offsetTable = $c03b6edda16b69f8$var$computeFloat16OffsetTable();
    return (quantizedArray)=>{
        const buffer = new ArrayBuffer(4 * quantizedArray.length);
        const bufferUint32View = new Uint32Array(buffer);
        for(let index = 0; index < quantizedArray.length; index++){
            const float16Bits = quantizedArray[index];
            const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 0x3ff)] + exponentTable[float16Bits >> 10];
            bufferUint32View[index] = float32Bits;
        }
        return new Float32Array(buffer);
    };
}


class $fb7f0e0c40e35172$export$512275d398c0bdcd {
    constructor(){
        this.saveRouters = [];
        this.loadRouters = [];
    }
    static getInstance() {
        if ($fb7f0e0c40e35172$export$512275d398c0bdcd.instance == null) $fb7f0e0c40e35172$export$512275d398c0bdcd.instance = new $fb7f0e0c40e35172$export$512275d398c0bdcd();
        return $fb7f0e0c40e35172$export$512275d398c0bdcd.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */ static registerSaveRouter(saveRouter) {
        $fb7f0e0c40e35172$export$512275d398c0bdcd.getInstance().saveRouters.push(saveRouter);
    }
    /**
     * Register a load-handler router.
     *
     * @param loadRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `load` method defined or `null`.
     */ static registerLoadRouter(loadRouter) {
        $fb7f0e0c40e35172$export$512275d398c0bdcd.getInstance().loadRouters.push(loadRouter);
    }
    /**
     * Look up IOHandler for saving, given a URL-like string.
     *
     * @param url
     * @returns If only one match is found, an instance of IOHandler with the
     * `save` method defined. If no match is found, `null`.
     * @throws Error, if more than one match is found.
     */ static getSaveHandlers(url) {
        return $fb7f0e0c40e35172$export$512275d398c0bdcd.getHandlers(url, 'save');
    }
    /**
     * Look up IOHandler for loading, given a URL-like string.
     *
     * @param url
     * @param loadOptions Optional, custom load options.
     * @returns All valid handlers for `url`, given the currently registered
     *   handler routers.
     */ static getLoadHandlers(url, loadOptions) {
        return $fb7f0e0c40e35172$export$512275d398c0bdcd.getHandlers(url, 'load', loadOptions);
    }
    static getHandlers(url, handlerType, loadOptions) {
        const validHandlers = [];
        const routers = handlerType === 'load' ? $fb7f0e0c40e35172$export$512275d398c0bdcd.getInstance().loadRouters : $fb7f0e0c40e35172$export$512275d398c0bdcd.getInstance().saveRouters;
        routers.forEach((router)=>{
            const handler = router(url, loadOptions);
            if (handler !== null) validHandlers.push(handler);
        });
        return validHandlers;
    }
}
const $fb7f0e0c40e35172$export$94da4683f36f634e = (loudRouter)=>$fb7f0e0c40e35172$export$512275d398c0bdcd.registerSaveRouter(loudRouter)
;
const $fb7f0e0c40e35172$export$8bf64df3d1fb9866 = (loudRouter)=>$fb7f0e0c40e35172$export$512275d398c0bdcd.registerLoadRouter(loudRouter)
;
const $fb7f0e0c40e35172$export$88af18fd9ddb62ff = (url)=>$fb7f0e0c40e35172$export$512275d398c0bdcd.getSaveHandlers(url)
;
const $fb7f0e0c40e35172$export$90c6c4d24103fa9a = (url, loadOptions)=>$fb7f0e0c40e35172$export$512275d398c0bdcd.getLoadHandlers(url, loadOptions)
;


const $397468d6b9fb350e$var$DATABASE_NAME = 'tensorflowjs';
const $397468d6b9fb350e$var$DATABASE_VERSION = 1;
// Model data and ModelArtifactsInfo (metadata) are stored in two separate
// stores for efficient access of the list of stored models and their metadata.
// 1. The object store for model data: topology, weights and weight manifests.
const $397468d6b9fb350e$var$MODEL_STORE_NAME = 'models_store';
// 2. The object store for ModelArtifactsInfo, including meta-information such
//    as the type of topology (JSON vs binary), byte size of the topology, byte
//    size of the weights, etc.
const $397468d6b9fb350e$var$INFO_STORE_NAME = 'model_info_store';
async function $397468d6b9fb350e$export$24b6df48b2529372() {
    const idbFactory = $397468d6b9fb350e$var$getIndexedDBFactory();
    return new Promise((resolve, reject)=>{
        const deleteRequest = idbFactory.deleteDatabase($397468d6b9fb350e$var$DATABASE_NAME);
        deleteRequest.onsuccess = ()=>resolve()
        ;
        deleteRequest.onerror = (error)=>reject(error)
        ;
    });
}
function $397468d6b9fb350e$var$getIndexedDBFactory() {
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER')) // TODO(cais): Add more info about what IOHandler subtypes are available.
    //   Maybe point to a doc page on the web and/or automatically determine
    //   the available IOHandlers and print them in the error message.
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    // tslint:disable-next-line:no-any
    const theWindow = typeof window === 'undefined' ? self : window;
    const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
    if (factory == null) throw new Error('The current browser does not appear to support IndexedDB.');
    return factory;
}
function $397468d6b9fb350e$var$setUpDatabase(openRequest) {
    const db = openRequest.result;
    db.createObjectStore($397468d6b9fb350e$var$MODEL_STORE_NAME, {
        keyPath: 'modelPath'
    });
    db.createObjectStore($397468d6b9fb350e$var$INFO_STORE_NAME, {
        keyPath: 'modelPath'
    });
}
class $397468d6b9fb350e$export$2c670ce804876090 {
    constructor(modelPath){
        this.indexedDB = $397468d6b9fb350e$var$getIndexedDBFactory();
        if (modelPath == null || !modelPath) throw new Error('For IndexedDB, modelPath must not be null, undefined or empty.');
        this.modelPath = modelPath;
    }
    async save(modelArtifacts) {
        // TODO(cais): Support saving GraphDef models.
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return this.databaseAction(this.modelPath, modelArtifacts);
    }
    async load() {
        return this.databaseAction(this.modelPath);
    }
    /**
     * Perform database action to put model artifacts into or read model artifacts
     * from IndexedDB object store.
     *
     * Whether the action is put or get depends on whether `modelArtifacts` is
     * specified. If it is specified, the action will be put; otherwise the action
     * will be get.
     *
     * @param modelPath A unique string path for the model.
     * @param modelArtifacts If specified, it will be the model artifacts to be
     *   stored in IndexedDB.
     * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
     *   of `ModelArtifacts`, if the action is get.
     */ databaseAction(modelPath, modelArtifacts) {
        return new Promise((resolve, reject)=>{
            const openRequest = this.indexedDB.open($397468d6b9fb350e$var$DATABASE_NAME, $397468d6b9fb350e$var$DATABASE_VERSION);
            openRequest.onupgradeneeded = ()=>$397468d6b9fb350e$var$setUpDatabase(openRequest)
            ;
            openRequest.onsuccess = ()=>{
                const db = openRequest.result;
                if (modelArtifacts == null) {
                    // Read model out from object store.
                    const modelTx = db.transaction($397468d6b9fb350e$var$MODEL_STORE_NAME, 'readonly');
                    const modelStore = modelTx.objectStore($397468d6b9fb350e$var$MODEL_STORE_NAME);
                    const getRequest = modelStore.get(this.modelPath);
                    getRequest.onsuccess = ()=>{
                        if (getRequest.result == null) {
                            db.close();
                            return reject(new Error(`Cannot find model with path '${this.modelPath}' ` + `in IndexedDB.`));
                        } else resolve(getRequest.result.modelArtifacts);
                    };
                    getRequest.onerror = (error)=>{
                        db.close();
                        return reject(getRequest.error);
                    };
                    modelTx.oncomplete = ()=>db.close()
                    ;
                } else {
                    // Put model into object store.
                    const modelArtifactsInfo = $c03b6edda16b69f8$export$ece8b449d7d29272(modelArtifacts);
                    // First, put ModelArtifactsInfo into info store.
                    const infoTx = db.transaction($397468d6b9fb350e$var$INFO_STORE_NAME, 'readwrite');
                    let infoStore = infoTx.objectStore($397468d6b9fb350e$var$INFO_STORE_NAME);
                    const putInfoRequest = infoStore.put({
                        modelPath: this.modelPath,
                        modelArtifactsInfo: modelArtifactsInfo
                    });
                    let modelTx;
                    putInfoRequest.onsuccess = ()=>{
                        // Second, put model data into model store.
                        modelTx = db.transaction($397468d6b9fb350e$var$MODEL_STORE_NAME, 'readwrite');
                        const modelStore = modelTx.objectStore($397468d6b9fb350e$var$MODEL_STORE_NAME);
                        const putModelRequest = modelStore.put({
                            modelPath: this.modelPath,
                            modelArtifacts: modelArtifacts,
                            modelArtifactsInfo: modelArtifactsInfo
                        });
                        putModelRequest.onsuccess = ()=>resolve({
                                modelArtifactsInfo: modelArtifactsInfo
                            })
                        ;
                        putModelRequest.onerror = (error)=>{
                            // If the put-model request fails, roll back the info entry as
                            // well.
                            infoStore = infoTx.objectStore($397468d6b9fb350e$var$INFO_STORE_NAME);
                            const deleteInfoRequest = infoStore.delete(this.modelPath);
                            deleteInfoRequest.onsuccess = ()=>{
                                db.close();
                                return reject(putModelRequest.error);
                            };
                            deleteInfoRequest.onerror = (error)=>{
                                db.close();
                                return reject(putModelRequest.error);
                            };
                        };
                    };
                    putInfoRequest.onerror = (error)=>{
                        db.close();
                        return reject(putInfoRequest.error);
                    };
                    infoTx.oncomplete = ()=>{
                        if (modelTx == null) db.close();
                        else modelTx.oncomplete = ()=>db.close()
                        ;
                    };
                }
            };
            openRequest.onerror = (error)=>reject(openRequest.error)
            ;
        });
    }
}
$397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME = 'indexeddb://';
const $397468d6b9fb350e$export$7375c81acb8edf6e = (url)=>{
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER')) return null;
    else {
        if (!Array.isArray(url) && url.startsWith($397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME)) return $397468d6b9fb350e$export$a4d8901e5a950049(url.slice($397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME.length));
        else return null;
    }
};
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerSaveRouter($397468d6b9fb350e$export$7375c81acb8edf6e);
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerLoadRouter($397468d6b9fb350e$export$7375c81acb8edf6e);
function $397468d6b9fb350e$export$a4d8901e5a950049(modelPath) {
    return new $397468d6b9fb350e$export$2c670ce804876090(modelPath);
}
function $397468d6b9fb350e$var$maybeStripScheme(key) {
    return key.startsWith($397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME) ? key.slice($397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME.length) : key;
}
class $397468d6b9fb350e$export$4b0775e2ff88802 {
    constructor(){
        this.indexedDB = $397468d6b9fb350e$var$getIndexedDBFactory();
    }
    async listModels() {
        return new Promise((resolve, reject)=>{
            const openRequest = this.indexedDB.open($397468d6b9fb350e$var$DATABASE_NAME, $397468d6b9fb350e$var$DATABASE_VERSION);
            openRequest.onupgradeneeded = ()=>$397468d6b9fb350e$var$setUpDatabase(openRequest)
            ;
            openRequest.onsuccess = ()=>{
                const db = openRequest.result;
                const tx = db.transaction($397468d6b9fb350e$var$INFO_STORE_NAME, 'readonly');
                const store = tx.objectStore($397468d6b9fb350e$var$INFO_STORE_NAME);
                // tslint:disable:max-line-length
                // Need to cast `store` as `any` here because TypeScript's DOM
                // library does not have the `getAll()` method even though the
                // method is supported in the latest version of most mainstream
                // browsers:
                // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll
                // tslint:enable:max-line-length
                // tslint:disable-next-line:no-any
                const getAllInfoRequest = store.getAll();
                getAllInfoRequest.onsuccess = ()=>{
                    const out = {};
                    for (const item of getAllInfoRequest.result)out[item.modelPath] = item.modelArtifactsInfo;
                    resolve(out);
                };
                getAllInfoRequest.onerror = (error)=>{
                    db.close();
                    return reject(getAllInfoRequest.error);
                };
                tx.oncomplete = ()=>db.close()
                ;
            };
            openRequest.onerror = (error)=>reject(openRequest.error)
            ;
        });
    }
    async removeModel(path) {
        path = $397468d6b9fb350e$var$maybeStripScheme(path);
        return new Promise((resolve, reject)=>{
            const openRequest = this.indexedDB.open($397468d6b9fb350e$var$DATABASE_NAME, $397468d6b9fb350e$var$DATABASE_VERSION);
            openRequest.onupgradeneeded = ()=>$397468d6b9fb350e$var$setUpDatabase(openRequest)
            ;
            openRequest.onsuccess = ()=>{
                const db = openRequest.result;
                const infoTx = db.transaction($397468d6b9fb350e$var$INFO_STORE_NAME, 'readwrite');
                const infoStore = infoTx.objectStore($397468d6b9fb350e$var$INFO_STORE_NAME);
                const getInfoRequest = infoStore.get(path);
                let modelTx;
                getInfoRequest.onsuccess = ()=>{
                    if (getInfoRequest.result == null) {
                        db.close();
                        return reject(new Error(`Cannot find model with path '${path}' ` + `in IndexedDB.`));
                    } else {
                        // First, delete the entry in the info store.
                        const deleteInfoRequest = infoStore.delete(path);
                        const deleteModelData = ()=>{
                            // Second, delete the entry in the model store.
                            modelTx = db.transaction($397468d6b9fb350e$var$MODEL_STORE_NAME, 'readwrite');
                            const modelStore = modelTx.objectStore($397468d6b9fb350e$var$MODEL_STORE_NAME);
                            const deleteModelRequest = modelStore.delete(path);
                            deleteModelRequest.onsuccess = ()=>resolve(getInfoRequest.result.modelArtifactsInfo)
                            ;
                            deleteModelRequest.onerror = (error)=>reject(getInfoRequest.error)
                            ;
                        };
                        // Proceed with deleting model data regardless of whether deletion
                        // of info data succeeds or not.
                        deleteInfoRequest.onsuccess = deleteModelData;
                        deleteInfoRequest.onerror = (error)=>{
                            deleteModelData();
                            db.close();
                            return reject(getInfoRequest.error);
                        };
                    }
                };
                getInfoRequest.onerror = (error)=>{
                    db.close();
                    return reject(getInfoRequest.error);
                };
                infoTx.oncomplete = ()=>{
                    if (modelTx == null) db.close();
                    else modelTx.oncomplete = ()=>db.close()
                    ;
                };
            };
            openRequest.onerror = (error)=>reject(openRequest.error)
            ;
        });
    }
}







const $30764f8ccb760489$var$PATH_SEPARATOR = '/';
const $30764f8ccb760489$var$PATH_PREFIX = 'tensorflowjs_models';
const $30764f8ccb760489$var$INFO_SUFFIX = 'info';
const $30764f8ccb760489$var$MODEL_TOPOLOGY_SUFFIX = 'model_topology';
const $30764f8ccb760489$var$WEIGHT_SPECS_SUFFIX = 'weight_specs';
const $30764f8ccb760489$var$WEIGHT_DATA_SUFFIX = 'weight_data';
const $30764f8ccb760489$var$MODEL_METADATA_SUFFIX = 'model_metadata';
function $30764f8ccb760489$export$af2a48c9611db360() {
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER') || typeof window === 'undefined' || typeof window.localStorage === 'undefined') throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");
    const LS = window.localStorage;
    const purgedModelPaths = [];
    for(let i = 0; i < LS.length; ++i){
        const key = LS.key(i);
        const prefix = $30764f8ccb760489$var$PATH_PREFIX + $30764f8ccb760489$var$PATH_SEPARATOR;
        if (key.startsWith(prefix) && key.length > prefix.length) {
            LS.removeItem(key);
            const modelName = $30764f8ccb760489$var$getModelPathFromKey(key);
            if (purgedModelPaths.indexOf(modelName) === -1) purgedModelPaths.push(modelName);
        }
    }
    return purgedModelPaths;
}
function $30764f8ccb760489$var$getModelKeys(path) {
    return {
        info: [
            $30764f8ccb760489$var$PATH_PREFIX,
            path,
            $30764f8ccb760489$var$INFO_SUFFIX
        ].join($30764f8ccb760489$var$PATH_SEPARATOR),
        topology: [
            $30764f8ccb760489$var$PATH_PREFIX,
            path,
            $30764f8ccb760489$var$MODEL_TOPOLOGY_SUFFIX
        ].join($30764f8ccb760489$var$PATH_SEPARATOR),
        weightSpecs: [
            $30764f8ccb760489$var$PATH_PREFIX,
            path,
            $30764f8ccb760489$var$WEIGHT_SPECS_SUFFIX
        ].join($30764f8ccb760489$var$PATH_SEPARATOR),
        weightData: [
            $30764f8ccb760489$var$PATH_PREFIX,
            path,
            $30764f8ccb760489$var$WEIGHT_DATA_SUFFIX
        ].join($30764f8ccb760489$var$PATH_SEPARATOR),
        modelMetadata: [
            $30764f8ccb760489$var$PATH_PREFIX,
            path,
            $30764f8ccb760489$var$MODEL_METADATA_SUFFIX
        ].join($30764f8ccb760489$var$PATH_SEPARATOR)
    };
}
function $30764f8ccb760489$var$removeItems(keys) {
    for (const key of Object.values(keys))window.localStorage.removeItem(key);
}
/**
 * Get model path from a local-storage key.
 *
 * E.g., 'tensorflowjs_models/my/model/1/info' --> 'my/model/1'
 *
 * @param key
 */ function $30764f8ccb760489$var$getModelPathFromKey(key) {
    const items = key.split($30764f8ccb760489$var$PATH_SEPARATOR);
    if (items.length < 3) throw new Error(`Invalid key format: ${key}`);
    return items.slice(1, items.length - 1).join($30764f8ccb760489$var$PATH_SEPARATOR);
}
function $30764f8ccb760489$var$maybeStripScheme(key) {
    return key.startsWith($30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME) ? key.slice($30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME.length) : key;
}
class $30764f8ccb760489$export$8984a84f7aef20de {
    constructor(modelPath){
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER') || typeof window === 'undefined' || typeof window.localStorage === 'undefined') // TODO(cais): Add more info about what IOHandler subtypes are
        // available.
        //   Maybe point to a doc page on the web and/or automatically determine
        //   the available IOHandlers and print them in the error message.
        throw new Error('The current environment does not support local storage.');
        this.LS = window.localStorage;
        if (modelPath == null || !modelPath) throw new Error('For local storage, modelPath must not be null, undefined or empty.');
        this.modelPath = modelPath;
        this.keys = $30764f8ccb760489$var$getModelKeys(this.modelPath);
    }
    /**
     * Save model artifacts to browser local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @param modelArtifacts The model artifacts to be stored.
     * @returns An instance of SaveResult.
     */ async save(modelArtifacts) {
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        else {
            const topology = JSON.stringify(modelArtifacts.modelTopology);
            const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
            const modelArtifactsInfo = $c03b6edda16b69f8$export$ece8b449d7d29272(modelArtifacts);
            try {
                this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
                this.LS.setItem(this.keys.topology, topology);
                this.LS.setItem(this.keys.weightSpecs, weightSpecs);
                this.LS.setItem(this.keys.weightData, $c03b6edda16b69f8$export$28e753ea3e93cabf(modelArtifacts.weightData));
                // Note that JSON.stringify doesn't write out keys that have undefined
                // values, so for some keys, we set undefined instead of a null-ish
                // value.
                const metadata = {
                    format: modelArtifacts.format,
                    generatedBy: modelArtifacts.generatedBy,
                    convertedBy: modelArtifacts.convertedBy,
                    signature: modelArtifacts.signature != null ? modelArtifacts.signature : undefined,
                    userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : undefined,
                    modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : undefined,
                    trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : undefined
                };
                this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
                return {
                    modelArtifactsInfo: modelArtifactsInfo
                };
            } catch (err) {
                // If saving failed, clean up all items saved so far.
                $30764f8ccb760489$var$removeItems(this.keys);
                throw new Error(`Failed to save model '${this.modelPath}' to local storage: ` + `size quota being exceeded is a possible cause of this failure: ` + `modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, ` + `weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, ` + `weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
            }
        }
    }
    /**
     * Load a model from local storage.
     *
     * See the documentation to `browserLocalStorage` for details on the saved
     * artifacts.
     *
     * @returns The loaded model (if loading succeeds).
     */ async load() {
        const info = JSON.parse(this.LS.getItem(this.keys.info));
        if (info == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
        if (info.modelTopologyType !== 'JSON') throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        const out = {};
        // Load topology.
        const topology = JSON.parse(this.LS.getItem(this.keys.topology));
        if (topology == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' ` + `is missing.`);
        out.modelTopology = topology;
        // Load weight specs.
        const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
        if (weightSpecs == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' ` + `are missing.`);
        out.weightSpecs = weightSpecs;
        // Load meta-data fields.
        const metadataString = this.LS.getItem(this.keys.modelMetadata);
        if (metadataString != null) {
            const metadata = JSON.parse(metadataString);
            out.format = metadata.format;
            out.generatedBy = metadata.generatedBy;
            out.convertedBy = metadata.convertedBy;
            if (metadata.signature != null) out.signature = metadata.signature;
            if (metadata.userDefinedMetadata != null) out.userDefinedMetadata = metadata.userDefinedMetadata;
            if (metadata.modelInitializer != null) out.modelInitializer = metadata.modelInitializer;
            if (metadata.trainingConfig != null) out.trainingConfig = metadata.trainingConfig;
        }
        // Load weight data.
        const weightDataBase64 = this.LS.getItem(this.keys.weightData);
        if (weightDataBase64 == null) throw new Error(`In local storage, the binary weight values of model ` + `'${this.modelPath}' are missing.`);
        out.weightData = $c03b6edda16b69f8$export$aa941b9d243f1be4(weightDataBase64);
        return out;
    }
}
$30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME = 'localstorage://';
const $30764f8ccb760489$export$64ff64fd6b1180ae = (url)=>{
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER')) return null;
    else {
        if (!Array.isArray(url) && url.startsWith($30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME)) return $30764f8ccb760489$export$96d8dd89e6c22307(url.slice($30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME.length));
        else return null;
    }
};
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerSaveRouter($30764f8ccb760489$export$64ff64fd6b1180ae);
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerLoadRouter($30764f8ccb760489$export$64ff64fd6b1180ae);
function $30764f8ccb760489$export$96d8dd89e6c22307(modelPath) {
    return new $30764f8ccb760489$export$8984a84f7aef20de(modelPath);
}
class $30764f8ccb760489$export$bb7e7fb445a616f4 {
    constructor(){
        $904921ed29eeae0f$export$a7a9523472993e97($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER'), ()=>'Current environment is not a web browser'
        );
        $904921ed29eeae0f$export$a7a9523472993e97(typeof window === 'undefined' || typeof window.localStorage !== 'undefined', ()=>'Current browser does not appear to support localStorage'
        );
        this.LS = window.localStorage;
    }
    async listModels() {
        const out = {};
        const prefix = $30764f8ccb760489$var$PATH_PREFIX + $30764f8ccb760489$var$PATH_SEPARATOR;
        const suffix = $30764f8ccb760489$var$PATH_SEPARATOR + $30764f8ccb760489$var$INFO_SUFFIX;
        for(let i = 0; i < this.LS.length; ++i){
            const key = this.LS.key(i);
            if (key.startsWith(prefix) && key.endsWith(suffix)) {
                const modelPath = $30764f8ccb760489$var$getModelPathFromKey(key);
                out[modelPath] = JSON.parse(this.LS.getItem(key));
            }
        }
        return out;
    }
    async removeModel(path) {
        path = $30764f8ccb760489$var$maybeStripScheme(path);
        const keys = $30764f8ccb760489$var$getModelKeys(path);
        if (this.LS.getItem(keys.info) == null) throw new Error(`Cannot find model at path '${path}'`);
        const info = JSON.parse(this.LS.getItem(keys.info));
        $30764f8ccb760489$var$removeItems(keys);
        return info;
    }
}




const $1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX = '://';
class $1621d4c34e6da3a3$export$ccf7f72dec8f0028 {
    constructor(){
        this.managers = {};
    }
    static getInstance() {
        if ($1621d4c34e6da3a3$export$ccf7f72dec8f0028.instance == null) $1621d4c34e6da3a3$export$ccf7f72dec8f0028.instance = new $1621d4c34e6da3a3$export$ccf7f72dec8f0028();
        return $1621d4c34e6da3a3$export$ccf7f72dec8f0028.instance;
    }
    /**
     * Register a save-handler router.
     *
     * @param saveRouter A function that maps a URL-like string onto an instance
     * of `IOHandler` with the `save` method defined or `null`.
     */ static registerManager(scheme, manager) {
        $904921ed29eeae0f$export$a7a9523472993e97(scheme != null, ()=>'scheme must not be undefined or null.'
        );
        if (scheme.endsWith($1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX)) scheme = scheme.slice(0, scheme.indexOf($1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX));
        $904921ed29eeae0f$export$a7a9523472993e97(scheme.length > 0, ()=>'scheme must not be an empty string.'
        );
        const registry = $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getInstance();
        $904921ed29eeae0f$export$a7a9523472993e97(registry.managers[scheme] == null, ()=>`A model store manager is already registered for scheme '${scheme}'.`
        );
        registry.managers[scheme] = manager;
    }
    static getManager(scheme) {
        const manager = this.getInstance().managers[scheme];
        if (manager == null) throw new Error(`Cannot find model manager for scheme '${scheme}'`);
        return manager;
    }
    static getSchemes() {
        return Object.keys(this.getInstance().managers);
    }
}
/**
 * Helper method for parsing a URL string into a scheme and a path.
 *
 * @param url E.g., 'localstorage://my-model'
 * @returns A dictionary with two fields: scheme and path.
 *   Scheme: e.g., 'localstorage' in the example above.
 *   Path: e.g., 'my-model' in the example above.
 */ function $1621d4c34e6da3a3$var$parseURL(url) {
    if (url.indexOf($1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX) === -1) throw new Error(`The url string provided does not contain a scheme. ` + `Supported schemes are: ` + `${$1621d4c34e6da3a3$export$ccf7f72dec8f0028.getSchemes().join(',')}`);
    return {
        scheme: url.split($1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX)[0],
        path: url.split($1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX)[1]
    };
}
async function $1621d4c34e6da3a3$var$cloneModelInternal(sourceURL, destURL, deleteSource = false) {
    $904921ed29eeae0f$export$a7a9523472993e97(sourceURL !== destURL, ()=>`Old path and new path are the same: '${sourceURL}'`
    );
    const loadHandlers = $fb7f0e0c40e35172$export$512275d398c0bdcd.getLoadHandlers(sourceURL);
    $904921ed29eeae0f$export$a7a9523472993e97(loadHandlers.length > 0, ()=>`Copying failed because no load handler is found for source URL ${sourceURL}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(loadHandlers.length < 2, ()=>`Copying failed because more than one (${loadHandlers.length}) ` + `load handlers for source URL ${sourceURL}.`
    );
    const loadHandler = loadHandlers[0];
    const saveHandlers = $fb7f0e0c40e35172$export$512275d398c0bdcd.getSaveHandlers(destURL);
    $904921ed29eeae0f$export$a7a9523472993e97(saveHandlers.length > 0, ()=>`Copying failed because no save handler is found for destination ` + `URL ${destURL}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(saveHandlers.length < 2, ()=>`Copying failed because more than one (${loadHandlers.length}) ` + `save handlers for destination URL ${destURL}.`
    );
    const saveHandler = saveHandlers[0];
    const sourceScheme = $1621d4c34e6da3a3$var$parseURL(sourceURL).scheme;
    const sourcePath = $1621d4c34e6da3a3$var$parseURL(sourceURL).path;
    const sameMedium = sourceScheme === $1621d4c34e6da3a3$var$parseURL(sourceURL).scheme;
    const modelArtifacts = await loadHandler.load();
    // If moving within the same storage medium, remove the old model as soon as
    // the loading is done. Without doing this, it is possible that the combined
    // size of the two models will cause the cloning to fail.
    if (deleteSource && sameMedium) await $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getManager(sourceScheme).removeModel(sourcePath);
    const saveResult = await saveHandler.save(modelArtifacts);
    // If moving between mediums, the deletion is done after the save succeeds.
    // This guards against the case in which saving to the destination medium
    // fails.
    if (deleteSource && !sameMedium) await $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getManager(sourceScheme).removeModel(sourcePath);
    return saveResult.modelArtifactsInfo;
}
/**
 * List all models stored in registered storage mediums.
 *
 * For a web browser environment, the registered mediums are Local Storage and
 * IndexedDB.
 *
 * ```js
 * // First create and save a model.
 * const model = tf.sequential();
 * model.add(tf.layers.dense(
 *     {units: 1, inputShape: [10], activation: 'sigmoid'}));
 * await model.save('localstorage://demo/management/model1');
 *
 * // Then list existing models.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Delete the model.
 * await tf.io.removeModel('localstorage://demo/management/model1');
 *
 * // List models again.
 * console.log(JSON.stringify(await tf.io.listModels()));
 * ```
 *
 * @returns A `Promise` of a dictionary mapping URLs of existing models to
 * their model artifacts info. URLs include medium-specific schemes, e.g.,
 *   'indexeddb://my/model/1'. Model artifacts info include type of the
 * model's topology, byte sizes of the topology, weights, etc.
 *
 * @doc {
 *   heading: 'Models',
 *   subheading: 'Management',
 *   namespace: 'io',
 *   ignoreCI: true
 * }
 */ async function $1621d4c34e6da3a3$export$8d63af86d795ece4() {
    const schemes = $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getSchemes();
    const out = {};
    for (const scheme of schemes){
        const schemeOut = await $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getManager(scheme).listModels();
        for(const path in schemeOut){
            const url = scheme + $1621d4c34e6da3a3$var$URL_SCHEME_SUFFIX + path;
            out[url] = schemeOut[path];
        }
    }
    return out;
}
/**
 * Remove a model specified by URL from a reigstered storage medium.
 *
 * ```js
 * // First create and save a model.
 * const model = tf.sequential();
 * model.add(tf.layers.dense(
 *     {units: 1, inputShape: [10], activation: 'sigmoid'}));
 * await model.save('localstorage://demo/management/model1');
 *
 * // Then list existing models.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Delete the model.
 * await tf.io.removeModel('localstorage://demo/management/model1');
 *
 * // List models again.
 * console.log(JSON.stringify(await tf.io.listModels()));
 * ```
 *
 * @param url A URL to a stored model, with a scheme prefix, e.g.,
 *   'localstorage://my-model-1', 'indexeddb://my/model/2'.
 * @returns ModelArtifactsInfo of the deleted model (if and only if deletion
 *   is successful).
 * @throws Error if deletion fails, e.g., if no model exists at `path`.
 *
 * @doc {
 *   heading: 'Models',
 *   subheading: 'Management',
 *   namespace: 'io',
 *   ignoreCI: true
 * }
 */ async function $1621d4c34e6da3a3$export$e71037184d1ad0fd(url) {
    const schemeAndPath = $1621d4c34e6da3a3$var$parseURL(url);
    const manager = $1621d4c34e6da3a3$export$ccf7f72dec8f0028.getManager(schemeAndPath.scheme);
    return manager.removeModel(schemeAndPath.path);
}
/**
 * Copy a model from one URL to another.
 *
 * This function supports:
 *
 * 1. Copying within a storage medium, e.g.,
 *    `tf.io.copyModel('localstorage://model-1', 'localstorage://model-2')`
 * 2. Copying between two storage mediums, e.g.,
 *    `tf.io.copyModel('localstorage://model-1', 'indexeddb://model-1')`
 *
 * ```js
 * // First create and save a model.
 * const model = tf.sequential();
 * model.add(tf.layers.dense(
 *     {units: 1, inputShape: [10], activation: 'sigmoid'}));
 * await model.save('localstorage://demo/management/model1');
 *
 * // Then list existing models.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Copy the model, from Local Storage to IndexedDB.
 * await tf.io.copyModel(
 *     'localstorage://demo/management/model1',
 *     'indexeddb://demo/management/model1');
 *
 * // List models again.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Remove both models.
 * await tf.io.removeModel('localstorage://demo/management/model1');
 * await tf.io.removeModel('indexeddb://demo/management/model1');
 * ```
 *
 * @param sourceURL Source URL of copying.
 * @param destURL Destination URL of copying.
 * @returns ModelArtifactsInfo of the copied model (if and only if copying
 *   is successful).
 * @throws Error if copying fails, e.g., if no model exists at `sourceURL`, or
 *   if `oldPath` and `newPath` are identical.
 *
 * @doc {
 *   heading: 'Models',
 *   subheading: 'Management',
 *   namespace: 'io',
 *   ignoreCI: true
 * }
 */ async function $1621d4c34e6da3a3$export$b5971478866000ed(sourceURL, destURL) {
    const deleteSource = false;
    return $1621d4c34e6da3a3$var$cloneModelInternal(sourceURL, destURL, deleteSource);
}
/**
 * Move a model from one URL to another.
 *
 * This function supports:
 *
 * 1. Moving within a storage medium, e.g.,
 *    `tf.io.moveModel('localstorage://model-1', 'localstorage://model-2')`
 * 2. Moving between two storage mediums, e.g.,
 *    `tf.io.moveModel('localstorage://model-1', 'indexeddb://model-1')`
 *
 * ```js
 * // First create and save a model.
 * const model = tf.sequential();
 * model.add(tf.layers.dense(
 *     {units: 1, inputShape: [10], activation: 'sigmoid'}));
 * await model.save('localstorage://demo/management/model1');
 *
 * // Then list existing models.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Move the model, from Local Storage to IndexedDB.
 * await tf.io.moveModel(
 *     'localstorage://demo/management/model1',
 *     'indexeddb://demo/management/model1');
 *
 * // List models again.
 * console.log(JSON.stringify(await tf.io.listModels()));
 *
 * // Remove the moved model.
 * await tf.io.removeModel('indexeddb://demo/management/model1');
 * ```
 *
 * @param sourceURL Source URL of moving.
 * @param destURL Destination URL of moving.
 * @returns ModelArtifactsInfo of the copied model (if and only if copying
 *   is successful).
 * @throws Error if moving fails, e.g., if no model exists at `sourceURL`, or
 *   if `oldPath` and `newPath` are identical.
 *
 * @doc {
 *   heading: 'Models',
 *   subheading: 'Management',
 *   namespace: 'io',
 *   ignoreCI: true
 * }
 */ async function $1621d4c34e6da3a3$export$598f168272f4fec2(sourceURL, destURL) {
    const deleteSource = true;
    return $1621d4c34e6da3a3$var$cloneModelInternal(sourceURL, destURL, deleteSource);
}


class $7248bf5cd35e7327$export$c812b315576f1552 {
    fetch(path, init) {
        return fetch(path, init);
    }
    now() {
        return performance.now();
    }
    encode(text, encoding) {
        if (encoding !== 'utf-8' && encoding !== 'utf8') throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
        if (this.textEncoder == null) this.textEncoder = new TextEncoder();
        return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
        return new TextDecoder(encoding).decode(bytes);
    }
}
if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('IS_BROWSER')) {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().setPlatform('browser', new $7248bf5cd35e7327$export$c812b315576f1552());
    // Register LocalStorage IOHandler
    try {
        $1621d4c34e6da3a3$export$ccf7f72dec8f0028.registerManager($30764f8ccb760489$export$8984a84f7aef20de.URL_SCHEME, new $30764f8ccb760489$export$bb7e7fb445a616f4());
    } catch (err) {}
    // Register IndexedDB IOHandler
    try {
        $1621d4c34e6da3a3$export$ccf7f72dec8f0028.registerManager($397468d6b9fb350e$export$2c670ce804876090.URL_SCHEME, new $397468d6b9fb350e$export$4b0775e2ff88802());
    } catch (err1) {}
}




var $3tEm6 = parcelRequire("3tEm6");

const $f56b319b2af664b5$export$fc0623918121e18f = {
    // tslint:disable-next-line:no-require-imports
    importFetch: ()=>(parcelRequire("ltudh"))
};
let $f56b319b2af664b5$var$systemFetch;
function $f56b319b2af664b5$export$ab67f817cc7ff6dc() {
    $f56b319b2af664b5$var$systemFetch = null;
}
function $f56b319b2af664b5$export$fec6b32271d1a551(fetchFn) {
    $f56b319b2af664b5$var$systemFetch = fetchFn;
}
function $f56b319b2af664b5$export$f53da9ce5ba19de0() {
    return $f56b319b2af664b5$var$systemFetch;
}

class $f56b319b2af664b5$export$7befb6c3de272049 {
    constructor(){
        // tslint:disable-next-line:no-require-imports
        this.util = (parcelRequire("ltudh"));
        // According to the spec, the built-in encoder can do only UTF-8 encoding.
        // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/TextEncoder
        this.textEncoder = new this.util.TextEncoder();
    }
    fetch(path, requestInits) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().global.fetch != null) return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().global.fetch(path, requestInits);
        if ($f56b319b2af664b5$var$systemFetch == null) $f56b319b2af664b5$var$systemFetch = $f56b319b2af664b5$export$fc0623918121e18f.importFetch();
        return $f56b319b2af664b5$var$systemFetch(path, requestInits);
    }
    now() {
        const time = $3tEm6.hrtime();
        return time[0] * 1000 + time[1] / 1000000;
    }
    encode(text, encoding) {
        if (encoding !== 'utf-8' && encoding !== 'utf8') throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
        return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
        if (bytes.length === 0) return '';
        return new this.util.TextDecoder(encoding).decode(bytes);
    }
}
if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('IS_NODE') && !$78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('IS_BROWSER')) $78e7329b437d1e00$export$a7b6bc01c63cdfc3().setPlatform('node', new $f56b319b2af664b5$export$7befb6c3de272049());




function $034bc04874ecb003$export$ab1029bcae9ddb4a(shape, dtype = 'float32', values) {
    dtype = dtype || 'float32';
    $904921ed29eeae0f$export$3d8b7619bac22cf5(shape);
    return new $c341eb4171cc0419$export$350df26cd52e08e1(shape, dtype, values);
}







/**
 * Casts a `tf.Tensor` to a new dtype.
 *
 * ```js
 * const x = tf.tensor1d([1.5, 2.5, 3]);
 * tf.cast(x, 'int32').print();
 * ```
 * @param x The input tensor to be casted.
 * @param dtype The dtype to cast the input tensor to.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */ function $939ec2f1ca32d2a1$var$cast_(x, dtype) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'cast');
    // Sanity checks.
    if (!$904921ed29eeae0f$export$a6a3df2178ac9529(dtype)) throw new Error(`Failed to cast to unknown dtype ${dtype}`);
    if (dtype === 'string' && $x.dtype !== 'string' || dtype !== 'string' && $x.dtype === 'string') throw new Error('Only strings can be casted to strings');
    const inputs = {
        x: $x
    };
    const attrs = {
        dtype: dtype
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$107ecfb3d1ccbd77, inputs, attrs);
}
const $939ec2f1ca32d2a1$export$f2db7d5238e1d23f = $9e60b70ce0353b32$export$f59964a629598e2({
    cast_: $939ec2f1ca32d2a1$var$cast_
});






/**
 * Creates a new tensor with the same values and shape as the specified
 * tensor.
 *
 * ```js
 * const x = tf.tensor([1, 2]);
 *
 * x.clone().print();
 * ```
 *
 * @param x The tensor to clone.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $e3b15dff351ca276$var$clone_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'clone', 'string_or_numeric');
    const inputs = {
        x: $x
    };
    // Note this op is called tf.identity in python. Hence the kernel name used
    // here.
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$544bf02140fa9a77, inputs);
}
const $e3b15dff351ca276$export$9cd59f9826255e47 = $9e60b70ce0353b32$export$f59964a629598e2({
    clone_: $e3b15dff351ca276$var$clone_
});


function $67e19e81e9dedd83$export$c2d084dc44961371(x, verbose = false) {
    console.log(x.toString(verbose));
}



$a6bde3769fa0d8b5$export$ca8737f6c8c212b8();
const $719a4e3251485e1e$var$opHandler = {
    buffer: $034bc04874ecb003$export$ab1029bcae9ddb4a,
    cast: $939ec2f1ca32d2a1$export$f2db7d5238e1d23f,
    clone: $e3b15dff351ca276$export$9cd59f9826255e47,
    print: $67e19e81e9dedd83$export$c2d084dc44961371
};
$c341eb4171cc0419$export$1efe8d8b4884ad31($719a4e3251485e1e$var$opHandler);








const $642fc0c2d734faae$var$DEFAULT_FILE_NAME_PREFIX = 'model';
const $642fc0c2d734faae$var$DEFAULT_JSON_EXTENSION_NAME = '.json';
const $642fc0c2d734faae$var$DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';
function $642fc0c2d734faae$var$defer(f) {
    return new Promise((resolve)=>setTimeout(resolve)
    ).then(f);
}
class $642fc0c2d734faae$export$cc3c076530f2848f {
    constructor(fileNamePrefix){
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER')) // TODO(cais): Provide info on what IOHandlers are available under the
        //   current environment.
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        if (fileNamePrefix.startsWith($642fc0c2d734faae$export$cc3c076530f2848f.URL_SCHEME)) fileNamePrefix = fileNamePrefix.slice($642fc0c2d734faae$export$cc3c076530f2848f.URL_SCHEME.length);
        if (fileNamePrefix == null || fileNamePrefix.length === 0) fileNamePrefix = $642fc0c2d734faae$var$DEFAULT_FILE_NAME_PREFIX;
        this.modelJsonFileName = fileNamePrefix + $642fc0c2d734faae$var$DEFAULT_JSON_EXTENSION_NAME;
        this.weightDataFileName = fileNamePrefix + $642fc0c2d734faae$var$DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    async save(modelArtifacts) {
        if (typeof document === 'undefined') throw new Error("Browser downloads are not supported in this environment since `document` is not present");
        const weightsURL = window.URL.createObjectURL(new Blob([
            modelArtifacts.weightData
        ], {
            type: 'application/octet-stream'
        }));
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
        else {
            const weightsManifest = [
                {
                    paths: [
                        './' + this.weightDataFileName
                    ],
                    weights: modelArtifacts.weightSpecs
                }
            ];
            const modelJSON = $c03b6edda16b69f8$export$a725daa2cfaa7bd5(modelArtifacts, weightsManifest);
            const modelJsonURL = window.URL.createObjectURL(new Blob([
                JSON.stringify(modelJSON)
            ], {
                type: 'application/json'
            }));
            // If anchor elements are not provided, create them without attaching them
            // to parents, so that the downloaded file names can be controlled.
            const jsonAnchor = this.modelJsonAnchor == null ? document.createElement('a') : this.modelJsonAnchor;
            jsonAnchor.download = this.modelJsonFileName;
            jsonAnchor.href = modelJsonURL;
            // Trigger downloads by evoking a click event on the download anchors.
            // When multiple downloads are started synchronously, Firefox will only
            // save the last one.
            await $642fc0c2d734faae$var$defer(()=>jsonAnchor.dispatchEvent(new MouseEvent('click'))
            );
            if (modelArtifacts.weightData != null) {
                const weightDataAnchor = this.weightDataAnchor == null ? document.createElement('a') : this.weightDataAnchor;
                weightDataAnchor.download = this.weightDataFileName;
                weightDataAnchor.href = weightsURL;
                await $642fc0c2d734faae$var$defer(()=>weightDataAnchor.dispatchEvent(new MouseEvent('click'))
                );
            }
            return {
                modelArtifactsInfo: $c03b6edda16b69f8$export$ece8b449d7d29272(modelArtifacts)
            };
        }
    }
}
$642fc0c2d734faae$export$cc3c076530f2848f.URL_SCHEME = 'downloads://';
class $642fc0c2d734faae$var$BrowserFiles {
    constructor(files){
        if (files == null || files.length < 1) throw new Error(`When calling browserFiles, at least 1 file is required, ` + `but received ${files}`);
        this.jsonFile = files[0];
        this.weightsFiles = files.slice(1);
    }
    async load() {
        return new Promise((resolve, reject)=>{
            const jsonReader = new FileReader();
            jsonReader.onload = (event)=>{
                // tslint:disable-next-line:no-any
                const modelJSON = JSON.parse(event.target.result);
                const modelTopology = modelJSON.modelTopology;
                if (modelTopology == null) {
                    reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
                    return;
                }
                const weightsManifest1 = modelJSON.weightsManifest;
                if (weightsManifest1 == null) {
                    reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
                    return;
                }
                if (this.weightsFiles.length === 0) {
                    resolve({
                        modelTopology: modelTopology
                    });
                    return;
                }
                const modelArtifactsPromise = $c03b6edda16b69f8$export$b867c14eedd5b8a2(modelJSON, (weightsManifest)=>this.loadWeights(weightsManifest)
                );
                resolve(modelArtifactsPromise);
            };
            jsonReader.onerror = (error)=>reject(`Failed to read model topology and weights manifest JSON ` + `from file '${this.jsonFile.name}'. BrowserFiles supports loading ` + `Keras-style tf.Model artifacts only.`)
            ;
            jsonReader.readAsText(this.jsonFile);
        });
    }
    loadWeights(weightsManifest) {
        const weightSpecs = [];
        const paths = [];
        for (const entry of weightsManifest){
            weightSpecs.push(...entry.weights);
            paths.push(...entry.paths);
        }
        const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
        const promises = paths.map((path)=>this.loadWeightsFile(path, pathToFile[path])
        );
        return Promise.all(promises).then((buffers)=>[
                weightSpecs,
                $c03b6edda16b69f8$export$9a3e9c78eb778da8(buffers)
            ]
        );
    }
    loadWeightsFile(path, file) {
        return new Promise((resolve, reject)=>{
            const weightFileReader = new FileReader();
            weightFileReader.onload = (event)=>{
                // tslint:disable-next-line:no-any
                const weightData = event.target.result;
                resolve(weightData);
            };
            weightFileReader.onerror = (error)=>reject(`Failed to weights data from file of path '${path}'.`)
            ;
            weightFileReader.readAsArrayBuffer(file);
        });
    }
    /**
     * Check the compatibility between weights manifest and weight files.
     */ checkManifestAndWeightFiles(manifest) {
        const basenames = [];
        const fileNames = this.weightsFiles.map((file)=>$c03b6edda16b69f8$export$9bf319d8f74f51d1(file.name)
        );
        const pathToFile = {};
        for (const group of manifest)group.paths.forEach((path)=>{
            const pathBasename = $c03b6edda16b69f8$export$9bf319d8f74f51d1(path);
            if (basenames.indexOf(pathBasename) !== -1) throw new Error(`Duplicate file basename found in weights manifest: ` + `'${pathBasename}'`);
            basenames.push(pathBasename);
            if (fileNames.indexOf(pathBasename) === -1) throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
            else pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
        });
        if (basenames.length !== this.weightsFiles.length) throw new Error(`Mismatch in the number of files in weights manifest ` + `(${basenames.length}) and the number of weight files provided ` + `(${this.weightsFiles.length}).`);
        return pathToFile;
    }
}
const $642fc0c2d734faae$export$6149c5f14395749b = (url)=>{
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_BROWSER')) return null;
    else {
        if (!Array.isArray(url) && url.startsWith($642fc0c2d734faae$export$cc3c076530f2848f.URL_SCHEME)) return $642fc0c2d734faae$export$8fbc9551c735f788(url.slice($642fc0c2d734faae$export$cc3c076530f2848f.URL_SCHEME.length));
        else return null;
    }
};
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerSaveRouter($642fc0c2d734faae$export$6149c5f14395749b);
function $642fc0c2d734faae$export$8fbc9551c735f788(fileNamePrefix = 'model') {
    return new $642fc0c2d734faae$export$cc3c076530f2848f(fileNamePrefix);
}
function $642fc0c2d734faae$export$6729643cf069471c(files) {
    return new $642fc0c2d734faae$var$BrowserFiles(files);
}










function $e74ee76d4fca8faa$export$b88cae388b9e062e(promises1, onProgress, startFraction1, endFraction1) {
    checkPromises(promises1);
    startFraction1 = startFraction1 == null ? 0 : startFraction1;
    endFraction1 = endFraction1 == null ? 1 : endFraction1;
    checkFraction(startFraction1, endFraction1);
    let resolvedPromise = 0;
    const registerMonitor = (promise)=>{
        promise.then((value)=>{
            const fraction = startFraction1 + ++resolvedPromise / promises1.length * (endFraction1 - startFraction1);
            // pass fraction as parameter to callback function.
            onProgress(fraction);
            return value;
        });
        return promise;
    };
    function checkPromises(promises) {
        $904921ed29eeae0f$export$a7a9523472993e97(promises != null && Array.isArray(promises) && promises.length > 0, ()=>'promises must be a none empty array'
        );
    }
    function checkFraction(startFraction, endFraction) {
        $904921ed29eeae0f$export$a7a9523472993e97(startFraction >= 0 && startFraction <= 1, ()=>`Progress fraction must be in range [0, 1], but ` + `got startFraction ${startFraction}`
        );
        $904921ed29eeae0f$export$a7a9523472993e97(endFraction >= 0 && endFraction <= 1, ()=>`Progress fraction must be in range [0, 1], but ` + `got endFraction ${endFraction}`
        );
        $904921ed29eeae0f$export$a7a9523472993e97(endFraction >= startFraction, ()=>`startFraction must be no more than endFraction, but ` + `got startFraction ${startFraction} and endFraction ` + `${endFraction}`
        );
    }
    return Promise.all(promises1.map(registerMonitor));
}



async function $3d254f97b27084b1$export$6873c1a1d3325bf7(fetchURLs, loadOptions) {
    if (loadOptions == null) loadOptions = {};
    const fetchFunc = loadOptions.fetchFunc == null ? $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.fetch : loadOptions.fetchFunc;
    // Create the requests for all of the weights in parallel.
    const requests = fetchURLs.map((fetchURL)=>fetchFunc(fetchURL, loadOptions.requestInit, {
            isBinary: true
        })
    );
    const fetchStartFraction = 0;
    const fetchEndFraction = 0.5;
    const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await $e74ee76d4fca8faa$export$b88cae388b9e062e(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
    const bufferPromises = responses.map((response)=>response.arrayBuffer()
    );
    const bufferStartFraction = 0.5;
    const bufferEndFraction = 1;
    const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await $e74ee76d4fca8faa$export$b88cae388b9e062e(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
    return buffers;
}
async function $3d254f97b27084b1$export$55f7d42d35356096(manifest, filePathPrefix = '', weightNames, requestInit) {
    // TODO(nsthorat): Groups are currently fetched atomically. If you need a
    // single weight from a group, the whole group will be fetched. At a future
    // date, we should support fetching only the individual shards within a
    // group that are needed to reconstruct the requested weight.
    // TODO(cais): Use `decodeWeights` for implementation.
    const fetchWeights = (fetchUrls)=>$3d254f97b27084b1$export$6873c1a1d3325bf7(fetchUrls, {
            requestInit: requestInit
        })
    ;
    const $3d254f97b27084b1$export$55f7d42d35356096 = $3d254f97b27084b1$export$635f986c4ab6ebe2(fetchWeights);
    return $3d254f97b27084b1$export$55f7d42d35356096(manifest, filePathPrefix, weightNames);
}
function $3d254f97b27084b1$export$635f986c4ab6ebe2(fetchWeightsFunction) {
    return async (manifest, filePathPrefix = '', weightNames)=>{
        // Collect all the groups, weights, and their relative offsets to be
        // fetched.
        const groupIndicesToFetchMap = manifest.map(()=>false
        );
        const groupWeightsToFetch = {};
        const weightsFound = weightNames != null ? weightNames.map(()=>false
        ) : [];
        const allManifestWeightNames = [];
        manifest.forEach((manifestGroupConfig, groupIndex)=>{
            let groupOffset = 0;
            manifestGroupConfig.weights.forEach((weightsEntry)=>{
                const rawDtype = 'quantization' in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
                const weightsBytes = $72b38f44e03c9113$export$8103dee73e5eaa46[rawDtype] * $904921ed29eeae0f$export$b4c3214a70a0e73f(weightsEntry.shape);
                const enqueueWeightsForFetchingFn = ()=>{
                    groupIndicesToFetchMap[groupIndex] = true;
                    if (groupWeightsToFetch[groupIndex] == null) groupWeightsToFetch[groupIndex] = [];
                    groupWeightsToFetch[groupIndex].push({
                        manifestEntry: weightsEntry,
                        groupOffset: groupOffset,
                        sizeBytes: weightsBytes
                    });
                };
                if (weightNames != null) weightNames.forEach((weightName, weightIndex)=>{
                    if (weightName === weightsEntry.name) {
                        enqueueWeightsForFetchingFn();
                        weightsFound[weightIndex] = true;
                    }
                });
                else enqueueWeightsForFetchingFn();
                allManifestWeightNames.push(weightsEntry.name);
                groupOffset += weightsBytes;
            });
        });
        if (!weightsFound.every((found)=>found
        )) {
            const weightsNotFound = weightNames.filter((_, i)=>!weightsFound[i]
            );
            throw new Error(`Could not find weights in manifest with names: ` + `${weightsNotFound.join(', ')}. \n` + `Manifest JSON has weights with names: ` + `${allManifestWeightNames.join(', ')}.`);
        }
        // Convert the one-hot boolean groupId => shouldFetch map to a list of group
        // IDs.
        const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i)=>{
            if (shouldFetch) accumulator.push(i);
            return accumulator;
        }, []);
        const fetchUrls = [];
        groupIndicesToFetch.forEach((i)=>{
            manifest[i].paths.forEach((filepath)=>{
                const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;
                fetchUrls.push(fetchUrl);
            });
        });
        const buffers = await fetchWeightsFunction(fetchUrls);
        const weightsTensorMap = {};
        let bufferIndexOffset = 0;
        groupIndicesToFetch.forEach((i)=>{
            const numBuffers = manifest[i].paths.length;
            let groupBytes = 0;
            for(let i1 = 0; i1 < numBuffers; i1++)groupBytes += buffers[bufferIndexOffset + i1].byteLength;
            // Create a buffer for the whole group.
            const groupBuffer = new ArrayBuffer(groupBytes);
            const groupByteBuffer = new Uint8Array(groupBuffer);
            let groupBufferOffset = 0;
            for(let i2 = 0; i2 < numBuffers; i2++){
                const buffer = new Uint8Array(buffers[bufferIndexOffset + i2]);
                groupByteBuffer.set(buffer, groupBufferOffset);
                groupBufferOffset += buffer.byteLength;
            }
            const weightsEntries = groupWeightsToFetch[i];
            weightsEntries.forEach((weightsEntry)=>{
                const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                const nameToTensorMap = $c03b6edda16b69f8$export$7a14c2428d4f4a2e(byteBuffer, [
                    weightsEntry.manifestEntry
                ]);
                for(const name in nameToTensorMap)weightsTensorMap[name] = nameToTensorMap[name];
            });
            bufferIndexOffset += numBuffers;
        });
        return weightsTensorMap;
    };
}


const $c1d8d98d73977977$var$OCTET_STREAM_MIME_TYPE = 'application/octet-stream';
const $c1d8d98d73977977$var$JSON_TYPE = 'application/json';
class $c1d8d98d73977977$export$3df08bb5d0f8b499 {
    constructor(path, loadOptions){
        this.DEFAULT_METHOD = 'POST';
        if (loadOptions == null) loadOptions = {};
        this.weightPathPrefix = loadOptions.weightPathPrefix;
        this.onProgress = loadOptions.onProgress;
        this.weightUrlConverter = loadOptions.weightUrlConverter;
        if (loadOptions.fetchFunc != null) {
            $904921ed29eeae0f$export$a7a9523472993e97(typeof loadOptions.fetchFunc === 'function', ()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
            );
            this.fetch = loadOptions.fetchFunc;
        } else this.fetch = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().platform.fetch;
        $904921ed29eeae0f$export$a7a9523472993e97(path != null && path.length > 0, ()=>"URL path for http must not be null, undefined or empty."
        );
        if (Array.isArray(path)) $904921ed29eeae0f$export$a7a9523472993e97(path.length === 2, ()=>'URL paths for http must have a length of 2, ' + `(actual length is ${path.length}).`
        );
        this.path = path;
        if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) throw new Error('requestInit is expected to have no pre-existing body, but has one.');
        this.requestInit = loadOptions.requestInit || {};
    }
    async save(modelArtifacts) {
        if (modelArtifacts.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
        const init = Object.assign({
            method: this.DEFAULT_METHOD
        }, this.requestInit);
        init.body = new FormData();
        const weightsManifest = [
            {
                paths: [
                    './model.weights.bin'
                ],
                weights: modelArtifacts.weightSpecs
            }
        ];
        const modelTopologyAndWeightManifest = $c03b6edda16b69f8$export$a725daa2cfaa7bd5(modelArtifacts, weightsManifest);
        init.body.append('model.json', new Blob([
            JSON.stringify(modelTopologyAndWeightManifest)
        ], {
            type: $c1d8d98d73977977$var$JSON_TYPE
        }), 'model.json');
        if (modelArtifacts.weightData != null) init.body.append('model.weights.bin', new Blob([
            modelArtifacts.weightData
        ], {
            type: $c1d8d98d73977977$var$OCTET_STREAM_MIME_TYPE
        }), 'model.weights.bin');
        const response = await this.fetch(this.path, init);
        if (response.ok) return {
            modelArtifactsInfo: $c03b6edda16b69f8$export$ece8b449d7d29272(modelArtifacts),
            responses: [
                response
            ]
        };
        else throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ` + `${response.status}.`);
    }
    /**
     * Load model artifacts via HTTP request(s).
     *
     * See the documentation to `tf.io.http` for details on the saved
     * artifacts.
     *
     * @returns The loaded model artifacts (if loading succeeds).
     */ async load() {
        const modelConfigRequest = await this.fetch(this.path, this.requestInit);
        if (!modelConfigRequest.ok) throw new Error(`Request to ${this.path} failed with status code ` + `${modelConfigRequest.status}. Please verify this URL points to ` + `the model JSON of the model to load.`);
        let modelJSON;
        try {
            modelJSON = await modelConfigRequest.json();
        } catch (e) {
            let message = `Failed to parse model JSON of response from ${this.path}.`;
            // TODO(nsthorat): Remove this after some time when we're comfortable that
            // .pb files are mostly gone.
            if (this.path.endsWith('.pb')) message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
            else message += " Please make sure the server is serving valid JSON for this request.";
            throw new Error(message);
        }
        // We do not allow both modelTopology and weightsManifest to be missing.
        const modelTopology = modelJSON.modelTopology;
        const weightsManifest1 = modelJSON.weightsManifest;
        if (modelTopology == null && weightsManifest1 == null) throw new Error(`The JSON from HTTP path ${this.path} contains neither model ` + `topology or manifest for weights.`);
        return $c03b6edda16b69f8$export$b867c14eedd5b8a2(modelJSON, (weightsManifest)=>this.loadWeights(weightsManifest)
        );
    }
    async loadWeights(weightsManifest) {
        const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
        const [prefix, suffix] = $c1d8d98d73977977$export$7a5253c0f62e0150(weightPath);
        const pathPrefix = this.weightPathPrefix || prefix;
        const weightSpecs = [];
        for (const entry of weightsManifest)weightSpecs.push(...entry.weights);
        const fetchURLs = [];
        const urlPromises = [];
        for (const weightsGroup of weightsManifest){
            for (const path of weightsGroup.paths)if (this.weightUrlConverter != null) urlPromises.push(this.weightUrlConverter(path));
            else fetchURLs.push(pathPrefix + path + suffix);
        }
        if (this.weightUrlConverter) fetchURLs.push(...await Promise.all(urlPromises));
        const buffers = await $3d254f97b27084b1$export$6873c1a1d3325bf7(fetchURLs, {
            requestInit: this.requestInit,
            fetchFunc: this.fetch,
            onProgress: this.onProgress
        });
        return [
            weightSpecs,
            $c03b6edda16b69f8$export$9a3e9c78eb778da8(buffers)
        ];
    }
}
$c1d8d98d73977977$export$3df08bb5d0f8b499.URL_SCHEME_REGEX = /^https?:\/\//;
function $c1d8d98d73977977$export$7a5253c0f62e0150(url) {
    const lastSlash = url.lastIndexOf('/');
    const lastSearchParam = url.lastIndexOf('?');
    const prefix = url.substring(0, lastSlash);
    const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : '';
    return [
        prefix + '/',
        suffix
    ];
}
function $c1d8d98d73977977$export$18a721ae4733601b(url) {
    return url.match($c1d8d98d73977977$export$3df08bb5d0f8b499.URL_SCHEME_REGEX) != null;
}
const $c1d8d98d73977977$export$696b487c8ad531d2 = (url, loadOptions)=>{
    if (typeof fetch === 'undefined' && (loadOptions == null || loadOptions.fetchFunc == null)) // `http` uses `fetch` or `node-fetch`, if one wants to use it in
    // an environment that is not the browser or node they have to setup a
    // global fetch polyfill.
    return null;
    else {
        let isHTTP = true;
        if (Array.isArray(url)) isHTTP = url.every((urlItem)=>$c1d8d98d73977977$export$18a721ae4733601b(urlItem)
        );
        else isHTTP = $c1d8d98d73977977$export$18a721ae4733601b(url);
        if (isHTTP) return $c1d8d98d73977977$export$7d6f1c8842f9f527(url, loadOptions);
    }
    return null;
};
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerSaveRouter($c1d8d98d73977977$export$696b487c8ad531d2);
$fb7f0e0c40e35172$export$512275d398c0bdcd.registerLoadRouter($c1d8d98d73977977$export$696b487c8ad531d2);
function $c1d8d98d73977977$export$7d6f1c8842f9f527(path, loadOptions) {
    return new $c1d8d98d73977977$export$3df08bb5d0f8b499(path, loadOptions);
}
function $c1d8d98d73977977$export$624ff5bc4e3a9d72(path, loadOptions) {
    return $c1d8d98d73977977$export$7d6f1c8842f9f527(path, loadOptions);
}



/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ class $a4bf67e672323b57$var$PassthroughLoader {
    constructor(modelArtifacts){
        this.modelArtifacts = modelArtifacts;
    }
    async load() {
        return this.modelArtifacts;
    }
}
class $a4bf67e672323b57$var$PassthroughSaver {
    constructor(saveHandler){
        this.saveHandler = saveHandler;
    }
    async save(modelArtifacts) {
        return this.saveHandler(modelArtifacts);
    }
}
function $a4bf67e672323b57$export$89ba941c7951a2e8(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    if (arguments.length === 1) {
        const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
        if (isModelArtifacts) return new $a4bf67e672323b57$var$PassthroughLoader(modelArtifacts);
        else {
            // Legacy support: with only modelTopology.
            // TODO(cais): Remove this deprecated API.
            console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
            return new $a4bf67e672323b57$var$PassthroughLoader({
                modelTopology: modelArtifacts
            });
        }
    } else {
        // Legacy support.
        // TODO(cais): Remove this deprecated API.
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new $a4bf67e672323b57$var$PassthroughLoader({
            modelTopology: modelArtifacts,
            weightSpecs: weightSpecs,
            weightData: weightData,
            trainingConfig: trainingConfig
        });
    }
}
function $a4bf67e672323b57$export$fa4a26428614aae7(saveHandler) {
    return new $a4bf67e672323b57$var$PassthroughSaver(saveHandler);
}






var $c374f26140f3eb6b$exports = {};

$parcel$export($c374f26140f3eb6b$exports, "getBroadcastDims", function () { return $c374f26140f3eb6b$export$fc823784344690e0; });
$parcel$export($c374f26140f3eb6b$exports, "getReductionAxes", function () { return $c374f26140f3eb6b$export$9f11ec258a9b2804; });
$parcel$export($c374f26140f3eb6b$exports, "assertAndGetBroadcastShape", function () { return $c374f26140f3eb6b$export$a3e2a38a57ec8318; });
function $c374f26140f3eb6b$export$fc823784344690e0(inShape, outShape) {
    const inRank = inShape.length;
    const dims = [];
    for(let i = 0; i < inRank; i++){
        const dim = inRank - 1 - i;
        const a = inShape[dim] || 1;
        const b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) dims.unshift(dim);
    }
    return dims;
}
function $c374f26140f3eb6b$export$9f11ec258a9b2804(inShape, outShape) {
    const result = [];
    for(let i = 0; i < outShape.length; i++){
        const inDim = inShape[inShape.length - i - 1];
        const outAxis = outShape.length - i - 1;
        const outDim = outShape[outAxis];
        if (inDim == null || inDim === 1 && outDim > 1) result.unshift(outAxis);
    }
    return result;
}
function $c374f26140f3eb6b$export$a3e2a38a57ec8318(shapeA, shapeB) {
    const result = [];
    const l = Math.max(shapeA.length, shapeB.length);
    for(let i = 0; i < l; i++){
        let a = shapeA[shapeA.length - i - 1];
        if (a == null) a = 1;
        let b = shapeB[shapeB.length - i - 1];
        if (b == null) b = 1;
        if (a === 1) result.unshift(b);
        else if (b === 1) result.unshift(a);
        else if (a !== b) {
            const errMsg = `Operands could not be broadcast together with shapes ` + `${shapeA} and ${shapeB}.`;
            throw Error(errMsg);
        } else result.unshift(a);
    }
    return result;
}

var $c53aa01d4c37cbd8$exports = {};

$parcel$export($c53aa01d4c37cbd8$exports, "prepareAndValidate", function () { return $c53aa01d4c37cbd8$export$6bb34ea9be10068f; });

function $c53aa01d4c37cbd8$export$6bb34ea9be10068f(tensor, indices) {
    const tensorRank = tensor.shape.length;
    const indicesRank = indices.shape.length;
    if (tensorRank < 1) throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' + ` but the rank was ${tensorRank}.`);
    if (indicesRank < 1) throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indicesRank}.`);
    if (indices.dtype !== 'int32') throw new Error('tf.gatherND() expects the indices to be int32 type,' + ` but the dtype was ${indices.dtype}.`);
    if (indices.shape[indicesRank - 1] > tensorRank) throw new Error('index innermost dimension length must be <= tensor rank; saw: ' + `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
    if ($904921ed29eeae0f$export$b4c3214a70a0e73f(tensor.shape) === 0) throw new Error('Requested more than 0 entries, but input is empty.' + ` Input shape: ${tensor.shape}.`);
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    // The result shape is
    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]
    let nResult = 1;
    for(let i = 0; i < indicesShape.length - 1; ++i)nResult *= indicesShape[i];
    const inputShape = tensor.shape;
    const resultShape = indicesShape.slice();
    resultShape.pop();
    let sliceSize = 1;
    for(let i1 = sliceRank; i1 < tensorRank; ++i1){
        sliceSize *= inputShape[i1];
        resultShape.push(inputShape[i1]);
    }
    const strides = [
        ...$904921ed29eeae0f$export$6ad0292cf4d50f79(tensor.shape).map((stride)=>stride / sliceSize
        ),
        1
    ].slice(0, sliceRank);
    return [
        resultShape,
        nResult,
        sliceSize,
        strides
    ];
}

var $ddbb251d0c4839ae$exports = {};

$parcel$export($ddbb251d0c4839ae$exports, "validateUpdateShape", function () { return $ddbb251d0c4839ae$export$9d843bc97e7022ed; });
$parcel$export($ddbb251d0c4839ae$exports, "validateInput", function () { return $ddbb251d0c4839ae$export$4d09d4ac8ba225dd; });
$parcel$export($ddbb251d0c4839ae$exports, "calculateShapes", function () { return $ddbb251d0c4839ae$export$4dc1a8917bf18661; });

function $ddbb251d0c4839ae$export$9d843bc97e7022ed(shape, indices, updates) {
    const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
    const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' + `shape[sliceDim:], got updates.shape: ${updates.shape}` + `, indices.shape: ${indices.shape}, shape: ${shape}` + `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
    if (updates.rank < batchDim) throw new Error(shapeError + ` update.rank < ${batchDim}. `);
    if (shape.length < sliceDim + (updates.rank - batchDim)) throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
    if (updates.rank !== batchDim + shape.length - sliceDim) throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
    for(let d = 0; d < batchDim; ++d){
        if (updates.shape[d] !== indices.shape[d]) throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
    }
    for(let d1 = 0; d1 < updates.rank - batchDim; ++d1){
        if (updates.shape[d1 + batchDim] !== shape[d1 + sliceDim]) throw new Error(shapeError + ` updates.shape[${d1 + batchDim}] (${updates.shape[d1 + batchDim]}) != shape[${d1 + batchDim}] (${shape[d1 + batchDim]})`);
    }
}
function $ddbb251d0c4839ae$export$4d09d4ac8ba225dd(updates, indices, shape) {
    if (indices.rank < 1) throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' + ` but the rank was ${indices.rank}.`);
    if (updates.rank < 1) throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' + ` but the rank was ${updates.rank}.`);
    if (indices.dtype !== 'int32') throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
    if (shape.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
    if (shape.length === 0) {
        if (indices.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
        if (updates.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
    }
    $ddbb251d0c4839ae$export$9d843bc97e7022ed(shape, indices, updates);
}
function $ddbb251d0c4839ae$export$4dc1a8917bf18661(updates, indices, shape) {
    // Calculate the number of dimensions in indices
    const indicesRank = indices.shape.length;
    const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
    // Calculate the number of elements that make up each slice of our updated
    // tensor. This allows us to work with flattened tensors and copy over whole
    // slices at a time.
    const totalNd = shape.length;
    let sliceSize = 1;
    for(let i = sliceRank; i < totalNd; ++i)sliceSize *= shape[i];
    const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
    const numUpdates = $904921ed29eeae0f$export$b4c3214a70a0e73f(indices.shape) / safeSliceDim;
    const strides = [
        ...$904921ed29eeae0f$export$6ad0292cf4d50f79(shape.slice(0, sliceRank)),
        1
    ];
    const outputSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(shape);
    return {
        sliceRank: sliceRank,
        numUpdates: numUpdates,
        sliceSize: sliceSize,
        strides: strides,
        outputSize: outputSize
    };
}

var $1a8ddf4b5d32c90c$exports = {};

$parcel$export($1a8ddf4b5d32c90c$exports, "assertParamsValid", function () { return $1a8ddf4b5d32c90c$export$1da6c8ba17e84239; });
$parcel$export($1a8ddf4b5d32c90c$exports, "maskToAxes", function () { return $1a8ddf4b5d32c90c$export$ce8be3e704107015; });
$parcel$export($1a8ddf4b5d32c90c$exports, "computeOutShape", function () { return $1a8ddf4b5d32c90c$export$22fa6b3b1305508e; });
$parcel$export($1a8ddf4b5d32c90c$exports, "stridesWithElidedDims", function () { return $1a8ddf4b5d32c90c$export$7f5fa1173bdb6e15; });
$parcel$export($1a8ddf4b5d32c90c$exports, "getNormalizedAxes", function () { return $1a8ddf4b5d32c90c$export$895fe9252fb79d1; });
$parcel$export($1a8ddf4b5d32c90c$exports, "startIndicesWithElidedDims", function () { return $1a8ddf4b5d32c90c$export$a9f0de12634a4ce3; });
$parcel$export($1a8ddf4b5d32c90c$exports, "stopIndicesWithElidedDims", function () { return $1a8ddf4b5d32c90c$export$19a416bd7e87244f; });
$parcel$export($1a8ddf4b5d32c90c$exports, "startForAxis", function () { return $1a8ddf4b5d32c90c$export$643aca61b9318da8; });
$parcel$export($1a8ddf4b5d32c90c$exports, "stopForAxis", function () { return $1a8ddf4b5d32c90c$export$612a961a199ffe65; });
$parcel$export($1a8ddf4b5d32c90c$exports, "stridesForAxis", function () { return $1a8ddf4b5d32c90c$export$9e3fd91f45c1f07f; });
$parcel$export($1a8ddf4b5d32c90c$exports, "isSliceContinous", function () { return $1a8ddf4b5d32c90c$export$9dc11bd6855e72c6; });
$parcel$export($1a8ddf4b5d32c90c$exports, "computeFlatOffset", function () { return $1a8ddf4b5d32c90c$export$b01553f5da8f819c; });
$parcel$export($1a8ddf4b5d32c90c$exports, "parseSliceParams", function () { return $1a8ddf4b5d32c90c$export$8448a0604fef5d62; });
$parcel$export($1a8ddf4b5d32c90c$exports, "sliceInfo", function () { return $1a8ddf4b5d32c90c$export$54d224865abb6767; });

const $1a8ddf4b5d32c90c$var$NEW_AXIS = -2;
const $1a8ddf4b5d32c90c$var$SHRINK_AXIS = -1;
function $1a8ddf4b5d32c90c$export$1da6c8ba17e84239(input, begin, size) {
    const inputRank = input.shape.length;
    $904921ed29eeae0f$export$a7a9523472993e97(inputRank === begin.length, ()=>`Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(inputRank === size.length, ()=>`Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`
    );
    for(let i = 0; i < inputRank; ++i)$904921ed29eeae0f$export$a7a9523472993e97(begin[i] + size[i] <= input.shape[i], ()=>`Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`
    );
}
function $1a8ddf4b5d32c90c$export$ce8be3e704107015(mask) {
    const axes = [];
    let axis = 0;
    while(mask > 0){
        if (mask & 1) axes.push(axis);
        mask /= 2;
        axis++;
    }
    return axes;
}
function $1a8ddf4b5d32c90c$export$22fa6b3b1305508e(begin, end, strides) {
    const size = [];
    for(let axis = 0; axis < begin.length; axis++)size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
    return size;
}
function $1a8ddf4b5d32c90c$export$7f5fa1173bdb6e15(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
    const newStrides = [
        ...strides
    ];
    for(let i = newStrides.length; i < inputShape.length; i++)newStrides.push(1);
    for(let i1 = 0; i1 < numElidedAxes; i1++)if (i1 === 0) newStrides[ellipsisInsertionIndex] = 1;
    else {
        newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */ , 1 /* element to add */ );
        newStrides.pop();
    }
    return newStrides;
}
function $1a8ddf4b5d32c90c$var$unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
    if (normalizedAxis <= ellipsisInsertionIndex) return normalizedAxis;
    return normalizedAxis - (numElidedAxes - 1);
}
function $1a8ddf4b5d32c90c$var$getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
    const elidedAxes = [];
    for(let i = 0; i < numElidedAxes; i++)elidedAxes.push(ellipsisInsertionIndex + i);
    return elidedAxes;
}
function $1a8ddf4b5d32c90c$export$895fe9252fb79d1(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
    const inputRank = inputShape.length;
    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
    if (ellipsisAxes.length && numInterpolatedAxes > 0) {
        const fullIndex = ellipsisAxes[0];
        // The ellipsis applies to the masked index as well as any dimensions
        // that are interpolated.
        const numElidedAxes = numInterpolatedAxes + 1;
        normalizedBegin = $1a8ddf4b5d32c90c$export$a9f0de12634a4ce3(beginMask, fullIndex, numElidedAxes, begin, inputShape);
        normalizedEnd = $1a8ddf4b5d32c90c$export$19a416bd7e87244f(endMask, fullIndex, numElidedAxes, end, inputShape);
        normalizedStrides = $1a8ddf4b5d32c90c$export$7f5fa1173bdb6e15(strides, fullIndex, numElidedAxes, inputShape);
    } else for(let axis = 0; axis < inputRank; axis++){
        normalizedBegin[axis] = $1a8ddf4b5d32c90c$export$643aca61b9318da8(beginMask, begin, strides, inputShape, axis, ellipsisMask);
        normalizedEnd[axis] = $1a8ddf4b5d32c90c$export$612a961a199ffe65(endMask, end, strides, inputShape, axis, ellipsisMask);
        normalizedStrides[axis] = $1a8ddf4b5d32c90c$export$9e3fd91f45c1f07f(strides, axis, ellipsisMask);
    }
    return {
        begin: normalizedBegin,
        end: normalizedEnd,
        strides: normalizedStrides
    };
}
function $1a8ddf4b5d32c90c$export$a9f0de12634a4ce3(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
    const newIndices = [
        ...inputShape
    ];
    const elidedAxes = $1a8ddf4b5d32c90c$var$getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for(let axis = 0; axis < newIndices.length; axis++)if (elidedAxes.indexOf(axis) > -1) newIndices[axis] = 0;
    else {
        const originalAxis = $1a8ddf4b5d32c90c$var$unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalBegin[originalAxis];
        if (beginMask & 1 << originalAxis) originalValue = 0;
        newIndices[axis] = originalValue;
    }
    return newIndices;
}
function $1a8ddf4b5d32c90c$export$19a416bd7e87244f(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
    const newIndices = [
        ...inputShape
    ];
    const elidedAxes = $1a8ddf4b5d32c90c$var$getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for(let axis = 0; axis < newIndices.length; axis++)if (elidedAxes.indexOf(axis) > -1) newIndices[axis] = Number.MAX_SAFE_INTEGER;
    else {
        const originalAxis = $1a8ddf4b5d32c90c$var$unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalEnd[originalAxis];
        if (endMask & 1 << originalAxis) originalValue = Number.MAX_SAFE_INTEGER;
        newIndices[axis] = originalValue;
    }
    for(let i = 0; i < newIndices.length; i++){
        // Handle negative indices
        const axisSize = inputShape[i];
        if (newIndices[i] < 0) newIndices[i] += axisSize;
        newIndices[i] = $904921ed29eeae0f$export$7d15b64cf5a3a4c4(0, newIndices[i], inputShape[i]);
    }
    return newIndices;
}
function $1a8ddf4b5d32c90c$export$9e3fd91f45c1f07f(strides, axis, ellipsisMask) {
    let stride = strides[axis];
    if (ellipsisMask & 1 << axis || stride == null) stride = 1;
    return stride;
}
function $1a8ddf4b5d32c90c$export$643aca61b9318da8(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
    // Begin with the specified index
    let start = startIndices[axis];
    const stride = strides[axis] || 1;
    // Check the axis bit from right of masked axes, or the begin index is not set
    // for the axis.
    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
        if (stride > 0) // Forward iteration - use the first element. These values will get
        // clamped below (Note: We could have set them to 0 and axis_size-1, but
        // use lowest() and max() to maintain symmetry with StopForAxis())
        start = Number.MIN_SAFE_INTEGER;
        else // Backward iteration - use the last element.
        start = Number.MAX_SAFE_INTEGER;
    }
    // Handle negative indices
    const axisSize = inputShape[axis];
    if (start < 0) start += axisSize;
    // Clamping
    start = $904921ed29eeae0f$export$7d15b64cf5a3a4c4(0, start, axisSize - 1);
    return start;
}
function $1a8ddf4b5d32c90c$export$612a961a199ffe65(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
    // Begin with the specified index
    let stop = stopIndices[axis];
    const stride = strides[axis] || 1;
    // Check the axis bit from right of masked axes, or if the stop index is not
    // set for this axis.
    if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
        if (stride > 0) // Forward iteration - use the last element. These values will get
        // clamped below
        stop = Number.MAX_SAFE_INTEGER;
        else // Backward iteration - use the first element.
        stop = Number.MIN_SAFE_INTEGER;
    }
    // Handle negative indices
    const axisSize = inputShape[axis];
    if (stop < 0) stop += axisSize;
    // Clamping
    // Because the end index points one past the last element, we need slightly
    // different clamping ranges depending on the direction.
    if (stride > 0) // Forward iteration
    stop = $904921ed29eeae0f$export$7d15b64cf5a3a4c4(0, stop, axisSize);
    else // Backward iteration
    stop = $904921ed29eeae0f$export$7d15b64cf5a3a4c4(-1, stop, axisSize - 1);
    return stop;
}
function $1a8ddf4b5d32c90c$export$9dc11bd6855e72c6(shape, begin, size) {
    // Index of the first axis that has size > 1.
    let firstNonOneAxis = size.length;
    for(let i = 0; i < size.length; i++)if (size[i] > 1) {
        firstNonOneAxis = i;
        break;
    }
    for(let i2 = firstNonOneAxis + 1; i2 < size.length; i2++){
        if (begin[i2] > 0 || size[i2] !== shape[i2]) return false;
    }
    return true;
}
function $1a8ddf4b5d32c90c$export$b01553f5da8f819c(begin, strides) {
    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
    for(let i = 0; i < begin.length - 1; i++)flatOffset += begin[i] * strides[i];
    return flatOffset;
}
function $1a8ddf4b5d32c90c$export$8448a0604fef5d62(x, begin, size) {
    // The following logic allows for more ergonomic calls.
    let begin_;
    const xRank = x.shape.length;
    if (typeof begin === 'number') begin_ = [
        begin,
        ...new Array(xRank - 1).fill(0)
    ];
    else if (begin.length < xRank) begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
    else begin_ = begin.slice();
    begin_.forEach((d)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(d !== -1, ()=>'slice() does not support negative begin indexing.'
        );
    });
    let size_;
    if (size == null) size_ = new Array(xRank).fill(-1);
    else if (typeof size === 'number') size_ = [
        size,
        ...new Array(xRank - 1).fill(-1)
    ];
    else if (size.length < xRank) size_ = size.concat(new Array(xRank - size.length).fill(-1));
    else size_ = size;
    size_ = size_.map((d, i)=>{
        if (d >= 0) return d;
        else {
            $904921ed29eeae0f$export$a7a9523472993e97(d === -1, ()=>`Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`
            );
            return x.shape[i] - begin_[i];
        }
    });
    return [
        begin_,
        size_
    ];
}
function $1a8ddf4b5d32c90c$export$54d224865abb6767(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    let stridesNonNull;
    if (strides == null) {
        stridesNonNull = new Array(begin.length);
        stridesNonNull.fill(1);
    } else stridesNonNull = strides;
    // Only one non-zero bit is allowed in ellipsisMask, which means ellipsisMask
    // is a power of 2. Use bit compares to ensure ellipsisMask is 0 or a power
    // of 2. When i is a power of 2, i & (i - 1) is always 0.
    // Also ref:
    // https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2
    if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) throw new Error('Multiple ellipses in slice is not allowed.');
    // Step 1: Account for ellipsis and new axis.
    // Check for ellipsis and count how many non-newaxis there are after.
    let ellipsisSeen = false;
    const sparseSpec = {
        dims: stridesNonNull.length,
        numAddAxisAfterEllipsis: 0,
        begin: begin.slice(),
        end: end.slice(),
        strides: stridesNonNull.slice(),
        beginMask: beginMask,
        endMask: endMask,
        ellipsisMask: ellipsisMask,
        newAxisMask: newAxisMask,
        shrinkAxisMask: shrinkAxisMask
    };
    for(let i4 = 0; i4 < sparseSpec.dims; i4++){
        if (ellipsisSeen && (1 << i4 & newAxisMask) !== 0) sparseSpec.numAddAxisAfterEllipsis++;
        if (1 << i4 & ellipsisMask) ellipsisSeen = true;
    }
    // If no ellipsis insert one at the end.
    if (!ellipsisSeen) {
        sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
        sparseSpec.dims++; // this effects loop iteration below
    }
    // Step 2: Make a sparse spec into a full index spec.
    //
    // The sparse spec deos not correspond to the number of dimensions.
    // Make a dense spec that cooresponds to the number of dimensions.
    //
    // For example suppose foo[...,3:] on foo.shape = [2, 2, 3] then we need to
    // produce the missing beginMask for the first two dimensions i.e. from
    // beginMaskSpec = 0, endMaskSpec = 2, we achieve beginMask = 6 (110),
    // endMask = 7 (111).
    const denseSpec = {
        dims: xShape.length,
        beginMask: 0,
        endMask: 0,
        beginValid: false,
        endValid: false
    };
    $1a8ddf4b5d32c90c$var$buildDenseSpec(sparseSpec, denseSpec);
    // Step 3: Make implicit ranges (non-zero beginMasks and endMasks) explicit
    // and bounds check.
    let isIdentity = true;
    let sliceDim0 = true;
    let isSimpleSlice = true;
    const processingShape = [];
    const finalShape = [];
    for(let i3 = 0; i3 < xShape.length; ++i3){
        if (denseSpec.strides[i3] === 0) throw Error(`strides[${i3}] must be non-zero`);
        const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i3);
        const dimI = xShape[i3];
        if (dimI === -1) {
            processingShape.push(shrinkI ? 1 : -1);
            continue;
        }
        const masks = [
            denseSpec.beginMask & 1 << i3,
            denseSpec.endMask & 1 << i3
        ];
        const validRange = [
            denseSpec.strides[i3] > 0 ? 0 : -1,
            denseSpec.strides[i3] > 0 ? dimI : dimI - 1
        ];
        if (shrinkI && denseSpec.strides[i3] <= 0) throw Error('only stride 1 allowed on non-range indexing.');
        isSimpleSlice = isSimpleSlice && denseSpec.strides[i3] === 1;
        const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i3 && denseSpec.endMask & 1 << i3);
        if (denseSpec.beginValid && denseSpec.endValid) {
            if (shrinkI) {
                // If we are shrinking, the end index is now possibly incorrect. In
                // particular foo[-1] produces sparseBegin = -1, sparseEnd = 0.
                // and canonical puts these to n-1 and 0, which implies a degenerate
                // interval. Fortunately, it is now safe to re-create end as begin + 1.
                const xFwd = denseSpec.begin[i3] < 0 ? dimI + denseSpec.begin[i3] : denseSpec.begin[i3];
                denseSpec.begin[i3] = xFwd;
                denseSpec.end[i3] = denseSpec.begin[i3] + 1;
                if (xFwd < 0 || xFwd >= dimI) throw Error(`slice index ${denseSpec.begin[i3]} of dimension ${i3} out of bounds.`);
            } else {
                denseSpec.begin[i3] = $1a8ddf4b5d32c90c$var$canonical(denseSpec.begin[i3], 0, denseSpec.strides[i3], dimI, masks, validRange);
                denseSpec.end[i3] = $1a8ddf4b5d32c90c$var$canonical(denseSpec.end[i3], 1, denseSpec.strides[i3], dimI, masks, validRange);
            }
            // Update optimization values
            const takeAllInDimension = denseSpec.strides[i3] === 1 && denseSpec.begin[i3] === 0 && denseSpec.end[i3] === dimI;
            isIdentity = isIdentity && takeAllInDimension;
            sliceDim0 = sliceDim0 && (i3 === 0 && denseSpec.strides[i3] === 1 || takeAllInDimension);
        } else {
            isIdentity = isIdentity && denseSpec.strides[i3] === 1 && beginAndEndMasked;
            sliceDim0 = sliceDim0 && (i3 === 0 && denseSpec.strides[i3] === 1 || beginAndEndMasked);
        }
        // Compute the processing shape (the intermediate Eigen will produce)
        let intervalLength;
        let knownInterval = false;
        if (denseSpec.beginValid && denseSpec.endValid) {
            intervalLength = denseSpec.end[i3] - denseSpec.begin[i3];
            knownInterval = true;
        } else if (shrinkI) {
            // The dimension is still known as 1 for the processingShape, but will be
            // discarded for the final shape.
            intervalLength = 1;
            knownInterval = true;
        } else if (beginAndEndMasked) // Even if we don't have values for begin or end, we do know that this
        // dimension covers the whole interval. If we have shape information for
        // this dimension, that tells us the interval length.
        {
            if (dimI >= 0) {
                if (denseSpec.strides[i3] < 0) intervalLength = -dimI;
                else intervalLength = dimI;
                knownInterval = true;
            }
        }
        if (knownInterval) {
            let sizeI;
            // Hold zero if the interval is degenerate, otherwise account for
            // remainder
            if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i3] < 0) sizeI = 0;
            else sizeI = Math.trunc(intervalLength / denseSpec.strides[i3]) + (intervalLength % denseSpec.strides[i3] !== 0 ? 1 : 0);
            processingShape.push(sizeI);
        } else processingShape.push(-1);
    }
    // Step 4: Compute the final shape
    //
    // newAxis will increase dimension by 1 (with a one-size dimension)
    // slices like foo[3, ...] will reduce dimension by 1.
    // This cannot be done earlier, because it depends on Step 3.
    for(let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim){
        const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
        if (gatherIndex >= 0) finalShape.push(processingShape[gatherIndex]);
        else if (gatherIndex === $1a8ddf4b5d32c90c$var$NEW_AXIS) finalShape.push(1);
    }
    const finalShapeSparse = finalShape.filter((dim, i)=>denseSpec.finalShapeGatherIndices[i] !== $1a8ddf4b5d32c90c$var$NEW_AXIS
    );
    return {
        finalShapeSparse: finalShapeSparse,
        finalShape: finalShape,
        isIdentity: isIdentity,
        sliceDim0: sliceDim0,
        isSimpleSlice: isSimpleSlice,
        begin: denseSpec.begin,
        end: denseSpec.end,
        strides: denseSpec.strides
    };
}
function $1a8ddf4b5d32c90c$var$buildDenseSpec(sparse, dense) {
    dense.beginMask = 0;
    dense.endMask = 0;
    dense.shrinkAxisMask = 0;
    let fullIndex = 0;
    dense.beginValid = sparse.begin != null;
    dense.endValid = sparse.end != null;
    dense.begin = new Array(dense.dims);
    dense.end = new Array(dense.dims);
    dense.strides = new Array(dense.dims);
    dense.finalShapeGatherIndices = [];
    dense.finalShapeGatherIndicesSparse = [];
    dense.inputShapeGatherIndicesSparse = new Array(dense.dims);
    for(let i = 0; i < sparse.dims; i++){
        if (1 << i & sparse.ellipsisMask) {
            // Only the bit that has ellipsis will fall in this condition.
            // Expand the ellipsis into the appropriate indices
            // Note: this only works because we guaranteed one ellipsis.
            const nextIndex = Math.min(dense.dims - (sparse.dims - i) + 1 + sparse.numAddAxisAfterEllipsis, dense.dims);
            for(; fullIndex < nextIndex; fullIndex++){
                // newAxis aren't real axis so you have to skip.
                dense.begin[fullIndex] = 0;
                dense.end[fullIndex] = 0;
                dense.strides[fullIndex] = 1;
                dense.beginMask |= 1 << fullIndex;
                dense.endMask |= 1 << fullIndex;
                dense.finalShapeGatherIndices.push(fullIndex);
                dense.finalShapeGatherIndicesSparse.push(-1);
                dense.inputShapeGatherIndicesSparse[fullIndex] = i;
            }
        } else if (1 << i & sparse.newAxisMask) {
            // Only the bit that has newAxis will fall in this condition.
            dense.finalShapeGatherIndices.push($1a8ddf4b5d32c90c$var$NEW_AXIS);
            dense.finalShapeGatherIndicesSparse.push(-1);
        } else {
            if (fullIndex === dense.begin.length) throw Error(`Index out of range using input dim ${fullIndex}; input ` + `has only ${dense.dims} dims, ${dense.begin.length}.`);
            // Gather slicing spec into appropriate index.
            if (sparse.begin != null) dense.begin[fullIndex] = sparse.begin[i];
            if (sparse.end != null) dense.end[fullIndex] = sparse.end[i];
            dense.strides[fullIndex] = sparse.strides[i];
            if (sparse.beginMask & 1 << i) dense.beginMask |= 1 << fullIndex;
            if (sparse.endMask & 1 << i) dense.endMask |= 1 << fullIndex;
            // If shrink, record where to get the dimensionality from (i.e. newAxis)
            // creates a fake 1 size dimension. Also remember shrink axis (now in
            // dense form) so we can ignore dense.end below.
            if (sparse.shrinkAxisMask & 1 << i) {
                dense.finalShapeGatherIndices.push($1a8ddf4b5d32c90c$var$SHRINK_AXIS);
                dense.finalShapeGatherIndicesSparse.push(-1);
                dense.shrinkAxisMask |= 1 << fullIndex;
            } else {
                dense.finalShapeGatherIndices.push(fullIndex);
                // Remember that where in the sparse shape the dense dim comes from.
                dense.finalShapeGatherIndicesSparse.push(i);
            }
            dense.inputShapeGatherIndicesSparse[fullIndex] = i;
            fullIndex++;
        }
    }
}
function $1a8ddf4b5d32c90c$var$canonical(x, c, strideI, dimI, masks, validRange) {
    if (masks[c]) return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];
    else {
        const xFwd = x < 0 ? dimI + x : x; // make negative indices positive
        return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
    }
}

var $510a55f99d61727a$exports = {};

$parcel$export($510a55f99d61727a$exports, "fromUint8ToStringArray", function () { return $510a55f99d61727a$export$debaff328bdca650; });
$parcel$export($510a55f99d61727a$exports, "fromStringArrayToUint8", function () { return $510a55f99d61727a$export$ce1f4ec5bdd0ab9a; });
$parcel$export($510a55f99d61727a$exports, "slice_util", function () { return $1a8ddf4b5d32c90c$exports; });
$parcel$export($510a55f99d61727a$exports, "upcastType", function () { return $993b52a5dd76e458$export$7bcca02d1a156bdf; });
$parcel$export($510a55f99d61727a$exports, "segment_util", function () { return $cce5b68b95ab801d$exports; });


var $cce5b68b95ab801d$exports = {};

$parcel$export($cce5b68b95ab801d$exports, "segOpComputeOptimalWindowSize", function () { return $cce5b68b95ab801d$export$6ef0c7b128709ff; });
$parcel$export($cce5b68b95ab801d$exports, "computeOutShape", function () { return $cce5b68b95ab801d$export$22fa6b3b1305508e; });
$parcel$export($cce5b68b95ab801d$exports, "collectGatherOpShapeInfo", function () { return $cce5b68b95ab801d$export$fa9ad97afacf8191; });

var $239c3e1401044fa1$exports = {};

$parcel$export($239c3e1401044fa1$exports, "PARALLELIZE_THRESHOLD", function () { return $239c3e1401044fa1$export$ee3544492fe530f6; });
$parcel$export($239c3e1401044fa1$exports, "computeOptimalWindowSize", function () { return $239c3e1401044fa1$export$ee795473f4c8fb04; });

const $239c3e1401044fa1$export$ee3544492fe530f6 = 30;
function $239c3e1401044fa1$export$ee795473f4c8fb04(inSize) {
    if (inSize <= $239c3e1401044fa1$export$ee3544492fe530f6) return inSize;
    return $904921ed29eeae0f$export$c0ff3276320ddb5e(inSize, Math.floor(Math.sqrt(inSize)));
}


function $cce5b68b95ab801d$export$6ef0c7b128709ff(inSize, numSegments) {
    let done = false;
    let res;
    if (inSize <= $239c3e1401044fa1$export$ee3544492fe530f6) {
        res = inSize;
        done = true;
    } else res = $904921ed29eeae0f$export$c0ff3276320ddb5e(inSize, Math.floor(Math.sqrt(inSize)));
    while(!done)if (res > numSegments || res === inSize) done = true;
    else res = $904921ed29eeae0f$export$c0ff3276320ddb5e(inSize, res + 1);
    return res;
}
function $cce5b68b95ab801d$export$22fa6b3b1305508e(aShape, axis, numSegments) {
    const outShape = [];
    const rank = aShape.length;
    for(let dim = 0; dim < rank; dim++)if (dim !== axis) outShape.push(aShape[dim]);
    else outShape.push(numSegments);
    return outShape;
}
function $cce5b68b95ab801d$export$fa9ad97afacf8191(x, indices, axis, batchDims) {
    const indicesRank = indices.shape.length;
    const xRank = x.shape.length;
    if (batchDims !== 0) {
        if (batchDims < -indicesRank || batchDims > indicesRank) throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
    }
    if (batchDims < 0) batchDims += indicesRank;
    if (batchDims > xRank) throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
    if (axis < batchDims) throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
    for(let i = 0; i < batchDims; ++i){
        if (x.shape[i] !== indices.shape[i]) throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
    }
    const dimSize = x.shape[axis];
    const outputShape = [];
    let batchSize = 1;
    let outerSize = 1;
    let sliceSize = 1;
    for(let i1 = 0; i1 < batchDims; ++i1){
        outputShape.push(x.shape[i1]);
        batchSize *= x.shape[i1];
    }
    for(let i2 = batchDims; i2 < axis; i2++){
        outputShape.push(x.shape[i2]);
        outerSize *= x.shape[i2];
    }
    for(let i3 = batchDims; i3 < indicesRank; i3++)outputShape.push(indices.shape[i3]);
    for(let i4 = axis + 1; i4 < xRank; i4++){
        outputShape.push(x.shape[i4]);
        sliceSize *= x.shape[i4];
    }
    return {
        batchSize: batchSize,
        sliceSize: sliceSize,
        outerSize: outerSize,
        dimSize: dimSize,
        outputShape: outputShape
    };
}


var $0732cb950311b962$exports = {};

$parcel$export($0732cb950311b962$exports, "axesAreInnerMostDims", function () { return $0732cb950311b962$export$fcf762ecdaba1fc1; });
$parcel$export($0732cb950311b962$exports, "combineLocations", function () { return $0732cb950311b962$export$6cfee5a53150f612; });
$parcel$export($0732cb950311b962$exports, "computeOutAndReduceShapes", function () { return $0732cb950311b962$export$68ecd7df33283881; });
$parcel$export($0732cb950311b962$exports, "expandShapeToKeepDim", function () { return $0732cb950311b962$export$e35db9afe008d7e3; });
$parcel$export($0732cb950311b962$exports, "assertAxesAreInnerMostDims", function () { return $0732cb950311b962$export$f83b6b93f3b44c9c; });
$parcel$export($0732cb950311b962$exports, "getAxesPermutation", function () { return $0732cb950311b962$export$d2a6288eef79b310; });
$parcel$export($0732cb950311b962$exports, "getUndoAxesPermutation", function () { return $0732cb950311b962$export$2975b40e45f30ba8; });
$parcel$export($0732cb950311b962$exports, "getInnerMostAxes", function () { return $0732cb950311b962$export$b62922ed36931ab6; });

function $0732cb950311b962$export$fcf762ecdaba1fc1(axes, rank) {
    for(let i = 0; i < axes.length; ++i){
        if (axes[axes.length - i - 1] !== rank - 1 - i) return false;
    }
    return true;
}
function $0732cb950311b962$export$6cfee5a53150f612(outputLoc, reduceLoc, axes) {
    const rank = outputLoc.length + reduceLoc.length;
    const loc = [];
    let outIdx = 0;
    let reduceIdx = 0;
    for(let dim = 0; dim < rank; dim++)if (axes.indexOf(dim) === -1) loc.push(outputLoc[outIdx++]);
    else loc.push(reduceLoc[reduceIdx++]);
    return loc;
}
function $0732cb950311b962$export$68ecd7df33283881(aShape, axes) {
    const outShape = [];
    const rank = aShape.length;
    for(let dim1 = 0; dim1 < rank; dim1++)if (axes.indexOf(dim1) === -1) outShape.push(aShape[dim1]);
    const reduceShape = axes.map((dim)=>aShape[dim]
    );
    return [
        outShape,
        reduceShape
    ];
}
function $0732cb950311b962$export$e35db9afe008d7e3(shape, axes) {
    const reduceSubShape = axes.map((x)=>1
    );
    return $0732cb950311b962$export$6cfee5a53150f612(shape, reduceSubShape, axes);
}
function $0732cb950311b962$export$f83b6b93f3b44c9c(msg, axes, rank) {
    $904921ed29eeae0f$export$a7a9523472993e97($0732cb950311b962$export$fcf762ecdaba1fc1(axes, rank), ()=>`${msg} supports only inner-most axes for now. ` + `Got axes ${axes} and rank-${rank} input.`
    );
}
function $0732cb950311b962$export$d2a6288eef79b310(axes, rank) {
    if ($0732cb950311b962$export$fcf762ecdaba1fc1(axes, rank)) return null;
    const result = [];
    for(let i = 0; i < rank; ++i)if (axes.indexOf(i) === -1) result.push(i);
    axes.forEach((axis)=>result.push(axis)
    );
    return result;
}
function $0732cb950311b962$export$2975b40e45f30ba8(axes) {
    return axes.map((axis, i)=>[
            i,
            axis
        ]
    ).sort((a, b)=>a[1] - b[1]
    ).map((x)=>x[0]
    );
}
function $0732cb950311b962$export$b62922ed36931ab6(numAxes, rank) {
    const res = [];
    for(let i = rank - numAxes; i < rank; ++i)res.push(i);
    return res;
}



var $03d556d29f93f0f5$exports = {};

$parcel$export($03d556d29f93f0f5$exports, "assertParamsConsistent", function () { return $03d556d29f93f0f5$export$ce1cccab5e7518dd; });
$parcel$export($03d556d29f93f0f5$exports, "computeOutShape", function () { return $03d556d29f93f0f5$export$22fa6b3b1305508e; });

function $03d556d29f93f0f5$export$ce1cccab5e7518dd(shapes, axis) {
    const rank = shapes[0].length;
    shapes.forEach((shape, i)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(shape.length === rank, ()=>`Error in concat${rank}D: rank of tensors[${i}] must be the same ` + `as the rank of the rest (${rank})`
        );
    });
    $904921ed29eeae0f$export$a7a9523472993e97(axis >= 0 && axis < rank, ()=>`Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`
    );
    const firstShape = shapes[0];
    shapes.forEach((shape, i)=>{
        for(let r = 0; r < rank; r++)$904921ed29eeae0f$export$a7a9523472993e97(r === axis || shape[r] === firstShape[r], ()=>`Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` + `does not match the shape of the rest (${firstShape}) ` + `along the non-concatenated axis ${i}.`
        );
    });
}
function $03d556d29f93f0f5$export$22fa6b3b1305508e(shapes, axis) {
    const outputShape = shapes[0].slice();
    for(let i = 1; i < shapes.length; i++)outputShape[axis] += shapes[i][axis];
    return outputShape;
}


var $d3eadf2cbd3cb093$exports = {};

$parcel$export($d3eadf2cbd3cb093$exports, "computeDilation2DInfo", function () { return $d3eadf2cbd3cb093$export$24e8a5cb688b9852; });
$parcel$export($d3eadf2cbd3cb093$exports, "convertConv2DDataFormat", function () { return $d3eadf2cbd3cb093$export$1641c6bb3eb9a5b4; });
$parcel$export($d3eadf2cbd3cb093$exports, "computeConv2DInfo", function () { return $d3eadf2cbd3cb093$export$fdd37387e0a3c672; });
$parcel$export($d3eadf2cbd3cb093$exports, "computePool2DInfo", function () { return $d3eadf2cbd3cb093$export$67e321f77840205c; });
$parcel$export($d3eadf2cbd3cb093$exports, "computePool3DInfo", function () { return $d3eadf2cbd3cb093$export$1382473b2833755b; });
$parcel$export($d3eadf2cbd3cb093$exports, "computeConv3DInfo", function () { return $d3eadf2cbd3cb093$export$e4819ceef3994d7b; });
$parcel$export($d3eadf2cbd3cb093$exports, "computeDefaultPad", function () { return $d3eadf2cbd3cb093$export$670354fdcb16da70; });
$parcel$export($d3eadf2cbd3cb093$exports, "tupleValuesAreOne", function () { return $d3eadf2cbd3cb093$export$f16174446c2d5b2a; });
$parcel$export($d3eadf2cbd3cb093$exports, "eitherStridesOrDilationsAreOne", function () { return $d3eadf2cbd3cb093$export$1e13dbff91e2f5ca; });
$parcel$export($d3eadf2cbd3cb093$exports, "checkPadOnDimRoundingMode", function () { return $d3eadf2cbd3cb093$export$1b3400c26a44af8; });

function $d3eadf2cbd3cb093$export$24e8a5cb688b9852(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {
    // `computerConv2DInfo` require filterShape to be in the dimension of:
    // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have
    // outDepth, it should have the same depth as the input.
    // Input shape: [batch, height, width, inChannels]
    const inputChannels = inputShape[3];
    const $filterShape = [
        ...filterShape,
        inputChannels
    ];
    const $dataFormat = $d3eadf2cbd3cb093$export$1641c6bb3eb9a5b4(dataFormat);
    return $d3eadf2cbd3cb093$export$fdd37387e0a3c672(inputShape, $filterShape, strides, dilations, pad, null, null, $dataFormat);
}
function $d3eadf2cbd3cb093$export$67e321f77840205c(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {
    const [filterHeight, filterWidth] = $d3eadf2cbd3cb093$var$parseTupleParam(filterSize);
    let filterShape;
    if (dataFormat === 'channelsLast') filterShape = [
        filterHeight,
        filterWidth,
        inShape[3],
        inShape[3]
    ];
    else if (dataFormat === 'channelsFirst') filterShape = [
        filterHeight,
        filterWidth,
        inShape[1],
        inShape[1]
    ];
    else throw new Error(`Unknown dataFormat ${dataFormat}`);
    return $d3eadf2cbd3cb093$export$fdd37387e0a3c672(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
function $d3eadf2cbd3cb093$export$1382473b2833755b(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {
    const [filterDepth, filterHeight, filterWidth] = $d3eadf2cbd3cb093$var$parse3TupleParam(filterSize);
    let filterShape;
    let $dataFormat;
    if (dataFormat === 'NDHWC') {
        $dataFormat = 'channelsLast';
        filterShape = [
            filterDepth,
            filterHeight,
            filterWidth,
            inShape[4],
            inShape[4]
        ];
    } else if (dataFormat === 'NCDHW') {
        $dataFormat = 'channelsFirst';
        filterShape = [
            filterDepth,
            filterHeight,
            filterWidth,
            inShape[1],
            inShape[1]
        ];
    } else throw new Error(`Unknown dataFormat ${dataFormat}`);
    return $d3eadf2cbd3cb093$export$e4819ceef3994d7b(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);
}
function $d3eadf2cbd3cb093$export$fdd37387e0a3c672(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {
    let [batchSize, inHeight, inWidth, inChannels] = [
        -1,
        -1,
        -1,
        -1
    ];
    if (dataFormat === 'channelsLast') [batchSize, inHeight, inWidth, inChannels] = inShape;
    else if (dataFormat === 'channelsFirst') [batchSize, inChannels, inHeight, inWidth] = inShape;
    else throw new Error(`Unknown dataFormat ${dataFormat}`);
    const [filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideHeight, strideWidth] = $d3eadf2cbd3cb093$var$parseTupleParam(strides);
    const [dilationHeight, dilationWidth] = $d3eadf2cbd3cb093$var$parseTupleParam(dilations);
    const effectiveFilterHeight = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo: padInfo , outHeight: outHeight , outWidth: outWidth  } = $d3eadf2cbd3cb093$var$getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === 'channelsFirst') outShape = [
        batchSize,
        outChannels,
        outHeight,
        outWidth
    ];
    else if (dataFormat === 'channelsLast') outShape = [
        batchSize,
        outHeight,
        outWidth,
        outChannels
    ];
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        effectiveFilterHeight: effectiveFilterHeight,
        effectiveFilterWidth: effectiveFilterWidth,
        dilationHeight: dilationHeight,
        dilationWidth: dilationWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
function $d3eadf2cbd3cb093$export$e4819ceef3994d7b(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {
    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [
        -1,
        -1,
        -1,
        -1,
        -1
    ];
    if (dataFormat === 'channelsLast') [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
    else if (dataFormat === 'channelsFirst') [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
    else throw new Error(`Unknown dataFormat ${dataFormat}`);
    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideDepth, strideHeight, strideWidth] = $d3eadf2cbd3cb093$var$parse3TupleParam(strides);
    const [dilationDepth, dilationHeight, dilationWidth] = $d3eadf2cbd3cb093$var$parse3TupleParam(dilations);
    const effectiveFilterDepth = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterDepth, dilationDepth);
    const effectiveFilterHeight = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo: padInfo , outDepth: outDepth , outHeight: outHeight , outWidth: outWidth  } = $d3eadf2cbd3cb093$var$get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === 'channelsFirst') outShape = [
        batchSize,
        outChannels,
        outDepth,
        outHeight,
        outWidth
    ];
    else if (dataFormat === 'channelsLast') outShape = [
        batchSize,
        outDepth,
        outHeight,
        outWidth,
        outChannels
    ];
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inDepth: inDepth,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outDepth: outDepth,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideDepth: strideDepth,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterDepth: filterDepth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        effectiveFilterDepth: effectiveFilterDepth,
        effectiveFilterHeight: effectiveFilterHeight,
        effectiveFilterWidth: effectiveFilterWidth,
        dilationDepth: dilationDepth,
        dilationHeight: dilationHeight,
        dilationWidth: dilationWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
function $d3eadf2cbd3cb093$var$computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
    if (zeroPad == null) zeroPad = $d3eadf2cbd3cb093$export$670354fdcb16da70(inShape, fieldSize, stride);
    const inputRows = inShape[0];
    const inputCols = inShape[1];
    const outputRows = $d3eadf2cbd3cb093$var$round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = $d3eadf2cbd3cb093$var$round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [
        outputRows,
        outputCols
    ];
}
function $d3eadf2cbd3cb093$var$computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
    if (zeroPad == null) zeroPad = $d3eadf2cbd3cb093$export$670354fdcb16da70(inShape, fieldSize, stride);
    const inputDepth = inShape[0];
    const inputRows = inShape[1];
    const inputCols = inShape[2];
    const outputDepths = $d3eadf2cbd3cb093$var$round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputRows = $d3eadf2cbd3cb093$var$round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = $d3eadf2cbd3cb093$var$round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [
        outputDepths,
        outputRows,
        outputCols,
        outChannels
    ];
}
function $d3eadf2cbd3cb093$export$670354fdcb16da70(inputShape, fieldSize, stride, dilation = 1) {
    const effectiveFieldSize = $d3eadf2cbd3cb093$var$getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function $d3eadf2cbd3cb093$var$parseTupleParam(param) {
    if (typeof param === 'number') return [
        param,
        param,
        param
    ];
    if (param.length === 2) return [
        param[0],
        param[1],
        1
    ];
    return param;
}
function $d3eadf2cbd3cb093$var$parse3TupleParam(param) {
    return typeof param === 'number' ? [
        param,
        param,
        param
    ] : param;
}
/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d
 * Atrous convolution is equivalent to standard convolution with upsampled
 * filters with effective_filter_height =
 * filter_height + (filter_height - 1) * (dilation - 1)
 * and effective_filter_width =
 * filter_width + (filter_width - 1) * (dilation - 1),
 * produced by inserting dilation - 1 zeros along consecutive elements across
 * the filters' spatial dimensions.
 * When there is a dilation, this converts a filter dimension to the
 * effective filter dimension, so it can be used in a standard convolution.
 */ function $d3eadf2cbd3cb093$var$getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) return filterSize;
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function $d3eadf2cbd3cb093$var$getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
    let padInfo;
    let outHeight;
    let outWidth;
    if (typeof pad === 'number') {
        const padType = pad === 0 ? 'VALID' : 'NUMBER';
        padInfo = {
            top: pad,
            bottom: pad,
            left: pad,
            right: pad,
            type: padType
        };
        const outShape = $d3eadf2cbd3cb093$var$computeOutputShape2D([
            inHeight,
            inWidth
        ], filterHeight, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    } else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
        const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = {
            top: top,
            bottom: bottom,
            left: left,
            right: right,
            type: 'SAME'
        };
    } else if (pad === 'valid') {
        padInfo = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            type: 'VALID'
        };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else if (typeof pad === 'object') {
        const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];
        const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];
        const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];
        const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];
        const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? 'VALID' : 'EXPLICIT';
        padInfo = {
            top: top,
            bottom: bottom,
            left: left,
            right: right,
            type: padType
        };
        outHeight = $d3eadf2cbd3cb093$var$round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
        outWidth = $d3eadf2cbd3cb093$var$round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
    } else throw Error(`Unknown padding parameter: ${pad}`);
    return {
        padInfo: padInfo,
        outHeight: outHeight,
        outWidth: outWidth
    };
}
function $d3eadf2cbd3cb093$var$get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
    let padInfo;
    let outDepth;
    let outHeight;
    let outWidth;
    if (typeof pad === 'number') {
        const padType = pad === 0 ? 'VALID' : 'NUMBER';
        padInfo = {
            top: pad,
            bottom: pad,
            left: pad,
            right: pad,
            front: pad,
            back: pad,
            type: padType
        };
        const outShape = $d3eadf2cbd3cb093$var$computeOutputShape4D([
            inDepth,
            inHeight,
            inWidth,
            1
        ], filterDepth, 1, strideDepth, pad, roundingMode);
        outDepth = outShape[0];
        outHeight = outShape[1];
        outWidth = outShape[2];
    } else if (pad === 'same') {
        outDepth = Math.ceil(inDepth / strideDepth);
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
        const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        const front = Math.floor(padAlongDepth / 2);
        const back = padAlongDepth - front;
        const top = Math.floor(padAlongHeight / 2);
        const bottom = padAlongHeight - top;
        const left = Math.floor(padAlongWidth / 2);
        const right = padAlongWidth - left;
        padInfo = {
            top: top,
            bottom: bottom,
            left: left,
            right: right,
            front: front,
            back: back,
            type: 'SAME'
        };
    } else if (pad === 'valid') {
        padInfo = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            front: 0,
            back: 0,
            type: 'VALID'
        };
        outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else throw Error(`Unknown padding parameter: ${pad}`);
    return {
        padInfo: padInfo,
        outDepth: outDepth,
        outHeight: outHeight,
        outWidth: outWidth
    };
}
/**
 * Rounds a value depending on the rounding mode
 * @param value
 * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is
 *     provided, it will default to truncate.
 */ function $d3eadf2cbd3cb093$var$round(value, roundingMode) {
    if (!roundingMode) return Math.trunc(value);
    switch(roundingMode){
        case 'round':
            // used for Caffe Conv
            return Math.round(value);
        case 'ceil':
            // used for Caffe Pool
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error(`Unknown roundingMode ${roundingMode}`);
    }
}
function $d3eadf2cbd3cb093$export$f16174446c2d5b2a(param) {
    const [dimA, dimB, dimC] = $d3eadf2cbd3cb093$var$parseTupleParam(param);
    return dimA === 1 && dimB === 1 && dimC === 1;
}
function $d3eadf2cbd3cb093$export$1e13dbff91e2f5ca(strides, dilations) {
    return $d3eadf2cbd3cb093$export$f16174446c2d5b2a(strides) || $d3eadf2cbd3cb093$export$f16174446c2d5b2a(dilations);
}
function $d3eadf2cbd3cb093$export$1641c6bb3eb9a5b4(dataFormat) {
    if (dataFormat === 'NHWC') return 'channelsLast';
    else if (dataFormat === 'NCHW') return 'channelsFirst';
    else throw new Error(`Unknown dataFormat ${dataFormat}`);
}
function $d3eadf2cbd3cb093$export$1b3400c26a44af8(opDesc, pad, dimRoundingMode) {
    if (dimRoundingMode != null) {
        if (typeof pad === 'string') throw Error(`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
        else if (typeof pad === 'number') $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$357fc28f6427af8b(pad), ()=>`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`
        );
        else if (typeof pad === 'object') pad.forEach((p)=>{
            p.forEach((v)=>{
                $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$357fc28f6427af8b(v), ()=>`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`
                );
            });
        });
        else throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);
    }
}


var $9573406eea6a3a06$exports = {};

$parcel$export($9573406eea6a3a06$exports, "getFusedDyActivation", function () { return $9573406eea6a3a06$export$a1905aed55f51aef; });
$parcel$export($9573406eea6a3a06$exports, "getFusedBiasGradient", function () { return $9573406eea6a3a06$export$1a797e236ae09d1f; });
$parcel$export($9573406eea6a3a06$exports, "applyActivation", function () { return $9573406eea6a3a06$export$a0f250a2ba84196; });
$parcel$export($9573406eea6a3a06$exports, "shouldFuse", function () { return $9573406eea6a3a06$export$4904add493b957ab; });





/**
 * Computes exponential linear element-wise: `x > 0 ? x : (e ^ x) - 1`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 1, -3, 2]);
 *
 * x.elu().print();  // or tf.elu(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $010a82e4fb14a2ed$var$elu_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'elu', 'float32');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$64636e173424d83d, inputs);
}
const $010a82e4fb14a2ed$export$796b583dd79d8524 = $9e60b70ce0353b32$export$f59964a629598e2({
    elu_: $010a82e4fb14a2ed$var$elu_
});






/**
 * Computes leaky rectified linear element-wise.
 *
 * See
 * [http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](
 *     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)
 * ```
 * @param x The input tensor.
 * @param alpha The scaling factor for negative values, defaults to 0.2.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $52323954d8a43e69$var$leakyRelu_(x, alpha = 0.2) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'leakyRelu');
    const inputs = {
        x: $x
    };
    const attrs = {
        alpha: alpha
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$f0c7162bb7af1a2d, inputs, attrs);
}
const $52323954d8a43e69$export$23a860e40a2c6b61 = $9e60b70ce0353b32$export$f59964a629598e2({
    leakyRelu_: $52323954d8a43e69$var$leakyRelu_
});







/**
 * Multiplies two `tf.Tensor`s element-wise, A * B. Supports broadcasting.
 *
 * We also expose `tf.mulStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.tensor1d([2, 3, 4, 5]);
 *
 * a.mul(b).print();  // or tf.mul(a, b)
 * ```
 *
 * ```js
 * // Broadcast mul a with b.
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.scalar(5);
 *
 * a.mul(b).print();  // or tf.mul(a, b)
 * ```
 * @param a The first tensor to multiply.
 * @param b The second tensor to multiply. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $51103026006cddca$var$mul_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'mul');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'mul');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$f14f83b3b531d498, inputs);
}
const $51103026006cddca$export$6e3a27864ab166fe = $9e60b70ce0353b32$export$f59964a629598e2({
    mul_: $51103026006cddca$var$mul_
});






/**
 * Computes leaky rectified linear element-wise with parametric alphas.
 *
 * `x < 0 ? alpha * x : f(x) = x`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 * const alpha = tf.scalar(0.1);
 *
 * x.prelu(alpha).print();  // or tf.prelu(x, alpha)
 * ```
 * @param x The input tensor.
 * @param alpha Scaling factor for negative values.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $18a4f2fe019cf2e0$var$prelu_(x, alpha) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'prelu');
    const $alpha = $d7ebc35f1f4a180c$export$ede379c4c939d71a(alpha, 'alpha', 'prelu');
    const inputs = {
        x: $x,
        alpha: $alpha
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$a42f35f308fc2fa3, inputs);
}
const $18a4f2fe019cf2e0$export$5882f235222e6729 = $9e60b70ce0353b32$export$f59964a629598e2({
    prelu_: $18a4f2fe019cf2e0$var$prelu_
});






/**
 * Computes rectified linear element-wise: `max(x, 0)`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.relu().print();  // or tf.relu(x)
 * ```
 * @param x The input tensor. If the dtype is `bool`, the output dtype will be
 *     `int32'.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $c55220628ab79485$var$relu_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'relu');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$9a6ff968bf961432, inputs);
}
const $c55220628ab79485$export$16d1e4612cc0139f = $9e60b70ce0353b32$export$f59964a629598e2({
    relu_: $c55220628ab79485$var$relu_
});






/**
 * Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 8]);
 *
 * x.relu6().print();  // or tf.relu6(x)
 * ```
 * @param x The input tensor. If the dtype is `bool`, the output dtype will be
 *     `int32'.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $c1dd63ba62a71ccf$var$relu6_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'relu6');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$3be9e924f629054e, inputs);
}
const $c1dd63ba62a71ccf$export$4a62bcb95e9c44c4 = $9e60b70ce0353b32$export$f59964a629598e2({
    relu6_: $c1dd63ba62a71ccf$var$relu6_
});






/**
 * Reshapes a `tf.Tensor` to a given shape.
 *
 * Given an input tensor, returns a new tensor with the same values as the
 * input tensor with shape `shape`.
 *
 * If one component of shape is the special value -1, the size of that
 * dimension is computed so that the total size remains constant. In
 * particular, a shape of [-1] flattens into 1-D. At most one component of
 * shape can be -1.
 *
 * If shape is 1-D or higher, then the operation returns a tensor with shape
 * shape filled with the values of tensor. In this case, the number of
 * elements implied by shape must be the same as the number of elements in
 * tensor.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * x.reshape([2, 2]).print();
 * ```
 *
 * @param x The input tensor to be reshaped.
 * @param shape An array of integers defining the output tensor shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */ function $98803384c5ab66ad$var$reshape_(x, shape) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'reshape', 'string_or_numeric');
    const inputs = {
        x: $x
    };
    const attrs = {
        shape: shape
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$755ddd847e5abe03, inputs, attrs);
}
const $98803384c5ab66ad$export$9eaad88cf88cee2b = $9e60b70ce0353b32$export$f59964a629598e2({
    reshape_: $98803384c5ab66ad$var$reshape_
});






/**
 * Computes sigmoid element-wise, `1 / (1 + exp(-x))`
 *
 * ```js
 * const x = tf.tensor1d([0, -1, 2, -3]);
 *
 * x.sigmoid().print();  // or tf.sigmoid(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $5c433a9400a3ea22$var$sigmoid_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'sigmoid', 'float32');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$fde18c826dda6b1b, inputs);
}
const $5c433a9400a3ea22$export$3b295495ca3cad7c = $9e60b70ce0353b32$export$f59964a629598e2({
    sigmoid_: $5c433a9400a3ea22$var$sigmoid_
});






/**
 * Computes step of the input `tf.Tensor` element-wise: `x > 0 ? 1 : alpha * x`
 *
 * ```js
 * const x = tf.tensor1d([0, 2, -1, -3]);
 *
 * x.step(.5).print();  // or tf.step(x, .5)
 * ```
 * @param x The input tensor.
 * @param alpha The gradient when input is negative.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $4903e66ca3de96a8$var$step_(x, alpha = 0.0) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'step');
    const inputs = {
        x: $x
    };
    const attrs = {
        alpha: alpha
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$fd55ce593607084a, inputs, attrs);
}
const $4903e66ca3de96a8$export$35d34bc0ed591a92 = $9e60b70ce0353b32$export$f59964a629598e2({
    step_: $4903e66ca3de96a8$var$step_
});







/**
 * Computes the sum of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If axes has no entries, all dimensions are reduced, and a
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.sum().print();  // or tf.sum(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.sum(axis).print();  // or tf.sum(x, axis)
 * ```
 *
 * @param x The input tensor to compute the sum over. If the dtype is `bool`
 *   it will be converted to `int32` and the output dtype will be `int32`.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $f082be780698e75d$var$sum_(x, axis = null, keepDims = false) {
    let $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'sum');
    if ($x.dtype === 'bool') $x = $939ec2f1ca32d2a1$export$f2db7d5238e1d23f($x, 'int32');
    const inputs = {
        x: $x
    };
    const attrs = {
        axis: axis,
        keepDims: keepDims
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$534760f50726d5, inputs, attrs);
}
const $f082be780698e75d$export$8a63f25cc62965f1 = $9e60b70ce0353b32$export$f59964a629598e2({
    sum_: $f082be780698e75d$var$sum_
});


function $9573406eea6a3a06$export$a1905aed55f51aef(dy, y, activation) {
    if (activation == null || activation === 'linear') return dy;
    if (activation === 'relu') return $51103026006cddca$export$6e3a27864ab166fe(dy, $4903e66ca3de96a8$export$35d34bc0ed591a92(y));
    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
}
function $9573406eea6a3a06$export$1a797e236ae09d1f(bias, dyActivation) {
    let res = dyActivation;
    const reduceAxes = $c374f26140f3eb6b$export$9f11ec258a9b2804(bias.shape, dyActivation.shape);
    if (reduceAxes.length > 0) res = $f082be780698e75d$export$8a63f25cc62965f1(res, reduceAxes);
    return $98803384c5ab66ad$export$9eaad88cf88cee2b(res, bias.shape);
}
function $9573406eea6a3a06$export$a0f250a2ba84196(x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === 'linear') return x;
    else if (activation === 'relu') return $c55220628ab79485$export$16d1e4612cc0139f(x);
    else if (activation === 'elu') return $010a82e4fb14a2ed$export$796b583dd79d8524(x);
    else if (activation === 'relu6') return $c1dd63ba62a71ccf$export$4a62bcb95e9c44c4(x);
    else if (activation === 'prelu') return $18a4f2fe019cf2e0$export$5882f235222e6729(x, preluActivationWeights);
    else if (activation === 'leakyrelu') return $52323954d8a43e69$export$23a860e40a2c6b61(x, leakyreluAlpha);
    else if (activation === 'sigmoid') return $5c433a9400a3ea22$export$3b295495ca3cad7c(x);
    throw new Error(`Unknown fused activation ${activation}.`);
}
const $9573406eea6a3a06$export$4904add493b957ab = (gradientDepth, activation)=>{
    const gradientMode = gradientDepth > 0;
    return !gradientMode || activation === 'linear';
};




var $b2071f32b1b84c97$exports = {};

$parcel$export($b2071f32b1b84c97$exports, "getImageCenter", function () { return $b2071f32b1b84c97$export$3c8762d0dab347aa; });
function $b2071f32b1b84c97$export$3c8762d0dab347aa(center, imageHeight, imageWidth) {
    const centerX = imageWidth * (typeof center === 'number' ? center : center[0]);
    const centerY = imageHeight * (typeof center === 'number' ? center : center[1]);
    return [
        centerX,
        centerY
    ];
}


var $e782d45896569519$exports = {};

$parcel$export($e782d45896569519$exports, "getReshaped", function () { return $e782d45896569519$export$4a6fd6a82dc667e2; });
$parcel$export($e782d45896569519$exports, "getPermuted", function () { return $e782d45896569519$export$4def7dccf4cfc2e9; });
$parcel$export($e782d45896569519$exports, "getReshapedPermuted", function () { return $e782d45896569519$export$2435a8b57f99e080; });
$parcel$export($e782d45896569519$exports, "getSliceBeginCoords", function () { return $e782d45896569519$export$b9a01540baa98f86; });
$parcel$export($e782d45896569519$exports, "getSliceSize", function () { return $e782d45896569519$export$2457416ec9e0c8d3; });
function $e782d45896569519$export$4a6fd6a82dc667e2(inputShape, blockShape, prod, batchToSpace = true) {
    let reshaped = [];
    if (batchToSpace) {
        reshaped = reshaped.concat(blockShape.slice(0));
        reshaped.push(inputShape[0] / prod);
        reshaped = reshaped.concat(inputShape.slice(1));
    } else {
        reshaped = reshaped.concat(inputShape[0]);
        const spatialLength = blockShape.length;
        for(let i = 0; i < spatialLength; ++i)reshaped = reshaped.concat([
            inputShape[i + 1] / blockShape[i],
            blockShape[i]
        ]);
        reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
    }
    return reshaped;
}
function $e782d45896569519$export$4def7dccf4cfc2e9(reshapedRank, blockShapeRank, batchToSpace = true) {
    const permuted = [];
    if (batchToSpace) {
        permuted.push(blockShapeRank);
        for(let i = blockShapeRank + 1; i < reshapedRank; ++i)if (i <= 2 * blockShapeRank) {
            permuted.push(i);
            permuted.push(i - (blockShapeRank + 1));
        } else permuted.push(i);
    } else {
        const permutedBeforeBatch = [];
        const permutedAfterBatch = [];
        for(let i = 1; i < reshapedRank; ++i)if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) permutedAfterBatch.push(i);
        else permutedBeforeBatch.push(i);
        permuted.push(...permutedBeforeBatch);
        permuted.push(0);
        permuted.push(...permutedAfterBatch);
    }
    return permuted;
}
function $e782d45896569519$export$2435a8b57f99e080(inputShape, blockShape, prod, batchToSpace = true) {
    const reshapedPermuted = [];
    if (batchToSpace) reshapedPermuted.push(inputShape[0] / prod);
    else reshapedPermuted.push(inputShape[0] * prod);
    for(let i = 1; i < inputShape.length; ++i)if (i <= blockShape.length) {
        if (batchToSpace) reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
        else reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
    } else reshapedPermuted.push(inputShape[i]);
    return reshapedPermuted;
}
function $e782d45896569519$export$b9a01540baa98f86(crops, blockShape) {
    const sliceBeginCoords = [
        0
    ];
    for(let i = 0; i < blockShape; ++i)sliceBeginCoords.push(crops[i][0]);
    return sliceBeginCoords;
}
function $e782d45896569519$export$2457416ec9e0c8d3(uncroppedShape, crops, blockShape) {
    const sliceSize = uncroppedShape.slice(0, 1);
    for(let i = 0; i < blockShape; ++i)sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
    return sliceSize;
}




var $e511d09b8c1a9850$exports = {};

$parcel$export($e511d09b8c1a9850$exports, "SELU_SCALEALPHA", function () { return $e511d09b8c1a9850$export$49dc487a025ce2d0; });
$parcel$export($e511d09b8c1a9850$exports, "SELU_SCALE", function () { return $e511d09b8c1a9850$export$e6ebc294ea9ea7e7; });
const $e511d09b8c1a9850$export$49dc487a025ce2d0 = 1.7580993408473768599402175208123;
const $e511d09b8c1a9850$export$e6ebc294ea9ea7e7 = 1.0507009873554804934193349852946;



var $c50fc7efa04de0c4$exports = {};

$parcel$export($c50fc7efa04de0c4$exports, "ERF_P", function () { return $c50fc7efa04de0c4$export$5588b9ca3e514e43; });
$parcel$export($c50fc7efa04de0c4$exports, "ERF_A1", function () { return $c50fc7efa04de0c4$export$2ac384940e9cdd31; });
$parcel$export($c50fc7efa04de0c4$exports, "ERF_A2", function () { return $c50fc7efa04de0c4$export$db2d4485da836713; });
$parcel$export($c50fc7efa04de0c4$exports, "ERF_A3", function () { return $c50fc7efa04de0c4$export$644ec7b31d43803f; });
$parcel$export($c50fc7efa04de0c4$exports, "ERF_A4", function () { return $c50fc7efa04de0c4$export$904f8b3bbafadf78; });
$parcel$export($c50fc7efa04de0c4$exports, "ERF_A5", function () { return $c50fc7efa04de0c4$export$e40fe2da7629526; });
const $c50fc7efa04de0c4$export$5588b9ca3e514e43 = 0.3275911;
const $c50fc7efa04de0c4$export$2ac384940e9cdd31 = 0.254829592;
const $c50fc7efa04de0c4$export$db2d4485da836713 = -0.284496736;
const $c50fc7efa04de0c4$export$644ec7b31d43803f = 1.421413741;
const $c50fc7efa04de0c4$export$904f8b3bbafadf78 = -1.453152027;
const $c50fc7efa04de0c4$export$e40fe2da7629526 = 1.061405429;



var $9df65e7b32eb487a$exports = {};

$parcel$export($9df65e7b32eb487a$exports, "mergeRealAndImagArrays", function () { return $9df65e7b32eb487a$export$e54cb13fcd32a531; });
$parcel$export($9df65e7b32eb487a$exports, "splitRealAndImagArrays", function () { return $9df65e7b32eb487a$export$fa0ac0984ed1da1c; });
$parcel$export($9df65e7b32eb487a$exports, "complexWithEvenIndex", function () { return $9df65e7b32eb487a$export$270b4351d25667e0; });
$parcel$export($9df65e7b32eb487a$exports, "complexWithOddIndex", function () { return $9df65e7b32eb487a$export$36193f08102303b4; });
$parcel$export($9df65e7b32eb487a$exports, "getComplexWithIndex", function () { return $9df65e7b32eb487a$export$628d071452d50aaf; });
$parcel$export($9df65e7b32eb487a$exports, "assignToTypedArray", function () { return $9df65e7b32eb487a$export$b7f57c25a82b9fba; });
$parcel$export($9df65e7b32eb487a$exports, "exponents", function () { return $9df65e7b32eb487a$export$7d98ee6b5f9e9f08; });
$parcel$export($9df65e7b32eb487a$exports, "exponent", function () { return $9df65e7b32eb487a$export$abde88043842a778; });
function $9df65e7b32eb487a$export$e54cb13fcd32a531(real, imag) {
    if (real.length !== imag.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real.length}, imag: ${imag.length}.`);
    const result = new Float32Array(real.length * 2);
    for(let i = 0; i < result.length; i += 2){
        result[i] = real[i / 2];
        result[i + 1] = imag[i / 2];
    }
    return result;
}
function $9df65e7b32eb487a$export$fa0ac0984ed1da1c(complex) {
    const real = new Float32Array(complex.length / 2);
    const imag = new Float32Array(complex.length / 2);
    for(let i = 0; i < complex.length; i += 2){
        real[i / 2] = complex[i];
        imag[i / 2] = complex[i + 1];
    }
    return {
        real: real,
        imag: imag
    };
}
function $9df65e7b32eb487a$export$270b4351d25667e0(complex) {
    const len = Math.ceil(complex.length / 4);
    const real = new Float32Array(len);
    const imag = new Float32Array(len);
    for(let i = 0; i < complex.length; i += 4){
        real[Math.floor(i / 4)] = complex[i];
        imag[Math.floor(i / 4)] = complex[i + 1];
    }
    return {
        real: real,
        imag: imag
    };
}
function $9df65e7b32eb487a$export$36193f08102303b4(complex) {
    const len = Math.floor(complex.length / 4);
    const real = new Float32Array(len);
    const imag = new Float32Array(len);
    for(let i = 2; i < complex.length; i += 4){
        real[Math.floor(i / 4)] = complex[i];
        imag[Math.floor(i / 4)] = complex[i + 1];
    }
    return {
        real: real,
        imag: imag
    };
}
function $9df65e7b32eb487a$export$628d071452d50aaf(complex, index) {
    const real = complex[index * 2];
    const imag = complex[index * 2 + 1];
    return {
        real: real,
        imag: imag
    };
}
function $9df65e7b32eb487a$export$b7f57c25a82b9fba(data, real, imag, index) {
    data[index * 2] = real;
    data[index * 2 + 1] = imag;
}
function $9df65e7b32eb487a$export$7d98ee6b5f9e9f08(n, inverse) {
    const real = new Float32Array(n / 2);
    const imag = new Float32Array(n / 2);
    for(let i = 0; i < Math.ceil(n / 2); i++){
        const x = (inverse ? 2 : -2) * Math.PI * (i / n);
        real[i] = Math.cos(x);
        imag[i] = Math.sin(x);
    }
    return {
        real: real,
        imag: imag
    };
}
function $9df65e7b32eb487a$export$abde88043842a778(k, n, inverse) {
    const x = (inverse ? 2 : -2) * Math.PI * (k / n);
    const real = Math.cos(x);
    const imag = Math.sin(x);
    return {
        real: real,
        imag: imag
    };
}


var $df108addc20af330$exports = {};

$parcel$export($df108addc20af330$exports, "decodeEinsumEquation", function () { return $df108addc20af330$export$2f615958577142db; });
$parcel$export($df108addc20af330$exports, "getEinsumPermutation", function () { return $df108addc20af330$export$ce55bd5175fdcdbf; });
$parcel$export($df108addc20af330$exports, "checkEinsumDimSizes", function () { return $df108addc20af330$export$40ac7c38e2986bbe; });
$parcel$export($df108addc20af330$exports, "getEinsumComputePath", function () { return $df108addc20af330$export$3f6835c0d48b762d; });
$parcel$export($df108addc20af330$exports, "isIdentityPermutation", function () { return $df108addc20af330$export$6a8a32f5fc3d978e; });

const $df108addc20af330$var$ARROW = '->';
const $df108addc20af330$var$ARROW_REGEX = /->/g;
const $df108addc20af330$var$COMMA = ',';
const $df108addc20af330$var$ELLIPSIS = '...';
function $df108addc20af330$export$2f615958577142db(equation, numTensors) {
    equation = equation.replace(/\s/g, ''); // Remove witespace in equation.
    const numArrows = (equation.length - equation.replace($df108addc20af330$var$ARROW_REGEX, '').length) / $df108addc20af330$var$ARROW.length;
    if (numArrows < 1) throw new Error('Equations without an arrow are not supported.');
    else if (numArrows > 1) throw new Error(`Equation must contain exactly one arrow ("${$df108addc20af330$var$ARROW}").`);
    const [inputString, outputString] = equation.split($df108addc20af330$var$ARROW);
    $904921ed29eeae0f$export$a7a9523472993e97(inputString.indexOf($df108addc20af330$var$ELLIPSIS) === -1, ()=>`The ellipsis notation ("${$df108addc20af330$var$ELLIPSIS}") is not supported yet.`
    );
    const inputTerms = inputString.split($df108addc20af330$var$COMMA);
    const numInputs = inputTerms.length;
    if (numTensors !== numInputs) throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
    if (numInputs > 2) throw new Error('Support for more than 2 input tensors is not implemented yet.');
    const allDims = [];
    for(let i = 0; i < outputString.length; ++i){
        const dimName = outputString[i];
        if (!inputTerms.some((inputTerm)=>inputTerm.indexOf(dimName) !== -1
        )) throw new Error(`Output subscripts contain the label ${dimName} ` + `not present in the input subscripts.`);
        if (allDims.indexOf(dimName) === -1) allDims.push(dimName);
    }
    for(let i1 = 0; i1 < inputString.length; ++i1){
        const dimName = inputString[i1];
        if (allDims.indexOf(dimName) === -1 && dimName !== $df108addc20af330$var$COMMA) allDims.push(dimName);
    }
    const idDims = new Array(inputTerms.length);
    for(let i2 = 0; i2 < numInputs; ++i2){
        if (new Set(inputTerms[i2].split('')).size !== inputTerms[i2].length) throw new Error(`Found duplicate axes in input component ${inputTerms[i2]}. ` + `Support for duplicate axes in input is not implemented yet.`);
        idDims[i2] = [];
        for(let j = 0; j < inputTerms[i2].length; ++j)idDims[i2].push(allDims.indexOf(inputTerms[i2][j]));
    }
    const numDims = allDims.length; // Number of unique dimensions.
    const numOutDims = outputString.length; // Number of output dimensions.
    const summedDims = []; // Dimensions being summed over.
    for(let i3 = numOutDims; i3 < numDims; ++i3)summedDims.push(i3);
    return {
        allDims: allDims,
        summedDims: summedDims,
        idDims: idDims
    };
}
function $df108addc20af330$export$ce55bd5175fdcdbf(nDims, idDims) {
    let permutationIndices = new Array(nDims);
    permutationIndices.fill(-1);
    for(let i = 0; i < idDims.length; ++i)permutationIndices[idDims[i]] = i;
    const expandDims = [];
    for(let i4 = 0; i4 < nDims; ++i4)if (permutationIndices[i4] === -1) expandDims.push(i4);
    permutationIndices = permutationIndices.filter((d)=>d !== -1
    );
    return {
        permutationIndices: permutationIndices,
        expandDims: expandDims
    };
}
function $df108addc20af330$export$40ac7c38e2986bbe(nDims, idDims, tensors) {
    const dimSizes = new Array(nDims);
    for(let i = 0; i < tensors.length; ++i){
        const shape = tensors[i].shape;
        for(let j = 0; j < idDims[i].length; ++j)if (dimSizes[idDims[i][j]] === undefined) dimSizes[idDims[i][j]] = shape[j];
        else $904921ed29eeae0f$export$a7a9523472993e97(dimSizes[idDims[i][j]] === shape[j], ()=>`Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} ` + `of input shaped ${JSON.stringify(shape)}, ` + `but got dimension ${shape[j]}`
        );
    }
}
function $df108addc20af330$export$3f6835c0d48b762d(summedDims, idDims) {
    const path = summedDims;
    const steps = [];
    let nSteps = 0;
    if (summedDims.length === 0) // Einsum that involes no summing: e.g., transpose and outer product.
    path.push(-1);
    nSteps = summedDims.length + 1;
    for(let i = 0; i < nSteps; ++i)steps.push([]);
    const computedTermIndices = [];
    for(let i5 = 0; i5 < path.length; ++i5){
        const summedDim = path[i5];
        const termIndices = $df108addc20af330$var$findTermsWithDim(idDims, summedDim);
        for (const termIndex of termIndices)if (computedTermIndices.indexOf(termIndex) === -1) {
            steps[i5].push(termIndex);
            computedTermIndices.push(termIndex);
        }
    }
    return {
        path: path,
        steps: steps
    };
}
function $df108addc20af330$export$6a8a32f5fc3d978e(perm) {
    return perm.every((dim, index)=>dim === index
    );
}
function $df108addc20af330$var$findTermsWithDim(idDims, dim) {
    const termIndices = [];
    for(let i = 0; i < idDims.length; ++i)if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) termIndices.push(i);
    return termIndices;
}


var $6a07a4c0c12feff6$exports = {};

$parcel$export($6a07a4c0c12feff6$exports, "prepareSplitSize", function () { return $6a07a4c0c12feff6$export$b45a3b30df9d4b49; });

function $6a07a4c0c12feff6$export$b45a3b30df9d4b49(x, numOrSizeSplits, axis = 0) {
    let splitSizes = [];
    if (typeof numOrSizeSplits === 'number') {
        $904921ed29eeae0f$export$a7a9523472993e97(x.shape[axis] % numOrSizeSplits === 0, ()=>'Number of splits must evenly divide the axis.'
        );
        splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
    } else {
        const numOfNegs = numOrSizeSplits.reduce((count, value)=>{
            if (value === -1) count += 1;
            return count;
        }, 0);
        $904921ed29eeae0f$export$a7a9523472993e97(numOfNegs <= 1, ()=>'There should be only one negative value in split array.'
        );
        const negIndex = numOrSizeSplits.indexOf(-1);
        // Allow the number of split array to be -1, which indicates the rest
        // of dimension is allocated to that split.
        if (negIndex !== -1) {
            const total = numOrSizeSplits.reduce((a, b)=>b > 0 ? a + b : a
            );
            numOrSizeSplits[negIndex] = x.shape[axis] - total;
        }
        $904921ed29eeae0f$export$a7a9523472993e97(x.shape[axis] === numOrSizeSplits.reduce((a, b)=>a + b
        ), ()=>'The sum of sizes must match the size of the axis dimension.'
        );
        splitSizes = numOrSizeSplits;
    }
    return splitSizes;
}


var $058e4705b022a254$exports = {};

$parcel$export($058e4705b022a254$exports, "getSparseFillEmptyRowsIndicesDenseShapeMismatch", function () { return $058e4705b022a254$export$afc2f2dec50723b1; });
$parcel$export($058e4705b022a254$exports, "getSparseFillEmptyRowsNegativeIndexErrorMessage", function () { return $058e4705b022a254$export$69038529bd45dbce; });
$parcel$export($058e4705b022a254$exports, "getSparseFillEmptyRowsOutOfRangeIndexErrorMessage", function () { return $058e4705b022a254$export$4179b115ac384c01; });
function $058e4705b022a254$export$afc2f2dec50723b1(indicesLength) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${indicesLength}`;
}
function $058e4705b022a254$export$69038529bd45dbce(index, value) {
    return `indices(${index}, 0) is invalid: ${value} < 0`;
}
function $058e4705b022a254$export$4179b115ac384c01(index, value, limit) {
    return `indices(${index}, 0) is invalid: ${value} >= ${limit}`;
}


var $c175d26fa90109ad$exports = {};

$parcel$export($c175d26fa90109ad$exports, "getSparseReshapeMultipleNegativeOneOutputDimErrorMessage", function () { return $c175d26fa90109ad$export$22b04105649d1e3d; });
$parcel$export($c175d26fa90109ad$exports, "getSparseReshapeNegativeOutputDimErrorMessage", function () { return $c175d26fa90109ad$export$3350ee0ca4641eae; });
$parcel$export($c175d26fa90109ad$exports, "getSparseReshapeEmptyTensorZeroOutputDimErrorMessage", function () { return $c175d26fa90109ad$export$632a7731cfb4dc4b; });
$parcel$export($c175d26fa90109ad$exports, "getSparseReshapeInputOutputMultipleErrorMessage", function () { return $c175d26fa90109ad$export$6996eb40ec18f24; });
$parcel$export($c175d26fa90109ad$exports, "getSparseReshapeInputOutputMismatchErrorMessage", function () { return $c175d26fa90109ad$export$7c74c1672e7ca2d1; });

function $c175d26fa90109ad$export$22b04105649d1e3d(dim1, dim2) {
    return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;
}
function $c175d26fa90109ad$export$3350ee0ca4641eae(dim, value) {
    return `size ${dim} must be non-negative, not ${value}`;
}
function $c175d26fa90109ad$export$632a7731cfb4dc4b() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function $c175d26fa90109ad$export$6996eb40ec18f24(inputShape, outputShape) {
    const inputSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(inputShape);
    const outputSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(outputShape);
    return `Input to reshape is a SparseTensor with ${inputSize}
  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;
}
function $c175d26fa90109ad$export$7c74c1672e7ca2d1(inputShape, outputShape) {
    const inputSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(inputShape);
    const outputSize = $904921ed29eeae0f$export$b4c3214a70a0e73f(outputShape);
    return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;
}


var $eeb88819a205d227$exports = {};

$parcel$export($eeb88819a205d227$exports, "getSparseSegmentReductionNegativeSegmentIdsErrorMessage", function () { return $eeb88819a205d227$export$cb1b83ffdf66736; });
$parcel$export($eeb88819a205d227$exports, "getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage", function () { return $eeb88819a205d227$export$6f5af72ace1661e1; });
$parcel$export($eeb88819a205d227$exports, "getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage", function () { return $eeb88819a205d227$export$bdc282d2ae15e823; });
$parcel$export($eeb88819a205d227$exports, "getSparseSegmentReductionIndicesOutOfRangeErrorMessage", function () { return $eeb88819a205d227$export$c470f477911f1cb7; });
function $eeb88819a205d227$export$cb1b83ffdf66736() {
    return `segment ids must be >= 0`;
}
function $eeb88819a205d227$export$6f5af72ace1661e1() {
    return `segment ids are not increasing`;
}
function $eeb88819a205d227$export$bdc282d2ae15e823(segmentId, outputRows) {
    return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;
}
function $eeb88819a205d227$export$c470f477911f1cb7(index, indexValue, inputRows) {
    return `Bad: indices[${index}] == ${indexValue} out of range [0, ${inputRows})`;
}


function $510a55f99d61727a$export$debaff328bdca650(vals) {
    try {
        // Decode the bytes into string.
        return vals.map((val)=>$f6b55a2021b78f0d$export$a0fb664af7d0cc44(val)
        );
    } catch (err) {
        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
    }
}
function $510a55f99d61727a$export$ce1f4ec5bdd0ab9a(strings) {
    return strings.map((s)=>$f6b55a2021b78f0d$export$8146d2e653b87d6a(s)
    );
}
$parcel$exportWildcard($510a55f99d61727a$exports, $0732cb950311b962$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $c374f26140f3eb6b$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $03d556d29f93f0f5$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $d3eadf2cbd3cb093$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $9573406eea6a3a06$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $239c3e1401044fa1$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $b2071f32b1b84c97$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $e782d45896569519$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $c53aa01d4c37cbd8$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $ddbb251d0c4839ae$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $e511d09b8c1a9850$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $c50fc7efa04de0c4$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $35abfa9829a48523$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $9df65e7b32eb487a$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $df108addc20af330$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $6a07a4c0c12feff6$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $058e4705b022a254$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $c175d26fa90109ad$exports);
$parcel$exportWildcard($510a55f99d61727a$exports, $eeb88819a205d227$exports);

var $c0ded10581046f08$exports = {};

$parcel$export($c0ded10581046f08$exports, "nonMaxSuppressionV3Impl", function () { return $eb9293ac2b3fed68$export$89e22275998c2878; });
$parcel$export($c0ded10581046f08$exports, "nonMaxSuppressionV4Impl", function () { return $eb9293ac2b3fed68$export$697e7a8cdfefe3a; });
$parcel$export($c0ded10581046f08$exports, "nonMaxSuppressionV5Impl", function () { return $eb9293ac2b3fed68$export$4ff849794bce73c5; });
$parcel$export($c0ded10581046f08$exports, "whereImpl", function () { return $26099d79a88d5259$export$3a1005f93c3f4453; });
function $e62788c87eae2e92$export$a64fad5e27f22af5(arr, element, comparator) {
    const index = $e62788c87eae2e92$export$2e0ae67339d5f1ac(arr, element, comparator);
    const insertionPoint = index < 0 ? -(index + 1) : index;
    arr.splice(insertionPoint, 0, element);
}
function $e62788c87eae2e92$export$2e0ae67339d5f1ac(arr, target, comparator) {
    return $e62788c87eae2e92$var$binarySearch_(arr, target, comparator || $e62788c87eae2e92$var$defaultComparator);
}
/**
 * Compares its two arguments for order.
 * @param a The first element to be compared.
 * @param b The second element to be compared.
 * @return A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */ function $e62788c87eae2e92$var$defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function $e62788c87eae2e92$var$binarySearch_(arr, target, comparator) {
    let left = 0;
    let right = arr.length;
    let middle = 0;
    let found = false;
    while(left < right){
        middle = left + (right - left >>> 1);
        const compareResult = comparator(target, arr[middle]);
        if (compareResult > 0) left = middle + 1;
        else {
            right = middle;
            // If compareResult is 0, the value is found. We record it is found,
            // and then keep looking because there may be duplicate.
            found = !compareResult;
        }
    }
    return found ? left : -left - 1;
}


function $eb9293ac2b3fed68$export$89e22275998c2878(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    return $eb9293ac2b3fed68$var$nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */ );
}
function $eb9293ac2b3fed68$export$697e7a8cdfefe3a(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
    return $eb9293ac2b3fed68$var$nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */ , false, padToMaxOutputSize /* padToMaxOutputSize */ , true);
}
function $eb9293ac2b3fed68$export$4ff849794bce73c5(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    return $eb9293ac2b3fed68$var$nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
}
function $eb9293ac2b3fed68$var$nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
    // The list is sorted in ascending order, so that we can always pop the
    // candidate with the largest score in O(1) time.
    const candidates = [];
    for(let i = 0; i < scores.length; i++)if (scores[i] > scoreThreshold) candidates.push({
        score: scores[i],
        boxIndex: i,
        suppressBeginIndex: 0
    });
    candidates.sort($eb9293ac2b3fed68$var$ascendingComparator);
    // If softNmsSigma is 0, the outcome of this algorithm is exactly same as
    // before.
    const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0.0;
    const selectedIndices = [];
    const selectedScores = [];
    while(selectedIndices.length < maxOutputSize && candidates.length > 0){
        const candidate = candidates.pop();
        const { score: originalScore , boxIndex: boxIndex , suppressBeginIndex: suppressBeginIndex  } = candidate;
        if (originalScore < scoreThreshold) break;
        // Overlapping boxes are likely to have similar scores, therefore we
        // iterate through the previously selected boxes backwards in order to
        // see if candidate's score should be suppressed. We use
        // suppressBeginIndex to track and ensure a candidate can be suppressed
        // by a selected box no more than once. Also, if the overlap exceeds
        // iouThreshold, we simply ignore the candidate.
        let ignoreCandidate = false;
        for(let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j){
            const iou = $eb9293ac2b3fed68$var$intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
            if (iou >= iouThreshold) {
                ignoreCandidate = true;
                break;
            }
            candidate.score = candidate.score * $eb9293ac2b3fed68$var$suppressWeight(iouThreshold, scale, iou);
            if (candidate.score <= scoreThreshold) break;
        }
        // At this point, if `candidate.score` has not dropped below
        // `scoreThreshold`, then we know that we went through all of the
        // previous selections and can safely update `suppressBeginIndex` to the
        // end of the selected array. Then we can re-insert the candidate with
        // the updated score and suppressBeginIndex back in the candidate list.
        // If on the other hand, `candidate.score` has dropped below the score
        // threshold, we will not add it back to the candidates list.
        candidate.suppressBeginIndex = selectedIndices.length;
        if (!ignoreCandidate) {
            // Candidate has passed all the tests, and is not suppressed, so
            // select the candidate.
            if (candidate.score === originalScore) {
                selectedIndices.push(boxIndex);
                selectedScores.push(candidate.score);
            } else if (candidate.score > scoreThreshold) // Candidate's score is suppressed but is still high enough to be
            // considered, so add back to the candidates list.
            $e62788c87eae2e92$export$a64fad5e27f22af5(candidates, candidate, $eb9293ac2b3fed68$var$ascendingComparator);
        }
    }
    // NonMaxSuppressionV4 feature: padding output to maxOutputSize.
    const validOutputs = selectedIndices.length;
    const elemsToPad = maxOutputSize - validOutputs;
    if (padToMaxOutputSize && elemsToPad > 0) {
        selectedIndices.push(...new Array(elemsToPad).fill(0));
        selectedScores.push(...new Array(elemsToPad).fill(0.0));
    }
    const result = {
        selectedIndices: selectedIndices
    };
    if (returnScoresTensor) result['selectedScores'] = selectedScores;
    if (returnValidOutputs) result['validOutputs'] = validOutputs;
    return result;
}
function $eb9293ac2b3fed68$var$intersectionOverUnion(boxes, i, j) {
    const iCoord = boxes.subarray(i * 4, i * 4 + 4);
    const jCoord = boxes.subarray(j * 4, j * 4 + 4);
    const yminI = Math.min(iCoord[0], iCoord[2]);
    const xminI = Math.min(iCoord[1], iCoord[3]);
    const ymaxI = Math.max(iCoord[0], iCoord[2]);
    const xmaxI = Math.max(iCoord[1], iCoord[3]);
    const yminJ = Math.min(jCoord[0], jCoord[2]);
    const xminJ = Math.min(jCoord[1], jCoord[3]);
    const ymaxJ = Math.max(jCoord[0], jCoord[2]);
    const xmaxJ = Math.max(jCoord[1], jCoord[3]);
    const areaI = (ymaxI - yminI) * (xmaxI - xminI);
    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) return 0.0;
    const intersectionYmin = Math.max(yminI, yminJ);
    const intersectionXmin = Math.max(xminI, xminJ);
    const intersectionYmax = Math.min(ymaxI, ymaxJ);
    const intersectionXmax = Math.min(xmaxI, xmaxJ);
    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) * Math.max(intersectionXmax - intersectionXmin, 0.0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
}
// A Gaussian penalty function, this method always returns values in [0, 1].
// The weight is a function of similarity, the more overlap two boxes are, the
// smaller the weight is, meaning highly overlapping boxe will be significantly
// penalized. On the other hand, a non-overlapping box will not be penalized.
function $eb9293ac2b3fed68$var$suppressWeight(iouThreshold, scale, iou) {
    const weight = Math.exp(scale * iou * iou);
    return iou <= iouThreshold ? weight : 0.0;
}
function $eb9293ac2b3fed68$var$ascendingComparator(c1, c2) {
    // For objects with same scores, we make the object with the larger index go
    // first. In an array that pops from the end, this means that the object with
    // the smaller index will be popped first. This ensures the same output as
    // the TensorFlow python version.
    return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
}



function $26099d79a88d5259$export$3a1005f93c3f4453(condShape, condVals) {
    const indices = [];
    for(let i = 0; i < condVals.length; i++)if (condVals[i]) indices.push(i);
    const inBuffer = $034bc04874ecb003$export$ab1029bcae9ddb4a(condShape, 'int32');
    const out = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        indices.length,
        condShape.length
    ], 'int32');
    for(let i1 = 0; i1 < indices.length; i1++){
        const loc = inBuffer.indexToLoc(indices[i1]);
        const offset = i1 * condShape.length;
        out.values.set(loc, offset);
    }
    return out.toTensor();
}











/**
 * Concatenates a list of `tf.Tensor`s along a given axis.
 *
 * The tensors ranks and types must match, and their sizes must match in all
 * dimensions except `axis`.
 *
 * Also available are stricter rank-specific methods that assert that
 * `tensors` are of the given rank:
 *   - `tf.concat1d`
 *   - `tf.concat2d`
 *   - `tf.concat3d`
 *   - `tf.concat4d`
 *
 * Except `tf.concat1d` (which does not have axis param), all methods have
 * same signature as this method.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * a.concat(b).print();  // or a.concat(b)
 * ```
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * const c = tf.tensor1d([5, 6]);
 * tf.concat([a, b, c]).print();
 * ```
 *
 * ```js
 * const a = tf.tensor2d([[1, 2], [10, 20]]);
 * const b = tf.tensor2d([[3, 4], [30, 40]]);
 * const axis = 1;
 * tf.concat([a, b], axis).print();
 * ```
 * @param tensors A list of tensors to concatenate.
 * @param axis The axis to concate along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $876962a92a0aaf94$var$concat_(tensors, axis = 0) {
    $904921ed29eeae0f$export$a7a9523472993e97(tensors.length >= 1, ()=>'Pass at least one tensor to concat'
    );
    const $tensors = $d7ebc35f1f4a180c$export$758e66616b4d410b(tensors, 'tensors', 'concat', 'string_or_numeric');
    if ($tensors[0].dtype === 'complex64') $tensors.forEach((tensor)=>{
        if (tensor.dtype !== 'complex64') throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor.dtype}. `);
    });
    if ($tensors.length === 1) return $e3b15dff351ca276$export$9cd59f9826255e47($tensors[0]);
    const inputs = $tensors;
    const attr = {
        axis: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$936bbfc007425eea, inputs, attr);
}
const $876962a92a0aaf94$export$ee1b3e54f0441b22 = $9e60b70ce0353b32$export$f59964a629598e2({
    concat_: $876962a92a0aaf94$var$concat_
});






/**
 * Returns the imaginary part of a complex (or real) tensor.
 *
 * Given a tensor input, this operation returns a tensor of type float that is
 * the imaginary part of each element in input considered as a complex number.
 * If input is real, a tensor of all zeros is returned.
 *
 * ```js
 * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
 * tf.imag(x).print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $998eaef76388a295$var$imag_(input) {
    const $input = $d7ebc35f1f4a180c$export$ede379c4c939d71a(input, 'input', 'imag');
    const inputs = {
        input: $input
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$303b4473993a24f, inputs);
}
const $998eaef76388a295$export$d78fab5778ab392b = $9e60b70ce0353b32$export$f59964a629598e2({
    imag_: $998eaef76388a295$var$imag_
});







/**
 * Returns the real part of a complex (or real) tensor.
 *
 * Given a tensor input, this operation returns a tensor of type float that is
 * the real part of each element in input considered as a complex number.
 *
 * If the input is real, it simply makes a clone.
 *
 * ```js
 * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);
 * tf.real(x).print();
 * ```
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $2de2294a26842846$var$real_(input) {
    const $input = $d7ebc35f1f4a180c$export$ede379c4c939d71a(input, 'input', 'real');
    const inputs = {
        input: $input
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$f41305719b94e675, inputs);
}
const $2de2294a26842846$export$9fc57fb453bdbd67 = $9e60b70ce0353b32$export$f59964a629598e2({
    real_: $2de2294a26842846$var$real_
});







/**
 * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`
 * and is of size `size`.
 *
 * Also available are stricter rank-specific methods with the same signature
 * as this method that assert that `x` is of the given rank:
 *   - `tf.slice1d`
 *   - `tf.slice2d`
 *   - `tf.slice3d`
 *   - `tf.slice4d`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.slice([1], [2]).print();
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * x.slice([1, 0], [1, 2]).print();
 * ```
 * @param x The input `tf.Tensor` to slice from.
 * @param begin The coordinates to start the slice from. The length can be
 *     less than the rank of x - the rest of the axes will have implicit 0 as
 *     start. Can also be a single number, in which case it specifies the
 *     first axis.
 * @param size The size of the slice. The length can be less than the rank of
 *     x - the rest of the axes will have implicit -1. A value of -1 requests
 *     the rest of the dimensions in the axis. Can also be a single number,
 *     in which case it specifies the size of the first axis.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $346651c97f629fbf$var$slice_(x, begin, size) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'slice', 'string_or_numeric');
    if ($x.rank === 0) throw new Error('Slicing scalar is not possible');
    const inputs = {
        x: $x
    };
    const attrs = {
        begin: begin,
        size: size
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$b3f2e2de3a8baa1e, inputs, attrs);
}
const $346651c97f629fbf$export$58adb3bec8346d0f = $9e60b70ce0353b32$export$f59964a629598e2({
    slice_: $346651c97f629fbf$var$slice_
});






/**
 * Splits a `tf.Tensor` into sub tensors.
 *
 * If `numOrSizeSplits` is a number, splits `x` along dimension `axis`
 * into `numOrSizeSplits` smaller tensors.
 * Requires that `numOrSizeSplits` evenly divides `x.shape[axis]`.
 *
 * If `numOrSizeSplits` is a number array, splits `x` into
 * `numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the
 * same size as `x` except along dimension `axis` where the size is
 * `numOrSizeSplits[i]`.
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);
 * const [a, b] = tf.split(x, 2, 1);
 * a.print();
 * b.print();
 *
 * const [c, d, e] = tf.split(x, [1, 2, 1], 1);
 * c.print();
 * d.print();
 * e.print();
 * ```
 *
 * @param x The input tensor to split.
 * @param numOrSizeSplits Either an integer indicating the number of
 * splits along the axis or an array of integers containing the sizes of
 * each output tensor along the axis. If a number then it must evenly divide
 * `x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.
 * Can contain one -1 indicating that dimension is to be inferred.
 * @param axis The dimension along which to split. Defaults to 0 (the first
 * dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $5d65ece42b107e33$var$split_(x, numOrSizeSplits, axis = 0) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'split');
    const inputs = {
        x: $x
    };
    const attr = {
        numOrSizeSplits: numOrSizeSplits,
        axis: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$8dffabb4071f05aa, inputs, attr);
}
const $5d65ece42b107e33$export$65980d18b75784e2 = $9e60b70ce0353b32$export$f59964a629598e2({
    split_: $5d65ece42b107e33$var$split_
});





function $1b84f1678bdd9c2a$export$4445a00dafa2633b(shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = $1b84f1678bdd9c2a$export$4445a00dafa2633b(shape, 'float32');
        const imag = $1b84f1678bdd9c2a$export$4445a00dafa2633b(shape, 'float32');
        return $b2f39045a9ff3425$export$83a0e34f1302825b(real, imag);
    }
    const values = $904921ed29eeae0f$export$edbc8aedac4e036f($904921ed29eeae0f$export$b4c3214a70a0e73f(shape), dtype);
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.makeTensor(values, shape, dtype);
}






/**
 * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the
 * given tensor.
 *
 * ```js
 * const x = tf.tensor([1, 2]);
 * tf.zerosLike(x).print();
 * ```
 *
 * @param x The tensor of required shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $5c281e4263014be7$var$zerosLike_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'zerosLike');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$430969a37eda1e88, inputs);
}
const $5c281e4263014be7$export$cb1f824e7733584d = $9e60b70ce0353b32$export$f59964a629598e2({
    zerosLike_: $5c281e4263014be7$var$zerosLike_
});






/**
 * Fast Fourier transform.
 *
 * Computes the 1-dimensional discrete Fourier transform over the inner-most
 * dimension of input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([1, 2, 3]);
 * const x = tf.complex(real, imag);
 *
 * x.fft().print();  // tf.spectral.fft(x).print();
 * ```
 * @param input The complex input to compute an fft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */ function $0ce52e80b75d460f$var$fft_(input) {
    $904921ed29eeae0f$export$a7a9523472993e97(input.dtype === 'complex64', ()=>`The dtype for tf.spectral.fft() must be complex64 ` + `but got ${input.dtype}.`
    );
    const inputs = {
        input: input
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$677347237c014ba, inputs);
}
const $0ce52e80b75d460f$export$a535ef183b6128fa = $9e60b70ce0353b32$export$f59964a629598e2({
    fft_: $0ce52e80b75d460f$var$fft_
});


/**
 * Real value input fast Fourier transform.
 *
 * Computes the 1-dimensional discrete Fourier transform over the
 * inner-most dimension of the real input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 *
 * real.rfft().print();
 * ```
 * @param input The real value input to compute an rfft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */ function $90ed2cf7a791761c$var$rfft_(input, fftLength) {
    $904921ed29eeae0f$export$a7a9523472993e97(input.dtype === 'float32', ()=>`The dtype for rfft() must be real value but got ${input.dtype}`
    );
    let innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let adjustedInput;
    if (fftLength != null && fftLength < innerDimensionSize) {
        // Need to crop
        const begin = input.shape.map((v)=>0
        );
        const size = input.shape.map((v)=>v
        );
        size[input.shape.length - 1] = fftLength;
        adjustedInput = $346651c97f629fbf$export$58adb3bec8346d0f(input, begin, size);
        innerDimensionSize = fftLength;
    } else if (fftLength != null && fftLength > innerDimensionSize) {
        // Need to pad with zeros
        const zerosShape = input.shape.map((v)=>v
        );
        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
        adjustedInput = $876962a92a0aaf94$export$ee1b3e54f0441b22([
            input,
            $1b84f1678bdd9c2a$export$4445a00dafa2633b(zerosShape)
        ], input.shape.length - 1);
        innerDimensionSize = fftLength;
    } else adjustedInput = input;
    // Complement the input with zero imaginary numbers.
    const zerosInput = $5c281e4263014be7$export$cb1f824e7733584d(adjustedInput);
    const complexInput = $98803384c5ab66ad$export$9eaad88cf88cee2b($b2f39045a9ff3425$export$83a0e34f1302825b(adjustedInput, zerosInput), [
        batch,
        innerDimensionSize
    ]);
    const ret = $0ce52e80b75d460f$export$a535ef183b6128fa(complexInput);
    // Exclude complex conjugations. These conjugations are put symmetrically.
    const half = Math.floor(innerDimensionSize / 2) + 1;
    const realValues = $2de2294a26842846$export$9fc57fb453bdbd67(ret);
    const imagValues = $998eaef76388a295$export$d78fab5778ab392b(ret);
    const realComplexConjugate = $5d65ece42b107e33$export$65980d18b75784e2(realValues, [
        half,
        innerDimensionSize - half
    ], realValues.shape.length - 1);
    const imagComplexConjugate = $5d65ece42b107e33$export$65980d18b75784e2(imagValues, [
        half,
        innerDimensionSize - half
    ], imagValues.shape.length - 1);
    const outputShape = adjustedInput.shape.slice();
    outputShape[adjustedInput.shape.length - 1] = half;
    return $98803384c5ab66ad$export$9eaad88cf88cee2b($b2f39045a9ff3425$export$83a0e34f1302825b(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
}
const $90ed2cf7a791761c$export$72aff1768917e9e5 = $9e60b70ce0353b32$export$f59964a629598e2({
    rfft_: $90ed2cf7a791761c$var$rfft_
});





/**
 * Inverse fast Fourier transform.
 *
 * Computes the inverse 1-dimensional discrete Fourier transform over the
 * inner-most dimension of input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([1, 2, 3]);
 * const x = tf.complex(real, imag);
 *
 * x.ifft().print();  // tf.spectral.ifft(x).print();
 * ```
 * @param input The complex input to compute an ifft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */ function $0db20788a292ed9c$var$ifft_(input) {
    $904921ed29eeae0f$export$a7a9523472993e97(input.dtype === 'complex64', ()=>`The dtype for tf.spectral.ifft() must be complex64 ` + `but got ${input.dtype}.`
    );
    const inputs = {
        input: input
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$21c6f576ae8100e8, inputs);
}
const $0db20788a292ed9c$export$776649b0bf8ce1fd = $9e60b70ce0353b32$export$f59964a629598e2({
    ifft_: $0db20788a292ed9c$var$ifft_
});












/**
 * Reverses a `tf.Tensor` along a specified axis.
 *
 * Also available are stricter rank-specific methods that assert that `x` is
 * of the given rank:
 *   - `tf.reverse1d`
 *   - `tf.reverse2d`
 *   - `tf.reverse3d`
 *   - `tf.reverse4d`
 *
 * Except `tf.reverse1d` (which does not have axis param), all methods have
 * same signature as this method.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.reverse().print();
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.reverse(axis).print();
 * ```
 * @param x The input tensor to be reversed.
 * @param axis The set of dimensions to reverse. Must be in the
 *     range [-rank(x), rank(x)). Defaults to all axes.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $e8b72a0f167afc01$var$reverse_(x, axis) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'reverse');
    const inputs = {
        x: $x
    };
    const attrs = {
        dims: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$53c81f36b32e1bba, inputs, attrs);
}
const $e8b72a0f167afc01$export$66c1ae025e96b4bc = $9e60b70ce0353b32$export$f59964a629598e2({
    reverse_: $e8b72a0f167afc01$var$reverse_
});




function $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(value, dtype) {
    if (($904921ed29eeae0f$export$b119cc7e1840e59c(value) && dtype !== 'string' || Array.isArray(value)) && dtype !== 'complex64') throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (dtype === 'string' && $904921ed29eeae0f$export$b119cc7e1840e59c(value) && !(value instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    const shape = [];
    const inferredShape = [];
    return $ca9108fe9b0ad943$export$f41686c891d7ebce(value, shape, inferredShape, dtype);
}




/**
 * Inversed real value input fast Fourier transform.
 *
 * Computes the 1-dimensional inversed discrete Fourier transform over the
 * inner-most dimension of the real input.
 *
 * ```js
 * const real = tf.tensor1d([1, 2, 3]);
 * const imag = tf.tensor1d([0, 0, 0]);
 * const x = tf.complex(real, imag);
 *
 * x.irfft().print();
 * ```
 * @param input The real value input to compute an irfft over.
 *
 * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}
 */ function $f91745d41797764a$var$irfft_(input) {
    const innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = input.size / innerDimensionSize;
    let ret;
    if (innerDimensionSize <= 2) {
        const complexInput = $98803384c5ab66ad$export$9eaad88cf88cee2b(input, [
            batch,
            innerDimensionSize
        ]);
        ret = $0db20788a292ed9c$export$776649b0bf8ce1fd(complexInput);
    } else {
        // The length of unique components of the DFT of a real-valued signal
        // is 2 * (input_len - 1)
        const outputShape = [
            batch,
            2 * (innerDimensionSize - 1)
        ];
        const realInput = $98803384c5ab66ad$export$9eaad88cf88cee2b($2de2294a26842846$export$9fc57fb453bdbd67(input), [
            batch,
            innerDimensionSize
        ]);
        const imagInput = $98803384c5ab66ad$export$9eaad88cf88cee2b($998eaef76388a295$export$d78fab5778ab392b(input), [
            batch,
            innerDimensionSize
        ]);
        const realConjugate = $e8b72a0f167afc01$export$66c1ae025e96b4bc($346651c97f629fbf$export$58adb3bec8346d0f(realInput, [
            0,
            1
        ], [
            batch,
            innerDimensionSize - 2
        ]), 1);
        const imagConjugate = $51103026006cddca$export$6e3a27864ab166fe($e8b72a0f167afc01$export$66c1ae025e96b4bc($346651c97f629fbf$export$58adb3bec8346d0f(imagInput, [
            0,
            1
        ], [
            batch,
            innerDimensionSize - 2
        ]), 1), $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(-1));
        const r = $876962a92a0aaf94$export$ee1b3e54f0441b22([
            realInput,
            realConjugate
        ], 1);
        const i = $876962a92a0aaf94$export$ee1b3e54f0441b22([
            imagInput,
            imagConjugate
        ], 1);
        const complexInput = $98803384c5ab66ad$export$9eaad88cf88cee2b($b2f39045a9ff3425$export$83a0e34f1302825b(r, i), [
            outputShape[0],
            outputShape[1]
        ]);
        ret = $0db20788a292ed9c$export$776649b0bf8ce1fd(complexInput);
    }
    ret = $2de2294a26842846$export$9fc57fb453bdbd67(ret);
    // reshape the result if the input is 3D tensor.
    if (input.rank === 3 && input.shape[0] !== 0) {
        const temp = ret;
        const batch = input.shape[0];
        ret = $98803384c5ab66ad$export$9eaad88cf88cee2b(ret, [
            batch,
            ret.shape[0] / batch,
            ret.shape[1]
        ]);
        temp.dispose();
    }
    return ret;
}
const $f91745d41797764a$export$f47f4e5bcd3d6a66 = $9e60b70ce0353b32$export$f59964a629598e2({
    irfft_: $f91745d41797764a$var$irfft_
});





function $9e73a3beda7739fe$export$8133e3bf3cd8f464(values, dtype) {
    $904921ed29eeae0f$export$44a06cc2759dd036(values);
    const inferredShape = $d7ebc35f1f4a180c$export$467a8ad638b9ad20(values, dtype);
    if (inferredShape.length !== 1) throw new Error('tensor1d() requires values to be a flat/TypedArray');
    const shape = null;
    return $ca9108fe9b0ad943$export$f41686c891d7ebce(values, shape, inferredShape, dtype);
}


function $4685c14e372486ba$export$6fc2fe3b19043bf3(value) {
    // Return 2**N for integer N such that 2**N >= value.
    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));
}
function $4685c14e372486ba$export$e875398ce092ee45(windowLength, a, b) {
    const even = 1 - windowLength % 2;
    const newValues = new Float32Array(windowLength);
    for(let i = 0; i < windowLength; ++i){
        const cosArg = 2.0 * Math.PI * i / (windowLength + even - 1);
        newValues[i] = a - b * Math.cos(cosArg);
    }
    return $9e73a3beda7739fe$export$8133e3bf3cd8f464(newValues, 'float32');
}


/**
 * Generate a hamming window.
 *
 * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows
 *
 * ```js
 * tf.signal.hammingWindow(10).print();
 * ```
 * @param The length of window
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */ function $1e3f798284492b52$var$hammingWindow_(windowLength) {
    return $4685c14e372486ba$export$e875398ce092ee45(windowLength, 0.54, 0.46);
}
const $1e3f798284492b52$export$941eafcc99b559fa = $9e60b70ce0353b32$export$f59964a629598e2({
    hammingWindow_: $1e3f798284492b52$var$hammingWindow_
});



/**
 * Generate a Hann window.
 *
 * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows
 *
 * ```js
 * tf.signal.hannWindow(10).print();
 * ```
 * @param The length of window
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */ function $14caca14f2f8ea04$var$hannWindow_(windowLength) {
    return $4685c14e372486ba$export$e875398ce092ee45(windowLength, 0.5, 0.5);
}
const $14caca14f2f8ea04$export$f498cfeee84e5e59 = $9e60b70ce0353b32$export$f59964a629598e2({
    hannWindow_: $14caca14f2f8ea04$var$hannWindow_
});




/**
 * Creates a `tf.Tensor` filled with a scalar value.
 *
 * ```js
 * tf.fill([2, 2], 4).print();
 * ```
 *
 * @param shape An array of integers defining the output tensor shape.
 * @param value The scalar value to fill the tensor with.
 * @param dtype The type of an element in the resulting tensor. Defaults to
 * 'float'.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $bc35e8e32cd99bc0$export$9563e054e6f787fb(shape, value, dtype) {
    const attrs = {
        shape: shape,
        value: value,
        dtype: dtype
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$ffffe40bfa0649a3, {}, attrs);
}








function $7e841f3329036206$export$b5469a65e8732256(values, shape, dtype) {
    $904921ed29eeae0f$export$44a06cc2759dd036(values);
    if (shape != null && shape.length !== 2) throw new Error('tensor2d() requires shape to have two numbers');
    const inferredShape = $d7ebc35f1f4a180c$export$467a8ad638b9ad20(values, dtype);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');
    if (inferredShape.length === 1 && shape == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return $ca9108fe9b0ad943$export$f41686c891d7ebce(values, shape, inferredShape, dtype);
}


/**
 * Expands input into frames of frameLength.
 * Slides a window size with frameStep.
 *
 * ```js
 * tf.signal.frame([1, 2, 3], 2, 1).print();
 * ```
 * @param signal The input tensor to be expanded
 * @param frameLength Length of each frame
 * @param frameStep The frame hop size in samples.
 * @param padEnd Whether to pad the end of signal with padValue.
 * @param padValue An number to use where the input signal does
 *     not exist when padEnd is True.
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */ function $76a13231d57cf76d$var$frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {
    let start = 0;
    const output = [];
    while(start + frameLength <= signal.size){
        output.push($346651c97f629fbf$export$58adb3bec8346d0f(signal, start, frameLength));
        start += frameStep;
    }
    if (padEnd) while(start < signal.size){
        const padLen = start + frameLength - signal.size;
        const pad = $876962a92a0aaf94$export$ee1b3e54f0441b22([
            $346651c97f629fbf$export$58adb3bec8346d0f(signal, start, frameLength - padLen),
            $bc35e8e32cd99bc0$export$9563e054e6f787fb([
                padLen
            ], padValue)
        ]);
        output.push(pad);
        start += frameStep;
    }
    if (output.length === 0) return $7e841f3329036206$export$b5469a65e8732256([], [
        0,
        frameLength
    ]);
    return $98803384c5ab66ad$export$9eaad88cf88cee2b($876962a92a0aaf94$export$ee1b3e54f0441b22(output), [
        output.length,
        frameLength
    ]);
}
const $76a13231d57cf76d$export$2cef06c20297c17d = $9e60b70ce0353b32$export$f59964a629598e2({
    frame_: $76a13231d57cf76d$var$frame_
});







/**
 * Computes the Short-time Fourier Transform of signals
 * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform
 *
 * ```js
 * const input = tf.tensor1d([1, 1, 1, 1, 1])
 * tf.signal.stft(input, 3, 1).print();
 * ```
 * @param signal 1-dimensional real value tensor.
 * @param frameLength The window length of samples.
 * @param frameStep The number of samples to step.
 * @param fftLength The size of the FFT to apply.
 * @param windowFn A callable that takes a window length and returns 1-d tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */ function $c9f36a23b692b96e$var$stft_(signal, frameLength, frameStep, fftLength, windowFn = $14caca14f2f8ea04$export$f498cfeee84e5e59) {
    if (fftLength == null) fftLength = $4685c14e372486ba$export$6fc2fe3b19043bf3(frameLength);
    const framedSignal = $76a13231d57cf76d$export$2cef06c20297c17d(signal, frameLength, frameStep);
    const windowedSignal = $51103026006cddca$export$6e3a27864ab166fe(framedSignal, windowFn(frameLength));
    return $90ed2cf7a791761c$export$72aff1768917e9e5(windowedSignal, fftLength);
}
const $c9f36a23b692b96e$export$eb1cf9b274257b4a = $9e60b70ce0353b32$export$f59964a629598e2({
    stft_: $c9f36a23b692b96e$var$stft_
});






/**
 * Extracts crops from the input image tensor and resizes them using bilinear
 * sampling or nearest neighbor sampling (possibly with aspect ratio change)
 * to a common output size specified by cropSize.
 *
 * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,
 *     where imageHeight and imageWidth must be positive, specifying the
 *     batch of images from which to take crops
 * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized
 *     coordinates of the box in the boxInd[i]'th image in the batch
 * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range
 *     `[0, batch)` that specifies the image that the `i`-th box refers to.
 * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`
 *     specifying the size to which all crops are resized to.
 * @param method Optional string from `'bilinear' | 'nearest'`,
 *     defaults to bilinear, which specifies the sampling method for resizing
 * @param extrapolationValue A threshold for deciding when to remove boxes based
 *     on score. Defaults to 0.
 * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $9a6f7e9712081be4$var$cropAndResize_(image, boxes, boxInd, cropSize, method = 'bilinear', extrapolationValue = 0) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'cropAndResize');
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'cropAndResize', 'float32');
    const $boxInd = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxInd, 'boxInd', 'cropAndResize', 'int32');
    const numBoxes = $boxes.shape[0];
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank === 4, ()=>'Error in cropAndResize: image must be rank 4,' + `but got rank ${$image.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($boxes.rank === 2 && $boxes.shape[1] === 4, ()=>`Error in cropAndResize: boxes must be have size [${numBoxes},4] ` + `but had shape ${$boxes.shape}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, ()=>`Error in cropAndResize: boxInd must be have size [${numBoxes}] ` + `but had shape ${$boxes.shape}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(cropSize.length === 2, ()=>`Error in cropAndResize: cropSize must be of length 2, but got ` + `length ${cropSize.length}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(cropSize[0] >= 1 && cropSize[1] >= 1, ()=>`cropSize must be atleast [1,1], but was ${cropSize}`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(method === 'bilinear' || method === 'nearest', ()=>`method must be bilinear or nearest, but was ${method}`
    );
    const inputs = {
        image: $image,
        boxes: $boxes,
        boxInd: $boxInd
    };
    const attrs = {
        method: method,
        extrapolationValue: extrapolationValue,
        cropSize: cropSize
    };
    const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$50bc9557793c2e04, inputs, attrs);
    return res;
}
const $9a6f7e9712081be4$export$6f0f0090e1f6cd3c = $9e60b70ce0353b32$export$f59964a629598e2({
    cropAndResize_: $9a6f7e9712081be4$var$cropAndResize_
});






/**
 * Flips the image left to right. Currently available in the CPU, WebGL, and
 * WASM backends.
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 */ /** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */ function $254dd336f4b96d50$var$flipLeftRight_(image) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'flipLeftRight', 'float32');
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank === 4, ()=>'Error in flipLeftRight: image must be rank 4,' + `but got rank ${$image.rank}.`
    );
    const inputs = {
        image: $image
    };
    const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$34e7296fc8558df5, inputs, {});
    return res;
}
const $254dd336f4b96d50$export$8358b9c43b687b22 = $9e60b70ce0353b32$export$f59964a629598e2({
    flipLeftRight_: $254dd336f4b96d50$var$flipLeftRight_
});









/**
 * Construct a tensor by repeating it the number of times given by reps.
 *
 * This operation creates a new tensor by replicating `input` `reps`
 * times. The output tensor's i'th dimension has `input.shape[i] *
 * reps[i]` elements, and the values of `input` are replicated
 * `reps[i]` times along the i'th dimension. For example, tiling
 * `[a, b, c, d]` by `[2]` produces `[a, b, c, d, a, b, c, d]`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 *
 * a.tile([2]).print();    // or a.tile([2])
 * ```
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * a.tile([1, 2]).print();  // or a.tile([1, 2])
 * ```
 * @param x The tensor to tile.
 * @param reps Determines the number of replications per dimension.
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $cbba2f030ac27cfb$var$tile_(x, reps) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'tile', 'string_or_numeric');
    $904921ed29eeae0f$export$a7a9523472993e97($x.rank === reps.length, ()=>`Error in transpose: rank of input ${$x.rank} ` + `must match length of reps ${reps}.`
    );
    const inputs = {
        x: $x
    };
    const attrs = {
        reps: reps
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$235cb65c20ad2b7, inputs, attrs);
}
const $cbba2f030ac27cfb$export$3c17558da18e4d75 = $9e60b70ce0353b32$export$f59964a629598e2({
    tile_: $cbba2f030ac27cfb$var$tile_
});


/**
 * Converts images from grayscale to RGB format.
 *
 * @param image A grayscale tensor to convert. The `image`'s last dimension must
 *     be size 1 with at least a two-dimensional shape.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $fed617945c920379$var$grayscaleToRGB_(image) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'grayscaleToRGB');
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank >= 2, ()=>'Error in grayscaleToRGB: images must be at least rank 2, ' + `but got rank ${$image.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(lastDims === 1, ()=>'Error in grayscaleToRGB: last dimension of a grayscale image ' + `should be size 1, but got size ${lastDims}.`
    );
    const reps = new Array($image.rank);
    reps.fill(1, 0, lastDimsIdx);
    reps[lastDimsIdx] = 3;
    return $cbba2f030ac27cfb$export$3c17558da18e4d75($image, reps);
}
const $fed617945c920379$export$f68e334bfd7e4be6 = $9e60b70ce0353b32$export$f59964a629598e2({
    grayscaleToRGB_: $fed617945c920379$var$grayscaleToRGB_
});






/**
 * Rotates the input image tensor counter-clockwise with an optional offset
 * center of rotation. Currently available in the CPU, WebGL, and WASM backends.
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 * @param radians The amount of rotation.
 * @param fillValue The value to fill in the empty space leftover
 *     after rotation. Can be either a single grayscale value (0-255), or an
 *     array of three numbers `[red, green, blue]` specifying the red, green,
 *     and blue channels. Defaults to `0` (black).
 * @param center The center of rotation. Can be either a single value (0-1), or
 *     an array of two numbers `[centerX, centerY]`. Defaults to `0.5` (rotates
 *     the image around its center).
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $13ef23286cc1fec0$var$rotateWithOffset_(image, radians, fillValue = 0, center = 0.5) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'rotateWithOffset', 'float32');
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank === 4, ()=>'Error in rotateWithOffset: image must be rank 4,' + `but got rank ${$image.rank}.`
    );
    const inputs = {
        image: $image
    };
    const attrs = {
        radians: radians,
        fillValue: fillValue,
        center: center
    };
    const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$c5a44649815d1c3, inputs, attrs);
    return res;
}
const $13ef23286cc1fec0$export$66462c489f5f29d2 = $9e60b70ce0353b32$export$f59964a629598e2({
    rotateWithOffset_: $13ef23286cc1fec0$var$rotateWithOffset_
});





function $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    if (iouThreshold == null) iouThreshold = 0.5;
    if (scoreThreshold == null) scoreThreshold = Number.NEGATIVE_INFINITY;
    if (softNmsSigma == null) softNmsSigma = 0.0;
    const numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    $904921ed29eeae0f$export$a7a9523472993e97(0 <= iouThreshold && iouThreshold <= 1, ()=>`iouThreshold must be in [0, 1], but was '${iouThreshold}'`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(boxes.rank === 2, ()=>`boxes must be a 2D tensor, but was of rank '${boxes.rank}'`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(boxes.shape[1] === 4, ()=>`boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(scores.rank === 1, ()=>'scores must be a 1D tensor'
    );
    $904921ed29eeae0f$export$a7a9523472993e97(scores.shape[0] === numBoxes, ()=>`scores has incompatible shape with boxes. Expected ${numBoxes}, ` + `but was ${scores.shape[0]}`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(0 <= softNmsSigma && softNmsSigma <= 1, ()=>`softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`
    );
    return {
        maxOutputSize: maxOutputSize,
        iouThreshold: iouThreshold,
        scoreThreshold: scoreThreshold,
        softNmsSigma: softNmsSigma
    };
}



/**
 * Performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @return A 1D tensor with the selected box indices.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $4068be45ca5b4399$var$nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppression', 'float32');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppression', 'float32');
    const inputs = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const attrs = {
        maxOutputSize: maxOutputSize,
        iouThreshold: iouThreshold,
        scoreThreshold: scoreThreshold
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$5e11788439c2f04, {
        boxes: $boxes,
        scores: $scores
    }, attrs);
}
const $4068be45ca5b4399$export$b7d265b19ca1d628 = $9e60b70ce0353b32$export$f59964a629598e2({
    nonMaxSuppression_: $4068be45ca5b4399$var$nonMaxSuppression_
});





/**
 * Performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * This is the async version of `nonMaxSuppression`
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @return A 1D tensor with the selected box indices.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ async function $f5df98b1bb2dbb6d$var$nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppressionAsync');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppressionAsync');
    const inputs = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const boxesAndScores = await Promise.all([
        $boxes.data(),
        $scores.data()
    ]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    // We call a cpu based impl directly with the typedarray data  here rather
    // than a kernel because all kernels are synchronous (and thus cannot await
    // .data()).
    const { selectedIndices: selectedIndices  } = $eb9293ac2b3fed68$export$89e22275998c2878(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    if ($boxes !== boxes) $boxes.dispose();
    if ($scores !== scores) $scores.dispose();
    return $9e73a3beda7739fe$export$8133e3bf3cd8f464(selectedIndices, 'int32');
}
const $f5df98b1bb2dbb6d$export$cc6d94dffac2ee1a = $f5df98b1bb2dbb6d$var$nonMaxSuppressionAsync_;






/**
 * Performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * This op also supports a Soft-NMS mode (c.f.
 * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score
 * of other overlapping boxes, therefore favoring different regions of the image
 * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`
 * parameter to be larger than 0.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param softNmsSigma A float representing the sigma parameter for Soft NMS.
 *     When sigma is 0, it falls back to nonMaxSuppression.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - selectedScores: A 1D tensor with the corresponding scores for each
 *       selected box.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $6dadc37f16b5ed2a$var$nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppression');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppression');
    const params = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const inputs = {
        boxes: $boxes,
        scores: $scores
    };
    const attrs = {
        maxOutputSize: maxOutputSize,
        iouThreshold: iouThreshold,
        scoreThreshold: scoreThreshold,
        softNmsSigma: softNmsSigma
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$cb45d3fcefce2ef0, inputs, attrs);
    return {
        selectedIndices: result[0],
        selectedScores: result[1]
    };
}
const $6dadc37f16b5ed2a$export$d65fe1460f8c5b4e = $9e60b70ce0353b32$export$f59964a629598e2({
    nonMaxSuppressionWithScore_: $6dadc37f16b5ed2a$var$nonMaxSuppressionWithScore_
});





/**
 * Asynchronously performs non maximum suppression of bounding boxes based on
 * iou (intersection over union).
 *
 * This op also supports a Soft-NMS mode (c.f.
 * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score
 * of other overlapping boxes, therefore favoring different regions of the image
 * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`
 * parameter to be larger than 0.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param softNmsSigma A float representing the sigma parameter for Soft NMS.
 *     When sigma is 0, it falls back to nonMaxSuppression.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - selectedScores: A 1D tensor with the corresponding scores for each
 *       selected box.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ async function $dc9f2d7fa84285cf$var$nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0.0) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppressionAsync');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppressionAsync');
    const params = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const boxesAndScores = await Promise.all([
        $boxes.data(),
        $scores.data()
    ]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    // We call a cpu based impl directly with the typedarray data  here rather
    // than a kernel because all kernels are synchronous (and thus cannot await
    // .data()).
    const { selectedIndices: selectedIndices , selectedScores: selectedScores  } = $eb9293ac2b3fed68$export$4ff849794bce73c5(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    if ($boxes !== boxes) $boxes.dispose();
    if ($scores !== scores) $scores.dispose();
    return {
        selectedIndices: $9e73a3beda7739fe$export$8133e3bf3cd8f464(selectedIndices, 'int32'),
        selectedScores: $9e73a3beda7739fe$export$8133e3bf3cd8f464(selectedScores)
    };
}
const $dc9f2d7fa84285cf$export$d1826570c883f7cf = $dc9f2d7fa84285cf$var$nonMaxSuppressionWithScoreAsync_;






/**
 * Asynchronously performs non maximum suppression of bounding boxes based on
 * iou (intersection over union), with an option to pad results.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param padToMaxOutputSize Defalts to false. If true, size of output
 *     `selectedIndices` is padded to maxOutputSize.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - validOutputs: A scalar denoting how many elements in `selectedIndices`
 *       are valid. Valid elements occur first, then padding.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $0443107719a329d9$var$nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppression');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppression');
    const params = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const inputs = {
        boxes: $boxes,
        scores: $scores
    };
    const attrs = {
        maxOutputSize: $maxOutputSize,
        iouThreshold: $iouThreshold,
        scoreThreshold: $scoreThreshold,
        padToMaxOutputSize: padToMaxOutputSize
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$7df908154366fe7f, inputs, attrs);
    return {
        selectedIndices: result[0],
        validOutputs: result[1]
    };
}
const $0443107719a329d9$export$d8d10e31c41c95dc = $9e60b70ce0353b32$export$f59964a629598e2({
    nonMaxSuppressionPadded_: $0443107719a329d9$var$nonMaxSuppressionPadded_
});






/**
 * Asynchronously performs non maximum suppression of bounding boxes based on
 * iou (intersection over union), with an option to pad results.
 *
 * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is
 *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of
 *     the bounding box.
 * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.
 * @param maxOutputSize The maximum number of boxes to be selected.
 * @param iouThreshold A float representing the threshold for deciding whether
 *     boxes overlap too much with respect to IOU. Must be between [0, 1].
 *     Defaults to 0.5 (50% box overlap).
 * @param scoreThreshold A threshold for deciding when to remove boxes based
 *     on score. Defaults to -inf, which means any score is accepted.
 * @param padToMaxOutputSize Defalts to false. If true, size of output
 *     `selectedIndices` is padded to maxOutputSize.
 * @return A map with the following properties:
 *     - selectedIndices: A 1D tensor with the selected box indices.
 *     - validOutputs: A scalar denoting how many elements in `selectedIndices`
 *       are valid. Valid elements occur first, then padding.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ async function $f75eefac1c3b4572$var$nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = $d7ebc35f1f4a180c$export$ede379c4c939d71a(boxes, 'boxes', 'nonMaxSuppressionAsync');
    const $scores = $d7ebc35f1f4a180c$export$ede379c4c939d71a(scores, 'scores', 'nonMaxSuppressionAsync');
    const params = $3af03ed73b9cbf53$export$ccf61bcb3b4e6ac6($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const [boxesVals, scoresVals] = await Promise.all([
        $boxes.data(),
        $scores.data()
    ]);
    // We call a cpu based impl directly with the typedarray data here rather
    // than a kernel because all kernels are synchronous (and thus cannot await
    // .data()).
    const { selectedIndices: selectedIndices , validOutputs: validOutputs  } = $eb9293ac2b3fed68$export$697e7a8cdfefe3a(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
    if ($boxes !== boxes) $boxes.dispose();
    if ($scores !== scores) $scores.dispose();
    return {
        selectedIndices: $9e73a3beda7739fe$export$8133e3bf3cd8f464(selectedIndices, 'int32'),
        validOutputs: $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(validOutputs, 'int32')
    };
}
const $f75eefac1c3b4572$export$4c5691f9710b88a8 = $f75eefac1c3b4572$var$nonMaxSuppressionPaddedAsync_;







/**
 * Bilinear resize a single 3D image or a batch of 3D images to a new shape.
 *
 * @param images The images, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param size The new shape `[newHeight, newWidth]` to resize the
 *     images to. Each channel is resized individually.
 * @param alignCorners Defaults to `false`. If true, rescale
 *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4
 *     corners of images and resized images. If false, rescale by
 *     `new_height / height`. Treat similarly the width dimension.
 * @param halfPixelCenters Defaults to `false`. Whether to assume pixel centers
 *     are at 0.5, which would make the floating point coordinates of the top
 *     left pixel 0.5, 0.5.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $3c4bba35a6466ccb$var$resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = $d7ebc35f1f4a180c$export$ede379c4c939d71a(images, 'images', 'resizeBilinear');
    $904921ed29eeae0f$export$a7a9523472993e97($images.rank === 3 || $images.rank === 4, ()=>`Error in resizeBilinear: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(size.length === 2, ()=>`Error in resizeBilinear: new shape must 2D, but got shape ` + `${size}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(halfPixelCenters === false || alignCorners === false, ()=>`Error in resizeBilinear: If halfPixelCenters is true, ` + `alignCorners must be false.`
    );
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = $98803384c5ab66ad$export$9eaad88cf88cee2b($images, [
            1,
            $images.shape[0],
            $images.shape[1],
            $images.shape[2]
        ]);
    }
    const [] = size;
    const inputs = {
        images: batchImages
    };
    const attrs = {
        alignCorners: alignCorners,
        halfPixelCenters: halfPixelCenters,
        size: size
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$24f2f15d869e0fd, inputs, attrs);
    if (reshapedTo4D) return $98803384c5ab66ad$export$9eaad88cf88cee2b(res, [
        res.shape[1],
        res.shape[2],
        res.shape[3]
    ]);
    return res;
}
const $3c4bba35a6466ccb$export$1f1cbc7da93d06a0 = $9e60b70ce0353b32$export$f59964a629598e2({
    resizeBilinear_: $3c4bba35a6466ccb$var$resizeBilinear_
});







/**
 * NearestNeighbor resize a batch of 3D images to a new shape.
 *
 * @param images The images, of rank 4 or rank 3, of shape
 *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.
 * @param size The new shape `[newHeight, newWidth]` to resize the
 *     images to. Each channel is resized individually.
 * @param alignCorners Defaults to False. If true, rescale
 *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4
 *     corners of images and resized images. If false, rescale by
 *     `new_height / height`. Treat similarly the width dimension.
 * @param halfPixelCenters Defaults to `false`. Whether to assumes pixels are of
 *      half the actual dimensions, and yields more accurate resizes. This flag
 *      would also make the floating point coordinates of the top left pixel
 *      0.5, 0.5.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $d222a579c76dbb58$var$resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
    const $images = $d7ebc35f1f4a180c$export$ede379c4c939d71a(images, 'images', 'resizeNearestNeighbor');
    $904921ed29eeae0f$export$a7a9523472993e97($images.rank === 3 || $images.rank === 4, ()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(size.length === 2, ()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ` + `${size}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($images.dtype === 'float32' || $images.dtype === 'int32', ()=>'`images` must have `int32` or `float32` as dtype'
    );
    $904921ed29eeae0f$export$a7a9523472993e97(halfPixelCenters === false || alignCorners === false, ()=>`Error in resizeNearestNeighbor: If halfPixelCenters is true, ` + `alignCorners must be false.`
    );
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
        reshapedTo4D = true;
        batchImages = $98803384c5ab66ad$export$9eaad88cf88cee2b($images, [
            1,
            $images.shape[0],
            $images.shape[1],
            $images.shape[2]
        ]);
    }
    const [] = size;
    const inputs = {
        images: batchImages
    };
    const attrs = {
        alignCorners: alignCorners,
        halfPixelCenters: halfPixelCenters,
        size: size
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$6c8d8ec26192bb18, inputs, attrs);
    if (reshapedTo4D) return $98803384c5ab66ad$export$9eaad88cf88cee2b(res, [
        res.shape[1],
        res.shape[2],
        res.shape[3]
    ]);
    return res;
}
const $d222a579c76dbb58$export$74a902ae74ac2560 = $9e60b70ce0353b32$export$f59964a629598e2({
    resizeNearestNeighbor_: $d222a579c76dbb58$var$resizeNearestNeighbor_
});










/**
 * Outputs a vector with length `size` and the same dtype as `weights`.
 *
 * If `weights` are empty, then index `i` stores the number of times the value
 * `i` is counted in `x`. If `weights` are non-empty, then index `i` stores the
 * sum of the value in `weights` at each index where the corresponding value in
 * `x` is `i`.
 *
 * Values in `x` outside of the range [0, size) are ignored.
 *
 * @param x The input int tensor, rank 1.
 * @param weights The weights tensor, must have the same shape as x, or a
 *     length-0 Tensor, in which case it acts as all weights equal to 1.
 * @param size Non-negative integer.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $1c6f757aa10b0ef1$var$bincount_(x, weights, size) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'bincount');
    const $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'bincount');
    $904921ed29eeae0f$export$a7a9523472993e97($x.dtype === 'int32', ()=>`Error in bincount: input ` + `dtype must be int32, but got ${$x.dtype}`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(size >= 0, ()=>`size must be non-negative, but got ${size}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($weights.size === $x.size || $weights.size === 0, ()=>`Error in bincount: weights must have the same size as input or` + `0-length, but got input shape: ${$x.shape}, weights shape: ` + `${$weights.shape}.`
    );
    const inputs = {
        x: $x,
        weights: $weights
    };
    const attrs = {
        size: size
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$45dfbbff595c32aa, inputs, attrs);
}
const $1c6f757aa10b0ef1$export$7e474bab088ed182 = $9e60b70ce0353b32$export$f59964a629598e2({
    bincount_: $1c6f757aa10b0ef1$var$bincount_
});








/**
 * Returns the truth value of (a <= b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.lessEqual(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $d4cb63e3ca686302$var$lessEqual_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'lessEqual', 'string_or_numeric');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'lessEqual', 'string_or_numeric');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$84afd0d8f7fb8c5d, inputs);
}
const $d4cb63e3ca686302$export$c24ad19a692bb92 = $9e60b70ce0353b32$export$f59964a629598e2({
    lessEqual_: $d4cb63e3ca686302$var$lessEqual_
});








/**
 * Returns the truth value of (a > b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.greater(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $e4ebbf786ece8ab8$var$greater_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'greater', 'string_or_numeric');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'greater', 'string_or_numeric');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d0a25eac5ee3f515, inputs);
}
const $e4ebbf786ece8ab8$export$9dca161faaf6308b = $9e60b70ce0353b32$export$f59964a629598e2({
    greater_: $e4ebbf786ece8ab8$var$greater_
});








/**
 * Adds two `tf.Tensor`s element-wise, A + B. Supports broadcasting.
 *
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3, 4]);
 * const b = tf.tensor1d([10, 20, 30, 40]);
 *
 * a.add(b).print();  // or tf.add(a, b)
 * ```
 *
 * ```js
 * // Broadcast add a with b.
 * const a = tf.scalar(5);
 * const b = tf.tensor1d([10, 20, 30, 40]);
 *
 * a.add(b).print();  // or tf.add(a, b)
 * ```
 * @param a The first `tf.Tensor` to add.
 * @param b The second `tf.Tensor` to add. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $a5476a4579f57f2c$var$add_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'add');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'add');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d0265b2c425512d6, inputs);
}
const $a5476a4579f57f2c$export$e16d8520af44a096 = $9e60b70ce0353b32$export$f59964a629598e2({
    add_: $a5476a4579f57f2c$var$add_
});












/**
 * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.
 * The result is rounded with floor function.
 *
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 9, 16]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.floorDiv(b).print();  // or tf.div(a, b)
 * ```
 *
 * ```js
 * // Broadcast div a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(2);
 *
 * a.floorDiv(b).print();  // or tf.floorDiv(a, b)
 * ```
 *
 * @param a The first tensor as the numerator.
 * @param b The second tensor as the denominator. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $79cd050f843d8504$var$floorDiv_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'floorDiv');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'floorDiv');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d79b5692ede26c2f, inputs);
}
const $79cd050f843d8504$export$112397bc52715a8 = $9e60b70ce0353b32$export$f59964a629598e2({
    floorDiv_: $79cd050f843d8504$var$floorDiv_
});



/**
 * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 9, 16]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.div(b).print();  // or tf.div(a, b)
 * ```
 *
 * ```js
 * // Broadcast div a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(2);
 *
 * a.div(b).print();  // or tf.div(a, b)
 * ```
 *
 * @param a The first tensor as the numerator.
 * @param b The second tensor as the denominator. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $172176b86d7c43d7$var$div_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'div');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'div');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    if ($a.dtype === 'int32' && $b.dtype === 'int32') return $79cd050f843d8504$export$112397bc52715a8($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    const attrs = {};
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$b9880b86e1014bb8, inputs, attrs);
}
const $172176b86d7c43d7$export$159d9494db57879b = $9e60b70ce0353b32$export$f59964a629598e2({
    div_: $172176b86d7c43d7$var$div_
});







/**
 * Subtracts two `tf.Tensor`s element-wise, A - B. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([10, 20, 30, 40]);
 * const b = tf.tensor1d([1, 2, 3, 4]);
 *
 * a.sub(b).print();  // or tf.sub(a, b)
 * ```
 *
 * ```js
 * // Broadcast subtract a with b.
 * const a = tf.tensor1d([10, 20, 30, 40]);
 * const b = tf.scalar(5);
 *
 * a.sub(b).print();  // or tf.sub(a, b)
 * ```
 * @param a The first `tf.Tensor` to subtract from.
 * @param b The second `tf.Tensor` to be subtracted. Must have the same dtype as
 * `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $5a1a44a0d119135c$var$sub_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'sub');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'sub');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d7a01e11500dfb6f, inputs);
}
const $5a1a44a0d119135c$export$f93b5905241a7cca = $9e60b70ce0353b32$export$f59964a629598e2({
    sub_: $5a1a44a0d119135c$var$sub_
});






/**
 * Computes round of input `tf.Tensor` element-wise: `round(x)`.
 * It implements banker's rounding.
 *
 * ```js
 * const x = tf.tensor1d([.6, 1.1, -3.3]);
 *
 * x.round().print();  // or tf.round(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $9441e421ccada777$var$round_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'round');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$c5ed3eef16c0612f, inputs);
}
const $9441e421ccada777$export$2077e0241d6afd3c = $9e60b70ce0353b32$export$f59964a629598e2({
    round_: $9441e421ccada777$var$round_
});











/**
 * Broadcast an array to a compatible shape NumPy-style.
 *
 * The tensor's shape is compared to the broadcast shape from end to beginning.
 * Ones are prepended to the tensor's shape until is has the same length as
 * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is
 * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then
 * the input tensor is tiled N times along that axis (using tf.tile).
 *
 * @param input The tensor that is to be broadcasted.
 * @param shape The input is to be broadcast to this shape.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */ function $68a3b4cf27d48fcd$var$broadcastTo_(x, shape) {
    let input = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'broadcastTo', 'x');
    const xShape = input.shape;
    if (shape.some((d)=>!(d > 0) || d % 1 !== 0
    )) throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);
    if (shape.length < input.rank) throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
    if (shape.length > input.rank) {
        const newShape = input.shape.slice();
        while(newShape.length < shape.length)newShape.unshift(1);
        input = $98803384c5ab66ad$export$9eaad88cf88cee2b(input, newShape);
    }
    const inputShape = input.shape;
    const reps = Array.from(shape);
    for(let i1 = shape.length - 1; i1 >= 0; i1--){
        if (inputShape[i1] === shape[i1]) reps[i1] = 1;
        else if (input.shape[i1] !== 1) throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
    }
    const axes = reps.map((n, i)=>n > 1 ? i : -1
    ).filter((i)=>i >= 0
    );
    if (axes.length === 0) return $e3b15dff351ca276$export$9cd59f9826255e47(input);
    // TODO call broadcastTo kernel directly once backends implement broadcstTo
    const inputs = {
        x: input
    };
    const attrs = {
        reps: reps
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$235cb65c20ad2b7, inputs, attrs);
}
const $68a3b4cf27d48fcd$export$ec9086aff2624eab = $9e60b70ce0353b32$export$f59964a629598e2({
    broadcastTo_: $68a3b4cf27d48fcd$var$broadcastTo_
});




/**
 * Returns the elements, either `a` or `b` depending on the `condition`.
 *
 * If the condition is true, select from `a`, otherwise select from `b`.
 *
 * ```js
 * const cond = tf.tensor1d([false, false, true], 'bool');
 * const a = tf.tensor1d([1 , 2, 3]);
 * const b = tf.tensor1d([-1, -2, -3]);
 *
 * a.where(cond, b).print();
 * ```
 *
 * @param condition The input condition. Must be of dtype bool.
 * @param a If `condition` is rank 1, `a` may have a higher rank but
 *     its first dimension must match the size of `condition`.
 * @param b A tensor with the same dtype as `a` and with shape that is
 *     compatible with `a`.
 * @return A tensor with same dtype as `a` and `b`, and shape that is
 *     broadcastable from `a` and `b`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $ab8a00845a489e8f$var$where_(condition, a, b) {
    const $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'where');
    const $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'where');
    const $condition = $d7ebc35f1f4a180c$export$ede379c4c939d71a(condition, 'condition', 'where', 'bool');
    // TODO: move this logic to forward function when the broadcastTo op is
    // implemented in WASM.
    // Find the broadcastable shape for $condition, $a, and $b.
    const broadcastShape = $c374f26140f3eb6b$export$a3e2a38a57ec8318($c374f26140f3eb6b$export$a3e2a38a57ec8318($condition.shape, $a.shape), $b.shape);
    const $broadcastedCondition = $68a3b4cf27d48fcd$export$ec9086aff2624eab($condition, broadcastShape);
    const $broadcastedA = $68a3b4cf27d48fcd$export$ec9086aff2624eab($a, broadcastShape);
    const $broadcastedB = $68a3b4cf27d48fcd$export$ec9086aff2624eab($b, broadcastShape);
    const inputs = {
        condition: $broadcastedCondition,
        t: $broadcastedA,
        e: $broadcastedB
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$ef9b1a59e592288f, inputs);
}
const $ab8a00845a489e8f$export$9c59b80dda569a6e = $9e60b70ce0353b32$export$f59964a629598e2({
    where_: $ab8a00845a489e8f$var$where_
});






function $05b749438087924f$export$d02631cccf789723(start, stop, step = 1, dtype = 'float32') {
    if (step === 0) throw new Error('Cannot have a step of zero');
    const attrs = {
        start: start,
        stop: stop,
        step: step,
        dtype: dtype
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$9a58ef0d7ad3278c, {} /* inputs */ , attrs);
}





/**
 * Performs image binarization with corresponding threshold
 * (depends on the method)value, which creates a binary image from a grayscale.
 * @param image 3d tensor of shape [imageHeight,imageWidth, depth],
 * where imageHeight and imageWidth must be positive.The image color
 * range should be [0, 255].
 * @param method Optional string from `'binary' | 'otsu'`
 * which specifies the method for thresholding. Defaults to 'binary'.
 * @param inverted Optional boolean whichspecifies
 * if colours should be inverted. Defaults to false.
 * @param threshValue Optional number which defines threshold value from 0 to 1.
 * Defaults to 0.5.
 * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which
 * contains binarized image.
 */ function $8f2ec818e3d7c7f5$var$threshold_(image, method = 'binary', inverted = false, threshValue = 0.5) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'threshold');
    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.
    Reference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */ const RED_INTENCITY_COEF = 0.2989;
    const GREEN_INTENCITY_COEF = 0.5870;
    const BLUE_INTENCITY_COEF = 0.1140;
    const totalPixelsInImage = $image.shape[0] * $image.shape[1];
    let $threshold = $51103026006cddca$export$6e3a27864ab166fe($9e73a3beda7739fe$export$8133e3bf3cd8f464([
        threshValue
    ]), 255);
    let r, g, b, grayscale;
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank === 3, ()=>'Error in threshold: image must be rank 3,' + `but got rank ${$image.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($image.shape[2] === 3 || $image.shape[2] === 1, ()=>"Error in threshold: image color channel must be equal to 3 or 1" + `but got ${$image.shape[2]}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($image.dtype === 'int32' || $image.dtype === 'float32', ()=>'Error in dtype: image dtype must be int32 or float32,' + `but got dtype ${$image.dtype}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(method === 'otsu' || method === 'binary', ()=>`Method must be binary or otsu, but was ${method}`
    );
    if ($image.shape[2] === 3) {
        [r, g, b] = $5d65ece42b107e33$export$65980d18b75784e2($image, [
            1,
            1,
            1
        ], -1);
        const $r = $51103026006cddca$export$6e3a27864ab166fe(r, RED_INTENCITY_COEF);
        const $g = $51103026006cddca$export$6e3a27864ab166fe(g, GREEN_INTENCITY_COEF);
        const $b = $51103026006cddca$export$6e3a27864ab166fe(b, BLUE_INTENCITY_COEF);
        grayscale = $a5476a4579f57f2c$export$e16d8520af44a096($a5476a4579f57f2c$export$e16d8520af44a096($r, $g), $b);
    } else grayscale = image;
    if (method === 'otsu') {
        const $histogram = $1c6f757aa10b0ef1$export$7e474bab088ed182($939ec2f1ca32d2a1$export$f2db7d5238e1d23f($9441e421ccada777$export$2077e0241d6afd3c(grayscale), 'int32'), $b61ddc0946231fbd$export$65df3ad1ad888abb([]), 256);
        $threshold = $8f2ec818e3d7c7f5$var$otsu($histogram, totalPixelsInImage);
    }
    const invCondition = inverted ? $d4cb63e3ca686302$export$c24ad19a692bb92(grayscale, $threshold) : $e4ebbf786ece8ab8$export$9dca161faaf6308b(grayscale, $threshold);
    const result = $939ec2f1ca32d2a1$export$f2db7d5238e1d23f($51103026006cddca$export$6e3a27864ab166fe(invCondition, 255), 'int32');
    return result;
}
function $8f2ec818e3d7c7f5$var$otsu(histogram, total) {
    let bestThresh = $9e73a3beda7739fe$export$8133e3bf3cd8f464([
        -1
    ]);
    let bestInBetVar = $9e73a3beda7739fe$export$8133e3bf3cd8f464([
        0
    ]);
    let cInBetVar = $9e73a3beda7739fe$export$8133e3bf3cd8f464([
        0
    ]);
    let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
    for(let index = 0; index < histogram.size - 1; index++){
        classFirst = $346651c97f629fbf$export$58adb3bec8346d0f(histogram, 0, index + 1);
        classSecond = $346651c97f629fbf$export$58adb3bec8346d0f(histogram, index + 1);
        weightForeground = $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(classFirst), total);
        weightBack = $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(classSecond), total);
        const meanFirstDivA = $f082be780698e75d$export$8a63f25cc62965f1($51103026006cddca$export$6e3a27864ab166fe(classFirst, $05b749438087924f$export$d02631cccf789723(0, classFirst.size)));
        meanFirst = $172176b86d7c43d7$export$159d9494db57879b(meanFirstDivA, $f082be780698e75d$export$8a63f25cc62965f1(classFirst));
        const meanSecFill = $bc35e8e32cd99bc0$export$9563e054e6f787fb(classSecond.shape, classFirst.size);
        const meanSecAdd = $a5476a4579f57f2c$export$e16d8520af44a096($05b749438087924f$export$d02631cccf789723(0, classSecond.size), meanSecFill);
        const meanSecMul = $51103026006cddca$export$6e3a27864ab166fe(classSecond, meanSecAdd);
        meanSec = $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(meanSecMul), $f082be780698e75d$export$8a63f25cc62965f1(classSecond));
        const cInBetVarSubA = $5a1a44a0d119135c$export$f93b5905241a7cca(meanFirst, meanSec);
        const cInBetVarSubB = $5a1a44a0d119135c$export$f93b5905241a7cca(meanFirst, meanSec);
        const cInBetVarMul = $51103026006cddca$export$6e3a27864ab166fe(weightForeground, weightBack);
        cInBetVar = $51103026006cddca$export$6e3a27864ab166fe($51103026006cddca$export$6e3a27864ab166fe(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
        const condition = $e4ebbf786ece8ab8$export$9dca161faaf6308b(cInBetVar, bestInBetVar);
        bestInBetVar = $ab8a00845a489e8f$export$9c59b80dda569a6e(condition, cInBetVar, bestInBetVar);
        bestThresh = $ab8a00845a489e8f$export$9c59b80dda569a6e(condition, $9e73a3beda7739fe$export$8133e3bf3cd8f464([
            index
        ]), bestThresh);
    }
    return bestThresh;
}
const $8f2ec818e3d7c7f5$export$454d09aca5f3ea63 = $9e60b70ce0353b32$export$f59964a629598e2({
    threshold_: $8f2ec818e3d7c7f5$var$threshold_
});






/**
 * Applies the given transform(s) to the image(s).
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 * @param transforms Projective transform matrix/matrices. A tensor1d of length
 *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0
 *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed
 *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),
 *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the
 *     transform mapping input points to output points.
 * @param interpolation Interpolation mode.
 *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.
 * @param fillMode Points outside the boundaries of the input are filled
 *     according to the given mode, one of 'constant', 'reflect', 'wrap',
 *     'nearest'. Default to 'constant'.
 *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by
 *     reflecting about the edge of the last pixel.
 *     'constant': (k k k k | a b c d | k k k k) The input is extended by
 *     filling all values beyond the edge with the same constant value k.
 *     'wrap': (a b c d | a b c d | a b c d) The input is extended by
 *     wrapping around to the opposite edge.
 *     'nearest': (a a a a | a b c d | d d d d) The input is extended by
 *     the nearest pixel.
 * @param fillValue A float represents the value to be filled outside the
 *     boundaries when fillMode is 'constant'.
 * @param Output dimension after the transform, [height, width]. If undefined,
 *     output is the same size as input image.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */ function $1b547eac402bf867$var$transform_(image, transforms, interpolation = 'nearest', fillMode = 'constant', fillValue = 0, outputShape) {
    const $image = $d7ebc35f1f4a180c$export$ede379c4c939d71a(image, 'image', 'transform', 'float32');
    const $transforms = $d7ebc35f1f4a180c$export$ede379c4c939d71a(transforms, 'transforms', 'transform', 'float32');
    $904921ed29eeae0f$export$a7a9523472993e97($image.rank === 4, ()=>'Error in transform: image must be rank 4,' + `but got rank ${$image.rank}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, ()=>`Error in transform: Input transform should be batch x 8 or 1 x 8`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(outputShape == null || outputShape.length === 2, ()=>'Error in transform: outputShape must be [height, width] or null, ' + `but got ${outputShape}.`
    );
    const inputs = {
        image: $image,
        transforms: $transforms
    };
    const attrs = {
        interpolation: interpolation,
        fillMode: fillMode,
        fillValue: fillValue,
        outputShape: outputShape
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$563a914cafbdc389, inputs, attrs);
}
const $1b547eac402bf867$export$51186ad6e864892a = $9e60b70ce0353b32$export$f59964a629598e2({
    transform_: $1b547eac402bf867$var$transform_
});









/**
 * Returns the truth value of (a >= b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([2, 2, 2]);
 *
 * a.greaterEqual(b).print();
 * ```
 *
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $5104da07fd0ef009$var$greaterEqual_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'greaterEqual', 'string_or_numeric');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'greaterEqual', 'string_or_numeric');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$3b7d21bc9aee0851, inputs);
}
const $5104da07fd0ef009$export$c2fd4164cadc1fa2 = $9e60b70ce0353b32$export$f59964a629598e2({
    greaterEqual_: $5104da07fd0ef009$var$greaterEqual_
});








/**
 * Returns the truth value of `a AND b` element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([false, false, true, true], 'bool');
 * const b = tf.tensor1d([false, true, false, true], 'bool');
 *
 * a.logicalAnd(b).print();
 * ```
 *
 * @param a The first input tensor. Must be of dtype bool.
 * @param b The second input tensor. Must be of dtype bool.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $039a44bc5c8e9082$var$logicalAnd_(a, b) {
    const $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'logicalAnd', 'bool');
    const $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'logicalAnd', 'bool');
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$8a27ff10dff4d6e5, inputs);
}
const $039a44bc5c8e9082$export$db5dd0ef9d505f = $9e60b70ce0353b32$export$f59964a629598e2({
    logicalAnd_: $039a44bc5c8e9082$var$logicalAnd_
});











/**
 * Stacks a list of rank-`R` `tf.Tensor`s into one rank-`(R+1)` `tf.Tensor`.
 *
 * ```js
 * const a = tf.tensor1d([1, 2]);
 * const b = tf.tensor1d([3, 4]);
 * const c = tf.tensor1d([5, 6]);
 * tf.stack([a, b, c]).print();
 * ```
 *
 * @param tensors A list of tensor objects with the same shape and dtype.
 * @param axis The axis to stack along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $01ba85cf120c021c$var$stack_(tensors, axis = 0) {
    const $tensors = $d7ebc35f1f4a180c$export$758e66616b4d410b(tensors, 'tensors', 'stack', 'string_or_numeric');
    $904921ed29eeae0f$export$a7a9523472993e97($tensors.length >= 1, ()=>'Pass at least one tensor to tf.stack'
    );
    if ($tensors.length > 0) $904921ed29eeae0f$export$a7a9523472993e97(axis <= $tensors[0].rank, ()=>'Axis must be <= rank of the tensor'
    );
    const inputs = $tensors;
    const attrs = {
        axis: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$c26f40b29201e5b7, inputs, attrs);
}
const $01ba85cf120c021c$export$a57ab32f40f83ea9 = $9e60b70ce0353b32$export$f59964a629598e2({
    stack_: $01ba85cf120c021c$var$stack_
});








/**
 * Unstacks a `tf.Tensor` of rank-`R` into a list of rank-`(R-1)` `tf.Tensor`s.
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * tf.unstack(a).forEach(tensor => tensor.print());
 * ```
 *
 * @param x A tensor object.
 * @param axis The axis to unstack along. Defaults to 0 (the first dim).
 *
 * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}
 */ function $c56090396ee120e9$var$unstack_(x, axis = 0) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'unstack', 'string_or_numeric');
    $904921ed29eeae0f$export$a7a9523472993e97(axis >= -$x.shape.length && axis < $x.shape.length, ()=>`Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`
    );
    const inputs = {
        value: $x
    };
    const attrs = {
        axis: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$441ad6bfc5db8ab4, inputs, attrs);
}
const $c56090396ee120e9$export$3c05285afa115eec = $9e60b70ce0353b32$export$f59964a629598e2({
    unstack_: $c56090396ee120e9$var$unstack_
});




/**
 * Copy a tensor setting everything outside a central band in each innermost
 * matrix to zero.
 *
 * The band part is computed as follows: Assume input has `k` dimensions
 * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where
 * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.
 * The indicator function
 * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower))`
 * `&& (num_upper < 0 || (n-m) <= num_upper)`
 *
 * ```js
 * const x = tf.tensor2d([[ 0,  1,  2, 3],
 *                        [-1,  0,  1, 2],
 *                        [-2, -1,  0, 1],
 *                        [-3, -2, -1, 0]]);
 * let y = tf.linalg.bandPart(x, 1, -1);
 * y.print(); // [[ 0,  1,  2, 3],
 *            //  [-1,  0,  1, 2],
 *            //  [ 0, -1,  0, 1],
 *            //  [ 0, 0 , -1, 0]]
 * let z = tf.linalg.bandPart(x, 2, 1);
 * z.print(); // [[ 0,  1,  0, 0],
 *            //  [-1,  0,  1, 0],
 *            //  [-2, -1,  0, 1],
 *            //  [ 0, -2, -1, 0]]
 * ```
 *
 * @param x Rank `k` tensor
 * @param numLower Number of subdiagonals to keep.
 *   If negative, keep entire lower triangle.
 * @param numUpper Number of subdiagonals to keep.
 *   If negative, keep entire upper triangle.
 * @returns Rank `k` tensor of the same shape as input.
 *   The extracted banded tensor.
 *
 * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}
 */ function $4eb45d43065c6608$var$bandPart_(a, numLower, numUpper) {
    $904921ed29eeae0f$export$a7a9523472993e97(numLower % 1 === 0, ()=>`bandPart(): numLower must be an integer, got ${numLower}.`
    );
    $904921ed29eeae0f$export$a7a9523472993e97(numUpper % 1 === 0, ()=>`bandPart(): numUpper must be an integer, got ${numUpper}.`
    );
    const $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'bandPart');
    $904921ed29eeae0f$export$a7a9523472993e97($a.rank >= 2, ()=>`bandPart(): Rank must be at least 2, got ${$a.rank}.`
    );
    const shape = $a.shape;
    const [M, N] = $a.shape.slice(-2);
    if (!(numLower <= M)) throw new Error(`bandPart(): numLower (${numLower})` + ` must not be greater than the number of rows (${M}).`);
    if (!(numUpper <= N)) throw new Error(`bandPart(): numUpper (${numUpper})` + ` must not be greater than the number of columns (${N}).`);
    if (numLower < 0) numLower = M;
    if (numUpper < 0) numUpper = N;
    const i = $98803384c5ab66ad$export$9eaad88cf88cee2b($05b749438087924f$export$d02631cccf789723(0, M, 1, 'int32'), [
        -1,
        1
    ]);
    const j = $05b749438087924f$export$d02631cccf789723(0, N, 1, 'int32');
    const ij = $5a1a44a0d119135c$export$f93b5905241a7cca(i, j);
    const inBand = $039a44bc5c8e9082$export$db5dd0ef9d505f($d4cb63e3ca686302$export$c24ad19a692bb92(ij, $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(+numLower, 'int32')), $5104da07fd0ef009$export$c2fd4164cadc1fa2(ij, $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(-numUpper, 'int32')));
    const zero = $1b84f1678bdd9c2a$export$4445a00dafa2633b([
        M,
        N
    ], $a.dtype);
    return $98803384c5ab66ad$export$9eaad88cf88cee2b($01ba85cf120c021c$export$a57ab32f40f83ea9($c56090396ee120e9$export$3c05285afa115eec($98803384c5ab66ad$export$9eaad88cf88cee2b($a, [
        -1,
        M,
        N
    ])).map((mat)=>$ab8a00845a489e8f$export$9c59b80dda569a6e(inBand, mat, zero)
    )), shape);
}
const $4eb45d43065c6608$export$8a3da9cb9e5610a0 = $9e60b70ce0353b32$export$f59964a629598e2({
    bandPart_: $4eb45d43065c6608$var$bandPart_
});











/**
 * Computes absolute value element-wise: `abs(x)`
 *
 * ```js
 * const x = tf.tensor1d([-1, 2, -3, 4]);
 *
 * x.abs().print();  // or tf.abs(x)
 * ```
 * @param x The input `tf.Tensor`.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $63f4b3b00d29e030$var$abs_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'abs');
    if ($x.dtype === 'complex64') {
        const inputs = {
            x: $x
        };
        return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$32902e58f1b48f4b, inputs);
    } else {
        const inputs = {
            x: $x
        };
        return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$b73c596ee8758a66, inputs);
    }
}
const $63f4b3b00d29e030$export$2335f513bbd82c6d = $9e60b70ce0353b32$export$f59964a629598e2({
    abs_: $63f4b3b00d29e030$var$abs_
});







/**
 * Computes the maximum of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in
 * `axes`. If `keepDims` is true, the reduced dimensions are retained with
 * length 1. If `axes` has no entries, all dimensions are reduced, and an
 * `tf.Tensor` with a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.max().print();  // or tf.max(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.max(axis).print();  // or tf.max(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $734c293f3e1e5e82$var$max_(x, axis = null, keepDims = false) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'max');
    const inputs = {
        x: $x
    };
    const attrs = {
        reductionIndices: axis,
        keepDims: keepDims
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$d36c09e5d02927e7, inputs, attrs);
}
const $734c293f3e1e5e82$export$8960430cfd85939f = $9e60b70ce0353b32$export$f59964a629598e2({
    max_: $734c293f3e1e5e82$var$max_
});






/**
 * Computes the minimum value from the input.
 *
 * Reduces the input along the dimensions given in `axes`. Unless `keepDims`
 * is true, the rank of the array is reduced by 1 for each entry in `axes`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axes` has no entries, all dimensions are reduced, and an array with a
 * single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.min().print();  // or tf.min(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.min(axis).print();  // or tf.min(x, axis)
 * ```
 *
 * @param x The input Tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $00645abe9a44ae3a$var$min_(x, axis = null, keepDims = false) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'min');
    const inputs = {
        x: $x
    };
    const attrs = {
        axis: axis,
        keepDims: keepDims
    };
    // tslint:disable-next-line: no-unnecessary-type-assertion
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$dfed19fabc75a31d, inputs, attrs);
}
const $00645abe9a44ae3a$export$96ec731ed4dcb222 = $9e60b70ce0353b32$export$f59964a629598e2({
    min_: $00645abe9a44ae3a$var$min_
});








/**
 * Computes the power of one `tf.Tensor` to another. Supports broadcasting.
 *
 * Given a `tf.Tensor` x and a `tf.Tensor` y, this operation computes x^y for
 * corresponding elements in x and y. The result's dtype will be the upcasted
 * type of the `base` and `exp` dtypes.
 *
 * ```js
 * const a = tf.tensor([[2, 3], [4, 5]])
 * const b = tf.tensor([[1, 2], [3, 0]]).toInt();
 *
 * a.pow(b).print();  // or tf.pow(a, b)
 * ```
 *
 * ```js
 * const a = tf.tensor([[1, 2], [3, 4]])
 * const b = tf.tensor(2).toInt();
 *
 * a.pow(b).print();  // or tf.pow(a, b)
 * ```
 * We also expose `powStrict` which has the same signature as this op and
 * asserts that `base` and `exp` are the same shape (does not broadcast).
 *
 * @param base The base `tf.Tensor` to pow element-wise.
 * @param exp The exponent `tf.Tensor` to pow element-wise.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $2bc3aa1f98d7a705$var$pow_(base, exp) {
    let $base = $d7ebc35f1f4a180c$export$ede379c4c939d71a(base, 'base', 'pow');
    let $exp = $d7ebc35f1f4a180c$export$ede379c4c939d71a(exp, 'exp', 'pow');
    [$base, $exp] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($base, $exp);
    const inputs = {
        a: $base,
        b: $exp
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$ce28d653ec559ee, inputs);
}
const $2bc3aa1f98d7a705$export$9c297f60e22e3389 = $9e60b70ce0353b32$export$f59964a629598e2({
    pow_: $2bc3aa1f98d7a705$var$pow_
});








/**
 * Computes square root of the input `tf.Tensor` element-wise: `y = sqrt(x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 4, -1]);
 *
 * x.sqrt().print();  // or tf.sqrt(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $1856327ba21a58b6$var$sqrt_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'sqrt', 'float32');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$21ab404ab9d512a6, inputs);
}
const $1856327ba21a58b6$export$eba8049fb5020b81 = $9e60b70ce0353b32$export$f59964a629598e2({
    sqrt_: $1856327ba21a58b6$var$sqrt_
});





/**
 * Computes square of `x` element-wise: `x ^ 2`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);
 *
 * x.square().print();  // or tf.square(x)
 * ```
 * @param x The input Tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $c1f388719de77577$var$square_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'square');
    const attrs = {};
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel('Square', {
        x: $x
    }, attrs);
}
const $c1f388719de77577$export$dd4f28cef696bc7d = $9e60b70ce0353b32$export$f59964a629598e2({
    square_: $c1f388719de77577$var$square_
});



/**
 * Computes the norm of scalar, vectors, and matrices.
 * This function can compute several different vector norms (the 1-norm, the
 * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)
 * and matrix norms (Frobenius, 1-norm, and inf-norm).
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.norm().print();  // or tf.norm(x)
 * ```
 *
 * @param x The input array.
 * @param ord Optional. Order of the norm. Supported norm types are
 * following:
 *
 *  | ord        | norm for matrices         | norm for vectors
 *  |------------|---------------------------|---------------------
 *  |'euclidean' |Frobenius norm             |2-norm
 *  |'fro'       |Frobenius norm	           |
 *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))
 *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))
 *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))
 *  |2           |                           |sum(abs(x)^2)^1/2*
 *
 * @param axis Optional. If axis is null (the default), the input is
 * considered a vector and a single vector norm is computed over the entire
 * set of values in the Tensor, i.e. norm(x, ord) is equivalent
 * to norm(x.reshape([-1]), ord). If axis is a integer, the input
 * is considered a batch of vectors, and axis determines the axis in x
 * over which to compute vector norms. If axis is a 2-tuple of integer it is
 * considered a batch of matrices and axis determines the axes in NDArray
 * over which to compute a matrix norm.
 * @param keepDims Optional. If true, the norm have the same dimensionality
 * as the input.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */ function $adc15c5dfda56123$var$norm_(x, ord = 'euclidean', axis = null, keepDims = false) {
    x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'norm');
    const $adc15c5dfda56123$export$1991ecd29cc92c6b = $adc15c5dfda56123$var$normImpl(x, ord, axis);
    let keepDimsShape = $adc15c5dfda56123$export$1991ecd29cc92c6b.shape;
    if (keepDims) {
        const axes = $904921ed29eeae0f$export$72b84eb9fe1f482(axis, x.shape);
        keepDimsShape = $0732cb950311b962$export$e35db9afe008d7e3($adc15c5dfda56123$export$1991ecd29cc92c6b.shape, axes);
    }
    return $98803384c5ab66ad$export$9eaad88cf88cee2b($adc15c5dfda56123$export$1991ecd29cc92c6b, keepDimsShape);
}
function $adc15c5dfda56123$var$normImpl(x, p, axis = null) {
    if (x.rank === 0) return $63f4b3b00d29e030$export$2335f513bbd82c6d(x);
    // consider vector when no axis is specified
    if (x.rank !== 1 && axis === null) return $adc15c5dfda56123$var$normImpl($98803384c5ab66ad$export$9eaad88cf88cee2b(x, [
        -1
    ]), p, axis);
    // vector
    if (x.rank === 1 || typeof axis === 'number' || Array.isArray(axis) && axis.length === 1) {
        if (p === 1) return $f082be780698e75d$export$8a63f25cc62965f1($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis);
        if (p === Infinity) return $734c293f3e1e5e82$export$8960430cfd85939f($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis);
        if (p === -Infinity) return $00645abe9a44ae3a$export$96ec731ed4dcb222($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis);
        if (p === 'euclidean' || p === 2) // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2
        return $1856327ba21a58b6$export$eba8049fb5020b81($f082be780698e75d$export$8a63f25cc62965f1($2bc3aa1f98d7a705$export$9c297f60e22e3389($63f4b3b00d29e030$export$2335f513bbd82c6d(x), $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(2, 'int32')), axis));
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    // matrix (assumption axis[0] < axis[1])
    if (Array.isArray(axis) && axis.length === 2) {
        if (p === 1) return $734c293f3e1e5e82$export$8960430cfd85939f($f082be780698e75d$export$8a63f25cc62965f1($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis[0]), axis[1] - 1);
        if (p === Infinity) return $734c293f3e1e5e82$export$8960430cfd85939f($f082be780698e75d$export$8a63f25cc62965f1($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis[1]), axis[0]);
        if (p === -Infinity) return $00645abe9a44ae3a$export$96ec731ed4dcb222($f082be780698e75d$export$8a63f25cc62965f1($63f4b3b00d29e030$export$2335f513bbd82c6d(x), axis[1]), axis[0]);
        if (p === 'fro' || p === 'euclidean') // norm(x) = sqrt(sum(pow(x, 2)))
        return $1856327ba21a58b6$export$eba8049fb5020b81($f082be780698e75d$export$8a63f25cc62965f1($c1f388719de77577$export$dd4f28cef696bc7d(x), axis));
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
}
const $adc15c5dfda56123$export$1991ecd29cc92c6b = $9e60b70ce0353b32$export$f59964a629598e2({
    norm_: $adc15c5dfda56123$var$norm_
});








/**
 * Removes dimensions of size 1 from the shape of a `tf.Tensor`.
 *
 * ```js
 * const x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);
 * x.squeeze().print();
 * ```
 *
 * @param x The input tensor to be squeezed.
 * @param axis An optional list of numbers. If specified, only
 *     squeezes the dimensions listed. The dimension index starts at 0. It
 * is an error to squeeze a dimension that is not 1.
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */ function $ab1704aa8b7085eb$var$squeeze_(x, axis) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'squeeze');
    return $98803384c5ab66ad$export$9eaad88cf88cee2b($x, $904921ed29eeae0f$export$3106ace2a3b5396d($x.shape, axis).newShape);
}
const $ab1704aa8b7085eb$export$889c931173b77c2f = $9e60b70ce0353b32$export$f59964a629598e2({
    squeeze_: $ab1704aa8b7085eb$var$squeeze_
});





/**
 * Gram-Schmidt orthogonalization.
 *
 * ```js
 * const x = tf.tensor2d([[1, 2], [3, 4]]);
 * let y = tf.linalg.gramSchmidt(x);
 * y.print();
 * console.log('Othogonalized:');
 * y.dot(y.transpose()).print();  // should be nearly the identity matrix.
 * console.log('First row direction maintained:');
 * const data = await y.array();
 * console.log(data[0][1] / data[0][0]);  // should be nearly 2.
 * ```
 *
 * @param xs The vectors to be orthogonalized, in one of the two following
 *   formats:
 *   - An Array of `tf.Tensor1D`.
 *   - A `tf.Tensor2D`, i.e., a matrix, in which case the vectors are the rows
 *     of `xs`.
 *   In each case, all the vectors must have the same length and the length
 *   must be greater than or equal to the number of vectors.
 * @returns The orthogonalized and normalized vectors or matrix.
 *   Orthogonalization means that the vectors or the rows of the matrix
 *   are orthogonal (zero inner products). Normalization means that each
 *   vector or each row of the matrix has an L2 norm that equals `1`.
 *
 * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}
 */ function $e9cde38139e46c57$var$gramSchmidt_(xs) {
    let inputIsTensor2D;
    if (Array.isArray(xs)) {
        inputIsTensor2D = false;
        $904921ed29eeae0f$export$a7a9523472993e97(xs != null && xs.length > 0, ()=>"Gram-Schmidt process: input must not be null, undefined, or empty"
        );
        const dim = xs[0].shape[0];
        for(let i = 1; i < xs.length; ++i)$904921ed29eeae0f$export$a7a9523472993e97(xs[i].shape[0] === dim, ()=>'Gram-Schmidt: Non-unique lengths found in the input vectors: ' + `(${xs[i].shape[0]} vs. ${dim})`
        );
    } else {
        inputIsTensor2D = true;
        xs = $5d65ece42b107e33$export$65980d18b75784e2(xs, xs.shape[0], 0).map((x)=>$ab1704aa8b7085eb$export$889c931173b77c2f(x, [
                0
            ])
        );
    }
    $904921ed29eeae0f$export$a7a9523472993e97(xs.length <= xs[0].shape[0], ()=>`Gram-Schmidt: Number of vectors (${xs.length}) exceeds ` + `number of dimensions (${xs[0].shape[0]}).`
    );
    const ys = [];
    const xs1d = xs;
    for(let i = 0; i < xs.length; ++i)ys.push($a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(()=>{
        let x = xs1d[i];
        if (i > 0) for(let j = 0; j < i; ++j){
            const proj = $51103026006cddca$export$6e3a27864ab166fe($f082be780698e75d$export$8a63f25cc62965f1($51103026006cddca$export$6e3a27864ab166fe(ys[j], x)), ys[j]);
            x = $5a1a44a0d119135c$export$f93b5905241a7cca(x, proj);
        }
        return $172176b86d7c43d7$export$159d9494db57879b(x, $adc15c5dfda56123$export$1991ecd29cc92c6b(x, 'euclidean'));
    }));
    if (inputIsTensor2D) return $01ba85cf120c021c$export$a57ab32f40f83ea9(ys, 0);
    else return ys;
}
const $e9cde38139e46c57$export$d505610386a600de = $9e60b70ce0353b32$export$f59964a629598e2({
    gramSchmidt_: $e9cde38139e46c57$var$gramSchmidt_
});






function $307e90c4876a9d4d$export$1e73b1267274f27e() {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('PROD', true);
}
function $307e90c4876a9d4d$export$ef8a131e8a882a3a() {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('DEBUG', true);
}
function $307e90c4876a9d4d$export$cb100329fdb11914() {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('DEPRECATION_WARNINGS_ENABLED', false);
    console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
}
function $307e90c4876a9d4d$export$e46eea6a629d2da5(msg) {
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEPRECATION_WARNINGS_ENABLED')) console.warn(msg + ' You can disable deprecation warnings with ' + 'tf.disableDeprecationWarnings().');
}
$c341eb4171cc0419$export$ca605c1d8919649f($307e90c4876a9d4d$export$e46eea6a629d2da5);
function $307e90c4876a9d4d$export$f22ce7a2fa538c48() {
    $a6bde3769fa0d8b5$export$33b63313cc511a3b.disposeVariables();
}
function $307e90c4876a9d4d$export$d3c662a6136faebb() {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b;
}
function $307e90c4876a9d4d$export$827b61424e8f52d2() {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.memory();
}
function $307e90c4876a9d4d$export$4882ae973e0491e(f) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.profile(f);
}
function $307e90c4876a9d4d$export$b841c6a213a653eb(nameOrFn, fn) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(nameOrFn, fn);
}
function $307e90c4876a9d4d$export$fcfbbcec2cb820d5(container) {
    const tensors = $f5b489dcdac9fd38$export$888c106d343989f5(container);
    tensors.forEach((tensor)=>tensor.dispose()
    );
}
function $307e90c4876a9d4d$export$fae3166c418e0471(result) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.keep(result);
}
function $307e90c4876a9d4d$export$2da9be4cfdb689b1(f) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.time(f);
}
function $307e90c4876a9d4d$export$7953970fabc9c2(backendName) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.setBackend(backendName);
}
function $307e90c4876a9d4d$export$28ee1007e174a2a6() {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.ready();
}
function $307e90c4876a9d4d$export$b098501f764cdf30() {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.backendName;
}
function $307e90c4876a9d4d$export$c299110fbe92c80c(name) {
    $a6bde3769fa0d8b5$export$33b63313cc511a3b.removeBackend(name);
}
function $307e90c4876a9d4d$export$f94fbc07ea8e852e(name) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.findBackend(name);
}
function $307e90c4876a9d4d$export$e4a6d214466a2c7b(name) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.findBackendFactory(name);
}
function $307e90c4876a9d4d$export$1ac8c3a90eff05d(name, factory, priority = 1) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.registerBackend(name, factory, priority);
}
function $307e90c4876a9d4d$export$32a253b6f8b50fb4() {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.backend;
}
function $307e90c4876a9d4d$export$5f05d56a0f2349cc(platformName, platform) {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().setPlatform(platformName, platform);
}












/**
 * Returns a `tf.Tensor` that has expanded rank, by inserting a dimension
 * into the tensor's shape.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 * const axis = 1;
 * x.expandDims(axis).print();
 * ```
 *
 * @param x The input tensor whose dimensions to be expanded.
 * @param axis The dimension index at which to insert shape of `1`. Defaults
 *     to 0 (the first dimension).
 *
 * @doc {heading: 'Tensors', subheading: 'Transformations'}
 */ function $3dcf7a87c207ee7e$var$expandDims_(x, axis = 0) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'expandDims', 'string_or_numeric');
    $904921ed29eeae0f$export$a7a9523472993e97(axis <= $x.rank, ()=>'Axis must be <= rank of the tensor'
    );
    const inputs = {
        input: $x
    };
    const attrs = {
        dim: axis
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$2391750b1d901146, inputs, attrs);
}
const $3dcf7a87c207ee7e$export$d660d8ed21f46635 = $9e60b70ce0353b32$export$f59964a629598e2({
    expandDims_: $3dcf7a87c207ee7e$var$expandDims_
});





/**
 * Create an identity matrix.
 *
 * @param numRows Number of rows.
 * @param numColumns Number of columns. Defaults to `numRows`.
 * @param batchShape If provided, will add the batch shape to the beginning
 *   of the shape of the returned `tf.Tensor` by repeating the identity
 *   matrix.
 * @param dtype Data type.
 * @returns Identity matrix of the specified size and data type, possibly
 *   with batch repetition if `batchShape` is specified.
 *
 * @doc {heading: 'Tensors', subheading: 'Creation'}
 */ function $ee1ce6dc76f8bb9a$var$eye_(numRows, numColumns, batchShape, dtype = 'float32') {
    if (numColumns == null) numColumns = numRows;
    const buff = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        numRows,
        numColumns
    ], dtype);
    const n = numRows <= numColumns ? numRows : numColumns;
    for(let i = 0; i < n; ++i)buff.set(1, i, i);
    const out = $98803384c5ab66ad$export$9eaad88cf88cee2b(buff.toTensor(), [
        numRows,
        numColumns
    ]);
    if (batchShape == null) return out;
    else {
        if (batchShape.length === 1) return $cbba2f030ac27cfb$export$3c17558da18e4d75($3dcf7a87c207ee7e$export$d660d8ed21f46635(out, 0), [
            batchShape[0],
            1,
            1
        ]);
        else if (batchShape.length === 2) // tslint:disable-next-line:no-unnecessary-type-assertion
        return $cbba2f030ac27cfb$export$3c17558da18e4d75($3dcf7a87c207ee7e$export$d660d8ed21f46635($3dcf7a87c207ee7e$export$d660d8ed21f46635(out, 0), 0), [
            batchShape[0],
            batchShape[1],
            1,
            1
        ]);
        else if (batchShape.length === 3) // tslint:disable-next-line:no-unnecessary-type-assertion
        return $cbba2f030ac27cfb$export$3c17558da18e4d75($3dcf7a87c207ee7e$export$d660d8ed21f46635($3dcf7a87c207ee7e$export$d660d8ed21f46635($3dcf7a87c207ee7e$export$d660d8ed21f46635(out, 0), 0), 0), [
            batchShape[0],
            batchShape[1],
            batchShape[2],
            1,
            1
        ]);
        else throw new Error(`eye() currently supports only 1D and 2D ` + // tslint:disable-next-line:no-any
        `batchShapes, but received ${batchShape.length}D.`);
    }
}
const $ee1ce6dc76f8bb9a$export$4e18cf730a59887e = $9e60b70ce0353b32$export$f59964a629598e2({
    eye_: $ee1ce6dc76f8bb9a$var$eye_
});








/**
 * Computes the dot product of two matrices, A * B. These must be matrices.
 *
 * ```js
 * const a = tf.tensor2d([1, 2], [1, 2]);
 * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * a.matMul(b).print();  // or tf.matMul(a, b)
 * ```
 * @param a First matrix in dot product operation.
 * @param b Second matrix in dot product operation.
 * @param transposeA If true, `a` is transposed before multiplication.
 * @param transposeB If true, `b` is transposed before multiplication.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */ function $8e2c3ff1a0ec32ef$var$matMul_(a, b, transposeA = false, transposeB = false) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'matMul');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'matMul');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    const inputs = {
        a: $a,
        b: $b
    };
    const attrs = {
        transposeA: transposeA,
        transposeB: transposeB
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$9a3bf60b23f63c8, inputs, attrs);
}
const $8e2c3ff1a0ec32ef$export$6706882a873e9a8f = $9e60b70ce0353b32$export$f59964a629598e2({
    matMul_: $8e2c3ff1a0ec32ef$var$matMul_
});







/**
 * Computes `-1 * x` element-wise.
 *
 * ```js
 * const x = tf.tensor2d([1, 2, -2, 0], [2, 2]);
 *
 * x.neg().print();  // or tf.neg(x)
 * ```
 *
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $9afab0e3465a64e7$var$neg_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'neg');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$c07c549000872073, inputs);
}
const $9afab0e3465a64e7$export$d9493ff0dfa0fdd5 = $9e60b70ce0353b32$export$f59964a629598e2({
    neg_: $9afab0e3465a64e7$var$neg_
});














/**
 * Transposes the `tf.Tensor`. Permutes the dimensions according to `perm`.
 *
 * The returned `tf.Tensor`'s dimension `i` will correspond to the input
 * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,
 * where `n` is the rank of the input `tf.Tensor`. Hence by default, this
 * operation performs a regular matrix transpose on 2-D input `tf.Tensor`s.
 *
 * ```js
 * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);
 *
 * a.transpose().print();  // or tf.transpose(a)
 * ```
 *
 * @param x The tensor to transpose.
 * @param perm The permutation of the dimensions of a.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */ function $d83991607c65447c$var$transpose_(x, perm) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'transpose');
    if (perm == null) perm = $x.shape.map((s, i)=>i
    ).reverse();
    $904921ed29eeae0f$export$a7a9523472993e97($x.rank === perm.length, ()=>`Error in transpose: rank of input ${$x.rank} ` + `must match length of perm ${perm}.`
    );
    perm.forEach((axis)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(axis >= 0 && axis < $x.rank, ()=>`All entries in 'perm' must be between 0 and ${$x.rank - 1}` + ` but got ${perm}`
        );
    });
    if ($x.rank <= 1) return $x.clone();
    const inputs = {
        x: $x
    };
    const attrs = {
        perm: perm
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$7e714455f9a1f8f7, inputs, attrs);
}
const $d83991607c65447c$export$9cb09a71b7d66923 = $9e60b70ce0353b32$export$f59964a629598e2({
    transpose_: $d83991607c65447c$var$transpose_
});




/**
 * Compute QR decomposition of m-by-n matrix using Householder transformation.
 *
 * Implementation based on
 *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]
 * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)
 *
 * ```js
 * const a = tf.tensor2d([[1, 2], [3, 4]]);
 * let [q, r] = tf.linalg.qr(a);
 * console.log('Q');
 * q.print();
 * console.log('R');
 * r.print();
 * console.log('Orthogonalized');
 * q.dot(q.transpose()).print()  // should be nearly the identity matrix.
 * console.log('Reconstructed');
 * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];
 * ```
 *
 * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose
 *   it has the shape `[..., M, N]`.
 * @param fullMatrices An optional boolean parameter. Defaults to `false`.
 *   If `true`, compute full-sized `Q`. If `false` (the default),
 *   compute only the leading N columns of `Q` and `R`.
 * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,
 *   i.e., its columns all have unit norm and are mutually orthogonal.
 *   If `M >= N`,
 *     If `fullMatrices` is `false` (default),
 *       - `Q` has a shape of `[..., M, N]`,
 *       - `R` has a shape of `[..., N, N]`.
 *     If `fullMatrices` is `true` (default),
 *       - `Q` has a shape of `[..., M, M]`,
 *       - `R` has a shape of `[..., M, N]`.
 *   If `M < N`,
 *     - `Q` has a shape of `[..., M, M]`,
 *     - `R` has a shape of `[..., M, N]`.
 * @throws If the rank of `x` is less than 2.
 *
 * @doc {heading:'Operations',
 *       subheading:'Linear Algebra',
 *       namespace:'linalg'}
 */ function $1ed7b586509233bb$var$qr_(x, fullMatrices = false) {
    $904921ed29eeae0f$export$a7a9523472993e97(x.rank >= 2, ()=>`qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`
    );
    if (x.rank === 2) return $1ed7b586509233bb$var$qr2d(x, fullMatrices);
    else {
        // Rank > 2.
        // TODO(cais): Below we split the input into individual 2D tensors,
        //   perform QR decomposition on them and then stack the results back
        //   together. We should explore whether this can be parallelized.
        const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev)=>value * prev
        );
        const x2ds = $c56090396ee120e9$export$3c05285afa115eec($98803384c5ab66ad$export$9eaad88cf88cee2b(x, [
            outerDimsProd,
            x.shape[x.shape.length - 2],
            x.shape[x.shape.length - 1]
        ]), 0);
        const q2ds = [];
        const r2ds = [];
        x2ds.forEach((x2d)=>{
            const [q2d, r2d] = $1ed7b586509233bb$var$qr2d(x2d, fullMatrices);
            q2ds.push(q2d);
            r2ds.push(r2d);
        });
        const q = $98803384c5ab66ad$export$9eaad88cf88cee2b($01ba85cf120c021c$export$a57ab32f40f83ea9(q2ds, 0), x.shape);
        const r = $98803384c5ab66ad$export$9eaad88cf88cee2b($01ba85cf120c021c$export$a57ab32f40f83ea9(r2ds, 0), x.shape);
        return [
            q,
            r
        ];
    }
}
function $1ed7b586509233bb$var$qr2d(x, fullMatrices = false) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(()=>{
        $904921ed29eeae0f$export$a7a9523472993e97(x.shape.length === 2, ()=>`qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`
        );
        const m = x.shape[0];
        const n = x.shape[1];
        let q = $ee1ce6dc76f8bb9a$export$4e18cf730a59887e(m); // Orthogonal transform so far.
        let r = $e3b15dff351ca276$export$9cd59f9826255e47(x); // Transformed matrix so far.
        const one2D = $7e841f3329036206$export$b5469a65e8732256([
            [
                1
            ]
        ], [
            1,
            1
        ]);
        let w = $e3b15dff351ca276$export$9cd59f9826255e47(one2D);
        const iters = m >= n ? n : m;
        for(let j = 0; j < iters; ++j){
            // This tidy within the for-loop ensures we clean up temporary
            // tensors as soon as they are no longer needed.
            const rTemp = r;
            const wTemp = w;
            const qTemp = q;
            [w, r, q] = $a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(()=>{
                // Find H = I - tau * w * w', to put zeros below R(j, j).
                const rjEnd1 = $346651c97f629fbf$export$58adb3bec8346d0f(r, [
                    j,
                    j
                ], [
                    m - j,
                    1
                ]);
                const normX = $adc15c5dfda56123$export$1991ecd29cc92c6b(rjEnd1);
                const rjj = $346651c97f629fbf$export$58adb3bec8346d0f(r, [
                    j,
                    j
                ], [
                    1,
                    1
                ]);
                // The sign() function returns 0 on 0, which causes division by zero.
                const s = $ab8a00845a489e8f$export$9c59b80dda569a6e($e4ebbf786ece8ab8$export$9dca161faaf6308b(rjj, 0), $7e841f3329036206$export$b5469a65e8732256([
                    [
                        -1
                    ]
                ]), $7e841f3329036206$export$b5469a65e8732256([
                    [
                        1
                    ]
                ]));
                const u1 = $5a1a44a0d119135c$export$f93b5905241a7cca(rjj, $51103026006cddca$export$6e3a27864ab166fe(s, normX));
                const wPre = $172176b86d7c43d7$export$159d9494db57879b(rjEnd1, u1);
                if (wPre.shape[0] === 1) w = $e3b15dff351ca276$export$9cd59f9826255e47(one2D);
                else w = $876962a92a0aaf94$export$ee1b3e54f0441b22([
                    one2D,
                    $346651c97f629fbf$export$58adb3bec8346d0f(wPre, [
                        1,
                        0
                    ], [
                        wPre.shape[0] - 1,
                        wPre.shape[1]
                    ])
                ], 0);
                const tau = $9afab0e3465a64e7$export$d9493ff0dfa0fdd5($172176b86d7c43d7$export$159d9494db57879b($8e2c3ff1a0ec32ef$export$6706882a873e9a8f(s, u1), normX));
                // -- R := HR, Q := QH.
                const rjEndAll = $346651c97f629fbf$export$58adb3bec8346d0f(r, [
                    j,
                    0
                ], [
                    m - j,
                    n
                ]);
                const tauTimesW = $51103026006cddca$export$6e3a27864ab166fe(tau, w);
                const wT = $d83991607c65447c$export$9cb09a71b7d66923(w);
                if (j === 0) r = $5a1a44a0d119135c$export$f93b5905241a7cca(rjEndAll, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(tauTimesW, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(wT, rjEndAll)));
                else {
                    const rTimesTau = $5a1a44a0d119135c$export$f93b5905241a7cca(rjEndAll, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(tauTimesW, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(wT, rjEndAll)));
                    r = $876962a92a0aaf94$export$ee1b3e54f0441b22([
                        $346651c97f629fbf$export$58adb3bec8346d0f(r, [
                            0,
                            0
                        ], [
                            j,
                            n
                        ]),
                        rTimesTau
                    ], 0);
                }
                const tawTimesWT = $d83991607c65447c$export$9cb09a71b7d66923(tauTimesW);
                const qAllJEnd = $346651c97f629fbf$export$58adb3bec8346d0f(q, [
                    0,
                    j
                ], [
                    m,
                    q.shape[1] - j
                ]);
                if (j === 0) q = $5a1a44a0d119135c$export$f93b5905241a7cca(qAllJEnd, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f($8e2c3ff1a0ec32ef$export$6706882a873e9a8f(qAllJEnd, w), tawTimesWT));
                else {
                    const qTimesTau = $5a1a44a0d119135c$export$f93b5905241a7cca(qAllJEnd, $8e2c3ff1a0ec32ef$export$6706882a873e9a8f($8e2c3ff1a0ec32ef$export$6706882a873e9a8f(qAllJEnd, w), tawTimesWT));
                    q = $876962a92a0aaf94$export$ee1b3e54f0441b22([
                        $346651c97f629fbf$export$58adb3bec8346d0f(q, [
                            0,
                            0
                        ], [
                            m,
                            j
                        ]),
                        qTimesTau
                    ], 1);
                }
                return [
                    w,
                    r,
                    q
                ];
            });
            $307e90c4876a9d4d$export$fcfbbcec2cb820d5([
                rTemp,
                wTemp,
                qTemp
            ]);
        }
        if (!fullMatrices && m > n) {
            q = $346651c97f629fbf$export$58adb3bec8346d0f(q, [
                0,
                0
            ], [
                m,
                n
            ]);
            r = $346651c97f629fbf$export$58adb3bec8346d0f(r, [
                0,
                0
            ], [
                n,
                n
            ]);
        }
        return [
            q,
            r
        ];
    });
}
const $1ed7b586509233bb$export$7c27fb47516129d9 = $9e60b70ce0353b32$export$f59964a629598e2({
    qr_: $1ed7b586509233bb$var$qr_
});




var $9dbad4060c6ab7db$export$cc9fa7113d70efba;
(function($9dbad4060c6ab7db$export$cc9fa7113d70efba) {
    $9dbad4060c6ab7db$export$cc9fa7113d70efba[$9dbad4060c6ab7db$export$cc9fa7113d70efba["NONE"] = 0] = "NONE";
    $9dbad4060c6ab7db$export$cc9fa7113d70efba[$9dbad4060c6ab7db$export$cc9fa7113d70efba["MEAN"] = 1] = "MEAN";
    $9dbad4060c6ab7db$export$cc9fa7113d70efba[$9dbad4060c6ab7db$export$cc9fa7113d70efba["SUM"] = 2] = "SUM";
    $9dbad4060c6ab7db$export$cc9fa7113d70efba[$9dbad4060c6ab7db$export$cc9fa7113d70efba["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})($9dbad4060c6ab7db$export$cc9fa7113d70efba || ($9dbad4060c6ab7db$export$cc9fa7113d70efba = {}));












/**
 * Computes the mean of elements across dimensions of a `tf.Tensor`.
 *
 * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is
 * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with
 * a single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.mean().print();  // or tf.mean(a)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.mean(axis).print();  // or tf.mean(x, axis)
 * ```
 *
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. By default it reduces
 *     all dimensions.
 * @param keepDims If true, retains reduced dimensions with size 1.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $825f17388190a411$var$mean_(x, axis = null, keepDims = false) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'mean');
    const inputs = {
        x: $x
    };
    const attrs = {
        axis: axis,
        keepDims: keepDims
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$1c2d59c4b681fbd8, inputs, attrs);
}
const $825f17388190a411$export$1ce691f85baaa52 = $9e60b70ce0353b32$export$f59964a629598e2({
    mean_: $825f17388190a411$var$mean_
});









/**
 * Returns the truth value of (a != b) element-wise. Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 2, 3]);
 * const b = tf.tensor1d([0, 2, 3]);
 *
 * a.notEqual(b).print();
 * ```
 * @param a The first input tensor.
 * @param b The second input tensor. Must have the same dtype as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Logical'}
 */ function $6353bc00d10c3dfa$var$notEqual_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'notEqual', 'string_or_numeric');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'notEqual', 'string_or_numeric');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$385ebe9945cae0c5, inputs);
}
const $6353bc00d10c3dfa$export$53a6892c50694894 = $9e60b70ce0353b32$export$f59964a629598e2({
    notEqual_: $6353bc00d10c3dfa$var$notEqual_
});






function $c66d49d2d2fd42c9$export$21041dee6b8001b0(shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = $c66d49d2d2fd42c9$export$21041dee6b8001b0(shape, 'float32');
        const imag = $1b84f1678bdd9c2a$export$4445a00dafa2633b(shape, 'float32');
        return $b2f39045a9ff3425$export$83a0e34f1302825b(real, imag);
    }
    const values = $904921ed29eeae0f$export$b915f681a907ae99($904921ed29eeae0f$export$b4c3214a70a0e73f(shape), dtype);
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.makeTensor(values, shape, dtype);
}





/**
 * Computes the weighted loss between two tensors.
 *
 * @param losses Tensor of shape `[batch_size, d1, ... dN]`.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `losses`, and must be broadcastable to `losses` (i.e., all
 *    dimensions must be either `1`, or the same as the corresponding
 *    `losses` dimension).
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $6993d38d3a3354a1$var$computeWeightedLoss_(losses, weights, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $losses = $d7ebc35f1f4a180c$export$ede379c4c939d71a(losses, 'losses', 'computeWeightedLoss');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'computeWeightedLoss');
    const weightedLoss = $weights == null ? $losses : $51103026006cddca$export$6e3a27864ab166fe($losses, $weights);
    if (reduction === $9dbad4060c6ab7db$export$cc9fa7113d70efba.NONE) return weightedLoss;
    if (reduction === $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM) return $f082be780698e75d$export$8a63f25cc62965f1(weightedLoss);
    if (reduction === $9dbad4060c6ab7db$export$cc9fa7113d70efba.MEAN) {
        if ($weights == null) return $825f17388190a411$export$1ce691f85baaa52(weightedLoss);
        else {
            const broadcastFactor = $losses.size / $weights.size;
            const result = $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(weightedLoss), $f082be780698e75d$export$8a63f25cc62965f1($weights));
            return broadcastFactor > 1 ? $172176b86d7c43d7$export$159d9494db57879b(result, $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(broadcastFactor)) : result;
        }
    }
    if (reduction === $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
        if ($weights == null) return $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(weightedLoss), $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46($losses.size));
        else {
            const broadcastedWeights = $51103026006cddca$export$6e3a27864ab166fe($weights, $c66d49d2d2fd42c9$export$21041dee6b8001b0($losses.shape));
            const numNonZeros = $939ec2f1ca32d2a1$export$f2db7d5238e1d23f($f082be780698e75d$export$8a63f25cc62965f1($6353bc00d10c3dfa$export$53a6892c50694894(broadcastedWeights, $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(0))), 'float32');
            return $172176b86d7c43d7$export$159d9494db57879b($f082be780698e75d$export$8a63f25cc62965f1(weightedLoss), numNonZeros);
        }
    }
    throw Error(`Unknown reduction: ${reduction}`);
}
const $6993d38d3a3354a1$export$23bdc4cea2e28782 = $9e60b70ce0353b32$export$f59964a629598e2({
    computeWeightedLoss_: $6993d38d3a3354a1$var$computeWeightedLoss_
});


/**
 * Computes the absolute difference loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $78eff18c057f7c46$var$absoluteDifference_(labels, predictions, weights, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'absoluteDifference');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'absoluteDifference');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'absoluteDifference');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in absoluteDifference: ');
    const losses = $63f4b3b00d29e030$export$2335f513bbd82c6d($5a1a44a0d119135c$export$f93b5905241a7cca($labels, $predictions));
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $78eff18c057f7c46$export$d81f35aebafd8971 = $9e60b70ce0353b32$export$f59964a629598e2({
    absoluteDifference_: $78eff18c057f7c46$var$absoluteDifference_
});










/**
 * Computes the cosine distance loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param axis The dimension along which the cosine distance is computed.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $b1c45e12b30fb7ae$var$cosineDistance_(labels, predictions, axis, weights, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'cosineDistance');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'cosineDistance');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'cosineDistance');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in cosineDistance: ');
    const one = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1);
    const losses = $5a1a44a0d119135c$export$f93b5905241a7cca(one, $f082be780698e75d$export$8a63f25cc62965f1($51103026006cddca$export$6e3a27864ab166fe($labels, $predictions), axis, true));
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $b1c45e12b30fb7ae$export$6168ae03858f836b = $9e60b70ce0353b32$export$f59964a629598e2({
    cosineDistance_: $b1c45e12b30fb7ae$var$cosineDistance_
});










/**
 * Computes the Hinge loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $9857aeedc3613e9f$var$hingeLoss_(labels, predictions, weights, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    let $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'hingeLoss');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'hingeLoss');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'hingeLoss');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in hingeLoss: ');
    const one = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1);
    // Convert binary labels to (-1, 1)
    $labels = $5a1a44a0d119135c$export$f93b5905241a7cca($51103026006cddca$export$6e3a27864ab166fe($3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(2), $labels), one);
    const losses = $c55220628ab79485$export$16d1e4612cc0139f($5a1a44a0d119135c$export$f93b5905241a7cca(one, $51103026006cddca$export$6e3a27864ab166fe($labels, $predictions)));
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $9857aeedc3613e9f$export$fc7754731492f43f = $9e60b70ce0353b32$export$f59964a629598e2({
    hingeLoss_: $9857aeedc3613e9f$var$hingeLoss_
});













/**
 * Returns the min of a and b (`a < b ? a : b`) element-wise.
 * Supports broadcasting.
 *
 * We also expose `minimumStrict` which has the same signature as this op and
 * asserts that `a` and `b` are the same shape (does not broadcast).
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.minimum(b).print();  // or tf.minimum(a, b)
 * ```
 *
 * ```js
 * // Broadcast minimum a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.minimum(b).print();  // or tf.minimum(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $a26a0bf75bd52f02$var$minimum_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'minimum');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'minimum');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    if ($a.dtype === 'bool') {
        $a = $939ec2f1ca32d2a1$export$f2db7d5238e1d23f($a, 'int32');
        $b = $939ec2f1ca32d2a1$export$f2db7d5238e1d23f($b, 'int32');
    }
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$23cb308301e89d6b, inputs);
}
const $a26a0bf75bd52f02$export$916782c1f0ddb132 = $9e60b70ce0353b32$export$f59964a629598e2({
    minimum_: $a26a0bf75bd52f02$var$minimum_
});








/**
 * Computes the huber loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param delta Point where huber loss changes from quadratic to linear.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`.
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $2c5af3998d6c7edf$var$huberLoss_(labels, predictions, weights, delta = 1.0, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'huberLoss');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'huberLoss');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'huberLoss');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in huberLoss: ');
    const deltaScalar = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(delta);
    const error = $63f4b3b00d29e030$export$2335f513bbd82c6d($5a1a44a0d119135c$export$f93b5905241a7cca($predictions, $labels));
    const quadratic = $a26a0bf75bd52f02$export$916782c1f0ddb132(error, deltaScalar);
    const linear = $5a1a44a0d119135c$export$f93b5905241a7cca(error, quadratic);
    const losses = $a5476a4579f57f2c$export$e16d8520af44a096($51103026006cddca$export$6e3a27864ab166fe($3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(0.5), $c1f388719de77577$export$dd4f28cef696bc7d(quadratic)), $51103026006cddca$export$6e3a27864ab166fe(deltaScalar, linear));
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $2c5af3998d6c7edf$export$ad2dd557b367bf2b = $9e60b70ce0353b32$export$f59964a629598e2({
    huberLoss_: $2c5af3998d6c7edf$var$huberLoss_
});








/**
 * Computes natural logarithm of the input `tf.Tensor` element-wise: `ln(x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.E]);
 *
 * x.log().print();  // or tf.log(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $e5d133219c0a6a48$var$log_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'log', 'float32');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$ce30dbb46644d06c, inputs);
}
const $e5d133219c0a6a48$export$bef1f36f5486a6a3 = $9e60b70ce0353b32$export$f59964a629598e2({
    log_: $e5d133219c0a6a48$var$log_
});









/**
 * Computes the log loss between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param epsilon A small increment to avoid taking log of zero
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $9fb2b9ba48c13a9b$var$logLoss_(labels, predictions, weights, epsilon = 1e-7, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'logLoss');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'logLoss');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'logLoss');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in logLoss: ');
    const one = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1);
    const epsilonScalar = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(epsilon);
    const l1 = $9afab0e3465a64e7$export$d9493ff0dfa0fdd5($51103026006cddca$export$6e3a27864ab166fe($labels, $e5d133219c0a6a48$export$bef1f36f5486a6a3($a5476a4579f57f2c$export$e16d8520af44a096($predictions, epsilonScalar))));
    const l2 = $51103026006cddca$export$6e3a27864ab166fe($5a1a44a0d119135c$export$f93b5905241a7cca(one, $labels), $e5d133219c0a6a48$export$bef1f36f5486a6a3($a5476a4579f57f2c$export$e16d8520af44a096($5a1a44a0d119135c$export$f93b5905241a7cca(one, $predictions), epsilonScalar)));
    const losses = $5a1a44a0d119135c$export$f93b5905241a7cca(l1, l2);
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $9fb2b9ba48c13a9b$export$5ca6937b99935214 = $9e60b70ce0353b32$export$f59964a629598e2({
    logLoss_: $9fb2b9ba48c13a9b$var$logLoss_
});











/**
 * Returns (a - b) * (a - b) element-wise.
 * Supports broadcasting.
 *
 * ```js
 * const a = tf.tensor1d([1, 4, 3, 16]);
 * const b = tf.tensor1d([1, 2, 9, 4]);
 *
 * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
 * ```
 *
 * ```js
 * // Broadcast squared difference  a with b.
 * const a = tf.tensor1d([2, 4, 6, 8]);
 * const b = tf.scalar(5);
 *
 * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)
 * ```
 *
 * @param a The first tensor.
 * @param b The second tensor. Must have the same type as `a`.
 *
 * @doc {heading: 'Operations', subheading: 'Arithmetic'}
 */ function $9ce4584a2da6a282$var$squaredDifference_(a, b) {
    let $a = $d7ebc35f1f4a180c$export$ede379c4c939d71a(a, 'a', 'squaredDifference');
    let $b = $d7ebc35f1f4a180c$export$ede379c4c939d71a(b, 'b', 'squaredDifference');
    [$a, $b] = $f5b489dcdac9fd38$export$8b0e24c749a224d7($a, $b);
    $c374f26140f3eb6b$export$a3e2a38a57ec8318($a.shape, $b.shape);
    const inputs = {
        a: $a,
        b: $b
    };
    const attrs = {};
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$2f922d20d66089c6, inputs, attrs);
}
const $9ce4584a2da6a282$export$b178697fb6d0b37f = $9e60b70ce0353b32$export$f59964a629598e2({
    squaredDifference_: $9ce4584a2da6a282$var$squaredDifference_
});



/**
 * Computes the mean squared error between two tensors.
 *
 * @param labels The ground truth output tensor, same dimensions as
 *    'predictions'.
 * @param predictions The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}
 */ function $78dfa95c4c8619c6$var$meanSquaredError_(labels, predictions, weights, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'meanSquaredError');
    const $predictions = $d7ebc35f1f4a180c$export$ede379c4c939d71a(predictions, 'predictions', 'meanSquaredError');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'meanSquaredError');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $predictions.shape, 'Error in meanSquaredError: ');
    const losses = $9ce4584a2da6a282$export$b178697fb6d0b37f($labels, $predictions);
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $78dfa95c4c8619c6$export$33de16355e97f7fb = $9e60b70ce0353b32$export$f59964a629598e2({
    meanSquaredError_: $78dfa95c4c8619c6$var$meanSquaredError_
});









/**
 * Computes exponential of the input `tf.Tensor` element-wise. `e ^ x`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, -3]);
 *
 * x.exp().print();  // or tf.exp(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $e0542e85b282cc39$var$exp_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'exp');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$f908be7a96fb3363, inputs);
}
const $e0542e85b282cc39$export$b310ec824aaee37f = $9e60b70ce0353b32$export$f59964a629598e2({
    exp_: $e0542e85b282cc39$var$exp_
});






/**
 * Computes natural logarithm of the input `tf.Tensor` plus one
 * element-wise: `ln(1 + x)`
 *
 * ```js
 * const x = tf.tensor1d([1, 2, Math.E - 1]);
 *
 * x.log1p().print();  // or tf.log1p(x)
 * ```
 * @param x The input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'Basic math'}
 */ function $5454768aaf0ee1ad$var$log1p_(x) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'log1p');
    const inputs = {
        x: $x
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$70f05bf9ddcfca68, inputs);
}
const $5454768aaf0ee1ad$export$144dcf16adfb9698 = $9e60b70ce0353b32$export$f59964a629598e2({
    log1p_: $5454768aaf0ee1ad$var$log1p_
});










function $a3a588ac97ceb4fc$var$sigmoidCrossEntropyWithLogits_(labels, logits) {
    const $labels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(labels, 'labels', 'sigmoidCrossEntropyWithLogits');
    const $logits = $d7ebc35f1f4a180c$export$ede379c4c939d71a(logits, 'logits', 'sigmoidCrossEntropyWithLogits');
    $904921ed29eeae0f$export$e08b27e7f37e2782($labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');
    /**
     * Implementation Details:
     *
     * For brevity, let `x = logits`, `z = labels`.  The logistic loss is
     *     z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))
     *   = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))
     *   = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))
     *   = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))
     *   = (1 - z) * x + log(1 + exp(-x))
     *   = x - x * z + log(1 + exp(-x))
     *
     *   For x < 0, to avoid overflow in exp(-x), we reformulate the above
     *     x - x * z + log(1 + exp(-x))
     *   = log(exp(x)) - x * z + log(1 + exp(-x))
     *   = - x * z + log(1 + exp(x))
     *
     * Hence, to ensure stability and avoid overflow, the implementation uses
     * this equivalent formulation:
     *     max(x, 0) - x * z + log(1 + exp(-abs(x)))
     */ const maxOutput = $c55220628ab79485$export$16d1e4612cc0139f($logits);
    const outputXTarget = $51103026006cddca$export$6e3a27864ab166fe($logits, $labels);
    const sigmoidOutput = $5454768aaf0ee1ad$export$144dcf16adfb9698($e0542e85b282cc39$export$b310ec824aaee37f($9afab0e3465a64e7$export$d9493ff0dfa0fdd5($63f4b3b00d29e030$export$2335f513bbd82c6d($logits))));
    return $a5476a4579f57f2c$export$e16d8520af44a096($5a1a44a0d119135c$export$f93b5905241a7cca(maxOutput, outputXTarget), sigmoidOutput);
}
/**
 * Computes the sigmoid cross entropy loss between two tensors.
 *
 * If labelSmoothing is nonzero, smooth the labels towards 1/2:
 *
 *   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)
 *                         + 0.5 * labelSmoothing
 *
 * @param multiClassLabels The ground truth output tensor of shape
 * [batch_size, num_classes], same dimensions as 'predictions'.
 * @param logits The predicted outputs.
 * @param weights Tensor whose rank is either 0, or the same rank as
 *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions
 *    must be either `1`, or the same as the corresponding `losses`
 *    dimension).
 * @param labelSmoothing If greater than 0, then smooth the labels.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }
 */ function $a3a588ac97ceb4fc$var$sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    let $multiClassLabels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');
    const $logits = $d7ebc35f1f4a180c$export$ede379c4c939d71a(logits, 'logits', 'sigmoidCrossEntropy');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'sigmoidCrossEntropy');
    $904921ed29eeae0f$export$e08b27e7f37e2782($multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');
    if (labelSmoothing > 0) {
        const labelSmoothingScalar = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(labelSmoothing);
        const one = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1);
        const half = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(0.5);
        $multiClassLabels = $a5476a4579f57f2c$export$e16d8520af44a096($51103026006cddca$export$6e3a27864ab166fe($multiClassLabels, $5a1a44a0d119135c$export$f93b5905241a7cca(one, labelSmoothingScalar)), $51103026006cddca$export$6e3a27864ab166fe(half, labelSmoothingScalar));
    }
    const losses = $a3a588ac97ceb4fc$var$sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $a3a588ac97ceb4fc$export$d099e04c73e0aede = $9e60b70ce0353b32$export$f59964a629598e2({
    sigmoidCrossEntropy_: $a3a588ac97ceb4fc$var$sigmoidCrossEntropy_
});





/**
 * Provided `f(x)`, returns another function `g(x, dy?)`, which gives the
 * gradient of `f(x)` with respect to `x`.
 *
 * If `dy` is provided, the gradient of `f(x).mul(dy).sum()` with respect to
 * `x` is computed instead. `f(x)` must take a single tensor `x` and return a
 * single tensor `y`. If `f()` takes multiple inputs, use `tf.grads` instead.
 *
 * ```js
 * // f(x) = x ^ 2
 * const f = x => x.square();
 * // f'(x) = 2x
 * const g = tf.grad(f);
 *
 * const x = tf.tensor1d([2, 3]);
 * g(x).print();
 * ```
 *
 * ```js
 * // f(x) = x ^ 3
 * const f = x => x.pow(tf.scalar(3, 'int32'));
 * // f'(x) = 3x ^ 2
 * const g = tf.grad(f);
 * // f''(x) = 6x
 * const gg = tf.grad(g);
 *
 * const x = tf.tensor1d([2, 3]);
 * gg(x).print();
 * ```
 *
 * @param f The function f(x), to compute gradient for.
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$c24429b22bb73814(f) {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in grad(f) must be a function'
    );
    return (x, dy)=>{
        // x can be of any dtype, thus null as the last argument.
        const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'tf.grad', 'string_or_numeric');
        const $dy = dy != null ? $d7ebc35f1f4a180c$export$ede379c4c939d71a(dy, 'dy', 'tf.grad') : null;
        return $a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(()=>{
            const { value: value , grads: $f1f576b919d86977$export$3f3749f5340c73f2  } = $a6bde3769fa0d8b5$export$33b63313cc511a3b.gradients(()=>f($x)
            , [
                $x
            ], $dy);
            if ($dy != null) $904921ed29eeae0f$export$e08b27e7f37e2782(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
            $f1f576b919d86977$var$checkGrads($f1f576b919d86977$export$3f3749f5340c73f2);
            return $f1f576b919d86977$export$3f3749f5340c73f2[0];
        });
    };
}
/**
 * Provided `f(x1, x2,...)`, returns another function `g([x1, x2,...], dy?)`,
 * which gives an array of gradients of `f()` with respect to each input
 * [`x1`,`x2`,...].
 *
 * If `dy` is passed when calling `g()`, the gradient of
 * `f(x1,...).mul(dy).sum()` with respect to each input is computed instead.
 * The provided `f` must take one or more tensors and return a single tensor
 * `y`. If `f()` takes a single input, we recommend using `tf.grad` instead.
 *
 * ```js
 * // f(a, b) = a * b
 * const f = (a, b) => a.mul(b);
 * // df / da = b, df / db = a
 * const g = tf.grads(f);
 *
 * const a = tf.tensor1d([2, 3]);
 * const b = tf.tensor1d([-2, -3]);
 * const [da, db] = g([a, b]);
 * console.log('da');
 * da.print();
 * console.log('db');
 * db.print();
 * ```
 *
 * @param f The function `f(x1, x2,...)` to compute gradients for.
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$3f3749f5340c73f2(f) {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in grads(f) must be a function'
    );
    return (args, dy)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(Array.isArray(args), ()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"
        );
        // args can be of any dtype, thus null as the last argument.
        const $args = $d7ebc35f1f4a180c$export$758e66616b4d410b(args, 'args', 'tf.grads', 'string_or_numeric');
        const $dy = dy != null ? $d7ebc35f1f4a180c$export$ede379c4c939d71a(dy, 'dy', 'tf.grads') : null;
        return $a6bde3769fa0d8b5$export$33b63313cc511a3b.tidy(()=>{
            const { value: value , grads: $f1f576b919d86977$export$3f3749f5340c73f2  } = $a6bde3769fa0d8b5$export$33b63313cc511a3b.gradients(()=>f(...$args)
            , $args, $dy);
            if ($dy != null) $904921ed29eeae0f$export$e08b27e7f37e2782(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
            $f1f576b919d86977$var$checkGrads($f1f576b919d86977$export$3f3749f5340c73f2);
            return $f1f576b919d86977$export$3f3749f5340c73f2;
        });
    };
}
/**
 * Like `tf.grad`, but also returns the value of `f()`. Useful when `f()`
 * returns a metric you want to show.
 *
 * The result is a rich object with the following properties:
 * - grad: The gradient of `f(x)` w.r.t `x` (result of `tf.grad`).
 * - value: The value returned by `f(x)`.
 *
 * ```js
 * // f(x) = x ^ 2
 * const f = x => x.square();
 * // f'(x) = 2x
 * const g = tf.valueAndGrad(f);
 *
 * const x = tf.tensor1d([2, 3]);
 * const {value, grad} = g(x);
 *
 * console.log('value');
 * value.print();
 * console.log('grad');
 * grad.print();
 * ```
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$9fbe39d4dcb3921e(f) {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in valueAndGrad(f) must be a function'
    );
    return (x, dy)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(x instanceof $c341eb4171cc0419$export$7b6b8d90402f8814, ()=>'The x passed in valueAndGrad(f)(x) must be a tensor'
        );
        $904921ed29eeae0f$export$a7a9523472993e97(dy == null || dy instanceof $c341eb4171cc0419$export$7b6b8d90402f8814, ()=>'The dy passed in valueAndGrad(f)(x, dy) must be a tensor'
        );
        const { grads: $f1f576b919d86977$export$3f3749f5340c73f2 , value: value  } = $a6bde3769fa0d8b5$export$33b63313cc511a3b.gradients(()=>f(x)
        , [
            x
        ], dy);
        $f1f576b919d86977$var$checkGrads($f1f576b919d86977$export$3f3749f5340c73f2);
        return {
            grad: $f1f576b919d86977$export$3f3749f5340c73f2[0],
            value: value
        };
    };
}
/**
 * Like `tf.grads`, but returns also the value of `f()`. Useful when `f()`
 * returns a metric you want to show.
 *
 * The result is a rich object with the following properties:
 * - grads: The gradients of `f()` w.r.t each input (result of `tf.grads`).
 * - value: The value returned by `f(x)`.
 *
 * ```js
 * // f(a, b) = a * b
 * const f = (a, b) => a.mul(b);
 * // df/da = b, df/db = a
 * const g = tf.valueAndGrads(f);
 *
 * const a = tf.tensor1d([2, 3]);
 * const b = tf.tensor1d([-2, -3]);
 * const {value, grads} = g([a, b]);
 *
 * const [da, db] = grads;
 *
 * console.log('value');
 * value.print();
 *
 * console.log('da');
 * da.print();
 * console.log('db');
 * db.print();
 * ```
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$c03281a254ef3cf0(f) {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in valueAndGrads(f) must be a function'
    );
    return (args, dy)=>{
        $904921ed29eeae0f$export$a7a9523472993e97(Array.isArray(args) && args.every((arg)=>arg instanceof $c341eb4171cc0419$export$7b6b8d90402f8814
        ), ()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"
        );
        $904921ed29eeae0f$export$a7a9523472993e97(dy == null || dy instanceof $c341eb4171cc0419$export$7b6b8d90402f8814, ()=>'The dy passed in valueAndGrads(f)(args, dy) must be a tensor'
        );
        const res = $a6bde3769fa0d8b5$export$33b63313cc511a3b.gradients(()=>f(...args)
        , args, dy);
        if (dy != null) $904921ed29eeae0f$export$e08b27e7f37e2782(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
        $f1f576b919d86977$var$checkGrads(res.grads);
        return res;
    };
}
/**
 * Computes and returns the gradient of f(x) with respect to the list of
 * trainable variables provided by `varList`. If no list is provided, it
 * defaults to all trainable variables.
 *
 * ```js
 * const a = tf.variable(tf.tensor1d([3, 4]));
 * const b = tf.variable(tf.tensor1d([5, 6]));
 * const x = tf.tensor1d([1, 2]);
 *
 * // f(a, b) = a * x ^ 2 + b * x
 * const f = () => a.mul(x.square()).add(b.mul(x)).sum();
 * // df/da = x ^ 2, df/db = x
 * const {value, grads} = tf.variableGrads(f);
 *
 * Object.keys(grads).forEach(varName => grads[varName].print());
 * ```
 *
 * @param f The function to execute. f() should return a scalar.
 * @param varList The list of variables to compute the gradients with respect
 *     to. Defaults to all trainable variables.
 * @returns An object with the following keys and values:
 *   - `value`: The value of the function `f`.
 *   - `grads`: A map from the names of the variables to the gradients.
 *     If the `varList` argument is provided explicitly and contains a subset of
 *     non-trainable variables, this map in the return value will contain keys
 *     that map the names of the non-trainable variables to `null`.
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$c756d9ed08b9677f(f, varList) {
    $904921ed29eeae0f$export$a7a9523472993e97($904921ed29eeae0f$export$f6e2535fb5126e54(f), ()=>'The f passed in variableGrads(f) must be a function'
    );
    $904921ed29eeae0f$export$a7a9523472993e97(varList == null || Array.isArray(varList) && varList.every((v)=>v instanceof $c341eb4171cc0419$export$c867a5c9595a1350
    ), ()=>"The varList passed in variableGrads(f, varList) must be an array of variables"
    );
    const specifiedVarList = varList != null;
    if (!specifiedVarList) {
        // Get all of the trainable variables.
        varList = [];
        for(const varName in $a6bde3769fa0d8b5$export$33b63313cc511a3b.registeredVariables)varList.push($a6bde3769fa0d8b5$export$33b63313cc511a3b.registeredVariables[varName]);
    }
    const specifiedNonTrainable = specifiedVarList ? varList.filter((variable)=>!variable.trainable
    ) : null;
    // Prune non-trainable variables.
    const originalVarCount = varList.length;
    varList = varList.filter((variable)=>variable.trainable
    );
    $904921ed29eeae0f$export$a7a9523472993e97(varList.length > 0, ()=>`variableGrads() expects at least one of the input variables to ` + `be trainable, but none of the ${originalVarCount} variables is ` + `trainable.`
    );
    const allowNoGradients = true;
    const { value: value , grads: $f1f576b919d86977$export$3f3749f5340c73f2  } = $a6bde3769fa0d8b5$export$33b63313cc511a3b.gradients(f, varList, null, allowNoGradients);
    $904921ed29eeae0f$export$a7a9523472993e97($f1f576b919d86977$export$3f3749f5340c73f2.some((g)=>g != null
    ), ()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
    );
    $904921ed29eeae0f$export$a7a9523472993e97(value.rank === 0, ()=>`The f passed in variableGrads(f) must return a scalar, but it ` + `returned a rank-${value.rank} tensor`
    );
    const namedGrads = {};
    varList.forEach((v, i)=>{
        if ($f1f576b919d86977$export$3f3749f5340c73f2[i] != null) namedGrads[v.name] = $f1f576b919d86977$export$3f3749f5340c73f2[i];
    });
    if (specifiedNonTrainable != null) // If varList is explicitly provided and contains non-trainable values,
    // add them to the returned gradients with `null` values.
    specifiedNonTrainable.forEach((v)=>namedGrads[v.name] = null
    );
    return {
        value: value,
        grads: namedGrads
    };
}
/**
 * Overrides the gradient computation of a function `f`.
 *
 * Takes a function
 * `f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]}`
 * and returns another function `g(...inputs)` which takes the same inputs as
 * `f`. When called, `g` returns `f().value`. In backward mode, custom gradients
 * with respect to each input of `f` are computed using `f().gradFunc`.
 *
 * The `save` function passsed to `f` should be used for saving tensors needed
 * in the gradient. And the `saved` passed to the `gradFunc` is a
 * `NamedTensorMap`, which contains those saved tensor.
 *
 * ```js
 * const customOp = tf.customGrad((x, save) => {
 *   // Save x to make sure it's available later for the gradient.
 *   save([x]);
 *   // Override gradient of our custom x ^ 2 op to be dy * abs(x);
 *   return {
 *     value: x.square(),
 *     // Note `saved.x` which points to the `x` we saved earlier.
 *     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]
 *   };
 * });
 *
 * const x = tf.tensor1d([-1, -2, 3]);
 * const dx = tf.grad(x => customOp(x));
 *
 * console.log(`f(x):`);
 * customOp(x).print();
 * console.log(`f'(x):`);
 * dx(x).print();
 * ```
 *
 * @param f The function to evaluate in forward mode, which should return
 *     `{value: Tensor, gradFunc: (dy, saved) => Tensor[]}`, where `gradFunc`
 *     returns the custom gradients of `f` with respect to its inputs.
 *
 * @doc {heading: 'Training', subheading: 'Gradients'}
 */ function $f1f576b919d86977$export$5519f0eeb00c44e5(f) {
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.customGrad(f);
}
function $f1f576b919d86977$var$checkGrads($f1f576b919d86977$export$3f3749f5340c73f2) {
    const numNullGradients = $f1f576b919d86977$export$3f3749f5340c73f2.filter((g)=>g == null
    ).length;
    if (numNullGradients > 0) throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
}




















/**
 * Computes the log(sum(exp(elements across the reduction dimensions)).
 *
 * Reduces the input along the dimensions given in `axis`. Unless `keepDims`
 * is true, the rank of the array is reduced by 1 for each entry in `axis`.
 * If `keepDims` is true, the reduced dimensions are retained with length 1.
 * If `axis` has no entries, all dimensions are reduced, and an array with a
 * single element is returned.
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3]);
 *
 * x.logSumExp().print();  // or tf.logSumExp(x)
 * ```
 *
 * ```js
 * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);
 *
 * const axis = 1;
 * x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)
 * ```
 * @param x The input tensor.
 * @param axis The dimension(s) to reduce. If null (the default),
 *     reduces all dimensions.
 * @param keepDims If true, retains reduced dimensions with length
 *     of 1. Defaults to false.
 *
 * @doc {heading: 'Operations', subheading: 'Reduction'}
 */ function $9284490eb3199f0a$var$logSumExp_(x, axis = null, keepDims = false) {
    const $x = $d7ebc35f1f4a180c$export$ede379c4c939d71a(x, 'x', 'logSumExp');
    const axes = $904921ed29eeae0f$export$72b84eb9fe1f482(axis, $x.shape);
    const xMax = $734c293f3e1e5e82$export$8960430cfd85939f($x, axes, true);
    const a = $5a1a44a0d119135c$export$f93b5905241a7cca($x, xMax);
    const b = $e0542e85b282cc39$export$b310ec824aaee37f(a);
    const c = $f082be780698e75d$export$8a63f25cc62965f1(b, axes);
    const d = $e5d133219c0a6a48$export$bef1f36f5486a6a3(c);
    const res = $a5476a4579f57f2c$export$e16d8520af44a096($98803384c5ab66ad$export$9eaad88cf88cee2b(xMax, d.shape), d);
    if (keepDims) {
        const newShape = $0732cb950311b962$export$e35db9afe008d7e3(res.shape, axes);
        return $98803384c5ab66ad$export$9eaad88cf88cee2b(res, newShape);
    }
    return res;
}
const $9284490eb3199f0a$export$e20aca1e89397787 = $9e60b70ce0353b32$export$f59964a629598e2({
    logSumExp_: $9284490eb3199f0a$var$logSumExp_
});











/**
 * Computes softmax cross entropy between logits and labels.
 *
 * Measures the probability error in discrete classification tasks in which
 * the classes are mutually exclusive (each entry is in exactly one class).
 * For example, each CIFAR-10 image is labeled with one and only one label: an
 * image can be a dog or a truck, but not both.
 *
 * `NOTE`: While the classes are mutually exclusive, their probabilities need
 * not be. All that is required is that each row of labels is a valid
 * probability distribution. If they are not, the computation of the gradient
 * will be incorrect.
 *
 * `WARNING`: This op expects unscaled logits, since it performs a softmax on
 * logits internally for efficiency. Do not call this op with the output of
 * softmax, as it will produce incorrect results.
 *
 * logits and labels must have the same shape, e.g. [batch_size, num_classes]
 * and the same dtype.
 * @param labels The labels array.
 * @param logits The logits array.
 * @param dim The dimension softmax would be performed on. Defaults to `-1`
 *     which indicates the last dimension.
 */ function $c375488a9615bd4d$var$softmaxCrossEntropyWithLogits_(labels1, logits1, dim = -1) {
    if (dim === -1) dim = logits1.rank - 1;
    if (dim !== logits1.rank - 1) throw Error(`Softmax cross entropy along a non-last dimension is not yet ` + `supported. Labels / logits was rank ${logits1.rank} ` + `and dim was ${dim}`);
    // Use a custom gradient for numerical stability.
    const customOp = $f1f576b919d86977$export$5519f0eeb00c44e5((labels2, logits, save)=>{
        // Reference:
        //   1. http://cs231n.github.io/linear-classify/#softmax
        //   2. https://blog.feedly.com/tricks-of-the-trade-logsumexp/
        const keepDims = true;
        const lse = $9284490eb3199f0a$export$e20aca1e89397787(logits, [
            dim
        ], keepDims);
        const logResult1 = $5a1a44a0d119135c$export$f93b5905241a7cca($939ec2f1ca32d2a1$export$f2db7d5238e1d23f(logits, 'float32'), lse);
        save([
            labels2,
            logResult1
        ]);
        const costVector = $9afab0e3465a64e7$export$d9493ff0dfa0fdd5($51103026006cddca$export$6e3a27864ab166fe(logResult1, labels2));
        const value = $f082be780698e75d$export$8a63f25cc62965f1(costVector, [
            dim
        ]);
        const gradFunc = (dy, saved)=>{
            const [labels, logResult] = saved;
            const dyShape = $0732cb950311b962$export$e35db9afe008d7e3(dy.shape, [
                dim
            ]);
            return [
                $51103026006cddca$export$6e3a27864ab166fe($98803384c5ab66ad$export$9eaad88cf88cee2b(dy, dyShape), $5a1a44a0d119135c$export$f93b5905241a7cca($939ec2f1ca32d2a1$export$f2db7d5238e1d23f(labels, 'float32'), $e0542e85b282cc39$export$b310ec824aaee37f(logResult))),
                $51103026006cddca$export$6e3a27864ab166fe($98803384c5ab66ad$export$9eaad88cf88cee2b(dy, dyShape), $5a1a44a0d119135c$export$f93b5905241a7cca($e0542e85b282cc39$export$b310ec824aaee37f(logResult), $939ec2f1ca32d2a1$export$f2db7d5238e1d23f(labels, 'float32'))), 
            ];
        };
        return {
            value: value,
            gradFunc: gradFunc
        };
    });
    return customOp(labels1, logits1);
}
/**
 * Computes the softmax cross entropy loss between two tensors.
 *
 * If labelSmoothing is nonzero, smooth the labels towards 1/2:
 *
 *   newOnehotLabels = onehotLabels * (1 - labelSmoothing)
 *                         + labelSmoothing / numClasses
 *
 * @param onehotLabels One hot encoded labels
 *    [batch_size, num_classes], same dimensions as 'predictions'.
 * @param logits The predicted outputs.
 * @param weights Tensor whose rank is either 0, or 1, and must be
 *    broadcastable to `loss`  of shape [batch_size]
 * @param labelSmoothing If greater than 0, then smooth the labels.
 * @param reduction Type of reduction to apply to loss. Should be of type
 *    `Reduction`
 *
 * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }
 */ function $c375488a9615bd4d$var$softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction = $9dbad4060c6ab7db$export$cc9fa7113d70efba.SUM_BY_NONZERO_WEIGHTS) {
    let $onehotLabels = $d7ebc35f1f4a180c$export$ede379c4c939d71a(onehotLabels, 'onehotLabels', 'softmaxCrossEntropy');
    const $logits = $d7ebc35f1f4a180c$export$ede379c4c939d71a(logits, 'logits', 'softmaxCrossEntropy');
    let $weights = null;
    if (weights != null) $weights = $d7ebc35f1f4a180c$export$ede379c4c939d71a(weights, 'weights', 'softmaxCrossEntropy');
    $904921ed29eeae0f$export$e08b27e7f37e2782($onehotLabels.shape, $logits.shape, 'Error in softmaxCrossEntropy: ');
    if (labelSmoothing > 0) {
        const labelSmoothingScalar = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(labelSmoothing);
        const one = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1);
        const numClasses = $3d4d3db2721d0fe6$export$7de3fcd3cdba2a46($onehotLabels.shape[1]);
        $onehotLabels = $a5476a4579f57f2c$export$e16d8520af44a096($51103026006cddca$export$6e3a27864ab166fe($onehotLabels, $5a1a44a0d119135c$export$f93b5905241a7cca(one, labelSmoothingScalar)), $172176b86d7c43d7$export$159d9494db57879b(labelSmoothingScalar, numClasses));
    }
    const losses = $c375488a9615bd4d$var$softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
    return $6993d38d3a3354a1$export$23bdc4cea2e28782(losses, $weights, reduction);
}
const $c375488a9615bd4d$export$38869aa02829577 = $9e60b70ce0353b32$export$f59964a629598e2({
    softmaxCrossEntropy_: $c375488a9615bd4d$var$softmaxCrossEntropy_
});





/**
 * The input SparseTensor is represented via the map of inputs {`indices`,
 * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`
 * but with indices `outputIndices` and values `outputValues`. This op inserts a
 * single entry for every row that doesn't have any values. The index is created
 * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.
 *
 * For example, suppose `spInput` has shape [5, 6] and non-empty values:
 * [0, 1]: a
 * [0, 3]: b
 * [2, 0]: c
 * [3, 1]: d
 *
 * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:
 * [0, 1]: a
 * [0, 3]: b
 * [1, 0]: `defaultValue`
 * [2, 0]: c
 * [3, 1]: d
 * [4, 0]: `defaultValue`
 *
 * The output SparseTensor will be in row-major order and will have the same
 * shape as the input.
 *
 * This op also returns an indicator vector shaped [dense_shape[0]] such that
 * emptyRowIndicator[i] = True iff row i was an empty row.
 *
 * And a reverse index map vector shaped [indices.shape[0]] that is used during
 * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==
 * outputIndices[outi, j] for all j
 *
 * ```js
 * const result = tf.sparse.sparseFillEmptyRows(
 *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],
 *   [0, 10, 13, 14, 32, 33], [5, 6], -1);
 * console.log(result);
 * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],
 *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]
 * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]
 * result['emptyRowIndicator'].print(); // [false, false, true, false, true]
 * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]
 * ```
 * @param indices: 2-D. the indices of the sparse tensor.
 * @param values: 1-D. the values of the sparse tensor.
 * @param denseShape: 1-D. the shape of the sparse tensor.
 * @param defaultValue: 0-D. default value to insert into location [row, 0, ...,
 *     0] for rows missing from the input sparse tensor.
 * @return A map with the following properties:
 *     - outputIndices
 *     - outputValues: 1-D. the values of the filled sparse tensor.
 *     - emptyRowIndicator: 1-D. whether the dense row was missing in the input
 * sparse tensor.
 *     - reverseIndexMap: 1-D. a map from the input indices to the output
 * indices.
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */ function $80fd96057b3a75e7$var$sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
    const $indices = $d7ebc35f1f4a180c$export$ede379c4c939d71a(indices, 'indices', 'sparseFillEmptyRows', 'int32');
    const $values = $d7ebc35f1f4a180c$export$ede379c4c939d71a(values, 'values', 'sparseFillEmptyRows');
    const $denseShape = $d7ebc35f1f4a180c$export$ede379c4c939d71a(denseShape, 'denseShape', 'sparseFillEmptyRows', 'int32');
    const $defaultValue = $d7ebc35f1f4a180c$export$ede379c4c939d71a(defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);
    if ($indices.rank !== 2) throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
    if ($values.rank !== 1) throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
    if ($denseShape.rank !== 1) throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
    if ($defaultValue.rank !== 0) throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
    const inputs = {
        indices: $indices,
        values: $values,
        denseShape: $denseShape,
        defaultValue: $defaultValue
    };
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$8f1933853a5c8cca, inputs);
    return {
        outputIndices: result[0],
        outputValues: result[1],
        emptyRowIndicator: result[2],
        reverseIndexMap: result[3]
    };
}
const $80fd96057b3a75e7$export$c82a1904a15b5028 = $9e60b70ce0353b32$export$f59964a629598e2({
    sparseFillEmptyRows_: $80fd96057b3a75e7$var$sparseFillEmptyRows_
});





/**
 * This operation has the same semantics as reshape on the represented dense
 * tensor. The `inputIndices` are recomputed based on the requested `newShape`.
 * If one component of `newShape` is the special value -1, the size of that
 * dimension is computed so that the total dense size remains constant. At most
 * one component of `newShape` can be -1. The number of dense elements implied
 * by `newShape` must be the same as the number of dense elements originally
 * implied by `inputShape`. Reshaping does not affect the order of values in the
 * SparseTensor. If the input tensor has rank R_in and N non-empty values, and
 * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],
 * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and
 * `outputShape` has length R_out.
 *
 * ```js
 * const result = tf.sparse.sparseReshape(
 *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],
 *   [2, 3, 6], [9, -1]);
 * console.log(result);
 * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]
 * result['outputShape'].print(); // [9, 4]
 * ```
 * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty
 * values in a SparseTensor.
 * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense
 * shape.
 * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.
 * @return A map with the following properties:
 *     - outputIndices: 2-D. N x R_out matrix with the updated indices of
 *       non-empty values in the output SparseTensor.
 *     - outputShape: 1-D. R_out vector with the full dense shape of the output
 *       SparseTensor. This is the same as newShape but with any -1 dimensions
 *        filled in.
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */ function $e3598f572b0df2fc$var$sparseReshape_(inputIndices, inputShape, newShape) {
    const $inputIndices = $d7ebc35f1f4a180c$export$ede379c4c939d71a(inputIndices, 'inputIndices', 'sparseReshape', 'int32');
    const $inputShape = $d7ebc35f1f4a180c$export$ede379c4c939d71a(inputShape, 'inputShape', 'sparseReshape', 'int32');
    const $newShape = $d7ebc35f1f4a180c$export$ede379c4c939d71a(newShape, 'newShape', 'sparseReshape', 'int32');
    if ($inputIndices.rank !== 2) throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
    if ($inputShape.rank !== 1) throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
    if ($newShape.rank !== 1) throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
    const inputs = {
        inputIndices: $inputIndices,
        inputShape: $inputShape,
        newShape: $newShape
    };
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$f08f0dca44fa542, inputs);
    return {
        outputIndices: result[0],
        outputShape: result[1]
    };
}
const $e3598f572b0df2fc$export$1408c45865e11fc6 = $9e60b70ce0353b32$export$f59964a629598e2({
    sparseReshape_: $e3598f572b0df2fc$var$sparseReshape_
});





/**
 * Computes the mean along sparse segments of a tensor.
 *
 * ```js
 * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);
 * // Select two rows, one segment.
 * const result1 = tf.sparse.sparseSegmentMean(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 0], 'int32'));
 * result1.print(); // [[0, 0, 0, 0]]
 *
 * // Select two rows, two segments.
 * const result2 = tf.sparse.sparseSegmentMean(c,
 *                                             tf.tensor1d([0, 1], 'int32'),
 *                                             tf.tensor1d([0, 1], 'int32'));
 * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]
 *
 * // Select all rows, two segments.
 * const result3 = tf.sparse.sparseSegmentMean(c,
 *                                             tf.tensor1d([0, 1, 2], 'int32'),
 *                                             tf.tensor1d([0, 1, 1], 'int32'));
 * result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]
 * ```
 * @param data: A Tensor of at least one dimension with data that will be
 *     assembled in the output.
 * @param indices: A 1-D Tensor with indices into data. Has same rank as
 *     segmentIds.
 * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values
 *     should be sorted and can be repeated.
 * @return Has same shape as data, except for dimension 0 which has equal to
 *         the number of segments.
 *
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */ function $179b8507b0d78ec2$var$sparseSegmentMean_(data, indices, segmentIds) {
    const $data = $d7ebc35f1f4a180c$export$ede379c4c939d71a(data, 'data', 'sparseSegmentMean');
    const $indices = $d7ebc35f1f4a180c$export$ede379c4c939d71a(indices, 'indices', 'sparseSegmentMean', 'int32');
    const $segmentIds = $d7ebc35f1f4a180c$export$ede379c4c939d71a(segmentIds, 'segmentIds', 'sparseSegmentMean', 'int32');
    if ($data.rank < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if ($indices.rank !== 1) throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
    if ($segmentIds.rank !== 1) throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
    const inputs = {
        data: $data,
        indices: $indices,
        segmentIds: $segmentIds
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$610b077aecc2447b, inputs);
}
const $179b8507b0d78ec2$export$dbc0c9096869d04e = $9e60b70ce0353b32$export$f59964a629598e2({
    sparseSegmentMean_: $179b8507b0d78ec2$var$sparseSegmentMean_
});





/**
 * Computes the sum along sparse segments of a tensor.
 *
 * ```js
 * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);
 * // Select two rows, one segment.
 * const result1 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 0], 'int32'));
 * result1.print(); // [[0, 0, 0, 0]]
 *
 * // Select two rows, two segment.
 * const result2 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1], 'int32'),
 *                                           tf.tensor1d([0, 1], 'int32'));
 * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]
 *
 * // Select all rows, two segments.
 * const result3 = tf.sparse.sparseSegmentSum(c,
 *                                           tf.tensor1d([0, 1, 2], 'int32'),
 *                                           tf.tensor1d([0, 0, 1], 'int32'));
 * result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]
 * ```
 * @param data: A Tensor of at least one dimension with data that will be
 *     assembled in the output.
 * @param indices: A 1-D Tensor with indices into data. Has same rank as
 *     segmentIds.
 * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values
 *     should be sorted and can be repeated.
 * @return Has same shape as data, except for dimension 0 which has equal to
 *         the number of segments.
 *
 * @doc {heading: 'Operations', subheading: 'Sparse'}
 */ function $66fa2abb955bb07a$var$sparseSegmentSum_(data, indices, segmentIds) {
    const $data = $d7ebc35f1f4a180c$export$ede379c4c939d71a(data, 'data', 'sparseSegmentSum');
    const $indices = $d7ebc35f1f4a180c$export$ede379c4c939d71a(indices, 'indices', 'sparseSegmentSum', 'int32');
    const $segmentIds = $d7ebc35f1f4a180c$export$ede379c4c939d71a(segmentIds, 'segmentIds', 'sparseSegmentSum', 'int32');
    if ($data.rank < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if ($indices.rank !== 1) throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
    if ($segmentIds.rank !== 1) throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
    const inputs = {
        data: $data,
        indices: $indices,
        segmentIds: $segmentIds
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$68351c28d7116b56, inputs);
}
const $66fa2abb955bb07a$export$2255ce53fc777865 = $9e60b70ce0353b32$export$f59964a629598e2({
    sparseSegmentSum_: $66fa2abb955bb07a$var$sparseSegmentSum_
});





/**
 * Creates ngrams from ragged string data.
 *
 * This op accepts a ragged tensor with 1 ragged dimension containing only
 * strings and outputs a ragged tensor with 1 ragged dimension containing ngrams
 * of that string, joined along the innermost axis.
 *
 * ```js
 * const result = tf.string.stringNGrams(
 *   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),
 *   '|', [1, 2], 'LP', 'RP', -1, false);
 * result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',
 *                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']
 * result['nGramsSplits'].print(); // [0, 5, 10]
 * ```
 * @param data: The values tensor of the ragged string tensor to make ngrams out
 *     of. Must be a 1D string tensor.
 * @param dataSplits: The splits tensor of the ragged string tensor to make
 *     ngrams out of.
 * @param separator: The string to append between elements of the token. Use ""
 *     for no separator.
 * @param nGramWidths: The sizes of the ngrams to create.
 * @param leftPad: The string to use to pad the left side of the ngram sequence.
 *     Only used if pad_width !== 0.
 * @param rightPad: The string to use to pad the right side of the ngram
 *     sequence. Only used if pad_width !== 0.
 * @param padWidth: The number of padding elements to add to each side of each
 *     sequence. Note that padding will never be greater than `nGramWidths`-1
 *     regardless of this value. If `padWidth`=-1 , then add max(`nGramWidths)-1
 *     elements.
 * @param preserveShortSequences: If true, then ensure that at least one ngram
 *     is generated for each input sequence. In particular, if an input sequence
 *     is shorter than min(ngramWidth) + 2*padWidth, then generate a single
 *     ngram containing the entire sequence. If false, then no ngrams are
 *     generated for these short input sequences.
 * @return A map with the following properties:
 *     - nGrams: The values tensor of the output ngrams ragged tensor.
 *     - nGramsSplits: The splits tensor of the output ngrams ragged tensor.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */ function $409c7deaf431c660$var$stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {
    const $data = $d7ebc35f1f4a180c$export$ede379c4c939d71a(data, 'data', 'stringNGrams', 'string');
    if ($data.dtype !== 'string') throw new Error('Data must be of datatype string');
    if ($data.shape.length !== 1) throw new Error(`Data must be a vector, saw: ${$data.shape}`);
    const $dataSplits = $d7ebc35f1f4a180c$export$ede379c4c939d71a(dataSplits, 'dataSplits', 'stringNGrams');
    if ($dataSplits.dtype !== 'int32') throw new Error('Data splits must be of datatype int32');
    const attrs = {
        separator: separator,
        nGramWidths: nGramWidths,
        leftPad: leftPad,
        rightPad: rightPad,
        padWidth: padWidth,
        preserveShortSequences: preserveShortSequences
    };
    const inputs = {
        data: $data,
        dataSplits: $dataSplits
    };
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$11a7f4af7d96ad41, inputs, attrs);
    return {
        nGrams: result[0],
        nGramsSplits: result[1]
    };
}
const $409c7deaf431c660$export$3490514dcc63b044 = $9e60b70ce0353b32$export$f59964a629598e2({
    stringNGrams_: $409c7deaf431c660$var$stringNGrams_
});





/**
 * Split elements of `input` based on `delimiter` into a SparseTensor .
 *
 * Let N be the size of source (typically N will be the batch size). Split each
 * element of `input` based on `delimiter` and return a SparseTensor containing
 * the splitted tokens. Empty tokens are ignored if `skipEmpty` is set to True.
 *
 * `delimiter` can be empty, or a string of split characters. If `delimiter` is
 * an empty string, each element of `input` is split into individual
 * character strings. Otherwise every character of `delimiter` is a potential
 * split point.
 *
 * ```js
 * const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');
 * result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]
 * result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']
 * result['shape'].print(); // [2, 3]
 * ```
 * @param input: 1-D. Strings to split.
 * @param delimiter: 0-D. Delimiter characters, or empty string.
 * @param skipEmpty: Optional. If true, skip the empty strings from the result.
 *     Defaults to true.
 * @return A map with the following properties:
 *     - indices: A dense matrix of int32 representing the indices of the sparse
 *       tensor.
 *     - values: A vector of strings corresponding to the splited values.
 *     - shape: a length-2 vector of int32 representing the shape of the sparse
 * tensor, where the first value is N and the second value is the maximum number
 * of tokens in a single input entry.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */ function $e959ae1bc571847a$var$stringSplit_(input, delimiter, skipEmpty = true) {
    const $input = $d7ebc35f1f4a180c$export$ede379c4c939d71a(input, 'input', 'stringSplit', 'string');
    const $delimiter = $d7ebc35f1f4a180c$export$ede379c4c939d71a(delimiter, 'delimiter', 'stringSplit', 'string');
    if ($input.rank !== 1) throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
    if ($delimiter.rank !== 0) throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
    const attrs = {
        skipEmpty: skipEmpty
    };
    const inputs = {
        input: $input,
        delimiter: $delimiter
    };
    const result = $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$7e266f7223b9d396, inputs, attrs);
    return {
        indices: result[0],
        values: result[1],
        shape: result[2]
    };
}
const $e959ae1bc571847a$export$aa7f8babb17e7672 = $9e60b70ce0353b32$export$f59964a629598e2({
    stringSplit_: $e959ae1bc571847a$var$stringSplit_
});





/**
 * Converts each string in the input Tensor to its hash mod by a number of
 * buckets.
 *
 * The hash function is deterministic on the content of the string within the
 * process and will never change. However, it is not suitable for cryptography.
 * This function may be used when CPU time is scarce and inputs are trusted or
 * unimportant. There is a risk of adversaries constructing inputs that all hash
 * to the same bucket.
 *
 * ```js
 * const result = tf.string.stringToHashBucketFast(
 *   ['Hello', 'TensorFlow', '2.x'], 3);
 * result.print(); // [0, 2, 2]
 * ```
 * @param input: The strings to assign a hash bucket.
 * @param numBuckets: The number of buckets.
 * @return A Tensor of the same shape as the input tensor.
 *
 * @doc {heading: 'Operations', subheading: 'String'}
 */ function $f85d9d6b99856e5e$var$stringToHashBucketFast_(input, numBuckets) {
    const $input = $d7ebc35f1f4a180c$export$ede379c4c939d71a(input, 'input', 'stringToHashBucketFast', 'string');
    const attrs = {
        numBuckets: numBuckets
    };
    if (numBuckets <= 0) throw new Error(`Number of buckets must be at least 1`);
    const inputs = {
        input: $input
    };
    return $a6bde3769fa0d8b5$export$33b63313cc511a3b.runKernel($2b76be1e72a8c1db$export$a5639899909bc8ae, inputs, attrs);
}
const $f85d9d6b99856e5e$export$6195616d6fd0c848 = $9e60b70ce0353b32$export$f59964a629598e2({
    stringToHashBucketFast_: $f85d9d6b99856e5e$var$stringToHashBucketFast_
});


/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ const $6543175c07504abe$var$delayCallback = (()=>{
    if (typeof requestAnimationFrame !== 'undefined') return requestAnimationFrame;
    else if (typeof setImmediate !== 'undefined') return setImmediate;
    return (f)=>f()
    ; // no delays
})();
/**
 * Returns a promise that resolve when a requestAnimationFrame has completed.
 *
 * On Node.js this uses setImmediate instead of requestAnimationFrame.
 *
 * This is simply a sugar method so that users can do the following:
 * `await tf.nextFrame();`
 *
 * @doc {heading: 'Performance', subheading: 'Timing'}
 */ function $6543175c07504abe$export$68d2d147c928d1dd() {
    return new Promise((resolve)=>$6543175c07504abe$var$delayCallback(()=>resolve()
        )
    );
}







var $1ac51db5370ba6a2$export$7b843996b6cf8ee0;
(function($1ac51db5370ba6a2$export$7b843996b6cf8ee0) {
    $1ac51db5370ba6a2$export$7b843996b6cf8ee0[$1ac51db5370ba6a2$export$7b843996b6cf8ee0["float32"] = 0] = "float32";
    $1ac51db5370ba6a2$export$7b843996b6cf8ee0[$1ac51db5370ba6a2$export$7b843996b6cf8ee0["int32"] = 1] = "int32";
    $1ac51db5370ba6a2$export$7b843996b6cf8ee0[$1ac51db5370ba6a2$export$7b843996b6cf8ee0["bool"] = 2] = "bool";
    $1ac51db5370ba6a2$export$7b843996b6cf8ee0[$1ac51db5370ba6a2$export$7b843996b6cf8ee0["string"] = 3] = "string";
    $1ac51db5370ba6a2$export$7b843996b6cf8ee0[$1ac51db5370ba6a2$export$7b843996b6cf8ee0["complex64"] = 4] = "complex64";
})($1ac51db5370ba6a2$export$7b843996b6cf8ee0 || ($1ac51db5370ba6a2$export$7b843996b6cf8ee0 = {}));
var $1ac51db5370ba6a2$export$4cb673822966e9a9;
(function($1ac51db5370ba6a2$export$4cb673822966e9a9) {
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["linear"] = 0] = "linear";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["relu"] = 1] = "relu";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["relu6"] = 2] = "relu6";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["prelu"] = 3] = "prelu";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["leakyrelu"] = 4] = "leakyrelu";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["sigmoid"] = 5] = "sigmoid";
    $1ac51db5370ba6a2$export$4cb673822966e9a9[$1ac51db5370ba6a2$export$4cb673822966e9a9["elu"] = 6] = "elu";
})($1ac51db5370ba6a2$export$4cb673822966e9a9 || ($1ac51db5370ba6a2$export$4cb673822966e9a9 = {}));


let $f88b0814e43a2190$var$wasmFusedMatMul;
function $f88b0814e43a2190$var$setup(backend) {
    $f88b0814e43a2190$var$wasmFusedMatMul = backend.wasm.cwrap($2b76be1e72a8c1db$export$8d1af0f7c2a4da9e, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number' // out_id
    ]);
}
function $f88b0814e43a2190$var$fusedBatchMatMul(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    if (a.dtype !== 'float32' || b.dtype !== 'float32') throw new Error(`_FusedMatMul for non non-float32 tensors not yet supported.`);
    const { transposeA: transposeA , transposeB: transposeB , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    const aId = backend.dataIdMap.get(a.dataId).id;
    const bId = backend.dataIdMap.get(b.dataId).id;
    let biasId = 0;
    if (bias != null) {
        const biasData = backend.dataIdMap.get(bias.dataId);
        if (biasData.shape.length !== 1) throw new Error(`_FusedMatMul only supports rank-1 bias but got ` + `rank ${biasData.shape.length}.`);
        biasId = biasData.id;
    }
    const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend.dataIdMap.get(preluActivationWeights.dataId).id;
    const fusedActivation = $1ac51db5370ba6a2$export$4cb673822966e9a9[activation];
    if (fusedActivation == null) throw new Error(`${activation} activation not yet supported for FusedConv2D ` + `in the wasm backend.`);
    const leftDim = transposeA ? a.shape[2] : a.shape[1];
    const rightDim = transposeB ? b.shape[1] : b.shape[2];
    const batchDims = $c374f26140f3eb6b$exports.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
    const out = backend.makeOutput([
        ...batchDims,
        leftDim,
        rightDim
    ], a.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const aShapeBytes = new Uint8Array(new Int32Array(a.shape).buffer);
    const bShapeBytes = new Uint8Array(new Int32Array(b.shape).buffer);
    $f88b0814e43a2190$var$wasmFusedMatMul(aId, aShapeBytes, a.shape.length, bId, bShapeBytes, b.shape.length, transposeA, transposeB, fusedActivation, biasId, preluActivationWeightsId, leakyreluAlpha || 0, outId);
    return out;
}
const $f88b0814e43a2190$export$f70d36da1c218f84 = {
    kernelName: $2b76be1e72a8c1db$export$8d1af0f7c2a4da9e,
    backendName: 'wasm',
    setupFunc: $f88b0814e43a2190$var$setup,
    kernelFunc: $f88b0814e43a2190$var$fusedBatchMatMul
};





function $ac378055f5ed31b0$export$1064a4367d46e10e(kernelName, outType) {
    let wasmFunc;
    function setupFunc(backend) {
        wasmFunc = backend.wasm.cwrap(kernelName, null, [
            'number',
            'number',
            'number', 
        ]);
    }
    function kernelFunc(args) {
        const { backend: backend , inputs: { x: x  }  } = args;
        const xId = backend.dataIdMap.get(x.dataId).id;
        const out = backend.makeOutput(x.shape, outType || x.dtype);
        const outId = backend.dataIdMap.get(out.dataId).id;
        // Short-circuit zero-sized tensors.
        if ($f6b55a2021b78f0d$exports.sizeFromShape(out.shape) === 0) return out;
        wasmFunc(xId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], outId);
        return out;
    }
    return {
        kernelName: kernelName,
        backendName: 'wasm',
        setupFunc: setupFunc,
        kernelFunc: kernelFunc
    };
}


const $a49d18fa8cce21b2$export$d66f48648b9d5ec7 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$b73c596ee8758a66);





function $0e332ad1f17d7d5e$export$643f3601638ef87a(kernelName, supportsFullBroadcast, dtype) {
    let wasmFunc;
    function setupFunc(backend) {
        wasmFunc = backend.wasm.cwrap(kernelName, null, [
            'number',
            'array',
            'number',
            'number',
            'array',
            'number',
            'number',
            'number' // out_id
        ]);
    }
    function kernelFunc1(args) {
        const { backend: backend , inputs: inputs  } = args;
        const { a: a , b: b  } = inputs;
        const aId = backend.dataIdMap.get(a.dataId).id;
        const bId = backend.dataIdMap.get(b.dataId).id;
        const outputType = dtype != null ? dtype : a.dtype;
        const newShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(a.shape, b.shape);
        const out = backend.makeOutput(newShape, outputType);
        // Short-circuit zero-sized tensors.
        if ($f6b55a2021b78f0d$exports.sizeFromShape(newShape) === 0) return out;
        const aShapeBytes = new Uint8Array(new Int32Array(a.shape).buffer);
        const bShapeBytes = new Uint8Array(new Int32Array(b.shape).buffer);
        const outId = backend.dataIdMap.get(out.dataId).id;
        const kernelFunc = ()=>wasmFunc(aId, aShapeBytes, a.shape.length, bId, bShapeBytes, b.shape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[a.dtype], outId)
        ;
        kernelFunc();
        return out;
    }
    return {
        kernelName: kernelName,
        backendName: 'wasm',
        setupFunc: setupFunc,
        kernelFunc: kernelFunc1
    };
}


const $7dc325cdec1e1476$var$supportsFullBroadcast = true;
const $7dc325cdec1e1476$export$b1f3a580afb68e4c = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$d0265b2c425512d6, $7dc325cdec1e1476$var$supportsFullBroadcast);




let $14510e08281e9f8e$var$wasmFunc;
function $14510e08281e9f8e$var$setupFunc(backend) {
    $14510e08281e9f8e$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$eef235ad06d3226a, null, [
        'array',
        'number',
        'number',
        'number', 
    ]);
}
function $14510e08281e9f8e$var$addn(args) {
    const { inputs: inputs , backend: backend  } = args;
    const out = backend.makeOutput(inputs[0].shape, inputs[0].dtype);
    // Short-circuit zero-sized tensors.
    if ($f6b55a2021b78f0d$exports.sizeFromShape(out.shape) === 0) return out;
    const inputIds = inputs.map((x)=>backend.dataIdMap.get(x.dataId).id
    );
    const inputIdsBytes = new Uint8Array(new Int32Array(inputIds).buffer);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $14510e08281e9f8e$var$wasmFunc(inputIdsBytes, inputIds.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[out.dtype], outId);
    return out;
}
const $14510e08281e9f8e$export$ff8000bc6f0313e1 = {
    kernelName: $2b76be1e72a8c1db$export$eef235ad06d3226a,
    backendName: 'wasm',
    setupFunc: $14510e08281e9f8e$var$setupFunc,
    kernelFunc: $14510e08281e9f8e$var$addn
};






function $2d04234e8e22f7e1$export$f0954fd7d5368655(args) {
    const { inputs: { x: x  } , backend: backend  } = args;
    const out = backend.makeOutput(x.shape, x.dtype);
    const inVals = backend.typedArrayFromHeap(x);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.set(inVals);
    return out;
}
const $2d04234e8e22f7e1$export$c426d3942537ad84 = {
    kernelName: $2b76be1e72a8c1db$export$544bf02140fa9a77,
    backendName: 'wasm',
    kernelFunc: $2d04234e8e22f7e1$export$f0954fd7d5368655
};



let $1c71bf11e4cf3d4a$var$wasmTranspose;
function $1c71bf11e4cf3d4a$var$setup(backend) {
    $1c71bf11e4cf3d4a$var$wasmTranspose = backend.wasm.cwrap($2b76be1e72a8c1db$export$7e714455f9a1f8f7, null, [
        'number',
        'array',
        'number',
        'number',
        'number',
        'array',
        'number', 
    ]);
}
function $1c71bf11e4cf3d4a$export$9cb09a71b7d66923(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    // Reduce any dimensions with size one. Lower-rank transpose kernel performs
    // better due to simpler memory access pattern.
    const [reducedShape, perm] = $1c71bf11e4cf3d4a$var$removeOneSizeDims(inputs.x.shape, attrs.perm);
    let permIsNoOp = true;
    for(let i = 0; i < perm.length; i++)if (perm[i] !== i) permIsNoOp = false;
    const outShape = $1c71bf11e4cf3d4a$var$computeOutShape(inputs.x.shape, attrs.perm);
    const x = {
        dataId: inputs.x.dataId,
        shape: reducedShape,
        dtype: inputs.x.dtype
    };
    if (permIsNoOp) {
        const cloned = $2d04234e8e22f7e1$export$f0954fd7d5368655({
            inputs: inputs,
            backend: backend
        });
        cloned.shape = outShape;
        return cloned;
    }
    const out = backend.makeOutput(outShape, x.dtype);
    const xId = backend.dataIdMap.get(x.dataId).id;
    const outId = backend.dataIdMap.get(out.dataId).id;
    const permBytes = new Uint8Array(new Int32Array(perm).buffer);
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    $1c71bf11e4cf3d4a$var$wasmTranspose(xId, xShapeBytes, x.shape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], outId, permBytes, perm.length);
    return out;
}
function $1c71bf11e4cf3d4a$var$computeOutShape(inShape, perm) {
    const outShape = new Array(inShape.length);
    for(let i = 0; i < outShape.length; i++)outShape[i] = inShape[perm[i]];
    return outShape;
}
function $1c71bf11e4cf3d4a$var$removeOneSizeDims(shape, perm) {
    const newShape = [];
    const newPerm = [];
    for(let i = 0; i < shape.length; ++i){
        if (shape[i] !== 1) newShape.push(shape[i]);
        if (shape[perm[i]] !== 1) newPerm.push(perm[i]);
    }
    for(let i1 = 0; i1 < newPerm.length; ++i1){
        let minValIdx = -1;
        for(let j = 0; j < newPerm.length; ++j)if (newPerm[j] >= i1 && (minValIdx === -1 || newPerm[minValIdx] > newPerm[j])) minValIdx = j;
        newPerm[minValIdx] = i1;
    }
    return [
        newShape,
        newPerm
    ];
}
const $1c71bf11e4cf3d4a$export$895a002a39b774be = {
    kernelName: $2b76be1e72a8c1db$export$7e714455f9a1f8f7,
    backendName: 'wasm',
    kernelFunc: $1c71bf11e4cf3d4a$export$9cb09a71b7d66923,
    setupFunc: $1c71bf11e4cf3d4a$var$setup
};


function $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend) {
    const xShape = x.shape;
    const xRank = x.shape.length;
    const originalAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, xShape);
    let axes = originalAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let xTransposed = null;
    let inputWasTransposed = false;
    if (permutedAxes != null) {
        const newShape = new Array(xRank);
        for(let i = 0; i < newShape.length; i++)newShape[i] = xShape[permutedAxes[i]];
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
        xTransposed = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            attrs: {
                perm: permutedAxes
            },
            backend: backend
        });
        const xId = backend.dataIdMap.get(x.dataId).id;
        const transposedId = backend.dataIdMap.get(xTransposed.dataId).id;
        if (transposedId !== xId) inputWasTransposed = true;
    }
    return {
        transposed: xTransposed,
        originalAxes: originalAxes,
        axes: axes,
        inputWasTransposed: inputWasTransposed
    };
}


let $54b2429a14de742e$var$wasmAll;
function $54b2429a14de742e$var$setup(backend) {
    $54b2429a14de742e$var$wasmAll = backend.wasm.cwrap($2b76be1e72a8c1db$export$5dceb1ab650a1776, null, [
        'number, number, number'
    ]);
}
function $54b2429a14de742e$var$all(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        input = transposed;
        inputId = transposedId;
    }
    const inputRank = input.shape.length;
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('all', axes, inputRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, x.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $54b2429a14de742e$var$wasmAll(inputId, reduceSize, outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $54b2429a14de742e$export$4e3f081eb1a330fa = {
    kernelName: $2b76be1e72a8c1db$export$5dceb1ab650a1776,
    backendName: 'wasm',
    setupFunc: $54b2429a14de742e$var$setup,
    kernelFunc: $54b2429a14de742e$var$all
};




let $b3f8c340aca5b6bc$var$wasmAny;
function $b3f8c340aca5b6bc$var$setup(backend) {
    $b3f8c340aca5b6bc$var$wasmAny = backend.wasm.cwrap($2b76be1e72a8c1db$export$b24b633b1364b94b, null, [
        'number, number, number'
    ]);
}
function $b3f8c340aca5b6bc$var$any(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        input = transposed;
        inputId = transposedId;
    }
    const inputRank = input.shape.length;
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('any', axes, inputRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, x.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $b3f8c340aca5b6bc$var$wasmAny(inputId, reduceSize, outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $b3f8c340aca5b6bc$export$1a8ff634f2df3da6 = {
    kernelName: $2b76be1e72a8c1db$export$b24b633b1364b94b,
    backendName: 'wasm',
    setupFunc: $b3f8c340aca5b6bc$var$setup,
    kernelFunc: $b3f8c340aca5b6bc$var$any
};





let $4849af9fb9711c3c$var$wasmFunc;
function $4849af9fb9711c3c$var$setup(backend) {
    $4849af9fb9711c3c$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$17612294a1503e1c, null, [
        'number',
        'number',
        'number',
        'number',
        'number' // out_id
    ]);
}
function $4849af9fb9711c3c$var$argmax(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        if (transposedId !== xId) {
            // transpose was not a no-op. We will need to dispose of this
            // once we are done.
            input = transposed;
            inputId = transposedId;
        }
    }
    const outShape = input.shape.slice(0, -1);
    const out = backend.makeOutput(outShape, 'int32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const outerSize = $f6b55a2021b78f0d$exports.sizeFromShape(out.shape);
    const innerSize = input.shape[axes[0]];
    $4849af9fb9711c3c$var$wasmFunc(inputId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[input.dtype], outerSize, innerSize, outId);
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    return out;
}
const $4849af9fb9711c3c$export$ec7419fc9ad0069e = {
    kernelName: $2b76be1e72a8c1db$export$17612294a1503e1c,
    backendName: 'wasm',
    kernelFunc: $4849af9fb9711c3c$var$argmax,
    setupFunc: $4849af9fb9711c3c$var$setup
};



let $430a8b279a0d0d38$var$wasmAvgPool;
function $430a8b279a0d0d38$var$setup(backend) {
    $430a8b279a0d0d38$var$wasmAvgPool = backend.wasm.cwrap($2b76be1e72a8c1db$export$37f2cc7be1add88c, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $430a8b279a0d0d38$var$avgPool(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const x = inputs.x;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const channels = convInfo.inChannels;
    if (convInfo.dataFormat !== 'channelsLast') throw new Error(`wasm backend does not support dataFormat:'` + `${convInfo.dataFormat}'. Please use 'channelsLast'.`);
    if (convInfo.dilationWidth !== 1 || convInfo.dilationHeight !== 1) throw new Error(`was backend only supports average pooling with dilation = [1, 1], ` + `got [${convInfo.dilationHeight}, ${convInfo.dilationWidth}].`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    $430a8b279a0d0d38$var$wasmAvgPool(xId, x.shape[0], x.shape[1], x.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, strideHeight, strideWidth, channels, outId);
    return out;
}
const $430a8b279a0d0d38$export$6c901824a23e6150 = {
    kernelName: $2b76be1e72a8c1db$export$37f2cc7be1add88c,
    backendName: 'wasm',
    setupFunc: $430a8b279a0d0d38$var$setup,
    kernelFunc: $430a8b279a0d0d38$var$avgPool
};




function $15ffb328294ad08e$export$9eaad88cf88cee2b(args) {
    const { inputs: inputs , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { shape: shape  } = attrs;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const $shape = $f6b55a2021b78f0d$exports.inferFromImplicitShape(shape, xSize);
    $f6b55a2021b78f0d$exports.assert(xSize === $f6b55a2021b78f0d$exports.sizeFromShape($shape), ()=>`new shape: ${$shape}, old shape: ${x.shape}. New shape and old ` + `shape must have the same number of elements.`
    );
    // Backend needs to track refCount for the dataId for reshape op
    args.backend.incRef(x.dataId);
    return {
        dataId: x.dataId,
        shape: $shape,
        dtype: x.dtype
    };
}
const $15ffb328294ad08e$export$cfa02e698602aca2 = {
    kernelName: $2b76be1e72a8c1db$export$755ddd847e5abe03,
    backendName: 'wasm',
    kernelFunc: $15ffb328294ad08e$export$9eaad88cf88cee2b
};


let $8ddacab274e09b13$var$wasmBatchMatMul;
function $8ddacab274e09b13$var$setup(backend) {
    $8ddacab274e09b13$var$wasmBatchMatMul = backend.wasm.cwrap($2b76be1e72a8c1db$export$9a3bf60b23f63c8, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number' // out_id
    ]);
}
function $8ddacab274e09b13$var$batchMatMul(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b  } = inputs;
    const { transposeA: transposeA , transposeB: transposeB  } = attrs;
    if (a.dtype !== 'float32' || b.dtype !== 'float32') throw new Error(`BatchMatMul for non non-float32 tensors not yet supported.`);
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsA);
    const batchDimB = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsB);
    const outShapeOuterDims = $c374f26140f3eb6b$exports.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([
        outerShapeA,
        outerShapeB
    ]);
    $f6b55a2021b78f0d$exports.assert(innerShapeA === innerShapeB, ()=>`Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`
    );
    const a3dShape = transposeA ? [
        batchDimA,
        innerShapeA,
        outerShapeA
    ] : [
        batchDimA,
        outerShapeA,
        innerShapeA
    ];
    const b3dShape = transposeB ? [
        batchDimB,
        outerShapeB,
        innerShapeB
    ] : [
        batchDimB,
        innerShapeB,
        outerShapeB
    ];
    // The rest of the implementation is designed to operate on rank-3 tensors
    const a3d = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: a
        },
        backend: backend,
        attrs: {
            shape: a3dShape
        }
    });
    const b3d = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: b
        },
        backend: backend,
        attrs: {
            shape: b3dShape
        }
    });
    const a3dId = backend.dataIdMap.get(a3d.dataId).id;
    const b3dId = backend.dataIdMap.get(b3d.dataId).id;
    const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
    const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
    const batchDim = Math.max(batchDimA, batchDimB);
    const out = backend.makeOutput([
        batchDim,
        leftDim,
        rightDim
    ], a3d.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const aShapeBytes = new Uint8Array(new Int32Array(a3d.shape).buffer);
    const bShapeBytes = new Uint8Array(new Int32Array(b3d.shape).buffer);
    $8ddacab274e09b13$var$wasmBatchMatMul(a3dId, aShapeBytes, a3d.shape.length, b3dId, bShapeBytes, b3d.shape.length, transposeA, transposeB, outId);
    backend.disposeData(a3d.dataId);
    backend.disposeData(b3d.dataId);
    out.shape = outShape;
    return out;
}
const $8ddacab274e09b13$export$d0dd993198185538 = {
    kernelName: $2b76be1e72a8c1db$export$9a3bf60b23f63c8,
    backendName: 'wasm',
    setupFunc: $8ddacab274e09b13$var$setup,
    kernelFunc: $8ddacab274e09b13$var$batchMatMul
};





var $7f515e65fbaac962$exports = {};

$parcel$export($7f515e65fbaac962$exports, "simpleAbsImpl", function () { return $e1d7b31057aa8a7a$export$9e7ee8a1798ec2d5; });
$parcel$export($7f515e65fbaac962$exports, "addImpl", function () { return $cbaec80dd34f96bb$export$da57353b24bb5e2; });
$parcel$export($7f515e65fbaac962$exports, "bincountImpl", function () { return $169583b362c12f18$export$8e4da6ec633bf0a6; });
$parcel$export($7f515e65fbaac962$exports, "bincountReduceImpl", function () { return $169583b362c12f18$export$486b8d48edd28ba5; });
$parcel$export($7f515e65fbaac962$exports, "ceilImpl", function () { return $a100094c89dd6d5d$export$72486f20c97f6da8; });
$parcel$export($7f515e65fbaac962$exports, "concatImpl", function () { return $8c0fda6ef00eb49d$export$777da59f594f497d; });
$parcel$export($7f515e65fbaac962$exports, "equalImpl", function () { return $114a5f7d44a64c41$export$437b1c87795f120c; });
$parcel$export($7f515e65fbaac962$exports, "expImpl", function () { return $4e30044b6b67a663$export$823000b70594f385; });
$parcel$export($7f515e65fbaac962$exports, "expm1Impl", function () { return $dda94f97a8e1daf8$export$44f6c1b1ff8db911; });
$parcel$export($7f515e65fbaac962$exports, "floorImpl", function () { return $5b144f27164f1f4e$export$c365361068e97c87; });
$parcel$export($7f515e65fbaac962$exports, "gatherNdImpl", function () { return $b5f6308f114a9bb4$export$eed1912b07a3c4d5; });
$parcel$export($7f515e65fbaac962$exports, "gatherV2Impl", function () { return $8d57ce41c39b729c$export$d7b732f2e62ccc09; });
$parcel$export($7f515e65fbaac962$exports, "greaterImpl", function () { return $92c0e9ae9f959176$export$bec57aa1d63b78bc; });
$parcel$export($7f515e65fbaac962$exports, "greaterEqualImpl", function () { return $a4bf2833f8178a9b$export$3cea60aeb61ae586; });
$parcel$export($7f515e65fbaac962$exports, "lessImpl", function () { return $38fa0ec3880a2dc4$export$d4d22ddbe6cd91a5; });
$parcel$export($7f515e65fbaac962$exports, "lessEqualImpl", function () { return $c2830dac3543b869$export$27397851733876fa; });
$parcel$export($7f515e65fbaac962$exports, "linSpaceImpl", function () { return $bb0c259378aaff95$export$31412d657cd1cc08; });
$parcel$export($7f515e65fbaac962$exports, "logImpl", function () { return $d97da17f52ed975d$export$8a107ec4d5b0e907; });
$parcel$export($7f515e65fbaac962$exports, "maxImpl", function () { return $290cb3a8bc723624$export$23c9b99bdac85be0; });
$parcel$export($7f515e65fbaac962$exports, "maximumImpl", function () { return $387d080214918c74$export$4e233ba825c9b60e; });
$parcel$export($7f515e65fbaac962$exports, "minimumImpl", function () { return $5928be63ba34a1a4$export$756c08a3fa64d43; });
$parcel$export($7f515e65fbaac962$exports, "multiplyImpl", function () { return $84b5dd89fe629858$export$ac59ae2be94ddda3; });
$parcel$export($7f515e65fbaac962$exports, "negImpl", function () { return $c4c77c008a62d83d$export$e9053236ce0e659b; });
$parcel$export($7f515e65fbaac962$exports, "notEqualImpl", function () { return $b96c4ec4fa331740$export$eaea354630818ed4; });
$parcel$export($7f515e65fbaac962$exports, "prodImpl", function () { return $a511c99458739875$export$a3c8a5271f6bb700; });
$parcel$export($7f515e65fbaac962$exports, "rangeImpl", function () { return $1752da38d99a9db0$export$3561205b7dff20bf; });
$parcel$export($7f515e65fbaac962$exports, "rsqrtImpl", function () { return $e4ff695093678829$export$7ec24de9bffc6b90; });
$parcel$export($7f515e65fbaac962$exports, "sigmoidImpl", function () { return $f57eef2a9f713d28$export$e31bae35ce8238b3; });
$parcel$export($7f515e65fbaac962$exports, "sliceImpl", function () { return $3f463099ff6ccc0b$export$4bdf1ac3fa5d3d6a; });
$parcel$export($7f515e65fbaac962$exports, "sparseFillEmptyRowsImpl", function () { return $a1ecb873653da6fc$export$9db01208a1bec190; });
$parcel$export($7f515e65fbaac962$exports, "sparseReshapeImpl", function () { return $576be96eb9be5e86$export$a65a15ebab81f5cd; });
$parcel$export($7f515e65fbaac962$exports, "sparseSegmentReductionImpl", function () { return $22121e811d80d726$export$7d3f7130c4245e65; });
$parcel$export($7f515e65fbaac962$exports, "sqrtImpl", function () { return $1bdf881481671c57$export$c6f4fdf945028fb; });
$parcel$export($7f515e65fbaac962$exports, "squaredDifferenceImpl", function () { return $bf9ce837076b486f$export$11806d7b3158c032; });
$parcel$export($7f515e65fbaac962$exports, "stridedSliceImpl", function () { return $a2de56570dbafe39$export$b7c450ffe7e10d88; });
$parcel$export($7f515e65fbaac962$exports, "stringNGramsImpl", function () { return $e61066bf26e590dd$export$67c0958e8184138b; });
$parcel$export($7f515e65fbaac962$exports, "stringSplitImpl", function () { return $ec69ed0754ce0772$export$c3b08e43aa36d65d; });
$parcel$export($7f515e65fbaac962$exports, "stringToHashBucketFastImpl", function () { return $3e3cb1423d6599f6$export$37cbed4d0b2fe56a; });
$parcel$export($7f515e65fbaac962$exports, "subImpl", function () { return $1fbda794b513f6c9$export$ad8defe68e22c8c1; });
$parcel$export($7f515e65fbaac962$exports, "tileImpl", function () { return $f61428d0206617c9$export$f3e554b937559516; });
$parcel$export($7f515e65fbaac962$exports, "topKImpl", function () { return $3334846189799256$export$b083239978762299; });
$parcel$export($7f515e65fbaac962$exports, "transposeImpl", function () { return $81b92e00647b9a32$export$986b9e65182e08d; });
$parcel$export($7f515e65fbaac962$exports, "uniqueImpl", function () { return $0f857a49f2c266d0$export$58be9cc013c994e; });


function $2f54d733028161b9$export$1412c17b2531581a(tensor, opName) {
    if (!Array.isArray(tensor)) tensor = [
        tensor
    ];
    tensor.forEach((t)=>{
        if (t != null) $f6b55a2021b78f0d$exports.assert(t.dtype !== 'complex64', ()=>`${opName} does not support complex64 tensors in the CPU backend.`
        );
    });
}


function $e1d7b31057aa8a7a$export$9e7ee8a1798ec2d5(vals) {
    const resultValues = new Float32Array(vals.length);
    for(let i = 0; i < vals.length; ++i)resultValues[i] = Math.abs(vals[i]);
    return resultValues;
}
const $e1d7b31057aa8a7a$export$2335f513bbd82c6d = (args)=>{
    const { x: x  } = args.inputs;
    const cpuBackend = args.backend;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'abs');
    let resultValues = new Float32Array($f6b55a2021b78f0d$exports.sizeFromShape(x.shape));
    const values = cpuBackend.data.get(x.dataId).values;
    resultValues = $e1d7b31057aa8a7a$export$9e7ee8a1798ec2d5(values);
    return cpuBackend.makeOutput(resultValues, x.shape, x.dtype);
};
const $e1d7b31057aa8a7a$export$d66f48648b9d5ec7 = {
    kernelName: $2b76be1e72a8c1db$export$b73c596ee8758a66,
    backendName: 'cpu',
    kernelFunc: $e1d7b31057aa8a7a$export$2335f513bbd82c6d
};




function $c0c4b4b9f56d6853$export$28de919591fae5d9(op) {
    return (aShape, bShape, aVals, bVals, dtype)=>{
        const newShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(aShape, bShape);
        const resultRank = newShape.length;
        const resultStrides = $f6b55a2021b78f0d$exports.computeStrides(newShape);
        const resultSize = $f6b55a2021b78f0d$exports.sizeFromShape(newShape);
        const result = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(dtype, resultSize);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const aStrides = $f6b55a2021b78f0d$exports.computeStrides(aShape);
        const bStrides = $f6b55a2021b78f0d$exports.computeStrides(bShape);
        const aBroadcastDims = $510a55f99d61727a$exports.getBroadcastDims(aShape, newShape);
        const bBroadcastDims = $510a55f99d61727a$exports.getBroadcastDims(bShape, newShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) for(let i = 0; i < result.length; ++i)result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);
        else for(let i1 = 0; i1 < result.length; ++i1){
            const loc = $f6b55a2021b78f0d$exports.indexToLoc(i1, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d)=>aLoc[d] = 0
            );
            const aIndex = $f6b55a2021b78f0d$exports.locToIndex(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d)=>bLoc[d] = 0
            );
            const bIndex = $f6b55a2021b78f0d$exports.locToIndex(bLoc, bRank, bStrides);
            result[i1] = op(aVals[aIndex], bVals[bIndex]);
        }
        return [
            result,
            newShape
        ];
    };
}








function $4bf097831c9b1d30$export$83a0e34f1302825b(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { real: real , imag: imag  } = inputs;
    const realVals = backend.data.get(real.dataId).values;
    const imagVals = backend.data.get(imag.dataId).values;
    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');
    const $4bf097831c9b1d30$export$83a0e34f1302825b = backend.data.get(complexInfo.dataId);
    // The complex tensor owns the underlying real and imag tensorInfos, only the
    // complex tensor tracks refCount, when complexData is disposed the
    // underlying tensorData will be disposed.
    $4bf097831c9b1d30$export$83a0e34f1302825b.complexTensorInfos = {
        real: backend.makeTensorInfo(real.shape, 'float32', realVals),
        imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)
    };
    return complexInfo;
}
const $4bf097831c9b1d30$export$67917f7910d27fd8 = {
    kernelName: $2b76be1e72a8c1db$export$50ceb3fb9926e63e,
    backendName: 'cpu',
    kernelFunc: $4bf097831c9b1d30$export$83a0e34f1302825b
};


function $9d20a34f1f5e2714$export$4445a00dafa2633b(backend, shape, dtype = 'float32') {
    if (dtype === 'complex64') {
        const real = $9d20a34f1f5e2714$export$4445a00dafa2633b(backend, shape, 'float32');
        const imag = $9d20a34f1f5e2714$export$4445a00dafa2633b(backend, shape, 'float32');
        return $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: real,
                imag: imag
            },
            backend: backend
        });
    }
    const values = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(shape), dtype);
    return backend.makeTensorInfo(shape, dtype, values);
}




function $cac0f9b7f5ef2746$export$f0954fd7d5368655(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    backend.incRef(x.dataId);
    return {
        dataId: x.dataId,
        shape: x.shape,
        dtype: x.dtype
    };
}
const $cac0f9b7f5ef2746$export$c426d3942537ad84 = {
    kernelName: $2b76be1e72a8c1db$export$544bf02140fa9a77,
    backendName: 'cpu',
    kernelFunc: $cac0f9b7f5ef2746$export$f0954fd7d5368655
};



function $cca3c2d597694263$export$9fc57fb453bdbd67(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const $cca3c2d597694263$export$9fc57fb453bdbd67 = backend.data.get(input.dataId).complexTensorInfos.real;
    const realVal = backend.data.get($cca3c2d597694263$export$9fc57fb453bdbd67.dataId).values;
    // When complex tensor is disposed, its underlying parts will be disposed too.
    // Make new tensor out of the real value of the complex. This makes sure the
    // value is still accessible even if complex tensor is disposed.
    return backend.makeTensorInfo($cca3c2d597694263$export$9fc57fb453bdbd67.shape, $cca3c2d597694263$export$9fc57fb453bdbd67.dtype, realVal);
}
const $cca3c2d597694263$export$4b7bce57557ae68b = {
    kernelName: $2b76be1e72a8c1db$export$f41305719b94e675,
    backendName: 'cpu',
    kernelFunc: $cca3c2d597694263$export$9fc57fb453bdbd67
};


function $bf6d67cb764aa536$export$f2db7d5238e1d23f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { dtype: dtype  } = attrs;
    // Casting to complex64.
    if (dtype === 'complex64') {
        if (x.dtype === 'complex64') return $cac0f9b7f5ef2746$export$f0954fd7d5368655({
            inputs: {
                x: x
            },
            backend: backend
        });
        const zerosTensorInfo = $9d20a34f1f5e2714$export$4445a00dafa2633b(backend, x.shape, x.dtype);
        const floatX = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                dtype: 'float32'
            }
        });
        const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: floatX,
                imag: zerosTensorInfo
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        backend.disposeIntermediateTensorInfo(floatX);
        return result;
    }
    // Casting from complex64
    if (x.dtype === 'complex64') {
        const realPart = $cca3c2d597694263$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const result = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
            inputs: {
                x: realPart
            },
            backend: backend,
            attrs: {
                dtype: dtype
            }
        });
        backend.disposeIntermediateTensorInfo(realPart);
        return result;
    }
    if (!$f6b55a2021b78f0d$exports.hasEncodingLoss(x.dtype, dtype)) {
        // We don't change the underlying data, since we cast to higher
        // precision.
        const result = $cac0f9b7f5ef2746$export$f0954fd7d5368655({
            inputs: {
                x: x
            },
            backend: backend
        });
        return {
            dataId: result.dataId,
            shape: result.shape,
            dtype: dtype
        };
    }
    if (dtype === 'int32') {
        const values = backend.data.get(x.dataId).values;
        const resultValues = Int32Array.from(values);
        return backend.makeTensorInfo(x.shape, 'int32', resultValues);
    }
    if (dtype === 'bool') {
        // This is essentially the result of notEqual(x, 0). We avoid using
        // kernel notEqual to avoid circular dependency, i.e. binary_utils ->
        // cast -> notEqual -> binary_utils.
        const xVals = backend.data.get(x.dataId).values;
        const zero = $f6b55a2021b78f0d$exports.toTypedArray([
            0
        ], x.dtype);
        const [resultData, resultShape] = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a !== b ? 1 : 0
        )(x.shape, [], xVals, zero, 'bool');
        return backend.makeTensorInfo(resultShape, 'bool', resultData);
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
const $bf6d67cb764aa536$export$ac4d0f0f3927a8f3 = {
    kernelName: $2b76be1e72a8c1db$export$107ecfb3d1ccbd77,
    backendName: 'cpu',
    kernelFunc: $bf6d67cb764aa536$export$f2db7d5238e1d23f
};



function $bed1816d9b4c970d$export$29353c66e70e3e16(name, simpleImpl, complexImpl, dtype) {
    if (complexImpl == null) return ({ inputs: inputs , backend: backend  })=>{
        const { a: a , b: b  } = inputs;
        const cpuBackend = backend;
        $2f54d733028161b9$export$1412c17b2531581a([
            a,
            b
        ], name);
        const aVals = cpuBackend.data.get(a.dataId).values;
        const bVals = cpuBackend.data.get(b.dataId).values;
        const decodedAVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any
        $510a55f99d61727a$exports.fromUint8ToStringArray(aVals) : aVals;
        const decodedBVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any
        $510a55f99d61727a$exports.fromUint8ToStringArray(bVals) : bVals;
        const $dtype = dtype || a.dtype;
        const [resultData, resultShape] = simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
        return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
    };
    return ({ inputs: inputs , backend: backend  })=>{
        const { a: a , b: b  } = inputs;
        const cpuBackend = backend;
        if (a.dtype === 'complex64' || b.dtype === 'complex64') {
            const $aComplex = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
                inputs: {
                    x: a
                },
                backend: cpuBackend,
                attrs: {
                    dtype: 'complex64'
                }
            });
            const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
            const aReal = $aComplexVals.complexTensorInfos.real;
            const aImag = $aComplexVals.complexTensorInfos.imag;
            const aRealVals = cpuBackend.data.get(aReal.dataId).values;
            const aImagVals = cpuBackend.data.get(aImag.dataId).values;
            const $bComplex = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
                inputs: {
                    x: b
                },
                backend: cpuBackend,
                attrs: {
                    dtype: 'complex64'
                }
            });
            const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
            const bReal = $bComplexVals.complexTensorInfos.real;
            const bImag = $bComplexVals.complexTensorInfos.imag;
            const bRealVals = cpuBackend.data.get(bReal.dataId).values;
            const bImagVals = cpuBackend.data.get(bImag.dataId).values;
            const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
            const resultReal = cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);
            const resultImag = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);
            const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
                inputs: {
                    real: resultReal,
                    imag: resultImag
                },
                backend: cpuBackend
            });
            cpuBackend.disposeIntermediateTensorInfo($aComplex);
            cpuBackend.disposeIntermediateTensorInfo($bComplex);
            cpuBackend.disposeIntermediateTensorInfo(resultReal);
            cpuBackend.disposeIntermediateTensorInfo(resultImag);
            return result;
        } else {
            const aVals = cpuBackend.data.get(a.dataId).values;
            const bVals = cpuBackend.data.get(b.dataId).values;
            const $dtype = dtype || a.dtype;
            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
        }
    };
}
function $bed1816d9b4c970d$export$79261d982c3c14a7(op) {
    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals)=>{
        const resultShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(aShape, bShape);
        const resultSize = $f6b55a2021b78f0d$exports.sizeFromShape(resultShape);
        const resultRank = resultShape.length;
        const resultStrides = $f6b55a2021b78f0d$exports.computeStrides(resultShape);
        const resultRealVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('float32', resultSize);
        const resultImagVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('float32', resultSize);
        const aBroadcastDims = $510a55f99d61727a$exports.getBroadcastDims(aShape, resultShape);
        const bBroadcastDims = $510a55f99d61727a$exports.getBroadcastDims(bShape, resultShape);
        const aVals = $510a55f99d61727a$exports.mergeRealAndImagArrays(aRealVals, aImagVals);
        const bVals = $510a55f99d61727a$exports.mergeRealAndImagArrays(bRealVals, bImagVals);
        const aRank = aShape.length;
        const aStrides = $f6b55a2021b78f0d$exports.computeStrides(aShape);
        const bRank = bShape.length;
        const bStrides = $f6b55a2021b78f0d$exports.computeStrides(bShape);
        if (aBroadcastDims.length + bBroadcastDims.length === 0) for(let i = 0; i < resultRealVals.length; i++){
            const aIdx = i % aVals.length;
            const bIdx = i % bVals.length;
            const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
            resultRealVals[i] = result.real;
            resultImagVals[i] = result.imag;
        }
        else for(let i1 = 0; i1 < resultRealVals.length; i1++){
            const loc = $f6b55a2021b78f0d$exports.indexToLoc(i1, resultRank, resultStrides);
            const aLoc = loc.slice(-aRank);
            aBroadcastDims.forEach((d)=>aLoc[d] = 0
            );
            const aIndex = $f6b55a2021b78f0d$exports.locToIndex(aLoc, aRank, aStrides);
            const bLoc = loc.slice(-bRank);
            bBroadcastDims.forEach((d)=>bLoc[d] = 0
            );
            const bIndex = $f6b55a2021b78f0d$exports.locToIndex(bLoc, bRank, bStrides);
            const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
            resultRealVals[i1] = opResult.real;
            resultImagVals[i1] = opResult.imag;
        }
        return [
            resultRealVals,
            resultImagVals,
            resultShape
        ];
    };
}


const $cbaec80dd34f96bb$export$da57353b24bb5e2 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a + b
);
const $cbaec80dd34f96bb$export$ace1d0de36b43ba2 = $bed1816d9b4c970d$export$79261d982c3c14a7((aReal, aImag, bReal, bImag)=>{
    return {
        real: aReal + bReal,
        imag: aImag + bImag
    };
});
const $cbaec80dd34f96bb$export$e16d8520af44a096 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$d0265b2c425512d6, $cbaec80dd34f96bb$export$da57353b24bb5e2, $cbaec80dd34f96bb$export$ace1d0de36b43ba2);
const $cbaec80dd34f96bb$export$b1f3a580afb68e4c = {
    kernelName: $2b76be1e72a8c1db$export$d0265b2c425512d6,
    backendName: 'cpu',
    kernelFunc: $cbaec80dd34f96bb$export$e16d8520af44a096
};



function $169583b362c12f18$export$8e4da6ec633bf0a6(xVals, weightsVals, weightsDtype, weightsShape, size) {
    const weightsSize = $f6b55a2021b78f0d$exports.sizeFromShape(weightsShape);
    const outVals = $f6b55a2021b78f0d$exports.makeZerosTypedArray(size, weightsDtype);
    for(let i = 0; i < xVals.length; i++){
        const value = xVals[i];
        if (value < 0) throw new Error('Input x must be non-negative!');
        if (value >= size) continue;
        if (weightsSize > 0) outVals[value] += weightsVals[i];
        else outVals[value] += 1;
    }
    return outVals;
}
function $169583b362c12f18$export$486b8d48edd28ba5(xBuf, weightsBuf, size, binaryOutput = false) {
    const numRows = xBuf.shape[0];
    const numCols = xBuf.shape[1];
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        numRows,
        size
    ], weightsBuf.dtype);
    for(let i = 0; i < numRows; i++)for(let j = 0; j < numCols; j++){
        const value = xBuf.get(i, j);
        if (value < 0) throw new Error('Input x must be non-negative!');
        if (value >= size) continue;
        if (binaryOutput) outBuf.set(1, i, value);
        else if (weightsBuf.size > 0) outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);
        else outBuf.set(outBuf.get(i, value) + 1, i, value);
    }
    return outBuf;
}




function $62ce970e0d69b269$export$ef8b4452872ef3fc(op) {
    return (values, dtype, attrs)=>{
        const newValues = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(dtype, values.length);
        for(let i = 0; i < values.length; ++i)newValues[i] = op(values[i], attrs);
        return newValues;
    };
}




function $9b8349e3cbf56231$export$ba4daf5748026fba(name, op, dtype) {
    return ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { x: x  } = inputs;
        $2f54d733028161b9$export$1412c17b2531581a(x, name);
        if (x.dtype === 'string' || dtype === 'string') throw new Error('unaryKernelFunc does not support string input/output');
        const cpuBackend = backend;
        const values = cpuBackend.data.get(x.dataId).values;
        const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
        const $dtype = dtype || x.dtype;
        const newValues = $f6b55a2021b78f0d$exports.getArrayFromDType($dtype, xSize);
        for(let i = 0; i < xSize; ++i)newValues[i] = op(values[i], attrs);
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
}
function $9b8349e3cbf56231$export$34f6865a07ad09b6(name, unaryImpl, dtype) {
    return ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { x: x  } = inputs;
        $2f54d733028161b9$export$1412c17b2531581a(x, name);
        if (x.dtype === 'string' || dtype === 'string') throw new Error('unaryKernelFunc does not support string input/output');
        const cpuBackend = backend;
        const values = cpuBackend.data.get(x.dataId).values;
        const $dtype = dtype || x.dtype;
        const newValues = unaryImpl(values, $dtype, attrs);
        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
}


const $a100094c89dd6d5d$export$72486f20c97f6da8 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.ceil(xi)
);
const $a100094c89dd6d5d$export$803ce6b71a0a94b2 = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$d4a1bccfd52ebd3, $a100094c89dd6d5d$export$72486f20c97f6da8);
const $a100094c89dd6d5d$export$df387212b1898306 = {
    kernelName: $2b76be1e72a8c1db$export$d4a1bccfd52ebd3,
    backendName: 'cpu',
    kernelFunc: $a100094c89dd6d5d$export$803ce6b71a0a94b2
};



function $8c0fda6ef00eb49d$export$777da59f594f497d(inputs, outShape, dtype, simplyConcat) {
    const outVals = $f6b55a2021b78f0d$exports.getArrayFromDType(dtype, $f6b55a2021b78f0d$exports.sizeFromShape(outShape));
    if (simplyConcat && dtype !== 'string') {
        // Use built-in TypedArray.set() method for speed.
        let offset = 0;
        inputs.forEach((input)=>{
            const size = $f6b55a2021b78f0d$exports.sizeFromShape(input.shape);
            outVals.set(input.vals, offset);
            offset += size;
        });
    } else {
        let colOffset = 0;
        inputs.forEach((input)=>{
            const decodedData = dtype === 'string' ? $510a55f99d61727a$exports.fromUint8ToStringArray(input.vals) : input.vals;
            let tIdx = 0;
            for(let row = 0; row < input.shape[0]; ++row){
                const resIdx = row * outShape[1] + colOffset;
                for(let col = 0; col < input.shape[1]; ++col)outVals[resIdx + col] = decodedData[tIdx++];
            }
            colOffset += input.shape[1];
        });
    }
    return outVals;
}





const $114a5f7d44a64c41$export$437b1c87795f120c = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a === b ? 1 : 0
);
const $114a5f7d44a64c41$export$411ce8e5a71e3069 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$8dcf9f58ce5cdfc, $114a5f7d44a64c41$export$437b1c87795f120c, null, 'bool');
const $114a5f7d44a64c41$export$3c8bc3d8ee318217 = {
    kernelName: $2b76be1e72a8c1db$export$8dcf9f58ce5cdfc,
    backendName: 'cpu',
    kernelFunc: $114a5f7d44a64c41$export$411ce8e5a71e3069
};





const $4e30044b6b67a663$export$823000b70594f385 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.exp(xi)
);
const $4e30044b6b67a663$export$b310ec824aaee37f = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$f908be7a96fb3363, $4e30044b6b67a663$export$823000b70594f385, 'float32');
const $4e30044b6b67a663$export$2fd7ea0fcf021f34 = {
    kernelName: $2b76be1e72a8c1db$export$f908be7a96fb3363,
    backendName: 'cpu',
    kernelFunc: $4e30044b6b67a663$export$b310ec824aaee37f
};





const $dda94f97a8e1daf8$export$44f6c1b1ff8db911 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.expm1(xi)
);
const $dda94f97a8e1daf8$export$b6c0a80d46d3391d = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$261f26143a1ff3, $dda94f97a8e1daf8$export$44f6c1b1ff8db911);
const $dda94f97a8e1daf8$export$16db8a08b36f938 = {
    kernelName: $2b76be1e72a8c1db$export$261f26143a1ff3,
    backendName: 'cpu',
    kernelFunc: $dda94f97a8e1daf8$export$b6c0a80d46d3391d
};





const $5b144f27164f1f4e$export$c365361068e97c87 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.floor(xi)
);
const $5b144f27164f1f4e$export$a3fe094919f356fd = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$4880b0ae5643c62b, $5b144f27164f1f4e$export$c365361068e97c87);
const $5b144f27164f1f4e$export$7e9a0f96fa6bd01c = {
    kernelName: $2b76be1e72a8c1db$export$4880b0ae5643c62b,
    backendName: 'cpu',
    kernelFunc: $5b144f27164f1f4e$export$a3fe094919f356fd
};



function $b5f6308f114a9bb4$export$eed1912b07a3c4d5(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        numSlices,
        sliceSize
    ], dtype);
    for(let i = 0; i < numSlices; i++){
        const index = [];
        let flattenIndex = 0;
        for(let j = 0; j < sliceRank; j++){
            const dim = indicesData[i * sliceRank + j];
            flattenIndex += dim * strides[j];
            index.push(dim);
        }
        if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) throw new Error(`Invalid indices: ${index} does not index into ${paramsShape}`);
        for(let k = 0; k < sliceSize; k++)outBuf.values[i * sliceSize + k] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));
    }
    return outBuf;
}



function $8d57ce41c39b729c$export$d7b732f2e62ccc09(xBuf, indicesBuf, flattenOutputShape) {
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(flattenOutputShape, xBuf.dtype);
    for(let i = 0; i < outBuf.size; ++i){
        const newLoc = outBuf.indexToLoc(i);
        const originalLoc = newLoc.slice();
        const batchIdx = originalLoc[0];
        const indicesIdx = originalLoc[2];
        const indicesIndex = indicesBuf.locToIndex([
            batchIdx,
            indicesIdx
        ]);
        originalLoc[2] = indicesBuf.values[indicesIndex];
        const originalIndex = xBuf.locToIndex(originalLoc);
        if (0 <= originalIndex && originalIndex < xBuf.values.length) outBuf.values[i] = xBuf.values[originalIndex];
         // Else, index is out of bounds, so leave the default zero val in outBuf.
    }
    return outBuf;
}





const $92c0e9ae9f959176$export$bec57aa1d63b78bc = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a > b ? 1 : 0
);
const $92c0e9ae9f959176$export$9dca161faaf6308b = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$d0a25eac5ee3f515, $92c0e9ae9f959176$export$bec57aa1d63b78bc, null, 'bool');
const $92c0e9ae9f959176$export$8c4f7e92d92310f8 = {
    kernelName: $2b76be1e72a8c1db$export$d0a25eac5ee3f515,
    backendName: 'cpu',
    kernelFunc: $92c0e9ae9f959176$export$9dca161faaf6308b
};





const $a4bf2833f8178a9b$export$3cea60aeb61ae586 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a >= b ? 1 : 0
);
const $a4bf2833f8178a9b$export$c2fd4164cadc1fa2 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$3b7d21bc9aee0851, $a4bf2833f8178a9b$export$3cea60aeb61ae586, null, 'bool');
const $a4bf2833f8178a9b$export$7a6926f9fcac24ca = {
    kernelName: $2b76be1e72a8c1db$export$3b7d21bc9aee0851,
    backendName: 'cpu',
    kernelFunc: $a4bf2833f8178a9b$export$c2fd4164cadc1fa2
};





const $38fa0ec3880a2dc4$export$d4d22ddbe6cd91a5 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a < b ? 1 : 0
);
const $38fa0ec3880a2dc4$export$bb1a638da8ad190f = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$728c50f1c88ac779, $38fa0ec3880a2dc4$export$d4d22ddbe6cd91a5, null, 'bool');
const $38fa0ec3880a2dc4$export$8d4530ce8b6ffc3c = {
    kernelName: $2b76be1e72a8c1db$export$728c50f1c88ac779,
    backendName: 'cpu',
    kernelFunc: $38fa0ec3880a2dc4$export$bb1a638da8ad190f
};





const $c2830dac3543b869$export$27397851733876fa = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a <= b ? 1 : 0
);
const $c2830dac3543b869$export$c24ad19a692bb92 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$84afd0d8f7fb8c5d, $c2830dac3543b869$export$27397851733876fa, null, 'bool');
const $c2830dac3543b869$export$9f26bd257393dd8 = {
    kernelName: $2b76be1e72a8c1db$export$84afd0d8f7fb8c5d,
    backendName: 'cpu',
    kernelFunc: $c2830dac3543b869$export$c24ad19a692bb92
};



function $bb0c259378aaff95$export$31412d657cd1cc08(start, stop, num) {
    const step = (stop - start) / (num - 1);
    const values = $f6b55a2021b78f0d$exports.makeZerosTypedArray(num, 'float32');
    values[0] = start;
    for(let i = 1; i < values.length; i++)values[i] = values[i - 1] + step;
    return values;
}





const $d97da17f52ed975d$export$8a107ec4d5b0e907 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.log(xi)
);
const $d97da17f52ed975d$export$bef1f36f5486a6a3 = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$ce30dbb46644d06c, $d97da17f52ed975d$export$8a107ec4d5b0e907);
const $d97da17f52ed975d$export$a4ae1f00643ddd14 = {
    kernelName: $2b76be1e72a8c1db$export$ce30dbb46644d06c,
    backendName: 'cpu',
    kernelFunc: $d97da17f52ed975d$export$bef1f36f5486a6a3
};



function $290cb3a8bc723624$export$23c9b99bdac85be0(aVals, reduceSize, outShape, dtype) {
    const vals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(dtype, $f6b55a2021b78f0d$exports.sizeFromShape(outShape));
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let max = aVals[offset];
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            if (Number.isNaN(value) || value > max) max = value;
        }
        vals[i] = max;
    }
    return vals;
}





const $387d080214918c74$export$4e233ba825c9b60e = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>Math.max(aValue, bValue)
);
const $387d080214918c74$export$b25e0be55f42c9a = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$d8d02ac92d161004, $387d080214918c74$export$4e233ba825c9b60e);
const $387d080214918c74$export$45b97bdc342e72a2 = {
    kernelName: $2b76be1e72a8c1db$export$d8d02ac92d161004,
    backendName: 'cpu',
    kernelFunc: $387d080214918c74$export$b25e0be55f42c9a
};





const $5928be63ba34a1a4$export$756c08a3fa64d43 = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>Math.min(aValue, bValue)
);
const $5928be63ba34a1a4$export$916782c1f0ddb132 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$23cb308301e89d6b, $5928be63ba34a1a4$export$756c08a3fa64d43);
const $5928be63ba34a1a4$export$ea24ffbbbce8d546 = {
    kernelName: $2b76be1e72a8c1db$export$23cb308301e89d6b,
    backendName: 'cpu',
    kernelFunc: $5928be63ba34a1a4$export$916782c1f0ddb132
};





const $84b5dd89fe629858$export$ac59ae2be94ddda3 = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>aValue * bValue
);
const $84b5dd89fe629858$export$93ff634b9c7cb5b9 = $bed1816d9b4c970d$export$79261d982c3c14a7((aReal, aImag, bReal, bImag)=>{
    return {
        real: aReal * bReal - aImag * bImag,
        imag: aReal * bImag + aImag * bReal
    };
});
const $84b5dd89fe629858$export$2060d2db72cce88f = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$f14f83b3b531d498, $84b5dd89fe629858$export$ac59ae2be94ddda3, $84b5dd89fe629858$export$93ff634b9c7cb5b9);
const $84b5dd89fe629858$export$745576778aafee88 = {
    kernelName: $2b76be1e72a8c1db$export$f14f83b3b531d498,
    backendName: 'cpu',
    kernelFunc: $84b5dd89fe629858$export$2060d2db72cce88f
};





function $c4c77c008a62d83d$export$e9053236ce0e659b(xVals, xShape, xDtype) {
    const minusOne = $f6b55a2021b78f0d$exports.createScalarValue(-1, xDtype);
    return $84b5dd89fe629858$export$ac59ae2be94ddda3([], xShape, minusOne, xVals, xDtype);
}
function $c4c77c008a62d83d$export$d9493ff0dfa0fdd5(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'neg');
    const xVals = backend.data.get(x.dataId).values;
    const [res, newShape] = $c4c77c008a62d83d$export$e9053236ce0e659b(xVals, x.shape, x.dtype);
    return backend.makeTensorInfo(newShape, x.dtype, res);
}
const $c4c77c008a62d83d$export$cc7b18b8229c3db = {
    kernelName: $2b76be1e72a8c1db$export$c07c549000872073,
    backendName: 'cpu',
    kernelFunc: $c4c77c008a62d83d$export$d9493ff0dfa0fdd5
};





const $b96c4ec4fa331740$export$eaea354630818ed4 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a !== b ? 1 : 0
);
const $b96c4ec4fa331740$export$53a6892c50694894 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$385ebe9945cae0c5, $b96c4ec4fa331740$export$eaea354630818ed4, null, 'bool');
const $b96c4ec4fa331740$export$d003d4d7e1500775 = {
    kernelName: $2b76be1e72a8c1db$export$385ebe9945cae0c5,
    backendName: 'cpu',
    kernelFunc: $b96c4ec4fa331740$export$53a6892c50694894
};







function $81b92e00647b9a32$export$986b9e65182e08d(xVals, xShape, dtype, perm, newShape) {
    const xRank = xShape.length;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(xShape);
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(xShape);
    const newStrides = $f6b55a2021b78f0d$exports.computeStrides(newShape);
    const result = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(dtype, $f6b55a2021b78f0d$exports.sizeFromShape(newShape));
    for(let i = 0; i < xSize; ++i){
        const loc = $f6b55a2021b78f0d$exports.indexToLoc(i, xRank, xStrides);
        // Permute location.
        const newLoc = new Array(loc.length);
        for(let i1 = 0; i1 < newLoc.length; i1++)newLoc[i1] = loc[perm[i1]];
        const newIndex = $f6b55a2021b78f0d$exports.locToIndex(newLoc, xRank, newStrides);
        result[newIndex] = xVals[i];
    }
    return result;
}


function $a2ad71a3b184be14$export$9cb09a71b7d66923(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x  } = inputs;
    const { perm: perm  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'transpose');
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for(let i = 0; i < newShape.length; i++)newShape[i] = x.shape[perm[i]];
    const values = backend.data.get(x.dataId).values;
    const result = $81b92e00647b9a32$export$986b9e65182e08d(values, x.shape, x.dtype, perm, newShape);
    const dataId = backend.write(result, newShape, x.dtype);
    return {
        dataId: dataId,
        shape: newShape,
        dtype: x.dtype
    };
}
const $a2ad71a3b184be14$export$895a002a39b774be = {
    kernelName: $2b76be1e72a8c1db$export$7e714455f9a1f8f7,
    backendName: 'cpu',
    kernelFunc: $a2ad71a3b184be14$export$9cb09a71b7d66923
};


function $a511c99458739875$export$a3c8a5271f6bb700(xShape, xDtype, xVals, reductionAxes) {
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(xShape, reductionAxes);
    const outDtype = $993b52a5dd76e458$export$7bcca02d1a156bdf(xDtype, 'int32');
    const outVals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(outShape), outDtype);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    for(let i = 0; i < outVals.length; ++i){
        const offset = i * reduceSize;
        let $a511c99458739875$export$5e143010dea16c85 = 1;
        for(let j = 0; j < reduceSize; ++j)$a511c99458739875$export$5e143010dea16c85 *= xVals[offset + j];
        outVals[i] = $a511c99458739875$export$5e143010dea16c85;
    }
    return {
        outVals: outVals,
        outShape: outShape,
        outDtype: outDtype
    };
}
function $a511c99458739875$export$5e143010dea16c85(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'prod');
    const xRank = x.shape.length;
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const permutation = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let reductionAxes = axes;
    let permutedX = x;
    const intermediateTensorInfos = [];
    if (permutation != null) {
        permutedX = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutation
            }
        });
        intermediateTensorInfos.push(permutedX);
        reductionAxes = $510a55f99d61727a$exports.getInnerMostAxes(reductionAxes.length, xRank);
    }
    const xVals = backend.data.get(permutedX.dataId).values;
    const { outVals: outVals , outShape: outShape , outDtype: outDtype  } = $a511c99458739875$export$a3c8a5271f6bb700(permutedX.shape, permutedX.dtype, xVals, reductionAxes);
    let resultShape = outShape;
    if (keepDims) resultShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, axes);
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return backend.makeTensorInfo(resultShape, outDtype, outVals);
}
const $a511c99458739875$export$d556aa935cef5c0c = {
    kernelName: $2b76be1e72a8c1db$export$b8a16d526a791fb0,
    backendName: 'cpu',
    kernelFunc: $a511c99458739875$export$5e143010dea16c85
};



function $1752da38d99a9db0$export$3561205b7dff20bf(start, stop, step, dtype) {
    const sameStartStop = start === stop;
    const increasingRangeNegativeStep = start < stop && step < 0;
    const decreasingRangePositiveStep = stop < start && step > 1;
    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) return $f6b55a2021b78f0d$exports.makeZerosTypedArray(0, dtype);
    const numElements = Math.abs(Math.ceil((stop - start) / step));
    const values = $f6b55a2021b78f0d$exports.makeZerosTypedArray(numElements, dtype);
    if (stop < start && step === 1) // Auto adjust the step's sign if it hasn't been set
    // (or was set to 1)
    step = -1;
    values[0] = start;
    for(let i = 1; i < values.length; i++)values[i] = values[i - 1] + step;
    return values;
}





const $e4ff695093678829$export$7ec24de9bffc6b90 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>1 / Math.sqrt(xi)
);
const $e4ff695093678829$export$1cc01d192953037e = $9b8349e3cbf56231$export$34f6865a07ad09b6($2b76be1e72a8c1db$export$7cc53aa09f5f3a2d, $e4ff695093678829$export$7ec24de9bffc6b90);
const $e4ff695093678829$export$941104b789956ef6 = {
    kernelName: $2b76be1e72a8c1db$export$7cc53aa09f5f3a2d,
    backendName: 'cpu',
    kernelFunc: $e4ff695093678829$export$1cc01d192953037e
};





const $f57eef2a9f713d28$export$e31bae35ce8238b3 = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>1 / (1 + Math.exp(-xi))
);
const $f57eef2a9f713d28$export$3b295495ca3cad7c = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$fde18c826dda6b1b, (xi)=>1 / (1 + Math.exp(-xi))
);
const $f57eef2a9f713d28$export$195d1cf7c59f3ef = {
    kernelName: $2b76be1e72a8c1db$export$fde18c826dda6b1b,
    backendName: 'cpu',
    kernelFunc: $f57eef2a9f713d28$export$3b295495ca3cad7c
};




function $3f463099ff6ccc0b$export$4bdf1ac3fa5d3d6a(vals, begin, size, shape, dtype) {
    const isContinous = $1a8ddf4b5d32c90c$exports.isSliceContinous(shape, begin, size);
    const length = $f6b55a2021b78f0d$exports.sizeFromShape(size);
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(shape);
    if (isContinous) {
        const flatOffset = $1a8ddf4b5d32c90c$exports.computeFlatOffset(begin, xStrides);
        if (dtype === 'string') return vals.slice(flatOffset, flatOffset + length);
        return vals.subarray(flatOffset, flatOffset + length);
    }
    const decodedData = dtype === 'string' ? $510a55f99d61727a$exports.fromUint8ToStringArray(vals) : vals;
    const inBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(shape, dtype, decodedData);
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(size, dtype);
    for(let i = 0; i < outBuf.size; ++i){
        const outLoc = outBuf.indexToLoc(i);
        const inLoc = outLoc.map((idx, j)=>idx + begin[j]
        );
        outBuf.set(inBuf.get(...inLoc), ...outLoc);
    }
    if (dtype === 'string') return $510a55f99d61727a$exports.fromStringArrayToUint8(outBuf.values);
    return outBuf.values;
}
function $3f463099ff6ccc0b$export$58adb3bec8346d0f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { begin: begin , size: size  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'slice');
    const [$begin, $size] = $1a8ddf4b5d32c90c$exports.parseSliceParams(x, begin, size);
    $1a8ddf4b5d32c90c$exports.assertParamsValid(x, $begin, $size);
    const vals = backend.data.get(x.dataId).values;
    const outVals = $3f463099ff6ccc0b$export$4bdf1ac3fa5d3d6a(vals, $begin, $size, x.shape, x.dtype);
    return backend.makeTensorInfo($size, x.dtype, outVals);
}
const $3f463099ff6ccc0b$export$8d8a1e11dd2cc6c4 = {
    kernelName: $2b76be1e72a8c1db$export$b3f2e2de3a8baa1e,
    backendName: 'cpu',
    kernelFunc: $3f463099ff6ccc0b$export$58adb3bec8346d0f
};



function $a1ecb873653da6fc$export$9db01208a1bec190(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
    const indicesCount = indicesShape[0];
    const denseRows = denseShape[0];
    const emptyRowIndicator = new Array(denseRows);
    const reverseIndexMap = new Array(indicesCount);
    const rank = indicesShape[1];
    if (denseRows === 0) {
        if (indicesCount !== 0) throw new Error($510a55f99d61727a$exports.getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesCount));
        const outputIndices = $f6b55a2021b78f0d$exports.getArrayFromDType(indicesDType, 0);
        const outputValues = $f6b55a2021b78f0d$exports.getArrayFromDType(valuesDType, 0);
        return [
            outputIndices,
            [
                0,
                rank
            ],
            outputValues,
            emptyRowIndicator,
            reverseIndexMap
        ];
    }
    let rowsAreOrdered = true;
    let lastIndicesRow = 0;
    const csrOffset = new Array(denseRows).fill(0);
    for(let i = 0; i < indicesCount; ++i){
        // indices is a 2d tensor with shape of [N, rank]
        const row = indices[i * rank];
        if (row < 0) throw new Error($510a55f99d61727a$exports.getSparseFillEmptyRowsNegativeIndexErrorMessage(i, row));
        if (row >= denseRows) throw new Error($510a55f99d61727a$exports.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i, row, denseRows));
        ++csrOffset[row];
        rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
        lastIndicesRow = row;
    }
    let allRowsFull = true;
    for(let row = 0; row < denseRows; ++row){
        // csrOffset here describes the number of elements in this dense row
        const rowEmpty = csrOffset[row] === 0;
        emptyRowIndicator[row] = rowEmpty;
        allRowsFull = allRowsFull && !rowEmpty;
        // In filled version, each row has at least one element.
        csrOffset[row] = Math.max(csrOffset[row], 1);
        // Update csrOffset to represent the number of elements up to and
        // including denseRows + 1:
        //  csrOffset[0] == #{elements of row 0}
        //  csrOffset[1] == #{elements of row 1} + #{elements of row 0}
        //  ..
        //  csrOffset[i] == starting index for elements in row i + 1.
        if (row > 0) csrOffset[row] += csrOffset[row - 1];
    }
    if (allRowsFull && rowsAreOrdered) {
        const outputIndices = indices;
        const outputValues = values;
        for(let i = 0; i < indicesCount; ++i)reverseIndexMap[i] = i;
        return [
            outputIndices,
            [
                indicesCount,
                rank
            ],
            outputValues,
            emptyRowIndicator,
            reverseIndexMap
        ];
    } else {
        const fullIndicesCount = csrOffset[denseRows - 1];
        const outputIndices = $f6b55a2021b78f0d$exports.getArrayFromDType(indicesDType, fullIndicesCount * rank);
        const outputValues = $f6b55a2021b78f0d$exports.getArrayFromDType(valuesDType, fullIndicesCount);
        const filledCount = new Array(denseRows).fill(0);
        // Fill in values for rows that are not missing
        for(let i = 0; i < indicesCount; ++i){
            // indices is a 2d tensor with shape of [N, rank]
            const row = indices[i * rank];
            const offset = filledCount[row];
            const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
            filledCount[row]++; // Increment the filled count for this row.
            for(let j = 0; j < rank; ++j)// indices and outputIndices are 2d tensors with shape of [N, rank]
            outputIndices[outputI * rank + j] = indices[i * rank + j];
            outputValues[outputI] = values[i];
            // We'll need this reverse index map to backprop correctly.
            reverseIndexMap[i] = outputI;
        }
        // Fill in values for rows that are missing
        for(let row = 0; row < denseRows; ++row){
            const rowCount = filledCount[row];
            if (rowCount === 0) {
                const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
                // Remaining index values were set to zero already.
                // Just need to set the row index in the right location.
                // outputIndices is a 2d tensor with shape of [N, rank]
                outputIndices[startingIndex * rank + 0] = row;
                for(let col = 1; col < rank; ++col)outputIndices[startingIndex * rank + col] = 0;
                outputValues[startingIndex] = defaultValue;
            }
        }
        return [
            outputIndices,
            [
                fullIndicesCount,
                rank
            ],
            outputValues,
            emptyRowIndicator,
            reverseIndexMap
        ];
    }
}



function $576be96eb9be5e86$export$a65a15ebab81f5cd(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
    const denseSize = $f6b55a2021b78f0d$exports.sizeFromShape(inputShape);
    const nnz = inputIndicesShape[0];
    const outputRank = targetShape.length;
    // Compute the output shape. Determine product of specified dimensions, and
    // find the index of the unspecified one.
    const outputShape = [];
    let product = 1;
    let unknownIndex = -1;
    for(let d = 0; d < outputRank; ++d){
        const size = targetShape[d];
        if (size === -1) {
            if (unknownIndex !== -1) throw new Error($510a55f99d61727a$exports.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d));
            unknownIndex = d;
            outputShape.push(1);
        } else {
            if (size < 0) throw new Error($510a55f99d61727a$exports.getSparseReshapeNegativeOutputDimErrorMessage(d, size));
            product *= size;
            outputShape.push(size);
        }
    }
    if (unknownIndex !== -1) {
        if (product <= 0) throw new Error($510a55f99d61727a$exports.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
        const missing = Math.trunc(denseSize / product);
        if (product * missing !== denseSize) throw new Error($510a55f99d61727a$exports.getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));
        outputShape[unknownIndex] = missing;
    }
    const outputSize = $f6b55a2021b78f0d$exports.sizeFromShape(outputShape);
    if (outputSize !== denseSize) throw new Error($510a55f99d61727a$exports.getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));
    const inputRank = inputShape.length;
    const inputStrides = [];
    if (inputRank > 0) {
        inputStrides[inputRank - 1] = 1;
        for(let d = inputRank - 2; d >= 0; --d)inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];
    }
    const outputStrides = [];
    if (outputRank > 0) {
        outputStrides[outputRank - 1] = 1;
        for(let d = outputRank - 2; d >= 0; --d)outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];
    }
    const newIndices = $f6b55a2021b78f0d$exports.getArrayFromDType(inputDType, nnz * outputRank);
    for(let i = 0; i < nnz; ++i){
        let id = 0;
        for(let j = 0; j < inputRank; ++j)// inputIndices is a 2d tensor with shape of [nnz, inputRank]
        id += inputIndices[i * inputRank + j] * inputStrides[j];
        for(let j1 = 0; j1 < outputRank; ++j1){
            // newIndices is a 2d tensor with shape of [nnz, outputRank]
            newIndices[i * outputRank + j1] = Math.trunc(id / outputStrides[j1]);
            id %= outputStrides[j1];
        }
    }
    return [
        newIndices,
        [
            nnz,
            outputRank
        ],
        outputShape
    ];
}



function $22121e811d80d726$export$7d3f7130c4245e65(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
    const numIndices = indices.length;
    // Flatten the array to two dimensions
    const inputFlat = [
        inputShape[0],
        input.length / inputShape[0]
    ];
    const numCol = inputFlat[1];
    // Note that the current implementation assumes that segmentIds values are
    // sorted.
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    const outputShape = inputShape.slice();
    outputShape[0] = outputRows;
    const outputLength = outputShape.reduce((product, value)=>product * value
    , 1);
    // Output array is initialized with the value 0 by default.
    const output = $f6b55a2021b78f0d$exports.getArrayFromDType(inputDType, outputLength);
    // Note that we do not initialize the output buffer with a default value, so
    // we need to explicitly set missing indices to the default value.
    if (numIndices === 0) {
        if (outputRows > 0) output.fill(defaultValue);
        return [
            output,
            outputShape
        ];
    }
    if (outputRows <= 0) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let start = 0, end = 1;
    // Index from which the output is not initialized.
    let uninitializedIndex = 0;
    let outIndex = segmentIds[start];
    while(true){
        // We initialize nextIndex to 0 to avoid may be uninitialized warning
        let nextIndex = 0;
        if (end < numIndices) {
            nextIndex = segmentIds[end];
            if (outIndex === nextIndex) {
                ++end;
                continue;
            }
            // We have a new segment here.  Verify that the segment ids are growing.
            if (outIndex >= nextIndex) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
        }
        if (outIndex < 0 || outIndex >= outputRows) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));
        // If there is a gap between two indices, we need to set that gap to the
        // default value.
        if (outIndex > uninitializedIndex) output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
        for(let i = start; i < end; ++i){
            const index = indices[i];
            if (index < 0 || index >= inputFlat[0]) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));
            for(let j = 0; j < numCol; j++)output[outIndex * numCol + j] += input[index * numCol + j];
        }
        if (isMean) for(let j = 0; j < numCol; j++)output[outIndex * numCol + j] /= end - start;
        start = end;
        ++end;
        uninitializedIndex = outIndex + 1;
        outIndex = nextIndex;
        if (end > numIndices) break;
    }
    // Fill the gap at the end with the default value.
    if (uninitializedIndex < outputRows) output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
    return [
        output,
        outputShape
    ];
}





const $1bdf881481671c57$export$c6f4fdf945028fb = $62ce970e0d69b269$export$ef8b4452872ef3fc((xi)=>Math.sqrt(xi)
);
const $1bdf881481671c57$export$eba8049fb5020b81 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$21ab404ab9d512a6, (xi)=>Math.sqrt(xi)
);
const $1bdf881481671c57$export$a592ba9268f10eeb = {
    kernelName: $2b76be1e72a8c1db$export$21ab404ab9d512a6,
    backendName: 'cpu',
    kernelFunc: $1bdf881481671c57$export$eba8049fb5020b81
};





const $bf9ce837076b486f$export$11806d7b3158c032 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>{
    const diff = a - b;
    return diff * diff;
});
const $bf9ce837076b486f$export$b178697fb6d0b37f = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$2f922d20d66089c6, $bf9ce837076b486f$export$11806d7b3158c032);
const $bf9ce837076b486f$export$9ed4691d69db8a43 = {
    kernelName: $2b76be1e72a8c1db$export$2f922d20d66089c6,
    backendName: 'cpu',
    kernelFunc: $bf9ce837076b486f$export$b178697fb6d0b37f
};



function $a2de56570dbafe39$export$b7c450ffe7e10d88(outShape, xBuf, strides, begin) {
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(outShape, xBuf.dtype);
    for(let i = 0; i < outBuf.size; i++){
        const loc = outBuf.indexToLoc(i);
        const newLoc = new Array(loc.length);
        for(let j = 0; j < newLoc.length; j++)newLoc[j] = loc[j] * strides[j] + begin[j];
        outBuf.set(xBuf.get(...newLoc), ...loc);
    }
    return outBuf;
}



/**
 * The StringNGramsOp class creates ngrams from ragged string data.
 * The constructor contains all attributes related to the operation such as
 * padding widths and strings, and the compute function can be used to
 * compute the ngrams for different ragged tensor inputs.
 */ class $e61066bf26e590dd$var$StringNGramsOp {
    constructor(separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences){
        this.separator = $f6b55a2021b78f0d$exports.encodeString(separator);
        this.nGramWidths = nGramWidths;
        this.leftPad = $f6b55a2021b78f0d$exports.encodeString(leftPad);
        this.rightPad = $f6b55a2021b78f0d$exports.encodeString(rightPad);
        this.padWidth = padWidth;
        this.preserveShort = preserveShortSequences;
    }
    getPadWidth(nGramWidth) {
        // Ngrams can be padded with either a fixed pad width or a dynamic pad
        // width depending on the 'padWidth' arg, but in no case should the padding
        // ever be wider than 'nGramWidth' - 1.
        return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
    }
    getNumNGrams(length, nGramWidth) {
        const padWidth = this.getPadWidth(nGramWidth);
        return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
    }
    createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
        for(let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex){
            const padWidth = this.getPadWidth(nGramWidth);
            const leftPadding = Math.max(0, padWidth - nGramIndex);
            const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
            const numTokens = nGramWidth - (leftPadding + rightPadding);
            const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
            // Calculate the total expected size of the nGram so we can reserve the
            // correct amount of space in the string.
            let nGramSize = 0;
            // Size of the left padding.
            nGramSize += leftPadding * this.leftPad.length;
            // Size of the tokens.
            for(let n = 0; n < numTokens; ++n)nGramSize += data[dataStartIndex + n].length;
            // Size of the right padding.
            nGramSize += rightPadding * this.rightPad.length;
            // Size of the separators.
            const numSeparators = leftPadding + rightPadding + numTokens - 1;
            nGramSize += numSeparators * this.separator.length;
            // Build the nGram.
            output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
            const nGram = output[outputStartIndex + nGramIndex];
            let nextNGramIndex = 0;
            const appendToNGram = (str)=>str.forEach((value)=>nGram[nextNGramIndex++] = value
                )
            ;
            for(let n1 = 0; n1 < leftPadding; ++n1){
                appendToNGram(this.leftPad);
                appendToNGram(this.separator);
            }
            // Only output first numTokens - 1 pairs of data and separator
            for(let n2 = 0; n2 < numTokens - 1; ++n2){
                appendToNGram(data[dataStartIndex + n2]);
                appendToNGram(this.separator);
            }
            // Handle case when there are no tokens or no right padding as these
            // can result in consecutive separators.
            if (numTokens > 0) {
                // If we have tokens, then output last and then pair each separator
                // with the right padding that follows, to ensure nGram ends either with
                // the token or with the right pad.
                appendToNGram(data[dataStartIndex + numTokens - 1]);
                for(let n = 0; n < rightPadding; ++n){
                    appendToNGram(this.separator);
                    appendToNGram(this.rightPad);
                }
            } else {
                // If we don't have tokens, then the last item inserted into the nGram
                // has been the separator from the left padding loop above. Hence,
                // output right pad and separator and make sure to finish with a
                // padding, not a separator.
                for(let n = 0; n < rightPadding - 1; ++n){
                    appendToNGram(this.rightPad);
                    appendToNGram(this.separator);
                }
                appendToNGram(this.rightPad);
            }
        }
    }
    // Data and splits together form the definition of the ragged tensor,
    // where data is 1 dimensional and contains the values of the tensor
    // and splits denotes the indices at which each row starts.
    compute(data, splits) {
        // Validate that the splits are valid indices into data, only if there are
        // splits specified.
        const inputDataSize = data.length;
        const splitsSize = splits.length;
        if (splitsSize > 0) {
            let prevSplit = splits[0];
            if (prevSplit !== 0) throw new Error(`First split value must be 0, got ${prevSplit}`);
            for(let i = 1; i < splitsSize; ++i){
                let validSplits = splits[i] >= prevSplit;
                validSplits = validSplits && splits[i] <= inputDataSize;
                if (!validSplits) throw new Error(`Invalid split value ${splits[i]}, must be in [${prevSplit}, ${inputDataSize}]`);
                prevSplit = splits[i];
            }
            if (prevSplit !== inputDataSize) throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
        }
        const numBatchItems = splitsSize - 1;
        const nGramsSplits = $f6b55a2021b78f0d$exports.getArrayFromDType('int32', splitsSize);
        // If there is no data or size, return an empty ragged tensor.
        if (inputDataSize === 0 || splitsSize === 0) {
            const empty = new Array(inputDataSize);
            for(let i = 0; i <= numBatchItems; ++i)nGramsSplits[i] = 0;
            return [
                empty,
                nGramsSplits
            ];
        }
        nGramsSplits[0] = 0;
        for(let i = 1; i <= numBatchItems; ++i){
            const length = splits[i] - splits[i - 1];
            let numNGrams = 0;
            this.nGramWidths.forEach((nGramWidth)=>{
                numNGrams += this.getNumNGrams(length, nGramWidth);
            });
            if (this.preserveShort && length > 0 && numNGrams === 0) numNGrams = 1;
            nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;
        }
        const nGrams = new Array(nGramsSplits[numBatchItems]);
        for(let i1 = 0; i1 < numBatchItems; ++i1){
            const splitIndex = splits[i1];
            let outputStartIdx = nGramsSplits[i1];
            this.nGramWidths.forEach((nGramWidth)=>{
                const length = splits[i1 + 1] - splits[i1];
                const numNGrams = this.getNumNGrams(length, nGramWidth);
                this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
                outputStartIdx += numNGrams;
            });
            // If we're preserving short sequences, check to see if no sequence was
            // generated by comparing the current output start idx to the original
            // one (nGramSplitsdata). If no ngrams were generated, then they will
            // be equal (since we increment outputStartIdx by numNGrams every
            // time we create a set of ngrams.)
            if (this.preserveShort && outputStartIdx === nGramsSplits[i1]) {
                const dataLength = splits[i1 + 1] - splits[i1];
                // One legitimate reason to not have any ngrams when this.preserveShort
                // is true is if the sequence itself is empty. In that case, move on.
                if (dataLength === 0) continue;
                // We don't have to worry about dynamic padding sizes here: if padding
                // was dynamic, every sequence would have had sufficient padding to
                // generate at least one nGram.
                const nGramWidth = dataLength + 2 * this.padWidth;
                const numNGrams = 1;
                this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
            }
        }
        return [
            nGrams,
            nGramsSplits
        ];
    }
}
function $e61066bf26e590dd$export$67c0958e8184138b(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {
    return new $e61066bf26e590dd$var$StringNGramsOp(separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences).compute(data, dataSplits);
}



function $ec69ed0754ce0772$var$split(str, delimiters, skipEmpty, result) {
    if (!str.length) return;
    // When the delimiter is empty, the input is split into individual characters.
    if (delimiters.length === 0) {
        for(let i = 0; i < str.length; ++i)result.push(str.subarray(i, i + 1));
        return;
    }
    // When there is one delimiter, the input is split only at that delimiter.
    if (delimiters.length === 1) {
        const delimiter = delimiters[0];
        let f = str.indexOf(delimiter);
        while(f !== -1){
            const token = str.subarray(0, f);
            if (!skipEmpty || token.length !== 0) result.push(token);
            str = str.subarray(f + 1);
            f = str.indexOf(delimiter);
        }
        if (!skipEmpty || str.length !== 0) result.push(str);
        return;
    }
    // When there are multiple delimiters, the input is split at every instance
    // one of the delimiters appears.
    let tokenStart = 0;
    for(let i = 0; i < str.length + 1; i++)if (i === str.length || delimiters.indexOf(str[i]) !== -1) {
        const token = str.subarray(tokenStart, i);
        if (!skipEmpty || token.length !== 0) result.push(token);
        tokenStart = i + 1;
    }
}
function $ec69ed0754ce0772$export$c3b08e43aa36d65d(input, delimiter, skipEmpty) {
    const batchSize = input.length;
    // Empty delimiter means split the input character by character.
    const tokens = [];
    let outputSize = 0;
    let maxNumEntries = 0;
    const numIndices = new Array(batchSize);
    for(let i = 0; i < batchSize; ++i){
        const prevTokensLength = tokens.length;
        $ec69ed0754ce0772$var$split(input[i], delimiter, skipEmpty, tokens);
        const nEntries = tokens.length - prevTokensLength;
        numIndices[i] = nEntries;
        outputSize += nEntries;
        maxNumEntries = Math.max(maxNumEntries, nEntries);
    }
    const indices = $f6b55a2021b78f0d$exports.getArrayFromDType('int32', outputSize * 2);
    const values = new Array(outputSize);
    const shape = [
        batchSize,
        maxNumEntries
    ];
    let c = 0;
    for(let i1 = 0; i1 < batchSize; ++i1)for(let j = 0; j < numIndices[i1]; ++j){
        // indices is a 2d tensor with shape of [outputSize, 2]
        indices[c * 2] = i1;
        indices[c * 2 + 1] = j;
        values[c] = tokens[c];
        ++c;
    }
    return [
        indices,
        values,
        shape
    ];
}



function $3e3cb1423d6599f6$export$37cbed4d0b2fe56a(input, numBuckets) {
    const output = $f6b55a2021b78f0d$exports.getArrayFromDType('int32', input.length);
    for(let i = 0; i < input.length; ++i)output[i] = $f6b55a2021b78f0d$exports.fingerPrint64(input[i]).modulo(numBuckets).getLowBitsUnsigned();
    return output;
}





const $1fbda794b513f6c9$export$ad8defe68e22c8c1 = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>aValue - bValue
);
const $1fbda794b513f6c9$export$e56bd24b892e7ec5 = $bed1816d9b4c970d$export$79261d982c3c14a7((aReal, aImag, bReal, bImag)=>{
    return {
        real: aReal - bReal,
        imag: aImag - bImag
    };
});
const $1fbda794b513f6c9$export$f93b5905241a7cca = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$d7a01e11500dfb6f, $1fbda794b513f6c9$export$ad8defe68e22c8c1, $1fbda794b513f6c9$export$e56bd24b892e7ec5);
const $1fbda794b513f6c9$export$5d068476dad60c4d = {
    kernelName: $2b76be1e72a8c1db$export$d7a01e11500dfb6f,
    backendName: 'cpu',
    kernelFunc: $1fbda794b513f6c9$export$f93b5905241a7cca
};



function $f61428d0206617c9$export$f3e554b937559516(xBuf, reps) {
    const newShape = new Array(xBuf.rank);
    for(let i = 0; i < newShape.length; i++)newShape[i] = xBuf.shape[i] * reps[i];
    const result = $034bc04874ecb003$export$ab1029bcae9ddb4a(newShape, xBuf.dtype);
    for(let i1 = 0; i1 < result.values.length; ++i1){
        const newLoc = result.indexToLoc(i1);
        const originalLoc = new Array(xBuf.rank);
        for(let j = 0; j < originalLoc.length; j++)originalLoc[j] = newLoc[j] % xBuf.shape[j];
        const originalIndex = xBuf.locToIndex(originalLoc);
        result.values[i1] = xBuf.values[originalIndex];
    }
    return result;
}



const $3334846189799256$var$comparePair = (a, b)=>{
    const valueDiff = b.value - a.value;
    return valueDiff === 0 ? a.index - b.index : valueDiff;
};
/**
 * Partitions array where all elements smaller than the (k+1) smallest element
 * are found to the left of it, and all larger to the right of it.
 * Based on the Floyd-Rivest Algorithm, ref:
 * https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm
 * @param array: Array to partition
 * @param left: Left index for the interval
 * @param right: Right index for the interval
 * @param k: Desired index value, where array[k] is the (k+1)th smallest element
 *           when left = 0
 */ function $3334846189799256$var$select(array, k, left = 0, right = array.length - 1) {
    while(right > left){
        // Use select recursively to sample a smaller set of size s
        // the arbitrary constants 600 and 0.5 are used in the original
        // version to minimize execution time.
        if (right - left > 600) {
            const n = right - left + 1;
            const i = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * Math.sign(i - n / 2);
            const newLeft = Math.max(left, Math.floor(k - i * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));
            $3334846189799256$var$select(array, k, newLeft, newRight);
        }
        // partition the elements between left and right around t
        const t = array[k];
        let i = left;
        let j = right;
        $f6b55a2021b78f0d$exports.swap(array, left, k);
        if ($3334846189799256$var$comparePair(array[right], t) > 0) $f6b55a2021b78f0d$exports.swap(array, left, right);
        while(i < j){
            $f6b55a2021b78f0d$exports.swap(array, i, j);
            i++;
            j--;
            while($3334846189799256$var$comparePair(array[i], t) < 0)i = i + 1;
            while($3334846189799256$var$comparePair(array[j], t) > 0)j = j - 1;
        }
        if ($3334846189799256$var$comparePair(array[left], t) === 0) $f6b55a2021b78f0d$exports.swap(array, left, j);
        else {
            j = j + 1;
            $f6b55a2021b78f0d$exports.swap(array, j, right);
        }
        // Adjust left and right towards the boundaries of the subset
        // containing the (k - left + 1)th smallest element.
        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}
function $3334846189799256$export$b083239978762299(x, xShape, xDtype, k, sorted) {
    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.
    const lastDim = xShape[xShape.length - 1];
    const [batch, size] = [
        x.length / lastDim,
        lastDim
    ];
    const allTopKVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(xDtype, batch * k);
    const allTopKIndices = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('int32', batch * k);
    for(let b = 0; b < batch; b++){
        const offset = b * size;
        const vals = x.subarray(offset, offset + size);
        let valAndInd = new Array(vals.length);
        vals.forEach((value, index)=>valAndInd[index] = {
                value: value,
                index: index
            }
        );
        if (k < valAndInd.length) {
            $3334846189799256$var$select(valAndInd, k);
            valAndInd = valAndInd.slice(0, k);
        }
        if (sorted) valAndInd.sort($3334846189799256$var$comparePair);
        const outOffset = b * k;
        const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
        const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
        for(let i = 0; i < k; i++){
            topKVals[i] = valAndInd[i].value;
            topKIndices[i] = valAndInd[i].index;
        }
    }
    // Reshape back to the original input shape, except that the last
    // dimension is k.
    const outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k;
    return [
        $034bc04874ecb003$export$ab1029bcae9ddb4a(outputShape, xDtype, allTopKVals),
        $034bc04874ecb003$export$ab1029bcae9ddb4a(outputShape, 'int32', allTopKIndices)
    ];
}




function $0f857a49f2c266d0$export$58be9cc013c994e(values, axis, shape, dtype) {
    // Normalize and validate axis.
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, shape)[0];
    // Calculate the new shape that is suitable for extracting data along the
    // given axis.
    //
    // The rank is 3.
    // The size of the 1st dimension is the size of all the axes < the given axis.
    // The size of the 2nd dimension is the same as the size of the given axis.
    // The size of the 3rd dimension is the size of all the axes > the given axis.
    //
    // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the
    // newShape would be: [2*3, 5, 4].
    //
    // Note that this is not the final output shape. This will be the shape for an
    // intermediate TensorBuffer (see inputBuffer below) to allow us to extract
    // values along the given axis. To demonstrate how it works, consider the
    // following example:
    //
    // Input: a 3D tensor, with shape [1, 2, 3]
    // [
    //   [
    //      [1,2,3],
    //      [4,5,6]
    //   ]
    // ]
    // Axis: 2 (the last axis).
    // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].
    //
    // For this example, newShape would be: [2, 3, 1], where 2 is calculated from
    // 1*2. The re-shaped data would look like:
    //
    // [
    //   [
    //     [1], [2], [3]
    //   ],
    //   [
    //     [4], [5], [6]
    //   ]
    // ]
    //
    // Then, we can construct a 3-level nested loop by the following dimension
    // order to extract the values along the axis (dimension1):
    // i: dimension1       // 0,1,2 (newShape[1])
    //   m: dimension0     // 0,1   (newShape[0])
    //     n: dimension2   // 0     (newShape[2])
    //
    //                       m, i, n
    //                      ---------
    // Iteration 0: data at [0, 0, 0] => "1"
    // Iteration 1: data at [1, 0, 0] => "4"
    // We got [1,4].
    // Iteration 2: data at [0, 1, 0] => "2"
    // Iteration 3: data at [1, 1, 0] => "5"
    // We got [2,5].
    // Iteration 4: data at [0, 2, 0] => "3"
    // Iteration 5: data at [1, 2, 0] => "6"
    // We got [3,6].
    const newShape = [
        1,
        shape[0],
        1
    ];
    for(let i3 = 0; i3 < $axis; i3++)newShape[0] *= shape[i3];
    newShape[1] = shape[$axis];
    for(let i1 = $axis + 1; i1 < shape.length; i1++)newShape[2] *= shape[i1];
    // A map from unique elements (their string representations) to their values
    // in "indices" (below).
    const uniqueElements = {};
    // The indices of each unique element in the original tensor along the given
    // axis. It is 1D and has the same size as the given axis.
    const indices = new Int32Array(shape[$axis]);
    // Create a buffer so we can easily extract value at a given location.
    const inputBuffer = new $c341eb4171cc0419$export$350df26cd52e08e1(newShape, dtype, values);
    // The indices along the given axis that have unique elements. This is a
    // de-duped version of "indices" above.
    const uniqueIndices = [];
    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
    for(let i2 = 0; i2 < shape[$axis]; i2++){
        // Extract values along the axis.
        let element;
        if (is1DTensor) // Fast path for 1D tensor input.
        element = values[i2].toString();
        else {
            const axisValues = [];
            for(let m = 0; m < newShape[0]; m++)for(let n = 0; n < newShape[2]; n++)axisValues.push(inputBuffer.get(m, i2, n));
            element = axisValues.join(',');
        }
        // Dedup and update various indices.
        if (uniqueElements[element] !== undefined) indices[i2] = uniqueElements[element];
        else {
            const uniqueIndex = Object.keys(uniqueElements).length;
            uniqueElements[element] = uniqueIndex;
            indices[i2] = uniqueIndex;
            uniqueIndices.push(i2);
        }
    }
    // Now we know where each of the unique elements are located along the axis
    // (uniqueIndices). Extract them from input buffer and store them in the
    // output buffer.
    const outputTmpShape = newShape.slice();
    outputTmpShape[1] = Object.keys(uniqueElements).length;
    const outputBuffer = new $c341eb4171cc0419$export$350df26cd52e08e1(outputTmpShape, dtype);
    uniqueIndices.forEach((uniqueElementIndex, i)=>{
        for(let m = 0; m < newShape[0]; m++)for(let n = 0; n < newShape[2]; n++)outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
    });
    // The output shape can be calculated from the input shape with the size of
    // the given axis replaced by the number of unique elements along that axis.
    const outputShape = shape.slice();
    outputShape[$axis] = outputTmpShape[1];
    return {
        outputValues: outputBuffer.values,
        outputShape: outputShape,
        indices: indices
    };
}





function $07557125b4fa10ce$export$58adb3bec8346d0f(args) {
    const { inputs: { x: x  } , attrs: { begin: begin , size: size  } , backend: backend  } = args;
    const [begin_, size_] = $1a8ddf4b5d32c90c$exports.parseSliceParams(x, begin, size);
    const isContinous = $1a8ddf4b5d32c90c$exports.isSliceContinous(x.shape, begin_, size_);
    const xVals = backend.readSync(x.dataId);
    const out = backend.makeOutput(size_, x.dtype);
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const outData = backend.dataIdMap.get(out.dataId);
    if (isContinous) {
        const flatOffset = $1a8ddf4b5d32c90c$exports.computeFlatOffset(begin_, xStrides);
        if (x.dtype === 'string') outData.stringBytes = xVals.slice(flatOffset, flatOffset + $f6b55a2021b78f0d$exports.sizeFromShape(size_));
        else {
            const outVals = backend.typedArrayFromHeap(out);
            outVals.set(xVals.subarray(flatOffset, flatOffset + $f6b55a2021b78f0d$exports.sizeFromShape(size_)));
        }
        return out;
    }
    if (x.dtype === 'string') {
        const res = $3f463099ff6ccc0b$export$4bdf1ac3fa5d3d6a(xVals, begin_, size_, x.shape, x.dtype);
        outData.stringBytes = res;
        return out;
    }
    const outVals = backend.typedArrayFromHeap(out);
    const rank = x.shape.length;
    if (rank === 2) $07557125b4fa10ce$var$slice2d(xVals, xStrides[0], outVals, begin_, size_);
    else if (rank === 3) $07557125b4fa10ce$var$slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);
    else if (rank === 4) $07557125b4fa10ce$var$slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);
    else {
        const res = $3f463099ff6ccc0b$export$4bdf1ac3fa5d3d6a(xVals, begin_, size_, x.shape, x.dtype);
        outVals.set(res);
    }
    return out;
}
function $07557125b4fa10ce$var$slice2d(xVals, xStride, outVals, begin, size) {
    let outOffset = 0;
    const beginI = begin[0];
    const beginJ = begin[1];
    const endI = beginI + size[0];
    for(let i = beginI; i < endI; i++){
        const xOffset = i * xStride + beginJ;
        outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);
        outOffset += size[1];
    }
}
function $07557125b4fa10ce$var$slice3d(xVals, xStride1, xStride2, outVals, begin, size) {
    let outOffset = 0;
    const beginI = begin[0];
    const beginJ = begin[1];
    const beginK = begin[2];
    const endI = beginI + size[0];
    const endJ = beginJ + size[1];
    for(let i = beginI; i < endI; i++)for(let j = beginJ; j < endJ; j++){
        const xOffset = i * xStride1 + j * xStride2 + beginK;
        outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);
        outOffset += size[2];
    }
}
function $07557125b4fa10ce$var$slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {
    let outOffset = 0;
    const beginI = begin[0];
    const beginJ = begin[1];
    const beginK = begin[2];
    const endI = beginI + size[0];
    const endJ = beginJ + size[1];
    const endK = beginK + size[2];
    const beginL = begin[3];
    for(let i = beginI; i < endI; i++){
        for(let j = beginJ; j < endJ; j++)for(let k = beginK; k < endK; k++){
            const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;
            outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);
            outOffset += size[3];
        }
    }
}
const $07557125b4fa10ce$export$8d8a1e11dd2cc6c4 = {
    kernelName: $2b76be1e72a8c1db$export$b3f2e2de3a8baa1e,
    backendName: 'wasm',
    kernelFunc: $07557125b4fa10ce$export$58adb3bec8346d0f
};



function $e91403e9acfb3c4b$var$batchToSpaceND(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , crops: crops  } = attrs;
    const prod = blockShape.reduce((a, b)=>a * b
    );
    const reshaped = $510a55f99d61727a$exports.getReshaped(x.shape, blockShape, prod);
    const permuted = $510a55f99d61727a$exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = $510a55f99d61727a$exports.getReshapedPermuted(x.shape, blockShape, prod);
    const sliceBeginCoords = $510a55f99d61727a$exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = $510a55f99d61727a$exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const xReshaped = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: reshaped
        }
    });
    const xTransposed = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
        inputs: {
            x: xReshaped
        },
        backend: backend,
        attrs: {
            perm: permuted
        }
    });
    const xTransposedReshaped = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: xTransposed
        },
        backend: backend,
        attrs: {
            shape: reshapedPermuted
        }
    });
    const result = $07557125b4fa10ce$export$58adb3bec8346d0f({
        inputs: {
            x: xTransposedReshaped
        },
        backend: backend,
        attrs: {
            begin: sliceBeginCoords,
            size: sliceSize
        }
    });
    backend.disposeData(xReshaped.dataId);
    backend.disposeData(xTransposed.dataId);
    backend.disposeData(xReshaped.dataId);
    return result;
}
const $e91403e9acfb3c4b$export$44e08e19f97e5513 = {
    kernelName: $2b76be1e72a8c1db$export$e2743f47f61cca1f,
    backendName: 'wasm',
    kernelFunc: $e91403e9acfb3c4b$var$batchToSpaceND
};



function $5f61adf1f6e221a6$export$f2db7d5238e1d23f(args) {
    const { inputs: { x: x  } , attrs: { dtype: dtype  } , backend: backend  } = args;
    const out = backend.makeOutput(x.shape, dtype);
    const inVals = backend.typedArrayFromHeap(x);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.set(inVals);
    return out;
}
const $5f61adf1f6e221a6$export$ac4d0f0f3927a8f3 = {
    kernelName: $2b76be1e72a8c1db$export$107ecfb3d1ccbd77,
    backendName: 'wasm',
    kernelFunc: $5f61adf1f6e221a6$export$f2db7d5238e1d23f
};




const $d10dac12345763ee$export$df387212b1898306 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$d4a1bccfd52ebd3);



let $8fd9c617d2200619$var$wasmClip;
function $8fd9c617d2200619$var$setup(backend) {
    $8fd9c617d2200619$var$wasmClip = backend.wasm.cwrap($2b76be1e72a8c1db$export$611c0e357ac37f7d, null, [
        'number',
        'number',
        'number',
        'number' // out_id
    ]);
}
function $8fd9c617d2200619$var$clip(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { clipValueMin: clipValueMin , clipValueMax: clipValueMax  } = attrs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(x.shape, x.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $8fd9c617d2200619$var$wasmClip(xId, clipValueMin, clipValueMax, outId);
    return out;
}
const $8fd9c617d2200619$export$f7ee8f07ce0ff4e1 = {
    kernelName: $2b76be1e72a8c1db$export$611c0e357ac37f7d,
    backendName: 'wasm',
    setupFunc: $8fd9c617d2200619$var$setup,
    kernelFunc: $8fd9c617d2200619$var$clip
};






function $0e9184a3b7ffed94$export$ee1b3e54f0441b22(args) {
    const { inputs: inputs , backend: backend  } = args;
    const axis = $f6b55a2021b78f0d$exports.parseAxisParam(args.attrs.axis, inputs[0].shape)[0];
    let outShape = $510a55f99d61727a$exports.computeOutShape(inputs.map((t)=>t.shape
    ), axis);
    // Keep only non-empty tensors (ignore tensors with 0 in their shape).
    const $inputs = inputs.filter((t)=>$f6b55a2021b78f0d$exports.sizeFromShape(t.shape) > 0
    );
    if ($inputs.length === 1) return $2d04234e8e22f7e1$export$f0954fd7d5368655({
        inputs: {
            x: $inputs[0]
        },
        backend: backend
    });
    const out = backend.makeOutput(outShape, inputs[0].dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(outShape) === 0) return out;
    const shapes = $inputs.map((t)=>t.shape
    );
    $510a55f99d61727a$exports.assertParamsConsistent(shapes, axis);
    if ($inputs[0].dtype === 'string') {
        // Any concat of n-dimensional tensors across any axis can be reduced to
        // a concatenation of two-dimensional tensors across the axis 1 by first
        // partitioning the axes of the original tensors into those less than the
        // axis to be concatenated and the rest. Then reshape the tensors
        // into a two-dimensional tensor by collapsing these two sets of axes and
        // concatenate the resulting matrices across the axis 1, finally reshaping
        // the result to have the proper shape.
        const inputs2D = $inputs.map((t)=>{
            const innerSize = $f6b55a2021b78f0d$exports.sizeFromShape(t.shape.slice(axis));
            const shape = [
                -1,
                innerSize
            ];
            return $15ffb328294ad08e$export$9eaad88cf88cee2b({
                inputs: {
                    x: t
                },
                backend: backend,
                attrs: {
                    shape: shape
                }
            });
        });
        const inputsValShapes = inputs2D.map((t)=>{
            return {
                vals: backend.readSync(t.dataId),
                shape: t.shape
            };
        });
        // Concats 2d tensors along axis=1.
        outShape = $510a55f99d61727a$exports.computeOutShape(inputs2D.map((t)=>t.shape
        ), 1 /* axis */ );
        const simplyConcat = inputs2D[0].shape[0] === 1;
        const outVals = $8c0fda6ef00eb49d$export$777da59f594f497d(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
        const finalOutShape = $510a55f99d61727a$exports.computeOutShape($inputs.map((t)=>t.shape
        ), axis);
        out.shape = finalOutShape;
        const outData = backend.dataIdMap.get(out.dataId);
        outData.stringBytes = $510a55f99d61727a$exports.fromStringArrayToUint8(outVals);
        inputs2D.forEach((t)=>backend.disposeData(t.dataId)
        );
        return out;
    }
    const batchDim = $f6b55a2021b78f0d$exports.sizeFromShape($inputs[0].shape.slice(0, axis));
    let sumInnerDims = 0;
    const innerDims = $inputs.map((input)=>{
        const innerDim = $f6b55a2021b78f0d$exports.sizeFromShape(input.shape.slice(axis));
        sumInnerDims += innerDim;
        return innerDim;
    });
    const inVals = $inputs.map((input)=>backend.typedArrayFromHeap(input)
    );
    const outVals = backend.typedArrayFromHeap(out);
    for(let b = 0; b < batchDim; b++){
        let outOffset = b * sumInnerDims;
        for(let i = 0; i < inVals.length; i++){
            const innerDim = innerDims[i];
            const inOffset = b * innerDim;
            const vals = inVals[i].subarray(inOffset, inOffset + innerDim);
            outVals.set(vals, outOffset);
            outOffset += innerDim;
        }
    }
    return out;
}
const $0e9184a3b7ffed94$export$c8cf96dae25282e5 = {
    kernelName: $2b76be1e72a8c1db$export$936bbfc007425eea,
    backendName: 'wasm',
    kernelFunc: $0e9184a3b7ffed94$export$ee1b3e54f0441b22
};



let $43c4f630994c7964$var$wasmConv2d;
function $43c4f630994c7964$var$setup(backend) {
    $43c4f630994c7964$var$wasmConv2d = backend.wasm.cwrap($2b76be1e72a8c1db$export$57742e605d475795, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $43c4f630994c7964$var$conv2d(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x , filter: filter  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const filterId = backend.dataIdMap.get(filter.dataId).id;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode , dataFormat: dataFormat  } = attrs;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const inputChannels = convInfo.inChannels;
    const outputChannels = convInfo.outChannels;
    const isSamePad = convInfo.padInfo.type === 'SAME' ? 1 : 0;
    if (convInfo.dataFormat !== 'channelsLast') throw new Error(`wasm backend Conv2D does not support dataFormat:'` + `${convInfo.dataFormat}'. Please use 'channelsLast'.`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    $43c4f630994c7964$var$wasmConv2d(xId, x.shape[0], x.shape[1], x.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
    return out;
}
const $43c4f630994c7964$export$4a39bf13b4378042 = {
    kernelName: $2b76be1e72a8c1db$export$57742e605d475795,
    backendName: 'wasm',
    setupFunc: $43c4f630994c7964$var$setup,
    kernelFunc: $43c4f630994c7964$var$conv2d
};



let $32d507adcf78b818$var$wasmConv2DBackpropInput;
function $32d507adcf78b818$var$setup(backend) {
    $32d507adcf78b818$var$wasmConv2DBackpropInput = backend.wasm.cwrap($2b76be1e72a8c1db$export$e26961e8ed0eb404, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $32d507adcf78b818$var$conv2DBackpropInput(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode , inputShape: inputShape  } = attrs;
    const dilations = 1;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
    const { batchSize: batchSize , filterHeight: filterHeight , filterWidth: filterWidth , inChannels: inChannels , inHeight: inHeight , inWidth: inWidth , outChannels: outChannels , outHeight: outHeight , outWidth: outWidth , strideHeight: strideHeight , strideWidth: strideWidth  } = convInfo;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const dxStrides = $f6b55a2021b78f0d$exports.computeStrides(convInfo.inShape);
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    const [fltS0, fltS1, fltS2] = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    const xBatchStride = dxStrides[0];
    const xRowStride = isChannelsLast ? dxStrides[1] : dxStrides[2];
    const xColStride = isChannelsLast ? dxStrides[2] : 1;
    const xChannelStride = isChannelsLast ? 1 : dxStrides[1];
    const yBatchStride = dyStrides[0];
    const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
    const yColStride = isChannelsLast ? dyStrides[2] : 1;
    const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
    const out = backend.makeOutput(convInfo.inShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const dyId = backend.dataIdMap.get(dy.dataId).id;
    const filterId = backend.dataIdMap.get(filter.dataId).id;
    $32d507adcf78b818$var$wasmConv2DBackpropInput(dyId, filterId, batchSize, filterHeight, filterWidth, inHeight, inWidth, inChannels, outHeight, outWidth, outChannels, strideHeight, strideWidth, topPad, leftPad, fltS0, fltS1, fltS2, xBatchStride, xRowStride, xColStride, xChannelStride, yBatchStride, yRowStride, yColStride, yChannelStride, outId);
    return out;
}
const $32d507adcf78b818$export$19bbc19fff1ed26f = {
    kernelName: $2b76be1e72a8c1db$export$e26961e8ed0eb404,
    backendName: 'wasm',
    setupFunc: $32d507adcf78b818$var$setup,
    kernelFunc: $32d507adcf78b818$var$conv2DBackpropInput
};




const $c3b5681bdd2d8367$export$ff099a1da5235a7e = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$ddfd0a983d257666);




const $9ee33fa3fdcfbc6e$export$c5824052b09ba0ed = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$5e311a1c57b0d27c);




// Must match enum in CropAndResize.cc
var $08e569ab1de6991f$var$InterpolationMethod;
(function(InterpolationMethod) {
    InterpolationMethod[InterpolationMethod["bilinear"] = 0] = "bilinear";
    InterpolationMethod[InterpolationMethod["nearest"] = 1] = "nearest";
})($08e569ab1de6991f$var$InterpolationMethod || ($08e569ab1de6991f$var$InterpolationMethod = {}));
let $08e569ab1de6991f$var$wasmCropAndResize;
function $08e569ab1de6991f$var$setup(backend) {
    $08e569ab1de6991f$var$wasmCropAndResize = backend.wasm.cwrap($2b76be1e72a8c1db$export$50bc9557793c2e04, null, [
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number' // out id
    ]);
}
function $08e569ab1de6991f$var$cropAndResize(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { method: method , extrapolationValue: extrapolationValue , cropSize: cropSize  } = attrs;
    const { image: image , boxes: boxes , boxInd: boxInd  } = inputs;
    const numBoxes = boxes.shape[0];
    const [cropHeight, cropWidth] = cropSize;
    const outShape = [
        numBoxes,
        cropHeight,
        cropWidth,
        image.shape[3]
    ];
    let imagesData = backend.dataIdMap.get(image.dataId);
    let castedData;
    if (image.dtype !== 'float32') {
        castedData = $5f61adf1f6e221a6$export$f2db7d5238e1d23f({
            backend: backend,
            inputs: {
                x: image
            },
            attrs: {
                dtype: 'float32'
            }
        });
        imagesData = backend.dataIdMap.get(castedData.dataId);
    }
    const imagesId = imagesData.id;
    const boxesId = backend.dataIdMap.get(boxes.dataId).id;
    const boxIndId = backend.dataIdMap.get(boxInd.dataId).id;
    const out = backend.makeOutput(outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const imagesShapeBytes = new Uint8Array(new Int32Array(image.shape).buffer);
    $08e569ab1de6991f$var$wasmCropAndResize(imagesId, boxesId, boxIndId, numBoxes, imagesShapeBytes, cropHeight, cropWidth, $08e569ab1de6991f$var$InterpolationMethod[method], extrapolationValue, outId);
    if (castedData != null) backend.disposeData(castedData.dataId);
    return out;
}
const $08e569ab1de6991f$export$f7086edcf0050c7f = {
    kernelName: $2b76be1e72a8c1db$export$50bc9557793c2e04,
    backendName: 'wasm',
    setupFunc: $08e569ab1de6991f$var$setup,
    kernelFunc: $08e569ab1de6991f$var$cropAndResize
};





let $5e250da6be6fd779$var$wasmCumprod;
function $5e250da6be6fd779$var$setup(backend) {
    $5e250da6be6fd779$var$wasmCumprod = backend.wasm.cwrap($2b76be1e72a8c1db$export$e581acc6014c47a, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number' // dtype
    ]);
}
function $5e250da6be6fd779$export$dc7513e907e94b8d(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    const xRank = x.shape.length;
    $f6b55a2021b78f0d$exports.assert(x.dtype === 'float32' || x.dtype === 'int32', ()=>`cumprod does not support ${x.dtype} tensors in the WASM backend`
    );
    // permute required axis to inner most axis
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], xRank);
    let permutedX = x;
    if (permutation !== null) permutedX = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        attrs: {
            perm: permutation
        },
        backend: backend
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, xRank)[0];
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('cumprod', [
        permutedAxis
    ], xRank);
    const permutedOut = backend.makeOutput(permutedX.shape, permutedX.dtype);
    const finalDim = permutedX.shape[permutedAxis];
    const permutedXId = backend.dataIdMap.get(permutedX.dataId).id;
    const permutedOutId = backend.dataIdMap.get(permutedOut.dataId).id;
    $5e250da6be6fd779$var$wasmCumprod(permutedXId, exclusive ? 1 : 0, reverse ? 1 : 0, finalDim, permutedOutId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype]);
    // transpose data back if permuted
    let out = permutedOut;
    if (permutation !== null) {
        const undoPermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        out = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
            inputs: {
                x: permutedOut
            },
            attrs: {
                perm: undoPermutation
            },
            backend: backend
        });
        backend.disposeData(permutedX.dataId);
        backend.disposeData(permutedOut.dataId);
    }
    return out;
}
const $5e250da6be6fd779$export$db50d81ed60c5a35 = {
    kernelName: $2b76be1e72a8c1db$export$e581acc6014c47a,
    backendName: 'wasm',
    setupFunc: $5e250da6be6fd779$var$setup,
    kernelFunc: $5e250da6be6fd779$export$dc7513e907e94b8d
};





let $8027aaad2a19feb6$var$wasmCumsum;
function $8027aaad2a19feb6$var$setup(backend) {
    $8027aaad2a19feb6$var$wasmCumsum = backend.wasm.cwrap($2b76be1e72a8c1db$export$706617d894ad63da, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number' // dtype
    ]);
}
function $8027aaad2a19feb6$export$71990b1e1c4912fe(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    const xRank = x.shape.length;
    $f6b55a2021b78f0d$exports.assert(x.dtype === 'float32' || x.dtype === 'int32', ()=>`cumsum does not support ${x.dtype} tensors in the WASM backend`
    );
    // permute required axis to inner most axis
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], xRank);
    let permutedX = x;
    if (permutation !== null) permutedX = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        attrs: {
            perm: permutation
        },
        backend: backend
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, xRank)[0];
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('cumsum', [
        permutedAxis
    ], xRank);
    const permutedOut = backend.makeOutput(permutedX.shape, permutedX.dtype);
    const finalDim = permutedX.shape[permutedAxis];
    const permutedXId = backend.dataIdMap.get(permutedX.dataId).id;
    const permutedOutId = backend.dataIdMap.get(permutedOut.dataId).id;
    $8027aaad2a19feb6$var$wasmCumsum(permutedXId, exclusive ? 1 : 0, reverse ? 1 : 0, finalDim, permutedOutId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype]);
    // transpose data back if permuted
    let out = permutedOut;
    if (permutation !== null) {
        const undoPermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        out = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
            inputs: {
                x: permutedOut
            },
            attrs: {
                perm: undoPermutation
            },
            backend: backend
        });
        backend.disposeData(permutedX.dataId);
        backend.disposeData(permutedOut.dataId);
    }
    return out;
}
const $8027aaad2a19feb6$export$2f6196f3316e7ed2 = {
    kernelName: $2b76be1e72a8c1db$export$706617d894ad63da,
    backendName: 'wasm',
    setupFunc: $8027aaad2a19feb6$var$setup,
    kernelFunc: $8027aaad2a19feb6$export$71990b1e1c4912fe
};



let $a13983ee83dd5c7b$var$wasmDepthToSpace;
function $a13983ee83dd5c7b$var$setup(backend) {
    $a13983ee83dd5c7b$var$wasmDepthToSpace = backend.wasm.cwrap($2b76be1e72a8c1db$export$fb0ee52d0cd6f233, null, [
        'number',
        'number',
        'number',
        'array',
        'number',
        'array',
        'array',
        'number',
        'number', 
    ]);
}
function $a13983ee83dd5c7b$export$3b50daec0f185f12(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockSize: blockSize , dataFormat: dataFormat  } = attrs;
    const batchSize = x.shape[0];
    const inputHeight = dataFormat === 'NHWC' ? x.shape[1] : x.shape[2];
    const inputWidth = dataFormat === 'NHWC' ? x.shape[2] : x.shape[3];
    const inputDepth = dataFormat === 'NHWC' ? x.shape[3] : x.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = dataFormat === 'NHWC' ? [
        batchSize,
        outputHeight,
        outputWidth,
        outputDepth
    ] : [
        batchSize,
        outputDepth,
        outputHeight,
        outputWidth
    ];
    const out = backend.makeOutput(outputShape, 'float32');
    const xData = backend.dataIdMap.get(x.dataId);
    const xId = xData.id;
    const xStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(x.shape)).buffer);
    const outputShapeBytes = new Uint8Array(new Int32Array(outputShape).buffer);
    const outStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(outputShape)).buffer);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const channelsLast = dataFormat === 'NHWC' ? 1 : 0;
    $a13983ee83dd5c7b$var$wasmDepthToSpace(xId, blockSize, channelsLast, xStridesBytes, x.shape.length - 1, outputShapeBytes, outStridesBytes, outputShape.length, outId);
    return out;
}
const $a13983ee83dd5c7b$export$9c5b88dcb1d2008b = {
    kernelName: $2b76be1e72a8c1db$export$fb0ee52d0cd6f233,
    backendName: 'wasm',
    setupFunc: $a13983ee83dd5c7b$var$setup,
    kernelFunc: $a13983ee83dd5c7b$export$3b50daec0f185f12
};



let $7c663e664c42ee7d$var$wasmDepthwiseConv2d;
function $7c663e664c42ee7d$var$setup(backend) {
    $7c663e664c42ee7d$var$wasmDepthwiseConv2d = backend.wasm.cwrap($2b76be1e72a8c1db$export$7c0fc590ff9e156f, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $7c663e664c42ee7d$var$depthwiseConv2d(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x , filter: filter  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const filterId = backend.dataIdMap.get(filter.dataId).id;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const $dilations = dilations == null ? [
        1,
        1
    ] : dilations;
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const inputChannels = convInfo.inChannels;
    const outputChannels = convInfo.outChannels;
    const isSamePad = convInfo.padInfo.type === 'SAME' ? 1 : 0;
    if (convInfo.dataFormat !== 'channelsLast') throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'` + `${convInfo.dataFormat}'. Please use 'channelsLast'.`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    $7c663e664c42ee7d$var$wasmDepthwiseConv2d(xId, x.shape[0], x.shape[1], x.shape[2], filterId, filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
    return out;
}
const $7c663e664c42ee7d$export$240667804b7c390e = {
    kernelName: $2b76be1e72a8c1db$export$7c0fc590ff9e156f,
    backendName: 'wasm',
    setupFunc: $7c663e664c42ee7d$var$setup,
    kernelFunc: $7c663e664c42ee7d$var$depthwiseConv2d
};




const $aff9bcacc9c83cf0$export$b990686634ee3cce = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$64636e173424d83d);




const $698a9e6f41506fcc$var$supportsFullBroadcast = false;
const $698a9e6f41506fcc$export$3c8bc3d8ee318217 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$8dcf9f58ce5cdfc, $698a9e6f41506fcc$var$supportsFullBroadcast, 'bool');




const $f6c186b41506887e$export$2fd7ea0fcf021f34 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$f908be7a96fb3363, 'float32');




function $8c1575fcdb3c587f$export$d660d8ed21f46635(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { input: input  } = inputs;
    const { dim: dim  } = attrs;
    const inputRank = input.shape.length;
    const newShape = input.shape.slice();
    let $dim = dim;
    if (dim < 0) {
        // Negative value is counted from the tail of rank.
        $f6b55a2021b78f0d$exports.assert(-(inputRank + 1) <= dim, ()=>`Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`
        );
        $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: input
        },
        backend: backend,
        attrs: {
            shape: newShape
        }
    });
}
const $8c1575fcdb3c587f$export$86341ba0ce5d8e60 = {
    kernelName: $2b76be1e72a8c1db$export$2391750b1d901146,
    backendName: 'wasm',
    kernelFunc: $8c1575fcdb3c587f$export$d660d8ed21f46635
};



function $ceb5f9a9a3fa695f$export$9563e054e6f787fb(args) {
    const { attrs: { shape: shape , value: value , dtype: dtype  } , backend: backend  } = args;
    const out = backend.makeOutput(shape, dtype);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.fill(value);
    return out;
}
const $ceb5f9a9a3fa695f$export$c953bf474b2bde62 = {
    kernelName: $2b76be1e72a8c1db$export$ffffe40bfa0649a3,
    backendName: 'wasm',
    kernelFunc: $ceb5f9a9a3fa695f$export$9563e054e6f787fb
};



let $6bad538bf202dbbb$var$wasmFlipLeftRight;
function $6bad538bf202dbbb$var$setup(backend) {
    $6bad538bf202dbbb$var$wasmFlipLeftRight = backend.wasm.cwrap($2b76be1e72a8c1db$export$34e7296fc8558df5, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $6bad538bf202dbbb$export$8358b9c43b687b22(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { image: image  } = inputs;
    const out = backend.makeOutput(image.shape, image.dtype);
    const imageId = backend.dataIdMap.get(image.dataId).id;
    const outId = backend.dataIdMap.get(out.dataId).id;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    $6bad538bf202dbbb$var$wasmFlipLeftRight(imageId, batch, imageHeight, imageWidth, numChannels, outId);
    return out;
}
const $6bad538bf202dbbb$export$c9ec83cb23304466 = {
    kernelName: $2b76be1e72a8c1db$export$34e7296fc8558df5,
    backendName: 'wasm',
    kernelFunc: $6bad538bf202dbbb$export$8358b9c43b687b22,
    setupFunc: $6bad538bf202dbbb$var$setup
};




const $e65c855f1cf93e00$export$7e9a0f96fa6bd01c = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$4880b0ae5643c62b);




const $f24299d1496aac2e$var$supportsFullBroadcast = false;
const $f24299d1496aac2e$export$7eac933a0c7fd37f = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$d79b5692ede26c2f, $f24299d1496aac2e$var$supportsFullBroadcast);



let $9cc7dfd324f9273c$var$wasmBatchNorm;
function $9cc7dfd324f9273c$var$setup(backend) {
    $9cc7dfd324f9273c$var$wasmBatchNorm = backend.wasm.cwrap($2b76be1e72a8c1db$export$3821a0416660aaa2, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number'
    ]);
}
function $9cc7dfd324f9273c$var$fusedBatchNorm(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { varianceEpsilon: varianceEpsilon  } = attrs;
    const { x: x , mean: mean , variance: variance , offset: offset , scale: scale  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const meanId = backend.dataIdMap.get(mean.dataId).id;
    const varianceId = backend.dataIdMap.get(variance.dataId).id;
    const offsetId = offset != null ? backend.dataIdMap.get(offset.dataId).id : 0;
    const scaleId = scale != null ? backend.dataIdMap.get(scale.dataId).id : 0;
    const out = backend.makeOutput(x.shape, x.dtype);
    // Short-circuit zero-sized tensors.
    if ($f6b55a2021b78f0d$exports.sizeFromShape(x.shape) === 0) return out;
    const outId = backend.dataIdMap.get(out.dataId).id;
    $9cc7dfd324f9273c$var$wasmBatchNorm(xId, meanId, varianceId, offsetId, scaleId, varianceEpsilon, outId);
    return out;
}
const $9cc7dfd324f9273c$export$bfc6b905951b4903 = {
    kernelName: $2b76be1e72a8c1db$export$3821a0416660aaa2,
    backendName: 'wasm',
    setupFunc: $9cc7dfd324f9273c$var$setup,
    kernelFunc: $9cc7dfd324f9273c$var$fusedBatchNorm
};




let $7052ee69be0c491f$var$wasmFusedConv2d;
function $7052ee69be0c491f$var$setup(backend) {
    $7052ee69be0c491f$var$wasmFusedConv2d = backend.wasm.cwrap($2b76be1e72a8c1db$export$86f8a8e3a8f2a8f2, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $7052ee69be0c491f$var$fusedConv2d(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode);
    const fusedActivation = $1ac51db5370ba6a2$export$4cb673822966e9a9[activation];
    if (fusedActivation == null) throw new Error(`${activation} activation not yet supported for FusedConv2D ` + `in the wasm backend.`);
    const xId = backend.dataIdMap.get(x.dataId).id;
    const filterId = backend.dataIdMap.get(filter.dataId).id;
    const outputChannels = convInfo.outChannels;
    let biasId = 0;
    if (bias != null) {
        const biasData = backend.dataIdMap.get(bias.dataId);
        if (biasData.shape.length !== 1) throw new Error(`FusedConv2D only supports rank-1 bias but got ` + `rank ${biasData.shape.length}.`);
        if (biasData.shape[0] !== outputChannels) throw new Error(`FusedConv2D bias shape (${biasData.shape}) does not ` + `match the number of output channels (${outputChannels})`);
        biasId = biasData.id;
    }
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const inputChannels = convInfo.inChannels;
    const isSamePad = convInfo.padInfo.type === 'SAME' ? 1 : 0;
    const batchSize = convInfo.batchSize;
    const inHeight = convInfo.inHeight;
    const inWidth = convInfo.inWidth;
    if (dataFormat !== 'NHWC') throw new Error(`wasm backend FusedConv2D does not support dataFormat:'` + `${dataFormat}'. Please use 'NHWC'.`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend.dataIdMap.get(preluActivationWeights.dataId).id;
    $7052ee69be0c491f$var$wasmFusedConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, leakyreluAlpha || 0, outId);
    return out;
}
const $7052ee69be0c491f$export$5b64efa829ddf94e = {
    kernelName: $2b76be1e72a8c1db$export$86f8a8e3a8f2a8f2,
    backendName: 'wasm',
    setupFunc: $7052ee69be0c491f$var$setup,
    kernelFunc: $7052ee69be0c491f$var$fusedConv2d
};




let $164208bc5c0c2232$var$wasmFusedDepthwiseConv2d;
function $164208bc5c0c2232$var$setup(backend) {
    $164208bc5c0c2232$var$wasmFusedDepthwiseConv2d = backend.wasm.cwrap($2b76be1e72a8c1db$export$5a249e8f498c02c1, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $164208bc5c0c2232$var$fusedDepthwiseConv2d(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
    const fusedActivation = $1ac51db5370ba6a2$export$4cb673822966e9a9[activation];
    if (fusedActivation == null) throw new Error(`${activation} activation not yet supported for FusedDepthwiseConv2D ` + `in the wasm backend.`);
    const xId = backend.dataIdMap.get(x.dataId).id;
    const filterId = backend.dataIdMap.get(filter.dataId).id;
    const outputChannels = convInfo.outChannels;
    let biasId = 0;
    if (bias != null) {
        const biasData = backend.dataIdMap.get(bias.dataId);
        if (biasData.shape.length !== 1) throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got ` + `rank ${biasData.shape.length}.`);
        if (biasData.shape[0] !== outputChannels) throw new Error(`FusedDepthwiseConv2D bias shape (${biasData.shape}) does not ` + `match the number of output channels (${outputChannels})`);
        biasId = biasData.id;
    }
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const inputChannels = convInfo.inChannels;
    const isSamePad = convInfo.padInfo.type === 'SAME' ? 1 : 0;
    const batchSize = convInfo.batchSize;
    const inHeight = convInfo.inHeight;
    const inWidth = convInfo.inWidth;
    if (dataFormat !== 'NHWC') throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'` + `${dataFormat}'. Please use 'NHWC'.`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const preluActivationWeightsId = preluActivationWeights == null ? 0 : backend.dataIdMap.get(preluActivationWeights.dataId).id;
    $164208bc5c0c2232$var$wasmFusedDepthwiseConv2d(xId, batchSize, inHeight, inWidth, filterId, filterHeight, filterWidth, biasId, padTop, padRight, padBottom, padLeft, isSamePad, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, fusedActivation, preluActivationWeightsId, leakyreluAlpha || 0, outId);
    return out;
}
const $164208bc5c0c2232$export$58481cc3409b412c = {
    kernelName: $2b76be1e72a8c1db$export$5a249e8f498c02c1,
    backendName: 'wasm',
    setupFunc: $164208bc5c0c2232$var$setup,
    kernelFunc: $164208bc5c0c2232$var$fusedDepthwiseConv2d
};




let $ab98cdbcc226bc2a$var$wasmGatherNd;
function $ab98cdbcc226bc2a$var$setup(backend) {
    $ab98cdbcc226bc2a$var$wasmGatherNd = backend.wasm.cwrap($2b76be1e72a8c1db$export$4ef6e37a23721703, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number' // outId
    ]);
}
function $ab98cdbcc226bc2a$var$gatherNd(args) {
    const { backend: backend , inputs: inputs  } = args;
    const { params: params , indices: indices  } = inputs;
    const [resultShape, numSlices, sliceSize, strides] = $c53aa01d4c37cbd8$exports.prepareAndValidate(params, indices);
    const out = backend.makeOutput(resultShape, params.dtype);
    if (numSlices === 0) return out;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const xData = backend.dataIdMap.get(params.dataId);
    const xId = xData.id;
    const indicesData = backend.dataIdMap.get(indices.dataId);
    const indicesId = indicesData.id;
    const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $ab98cdbcc226bc2a$var$wasmGatherNd(xId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[params.dtype], indicesId, numSlices, sliceRank, sliceSize, stridesBytes, outId);
    return out;
}
const $ab98cdbcc226bc2a$export$d9700eb1c7f5c969 = {
    kernelName: $2b76be1e72a8c1db$export$4ef6e37a23721703,
    backendName: 'wasm',
    setupFunc: $ab98cdbcc226bc2a$var$setup,
    kernelFunc: $ab98cdbcc226bc2a$var$gatherNd
};





let $eea0deee3a607b90$var$wasmGather;
function $eea0deee3a607b90$var$setup(backend) {
    $eea0deee3a607b90$var$wasmGather = backend.wasm.cwrap('Gather', null, [
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'array',
        'number' // outId
    ]);
}
function $eea0deee3a607b90$var$gatherV2(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { x: x , indices: indices  } = inputs;
    const { axis: axis , batchDims: batchDims  } = attrs;
    // Throw error when any index is out of bound.
    const parsedAxis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    const indicesVals = backend.readSync(indices.dataId);
    const axisDim = x.shape[parsedAxis];
    for(let i = 0; i < indicesVals.length; ++i){
        const index = indicesVals[i];
        $f6b55a2021b78f0d$exports.assert(index <= axisDim - 1 && index >= 0, ()=>`GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`
        );
    }
    const shapeInfo = $510a55f99d61727a$exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const flattenX = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        attrs: {
            shape: [
                shapeInfo.batchSize,
                shapeInfo.outerSize,
                shapeInfo.dimSize,
                shapeInfo.sliceSize
            ]
        },
        backend: backend
    });
    const indicesSize = $f6b55a2021b78f0d$exports.sizeFromShape(indices.shape);
    const flattenIndex = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        attrs: {
            shape: [
                shapeInfo.batchSize,
                indicesSize / shapeInfo.batchSize
            ]
        },
        backend: backend
    });
    const flattenOutputShape = [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
    ];
    const out = backend.makeOutput(flattenOutputShape, x.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(x.shape) === 0) return out;
    const stridesSize = flattenX.shape.length - 1;
    const xData = backend.dataIdMap.get(flattenX.dataId);
    const xId = xData.id;
    const indicesData = backend.dataIdMap.get(flattenIndex.dataId);
    const indicesId = indicesData.id;
    const outId = backend.dataIdMap.get(out.dataId).id;
    const xStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(flattenX.shape)).buffer);
    const outStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(flattenOutputShape)).buffer);
    $eea0deee3a607b90$var$wasmGather(xId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], xStridesBytes, stridesSize, indicesId, shapeInfo.batchSize, outStridesBytes, outId);
    backend.disposeData(flattenX.dataId);
    backend.disposeData(flattenIndex.dataId);
    // reshape
    out.shape = shapeInfo.outputShape;
    return out;
}
const $eea0deee3a607b90$export$b1bd3139c91d8765 = {
    kernelName: $2b76be1e72a8c1db$export$ccd988942e5c0181,
    backendName: 'wasm',
    setupFunc: $eea0deee3a607b90$var$setup,
    kernelFunc: $eea0deee3a607b90$var$gatherV2
};




const $c2fc3698976e847e$var$supportsFullBroadcast = false;
const $c2fc3698976e847e$export$8c4f7e92d92310f8 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$d0a25eac5ee3f515, $c2fc3698976e847e$var$supportsFullBroadcast, 'bool');




const $8f343a93fa6e18e0$var$supportsFullBroadcast = false;
const $8f343a93fa6e18e0$export$7a6926f9fcac24ca = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$3b7d21bc9aee0851, $8f343a93fa6e18e0$var$supportsFullBroadcast, 'bool');





let $54b8337ea5c90a9b$var$wasmFunc;
function $54b8337ea5c90a9b$var$setupFunc(backend) {
    $54b8337ea5c90a9b$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$f0c7162bb7af1a2d, null, [
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $54b8337ea5c90a9b$export$23a860e40a2c6b61(args) {
    const { inputs: { x: x  } , attrs: { alpha: alpha  } , backend: backend  } = args;
    const xId = backend.dataIdMap.get(x.dataId).id;
    // According to TF API, LeakyRelu returns float32 when input is either float32
    // or int32.
    const out = backend.makeOutput(x.shape, 'float32');
    if ($f6b55a2021b78f0d$exports.sizeFromShape(x.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $54b8337ea5c90a9b$var$wasmFunc(xId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], alpha, outId);
    }
    return out;
}
const $54b8337ea5c90a9b$export$aa04ab963fdf437f = {
    kernelName: $2b76be1e72a8c1db$export$f0c7162bb7af1a2d,
    backendName: 'wasm',
    setupFunc: $54b8337ea5c90a9b$var$setupFunc,
    kernelFunc: $54b8337ea5c90a9b$export$23a860e40a2c6b61
};




const $85d884d8ef6fafe0$var$supportsFullBroadcast = false;
const $85d884d8ef6fafe0$export$8d4530ce8b6ffc3c = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$728c50f1c88ac779, $85d884d8ef6fafe0$var$supportsFullBroadcast, 'bool');




const $45b8069d467fb1c0$var$supportsFullBroadcast = false;
const $45b8069d467fb1c0$export$9f26bd257393dd8 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$84afd0d8f7fb8c5d, $45b8069d467fb1c0$var$supportsFullBroadcast, 'bool');




const $714bf2c41b253bc4$export$a4ae1f00643ddd14 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$ce30dbb46644d06c);




const $838c61cff03ff2bd$var$supportsFullBroadcast = false;
const $838c61cff03ff2bd$export$257f1e82e69113fb = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$8a27ff10dff4d6e5, $838c61cff03ff2bd$var$supportsFullBroadcast, 'bool');





let $7da93261defccda4$var$wasmMax;
function $7da93261defccda4$var$setup(backend) {
    $7da93261defccda4$var$wasmMax = backend.wasm.cwrap($2b76be1e72a8c1db$export$d36c09e5d02927e7, null, [
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $7da93261defccda4$var$max(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { reductionIndices: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        input = transposed;
        inputId = transposedId;
    }
    const inputRank = input.shape.length;
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('max', axes, inputRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, x.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $7da93261defccda4$var$wasmMax(inputId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], reduceSize, outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $7da93261defccda4$export$7d79147246e312bb = {
    kernelName: $2b76be1e72a8c1db$export$d36c09e5d02927e7,
    backendName: 'wasm',
    setupFunc: $7da93261defccda4$var$setup,
    kernelFunc: $7da93261defccda4$var$max
};




const $06be692ec771ec1a$var$supportsFullBroadcast = false;
const $06be692ec771ec1a$export$45b97bdc342e72a2 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$d8d02ac92d161004, $06be692ec771ec1a$var$supportsFullBroadcast);



let $ed8bec49fe41b832$var$wasmMaxPool;
function $ed8bec49fe41b832$var$setup(backend) {
    $ed8bec49fe41b832$var$wasmMaxPool = backend.wasm.cwrap($2b76be1e72a8c1db$export$39ea33024ddd5cf, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $ed8bec49fe41b832$var$maxPool(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const x = inputs.x;
    const xId = backend.dataIdMap.get(x.dataId).id;
    // TF API supports int32 input. CPU and WebGL backend also support int32
    // input. WASM backend doesn't support it because it uses xnnpack which only
    // supports float32.
    //
    // Add the following assert only for the WASM backend instead of at core op
    // level.
    //
    // TODO: add support for int32 input.
    $f6b55a2021b78f0d$exports.assert(x.dtype === 'float32', ()=>`Error in MaxPool: only float32 input is supported. Got ${x.dtype}.`
    );
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = convInfo.padInfo.top;
    const padRight = convInfo.padInfo.right;
    const padBottom = convInfo.padInfo.bottom;
    const padLeft = convInfo.padInfo.left;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const inputChannels = convInfo.inChannels;
    const outputChannels = convInfo.outChannels;
    if (convInfo.dataFormat !== 'channelsLast') throw new Error(`wasm backend does not support dataFormat:'` + `${convInfo.dataFormat}'. Please use 'channelsLast'.`);
    const out = backend.makeOutput(convInfo.outShape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    $ed8bec49fe41b832$var$wasmMaxPool(xId, x.shape[0], x.shape[1], x.shape[2], filterHeight, filterWidth, padTop, padRight, padBottom, padLeft, dilationHeight, dilationWidth, strideHeight, strideWidth, inputChannels, outputChannels, outId);
    return out;
}
const $ed8bec49fe41b832$export$45c8263b38f19e33 = {
    kernelName: $2b76be1e72a8c1db$export$39ea33024ddd5cf,
    backendName: 'wasm',
    setupFunc: $ed8bec49fe41b832$var$setup,
    kernelFunc: $ed8bec49fe41b832$var$maxPool
};





let $ad841bfc9e9c9c70$var$wasmMean;
function $ad841bfc9e9c9c70$var$setup(backend) {
    $ad841bfc9e9c9c70$var$wasmMean = backend.wasm.cwrap($2b76be1e72a8c1db$export$1c2d59c4b681fbd8, null, [
        'number, number, number'
    ]);
}
function $ad841bfc9e9c9c70$export$1ce691f85baaa52(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    let reductionAxes = axes;
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        if (transposedId !== xId) {
            // transpose was not a no-op. We will need to dispose of this
            // once we are done.
            input = transposed;
            inputId = transposedId;
            reductionAxes = $510a55f99d61727a$exports.getInnerMostAxes(reductionAxes.length, input.shape.length);
        }
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('mean', reductionAxes, input.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, reductionAxes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    let castedInput = input;
    if (input.dtype !== 'float32') {
        castedInput = $5f61adf1f6e221a6$export$f2db7d5238e1d23f({
            backend: backend,
            inputs: {
                x: input
            },
            attrs: {
                dtype: 'float32'
            }
        });
        inputId = backend.dataIdMap.get(castedInput.dataId).id;
    }
    const out = backend.makeOutput(outShape, 'float32');
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $ad841bfc9e9c9c70$var$wasmMean(inputId, reduceSize, outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    if (input.dtype !== 'float32') backend.disposeData(castedInput.dataId);
    return out;
}
const $ad841bfc9e9c9c70$export$b934af0ccd0cdbe1 = {
    kernelName: $2b76be1e72a8c1db$export$1c2d59c4b681fbd8,
    backendName: 'wasm',
    setupFunc: $ad841bfc9e9c9c70$var$setup,
    kernelFunc: $ad841bfc9e9c9c70$export$1ce691f85baaa52
};





let $354f15c871b5f9f0$var$wasmMin;
function $354f15c871b5f9f0$var$setup(backend) {
    $354f15c871b5f9f0$var$wasmMin = backend.wasm.cwrap($2b76be1e72a8c1db$export$dfed19fabc75a31d, null, [
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $354f15c871b5f9f0$var$min(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        if (transposedId !== xId) {
            // transpose was not a no-op. We will need to dispose of this
            // once we are done.
            input = transposed;
            inputId = transposedId;
        }
    }
    const inputRank = input.shape.length;
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('min', axes, inputRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, input.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $354f15c871b5f9f0$var$wasmMin(inputId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], reduceSize, outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $354f15c871b5f9f0$export$3cd9f9a31b38cf18 = {
    kernelName: $2b76be1e72a8c1db$export$dfed19fabc75a31d,
    backendName: 'wasm',
    setupFunc: $354f15c871b5f9f0$var$setup,
    kernelFunc: $354f15c871b5f9f0$var$min
};




const $b38f0528e95e8aaf$var$supportsFullBroadcast = false;
const $b38f0528e95e8aaf$export$ea24ffbbbce8d546 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$23cb308301e89d6b, $b38f0528e95e8aaf$var$supportsFullBroadcast);




// Must match enum in MirrorPad.cc
var $5ff88d381308aa8a$var$MirrorPaddingMode;
(function(MirrorPaddingMode) {
    MirrorPaddingMode[MirrorPaddingMode["reflect"] = 0] = "reflect";
    MirrorPaddingMode[MirrorPaddingMode["symmetric"] = 1] = "symmetric";
})($5ff88d381308aa8a$var$MirrorPaddingMode || ($5ff88d381308aa8a$var$MirrorPaddingMode = {}));
let $5ff88d381308aa8a$var$wasmMirrorPad;
function $5ff88d381308aa8a$var$setup(backend) {
    $5ff88d381308aa8a$var$wasmMirrorPad = backend.wasm.cwrap($2b76be1e72a8c1db$export$f4c0e95fd7fd31e5, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'array',
        'number',
        'number', 
    ]);
}
function $5ff88d381308aa8a$var$mirrorPad(args) {
    const { inputs: { x: x  } , backend: backend , attrs: { paddings: paddings , mode: mode  }  } = args;
    const outShape = paddings.map((p, i)=>p[0] + x.shape[i] + p[1]
    );
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(outShape, x.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    const prePaddingsFlat = paddings.map((padTuple)=>padTuple[0]
    );
    const postPaddingsFlat = paddings.map((padTuple)=>padTuple[1]
    );
    const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
    const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
    $5ff88d381308aa8a$var$wasmMirrorPad(xId, xShapeBytes, x.shape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], prePaddingsBytes, postPaddingsBytes, $5ff88d381308aa8a$var$MirrorPaddingMode[mode], outId);
    return out;
}
const $5ff88d381308aa8a$export$2cfd6c6c7daeb5fc = {
    kernelName: $2b76be1e72a8c1db$export$f4c0e95fd7fd31e5,
    backendName: 'wasm',
    kernelFunc: $5ff88d381308aa8a$var$mirrorPad,
    setupFunc: $5ff88d381308aa8a$var$setup
};




const $e480075b484d2988$var$supportsFullBroadcast = true;
const $e480075b484d2988$export$745576778aafee88 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$f14f83b3b531d498, $e480075b484d2988$var$supportsFullBroadcast);




const $fb247c951dd503d9$export$cc7b18b8229c3db = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$c07c549000872073);



function $1346db5e6a28cea1$export$304727529d27ba95(backend, resOffset) {
    const result = new Int32Array(backend.wasm.HEAPU8.buffer, resOffset, 4);
    const pSelectedIndices = result[0];
    const selectedSize = result[1];
    const pSelectedScores = result[2];
    const pValidOutputs = result[3];
    // Since the result was allocated on the heap, we have to delete it.
    backend.wasm._free(resOffset);
    return {
        pSelectedIndices: pSelectedIndices,
        selectedSize: selectedSize,
        pSelectedScores: pSelectedScores,
        pValidOutputs: pValidOutputs
    };
}


let $a4ab8100f6e8356b$var$wasmFunc;
function $a4ab8100f6e8356b$var$setup(backend) {
    $a4ab8100f6e8356b$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$5e11788439c2f04, 'number', [
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $a4ab8100f6e8356b$var$kernelFunc(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { iouThreshold: iouThreshold , maxOutputSize: maxOutputSize , scoreThreshold: scoreThreshold  } = attrs;
    const { boxes: boxes , scores: scores  } = inputs;
    const boxesId = backend.dataIdMap.get(boxes.dataId).id;
    const scoresId = backend.dataIdMap.get(scores.dataId).id;
    const resOffset = $a4ab8100f6e8356b$var$wasmFunc(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold);
    const { pSelectedIndices: pSelectedIndices , selectedSize: selectedSize , pSelectedScores: pSelectedScores , pValidOutputs: pValidOutputs  } = $1346db5e6a28cea1$export$304727529d27ba95(backend, resOffset);
    // Since we are not using scores for V3, we have to delete it from the heap.
    backend.wasm._free(pSelectedScores);
    backend.wasm._free(pValidOutputs);
    const selectedIndicesTensor = backend.makeOutput([
        selectedSize
    ], 'int32', pSelectedIndices);
    return selectedIndicesTensor;
}
const $a4ab8100f6e8356b$export$549561cd158f260a = {
    kernelName: $2b76be1e72a8c1db$export$5e11788439c2f04,
    backendName: 'wasm',
    setupFunc: $a4ab8100f6e8356b$var$setup,
    kernelFunc: $a4ab8100f6e8356b$var$kernelFunc
};




let $835ecb14c3a68c0d$var$wasmFunc;
function $835ecb14c3a68c0d$var$setup(backend) {
    $835ecb14c3a68c0d$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$7df908154366fe7f, 'number', [
        'number',
        'number',
        'number',
        'number',
        'number',
        'bool', 
    ]);
}
function $835ecb14c3a68c0d$var$nonMaxSuppressionV4(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { iouThreshold: iouThreshold , maxOutputSize: maxOutputSize , scoreThreshold: scoreThreshold , padToMaxOutputSize: padToMaxOutputSize  } = attrs;
    const { boxes: boxes , scores: scores  } = inputs;
    const boxesId = backend.dataIdMap.get(boxes.dataId).id;
    const scoresId = backend.dataIdMap.get(scores.dataId).id;
    const resOffset = $835ecb14c3a68c0d$var$wasmFunc(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    const { pSelectedIndices: pSelectedIndices , selectedSize: selectedSize , pSelectedScores: pSelectedScores , pValidOutputs: pValidOutputs  } = $1346db5e6a28cea1$export$304727529d27ba95(backend, resOffset);
    // Since we are not using scores for V4, we have to delete it from the heap.
    backend.wasm._free(pSelectedScores);
    const selectedIndicesTensor = backend.makeOutput([
        selectedSize
    ], 'int32', pSelectedIndices);
    const validOutputsTensor = backend.makeOutput([], 'int32', pValidOutputs);
    return [
        selectedIndicesTensor,
        validOutputsTensor
    ];
}
const $835ecb14c3a68c0d$export$906b8fb32c570e9d = {
    kernelName: $2b76be1e72a8c1db$export$7df908154366fe7f,
    backendName: 'wasm',
    setupFunc: $835ecb14c3a68c0d$var$setup,
    kernelFunc: $835ecb14c3a68c0d$var$nonMaxSuppressionV4
};




let $fa637e310b940322$var$wasmFunc;
function $fa637e310b940322$var$setup(backend) {
    $fa637e310b940322$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$cb45d3fcefce2ef0, 'number', [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $fa637e310b940322$var$kernelFunc(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { iouThreshold: iouThreshold , maxOutputSize: maxOutputSize , scoreThreshold: scoreThreshold , softNmsSigma: softNmsSigma  } = attrs;
    const { boxes: boxes , scores: scores  } = inputs;
    const boxesId = backend.dataIdMap.get(boxes.dataId).id;
    const scoresId = backend.dataIdMap.get(scores.dataId).id;
    const resOffset = $fa637e310b940322$var$wasmFunc(boxesId, scoresId, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    const { pSelectedIndices: pSelectedIndices , selectedSize: selectedSize , pSelectedScores: pSelectedScores , pValidOutputs: pValidOutputs  } = $1346db5e6a28cea1$export$304727529d27ba95(backend, resOffset);
    // Since we are not using validOutputs for V5, we have to delete it from the
    // heap.
    backend.wasm._free(pValidOutputs);
    const selectedIndicesTensor = backend.makeOutput([
        selectedSize
    ], 'int32', pSelectedIndices);
    const selectedScoresTensor = backend.makeOutput([
        selectedSize
    ], 'float32', pSelectedScores);
    return [
        selectedIndicesTensor,
        selectedScoresTensor
    ];
}
const $fa637e310b940322$export$4c00b682f309701d = {
    kernelName: $2b76be1e72a8c1db$export$cb45d3fcefce2ef0,
    backendName: 'wasm',
    setupFunc: $fa637e310b940322$var$setup,
    kernelFunc: $fa637e310b940322$var$kernelFunc
};




const $80246a0f3e207f5d$var$supportsFullBroadcast = false;
const $80246a0f3e207f5d$export$d003d4d7e1500775 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$385ebe9945cae0c5, $80246a0f3e207f5d$var$supportsFullBroadcast, 'bool');



let $2d53390dfc452cca$var$wasmOneHot;
function $2d53390dfc452cca$var$setup(backend) {
    $2d53390dfc452cca$var$wasmOneHot = backend.wasm.cwrap($2b76be1e72a8c1db$export$18982b43ba8c02e9, null, [
        'number',
        'number',
        'number',
        'number',
        'number' // out_id
    ]);
}
function $2d53390dfc452cca$var$oneHot(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { indices: indices  } = inputs;
    const { depth: depth , onValue: onValue , offValue: offValue  } = attrs;
    const out = backend.makeOutput([
        ...indices.shape,
        depth
    ], 'int32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    const indicesData = backend.dataIdMap.get(indices.dataId);
    const indicesId = indicesData.id;
    $2d53390dfc452cca$var$wasmOneHot(indicesId, depth, onValue, offValue, outId);
    return out;
}
const $2d53390dfc452cca$export$dde5645b472b80b2 = {
    kernelName: $2b76be1e72a8c1db$export$18982b43ba8c02e9,
    backendName: 'wasm',
    setupFunc: $2d53390dfc452cca$var$setup,
    kernelFunc: $2d53390dfc452cca$var$oneHot
};



function $9d30096db190e417$var$onesLike(args) {
    const { inputs: { x: x  } , backend: backend  } = args;
    const out = backend.makeOutput(x.shape, x.dtype);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.fill(1);
    return out;
}
const $9d30096db190e417$export$d8d7015eb6ab37d0 = {
    kernelName: $2b76be1e72a8c1db$export$a2962e735c809d91,
    backendName: 'wasm',
    kernelFunc: $9d30096db190e417$var$onesLike
};





function $0c14524ae70d4d85$export$2a703dbb0cb35339(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    if (inputs.length === 1) return $8c1575fcdb3c587f$export$d660d8ed21f46635({
        inputs: {
            input: inputs[0]
        },
        backend: backend,
        attrs: {
            dim: axis
        }
    });
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t)=>{
        $f6b55a2021b78f0d$exports.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        $f6b55a2021b78f0d$exports.assert(dtype === t.dtype, ()=>'All tensors passed to stack must have matching dtypes'
        );
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t)=>{
        const expandedT = $8c1575fcdb3c587f$export$d660d8ed21f46635({
            inputs: {
                input: t
            },
            backend: backend,
            attrs: {
                dim: axis
            }
        });
        intermediateTensorInfos.push(expandedT);
        return expandedT;
    });
    const result = $0e9184a3b7ffed94$export$ee1b3e54f0441b22({
        inputs: expandedTensors,
        backend: backend,
        attrs: {
            axis: axis
        }
    });
    intermediateTensorInfos.forEach((t)=>backend.disposeData(t.dataId)
    );
    return result;
}
const $0c14524ae70d4d85$export$1645fa8803aa1f86 = {
    kernelName: $2b76be1e72a8c1db$export$c26f40b29201e5b7,
    backendName: 'wasm',
    kernelFunc: $0c14524ae70d4d85$export$2a703dbb0cb35339
};





let $929531b1c09f1ddf$var$wasmPadV2;
function $929531b1c09f1ddf$var$setup(backend) {
    $929531b1c09f1ddf$var$wasmPadV2 = backend.wasm.cwrap($2b76be1e72a8c1db$export$5d47ba206577f0f2, null, [
        'number',
        'array',
        'number',
        'number',
        'array',
        'array',
        'number',
        'number', 
    ]);
}
function $929531b1c09f1ddf$var$pad(args) {
    const { inputs: { x: x  } , backend: backend , attrs: { paddings: paddings , constantValue: constantValue  }  } = args;
    const outShape = paddings.map((p, i)=>p[0] + x.shape[i] + p[1]
    );
    if ($f6b55a2021b78f0d$exports.sizeFromShape(x.shape) === 0) // Short-circuit the computation, since x doesn't have value, only
    // the shape is used to compute output shape to pad.
    return $ceb5f9a9a3fa695f$export$9563e054e6f787fb({
        backend: backend,
        attrs: {
            shape: outShape,
            value: constantValue,
            dtype: x.dtype
        }
    });
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(outShape, x.dtype);
    const outTensorData = backend.dataIdMap.get(out.dataId);
    const outId = outTensorData.id;
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    const prePaddingsFlat = paddings.map((padTuple)=>padTuple[0]
    );
    const postPaddingsFlat = paddings.map((padTuple)=>padTuple[1]
    );
    const prePaddingsBytes = new Uint8Array(new Int32Array(prePaddingsFlat).buffer);
    const postPaddingsBytes = new Uint8Array(new Int32Array(postPaddingsFlat).buffer);
    $929531b1c09f1ddf$var$wasmPadV2(xId, xShapeBytes, x.shape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], prePaddingsBytes, postPaddingsBytes, constantValue, outId);
    return out;
}
const $929531b1c09f1ddf$export$b0317e720bfd61fc = {
    kernelName: $2b76be1e72a8c1db$export$5d47ba206577f0f2,
    backendName: 'wasm',
    kernelFunc: $929531b1c09f1ddf$var$pad,
    setupFunc: $929531b1c09f1ddf$var$setup
};




const $6602eada984e14ba$var$supportsFullBroadcast = false;
const $6602eada984e14ba$export$b823d49786719761 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$ce28d653ec559ee, $6602eada984e14ba$var$supportsFullBroadcast);




let $3a405a5643bdab58$var$wasmPrelu;
function $3a405a5643bdab58$var$setup(backend) {
    $3a405a5643bdab58$var$wasmPrelu = backend.wasm.cwrap($2b76be1e72a8c1db$export$a42f35f308fc2fa3, null, [
        'number',
        'number',
        'number' // out_id
    ]);
}
function $3a405a5643bdab58$var$prelu(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x , alpha: alpha  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const weightsId = backend.dataIdMap.get(alpha.dataId).id;
    let inputId = xId;
    const input = x;
    let castedInput = input;
    if (input.dtype !== 'float32') {
        castedInput = $5f61adf1f6e221a6$export$f2db7d5238e1d23f({
            backend: backend,
            inputs: {
                x: x
            },
            attrs: {
                dtype: 'float32'
            }
        });
        inputId = backend.dataIdMap.get(castedInput.dataId).id;
    }
    const out = backend.makeOutput(x.shape, 'float32');
    const outId = backend.dataIdMap.get(out.dataId).id;
    $3a405a5643bdab58$var$wasmPrelu(inputId, weightsId, outId);
    if (input.dtype !== 'float32') backend.disposeData(castedInput.dataId);
    return out;
}
const $3a405a5643bdab58$export$a5c4a9b694579636 = {
    kernelName: $2b76be1e72a8c1db$export$a42f35f308fc2fa3,
    backendName: 'wasm',
    setupFunc: $3a405a5643bdab58$var$setup,
    kernelFunc: $3a405a5643bdab58$var$prelu
};





let $613c9a9fcac53b4c$var$wasmProd;
function $613c9a9fcac53b4c$var$setup(backend) {
    $613c9a9fcac53b4c$var$wasmProd = backend.wasm.cwrap($2b76be1e72a8c1db$export$b8a16d526a791fb0, null, [
        'number',
        'number',
        'number',
        'number'
    ]);
}
function $613c9a9fcac53b4c$var$prod(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    let reductionAxes = axes;
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        if (transposedId !== xId) {
            // transpose was not a no-op. We will need to dispose of this
            // once we are done.
            input = transposed;
            inputId = transposedId;
            reductionAxes = $510a55f99d61727a$exports.getInnerMostAxes(reductionAxes.length, input.shape.length);
        }
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('prod', reductionAxes, input.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, reductionAxes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, input.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $613c9a9fcac53b4c$var$wasmProd(inputId, reduceSize, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[out.dtype], outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $613c9a9fcac53b4c$export$d556aa935cef5c0c = {
    kernelName: $2b76be1e72a8c1db$export$b8a16d526a791fb0,
    backendName: 'wasm',
    setupFunc: $613c9a9fcac53b4c$var$setup,
    kernelFunc: $613c9a9fcac53b4c$var$prod
};




const $aab44279a516b85d$export$d02631cccf789723 = (args)=>{
    const { backend: backend , attrs: attrs  } = args;
    const { start: start , stop: stop , step: step , dtype: dtype  } = attrs;
    const values = $1752da38d99a9db0$export$3561205b7dff20bf(start, stop, step, dtype);
    const out = backend.makeOutput([
        values.length
    ], dtype);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.set(values);
    return out;
};
const $aab44279a516b85d$export$361c4075706e31c2 = {
    kernelName: $2b76be1e72a8c1db$export$9a58ef0d7ad3278c,
    backendName: 'wasm',
    kernelFunc: $aab44279a516b85d$export$d02631cccf789723
};




const $ecdfefebed01499e$var$supportsFullBroadcast = true;
const $ecdfefebed01499e$export$15c5d6176b30b9a6 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$b9880b86e1014bb8, $ecdfefebed01499e$var$supportsFullBroadcast);




const $d6f67b26a49d4218$export$731f9199bde068eb = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$9a6ff968bf961432);




const $4a04483a8f11691e$export$92c30890ad649d53 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$3be9e924f629054e);





let $94b5bb1f759f5f26$var$wasmResizeBilinear;
function $94b5bb1f759f5f26$var$setup(backend) {
    $94b5bb1f759f5f26$var$wasmResizeBilinear = backend.wasm.cwrap($2b76be1e72a8c1db$export$24f2f15d869e0fd, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number' // outId
    ]);
}
function $94b5bb1f759f5f26$var$resizeBilinear(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { images: images  } = inputs;
    const { alignCorners: alignCorners , halfPixelCenters: halfPixelCenters , size: size  } = attrs;
    const [newHeight, newWidth] = size;
    const [batch, oldHeight, oldWidth, numChannels] = images.shape;
    const outShape = [
        batch,
        newHeight,
        newWidth,
        numChannels
    ];
    let xData = backend.dataIdMap.get(images.dataId);
    let castedData;
    if (xData.dtype !== 'float32') {
        castedData = $5f61adf1f6e221a6$export$f2db7d5238e1d23f({
            backend: backend,
            inputs: {
                x: images
            },
            attrs: {
                dtype: 'float32'
            }
        });
        xData = backend.dataIdMap.get(castedData.dataId);
    }
    const xId = xData.id;
    const out = backend.makeOutput(outShape, 'float32');
    if ($f6b55a2021b78f0d$exports.sizeFromShape(images.shape) === 0) return out;
    const outId = backend.dataIdMap.get(out.dataId).id;
    $94b5bb1f759f5f26$var$wasmResizeBilinear(xId, batch, oldHeight, oldWidth, numChannels, newHeight, newWidth, alignCorners ? 1 : 0, halfPixelCenters ? 1 : 0, outId);
    if (castedData != null) backend.disposeData(castedData.dataId);
    return out;
}
const $94b5bb1f759f5f26$export$a37a56137abc1357 = {
    kernelName: $2b76be1e72a8c1db$export$24f2f15d869e0fd,
    backendName: 'wasm',
    setupFunc: $94b5bb1f759f5f26$var$setup,
    kernelFunc: $94b5bb1f759f5f26$var$resizeBilinear
};





let $c23f48e232c70411$var$wasmReverse;
function $c23f48e232c70411$var$setup(backend) {
    $c23f48e232c70411$var$wasmReverse = backend.wasm.cwrap($2b76be1e72a8c1db$export$53c81f36b32e1bba, null, [
        'number',
        'array',
        'number',
        'array',
        'number',
        'number' // out_id
    ]);
}
function $c23f48e232c70411$export$66c1ae025e96b4bc(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { dims: dims  } = attrs;
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam(dims, x.shape);
    if (x.shape.length === 0) return $2d04234e8e22f7e1$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const out = backend.makeOutput(x.shape, x.dtype);
    const xId = backend.dataIdMap.get(x.dataId).id;
    const outId = backend.dataIdMap.get(out.dataId).id;
    const axesBytes = new Uint8Array(new Int32Array(axes).buffer);
    const outShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    $c23f48e232c70411$var$wasmReverse(xId, axesBytes, axes.length, outShapeBytes, x.shape.length, outId);
    const reshaped = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: out
        },
        attrs: {
            shape: x.shape
        },
        backend: backend
    });
    backend.disposeData(out.dataId);
    return reshaped;
}
const $c23f48e232c70411$export$cab6a4e8d2ed8e8d = {
    kernelName: $2b76be1e72a8c1db$export$53c81f36b32e1bba,
    backendName: 'wasm',
    kernelFunc: $c23f48e232c70411$export$66c1ae025e96b4bc,
    setupFunc: $c23f48e232c70411$var$setup
};




let $4ce6a1bca127238b$var$wasmRotate;
function $4ce6a1bca127238b$var$setup(backend) {
    $4ce6a1bca127238b$var$wasmRotate = backend.wasm.cwrap($2b76be1e72a8c1db$export$c5a44649815d1c3, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number', 
    ]);
}
function $4ce6a1bca127238b$export$66462c489f5f29d2(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { image: image  } = inputs;
    const { radians: radians , fillValue: fillValue , center: center  } = attrs;
    const out = backend.makeOutput(image.shape, image.dtype);
    const imageId = backend.dataIdMap.get(image.dataId).id;
    const outId = backend.dataIdMap.get(out.dataId).id;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    const [centerX, centerY] = $510a55f99d61727a$exports.getImageCenter(center, imageHeight, imageWidth);
    const fillIsBlack = fillValue === 0;
    const fullOpacityValue = 255;
    const fillValues = typeof fillValue === 'number' ? [
        fillValue,
        fillValue,
        fillValue,
        fillIsBlack ? 0 : fullOpacityValue
    ] : [
        ...fillValue,
        fullOpacityValue
    ];
    const fillBytes = new Uint8Array(new Int32Array(fillValues).buffer);
    $4ce6a1bca127238b$var$wasmRotate(imageId, batch, imageHeight, imageWidth, numChannels, radians, centerX, centerY, fillBytes, fillValues.length, outId);
    return out;
}
const $4ce6a1bca127238b$export$44ba8c83417ab668 = {
    kernelName: $2b76be1e72a8c1db$export$c5a44649815d1c3,
    backendName: 'wasm',
    kernelFunc: $4ce6a1bca127238b$export$66462c489f5f29d2,
    setupFunc: $4ce6a1bca127238b$var$setup
};




const $a080ea3221b52801$export$6c09e3291f636503 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$c5ed3eef16c0612f);




const $0508f0fe7e951840$export$941104b789956ef6 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$7cc53aa09f5f3a2d);




let $fbaa972b09ed0729$var$wasmScatterNd;
function $fbaa972b09ed0729$var$setup(backend) {
    $fbaa972b09ed0729$var$wasmScatterNd = backend.wasm.cwrap($2b76be1e72a8c1db$export$28eef6f0168af686, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number' // outId
    ]);
}
function $fbaa972b09ed0729$var$scatterNd(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { indices: indices , updates: updates  } = inputs;
    const { shape: shape  } = attrs;
    const out = backend.makeOutput(shape, updates.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(shape) === 0) return out;
    const { sliceRank: sliceRank , numUpdates: numUpdates , sliceSize: sliceSize , strides: strides , outputSize: outputSize  } = $ddbb251d0c4839ae$exports.calculateShapes(updates, indices, shape);
    const indicesData = backend.dataIdMap.get(indices.dataId);
    const indicesId = indicesData.id;
    const updatesData = backend.dataIdMap.get(updates.dataId);
    const updatesId = updatesData.id;
    const stridesBytes = new Uint8Array(new Int32Array(strides).buffer);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $fbaa972b09ed0729$var$wasmScatterNd(indicesId, updatesId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[updates.dtype], sliceRank, numUpdates, sliceSize, stridesBytes, outputSize, outId);
    return out;
}
const $fbaa972b09ed0729$export$573371744f044f5 = {
    kernelName: $2b76be1e72a8c1db$export$28eef6f0168af686,
    backendName: 'wasm',
    setupFunc: $fbaa972b09ed0729$var$setup,
    kernelFunc: $fbaa972b09ed0729$var$scatterNd
};



let $c079902389d4f86f$var$wasmSelect;
function $c079902389d4f86f$var$setup(backend) {
    $c079902389d4f86f$var$wasmSelect = backend.wasm.cwrap('SelectV2', null, [
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $c079902389d4f86f$var$select(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { condition: condition , t: t , e: e  } = inputs;
    const conditionId = backend.dataIdMap.get(condition.dataId).id;
    const tId = backend.dataIdMap.get(t.dataId).id;
    const eId = backend.dataIdMap.get(e.dataId).id;
    const out = backend.makeOutput(t.shape, t.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const cRank = condition.shape.length;
    const tRank = t.shape.length;
    const offset = cRank === 0 || cRank > 1 || tRank === 1 ? 1 : $f6b55a2021b78f0d$exports.sizeFromShape(t.shape.slice(1));
    $c079902389d4f86f$var$wasmSelect(conditionId, tId, eId, offset, outId);
    return out;
}
const $c079902389d4f86f$export$7ff911e710ee72fc = {
    kernelName: $2b76be1e72a8c1db$export$ef9b1a59e592288f,
    backendName: 'wasm',
    kernelFunc: $c079902389d4f86f$var$select,
    setupFunc: $c079902389d4f86f$var$setup
};



let $8d2970e1cecc2bc5$var$wasmFunc;
function $8d2970e1cecc2bc5$var$setup(backend) {
    $8d2970e1cecc2bc5$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$fde18c826dda6b1b, null, [
        'number',
        'number'
    ]);
}
function $8d2970e1cecc2bc5$var$sigmoid(args) {
    const { backend: backend , inputs: { x: x  }  } = args;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(x.shape, x.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    // Short-circuit zero-sized tensors.
    if ($f6b55a2021b78f0d$exports.sizeFromShape(out.shape) === 0) return out;
    $8d2970e1cecc2bc5$var$wasmFunc(xId, outId);
    return out;
}
const $8d2970e1cecc2bc5$export$195d1cf7c59f3ef = {
    kernelName: 'Sigmoid',
    backendName: 'wasm',
    setupFunc: $8d2970e1cecc2bc5$var$setup,
    kernelFunc: $8d2970e1cecc2bc5$var$sigmoid
};




const $080f047c992b94f5$export$d993ec4e5c253b66 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$75be1b631f7687);




let $443a30d32b2d0325$var$wasmFunc;
function $443a30d32b2d0325$var$setup(backend) {
    $443a30d32b2d0325$var$wasmFunc = backend.wasm.cwrap($2b76be1e72a8c1db$export$350a526055d3ca6e, null, [
        'number',
        'number',
        'number',
        'number' // batch
    ]);
}
function $443a30d32b2d0325$var$softmax(args) {
    const { backend: backend , inputs: { logits: logits  } , attrs: { dim: dim  }  } = args;
    const xId = backend.dataIdMap.get(logits.dataId).id;
    const out = backend.makeOutput(logits.shape, logits.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const channels = logits.shape[dim];
    const batch = $f6b55a2021b78f0d$exports.sizeFromShape(logits.shape) / channels;
    // Short-circuit zero-sized tensors.
    if ($f6b55a2021b78f0d$exports.sizeFromShape(out.shape) === 0) return out;
    $443a30d32b2d0325$var$wasmFunc(xId, outId, channels, batch);
    return out;
}
const $443a30d32b2d0325$export$c022691f23e2ee69 = {
    kernelName: $2b76be1e72a8c1db$export$350a526055d3ca6e,
    backendName: 'wasm',
    setupFunc: $443a30d32b2d0325$var$setup,
    kernelFunc: $443a30d32b2d0325$var$softmax
};






function $52f0a50b4a7cee2e$var$spaceToBatchND(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , paddings: paddings  } = attrs;
    const prod = $f6b55a2021b78f0d$exports.sizeFromShape(blockShape);
    const completePaddings = [
        [
            0,
            0
        ]
    ];
    completePaddings.push(...paddings);
    for(let i = 1 + blockShape.length; i < x.shape.length; ++i)completePaddings.push([
        0,
        0
    ]);
    const paddedX = $929531b1c09f1ddf$export$b0317e720bfd61fc.kernelFunc({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            paddings: completePaddings,
            constantValue: 0
        }
    });
    const reshapedPaddedShape = $510a55f99d61727a$exports.getReshaped(paddedX.shape, blockShape, prod, false);
    const permutedReshapedPaddedPermutation = $510a55f99d61727a$exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = $510a55f99d61727a$exports.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
    const reshapeInputs = {
        x: paddedX
    };
    const reshapeAttrs = {
        shape: reshapedPaddedShape
    };
    const paddedXReshaped = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: reshapeInputs,
        backend: backend,
        attrs: reshapeAttrs
    });
    const transposeInputs = {
        x: paddedXReshaped
    };
    const transposeAttrs = {
        perm: permutedReshapedPaddedPermutation
    };
    const paddedXT = $1c71bf11e4cf3d4a$export$9cb09a71b7d66923({
        inputs: transposeInputs,
        backend: backend,
        attrs: transposeAttrs
    });
    const resultReshapeInputs = {
        x: paddedXT
    };
    const resultReshapeAttrs = {
        shape: flattenShape
    };
    const result = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: resultReshapeInputs,
        backend: backend,
        attrs: resultReshapeAttrs
    });
    backend.disposeData(paddedX.dataId);
    backend.disposeData(paddedXReshaped.dataId);
    backend.disposeData(paddedXT.dataId);
    return result;
}
const $52f0a50b4a7cee2e$export$2f85417863d2050b = {
    kernelName: $2b76be1e72a8c1db$export$f63ac5409312707c,
    backendName: 'wasm',
    kernelFunc: $52f0a50b4a7cee2e$var$spaceToBatchND
};





let $b145ff42e1f40016$var$wasmSparseFillEmptyRows;
function $b145ff42e1f40016$export$de27182ff8187d6c(backend) {
    $b145ff42e1f40016$var$wasmSparseFillEmptyRows = backend.wasm.cwrap('SparseFillEmptyRows', 'number', [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $b145ff42e1f40016$export$c82a1904a15b5028(args) {
    const { backend: backend , inputs: inputs  } = args;
    const { indices: indices , values: values , denseShape: denseShape , defaultValue: defaultValue  } = inputs;
    const indicesCount = indices.shape[0];
    const rank = indices.shape[1];
    const denseRows = backend.readSync(denseShape.dataId)[0];
    // Set output size to maximum possible and resize later (actual result
    // might be smaller).
    const maxOutputIndicesShape = [
        indicesCount + denseRows,
        rank
    ];
    const indicesId = backend.dataIdMap.get(indices.dataId).id;
    const valuesId = backend.dataIdMap.get(values.dataId).id;
    const defaultValueId = backend.dataIdMap.get(defaultValue.dataId).id;
    const outputIndices = backend.makeOutput(maxOutputIndicesShape, indices.dtype);
    const outputIndicesId = backend.dataIdMap.get(outputIndices.dataId).id;
    const outputValues = backend.makeOutput(maxOutputIndicesShape.slice(0, 1), values.dtype);
    const outputValuesId = backend.dataIdMap.get(outputValues.dataId).id;
    const emptyRowIndicator = backend.makeOutput([
        denseRows
    ], 'bool');
    const emptyRowIndicatorId = backend.dataIdMap.get(emptyRowIndicator.dataId).id;
    const reverseIndexMap = backend.makeOutput([
        indicesCount
    ], indices.dtype);
    const reverseIndexMapId = backend.dataIdMap.get(reverseIndexMap.dataId).id;
    const exceptionValues = backend.makeOutput([
        4
    ], 'int32');
    const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;
    const outputRows = $b145ff42e1f40016$var$wasmSparseFillEmptyRows(indicesId, valuesId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[values.dtype], indicesCount, denseRows, rank, defaultValueId, outputIndicesId, outputValuesId, emptyRowIndicatorId, reverseIndexMapId, exceptionValuesId);
    const exceptionValuesArray = backend.readSync(exceptionValues.dataId);
    let exceptionMessage;
    switch(exceptionValuesArray[0]){
        case 1:
            exceptionMessage = $510a55f99d61727a$exports.getSparseFillEmptyRowsIndicesDenseShapeMismatch(exceptionValuesArray[1]);
            break;
        case 2:
            exceptionMessage = $510a55f99d61727a$exports.getSparseFillEmptyRowsNegativeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        case 3:
            exceptionMessage = $510a55f99d61727a$exports.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);
            break;
        default:
            exceptionMessage = '';
    }
    backend.disposeData(exceptionValues.dataId);
    if (exceptionMessage) {
        backend.disposeData(outputIndices.dataId);
        backend.disposeData(outputValues.dataId);
        backend.disposeData(emptyRowIndicator.dataId);
        backend.disposeData(reverseIndexMap.dataId);
        throw new Error(exceptionMessage);
    }
    let resizedIndices = outputIndices;
    let resizedValues = outputValues;
    // Overestimated output size.
    if (outputRows !== maxOutputIndicesShape[0]) {
        resizedIndices = $07557125b4fa10ce$export$58adb3bec8346d0f({
            inputs: {
                x: outputIndices
            },
            attrs: {
                begin: 0,
                size: [
                    outputRows,
                    rank
                ]
            },
            backend: backend
        });
        resizedValues = $07557125b4fa10ce$export$58adb3bec8346d0f({
            inputs: {
                x: outputValues
            },
            attrs: {
                begin: 0,
                size: outputRows
            },
            backend: backend
        });
        backend.disposeData(outputIndices.dataId);
        backend.disposeData(outputValues.dataId);
    }
    return [
        resizedIndices,
        resizedValues,
        emptyRowIndicator,
        reverseIndexMap
    ];
}
const $b145ff42e1f40016$export$818286c593224d1a = {
    kernelName: $2b76be1e72a8c1db$export$8f1933853a5c8cca,
    backendName: 'wasm',
    setupFunc: $b145ff42e1f40016$export$de27182ff8187d6c,
    kernelFunc: $b145ff42e1f40016$export$c82a1904a15b5028
};



let $bc515f68b5813683$var$wasmSparseReshape;
function $bc515f68b5813683$var$setup(backend) {
    $bc515f68b5813683$var$wasmSparseReshape = backend.wasm.cwrap($2b76be1e72a8c1db$export$f08f0dca44fa542, null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $bc515f68b5813683$var$sparseReshape(args) {
    const { backend: backend , inputs: inputs  } = args;
    const { inputIndices: inputIndices , inputShape: inputShape , newShape: newShape  } = inputs;
    if (inputIndices.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${inputIndices.shape}`);
    if (inputShape.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${inputShape.shape}`);
    if (newShape.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    const inputIndicesId = backend.dataIdMap.get(inputIndices.dataId).id;
    const inputShapeId = backend.dataIdMap.get(inputShape.dataId).id;
    const newShapeId = backend.dataIdMap.get(newShape.dataId).id;
    const nnz = inputIndices.shape[0];
    const outputRank = $f6b55a2021b78f0d$exports.sizeFromShape(newShape.shape);
    const newIndices = backend.makeOutput([
        nnz,
        outputRank
    ], inputIndices.dtype);
    const newIndicesId = backend.dataIdMap.get(newIndices.dataId).id;
    const outputShape = backend.makeOutput([
        outputRank
    ], newShape.dtype);
    const outputShapeId = backend.dataIdMap.get(outputShape.dataId).id;
    const exceptionValues = backend.makeOutput([
        3
    ], 'int32');
    const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;
    $bc515f68b5813683$var$wasmSparseReshape(inputIndicesId, inputShapeId, newShapeId, nnz, newIndicesId, outputShapeId, exceptionValuesId);
    const exceptionValuesArray = backend.readSync(exceptionValues.dataId);
    let exceptionMessage;
    switch(exceptionValuesArray[0]){
        case 0:
            exceptionMessage = $510a55f99d61727a$exports.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        case 1:
            exceptionMessage = $510a55f99d61727a$exports.getSparseReshapeNegativeOutputDimErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        case 2:
            exceptionMessage = $510a55f99d61727a$exports.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
            break;
        case 3:
            {
                const inputShapeValues = Array.from(backend.readSync(inputShape.dataId)), outputShapeValues = Array.from(backend.readSync(outputShape.dataId));
                exceptionMessage = $510a55f99d61727a$exports.getSparseReshapeInputOutputMultipleErrorMessage(inputShapeValues, outputShapeValues);
                break;
            }
        case 4:
            {
                const inputShapeValues = Array.from(backend.readSync(inputShape.dataId)), outputShapeValues = Array.from(backend.readSync(outputShape.dataId));
                exceptionMessage = $510a55f99d61727a$exports.getSparseReshapeInputOutputMismatchErrorMessage(inputShapeValues, outputShapeValues);
                break;
            }
        default:
            exceptionMessage = '';
    }
    backend.disposeData(exceptionValues.dataId);
    if (exceptionMessage) {
        backend.disposeData(newIndices.dataId);
        backend.disposeData(outputShape.dataId);
        throw new Error(exceptionMessage);
    }
    return [
        newIndices,
        outputShape
    ];
}
const $bc515f68b5813683$export$eb106efc10374803 = {
    kernelName: $2b76be1e72a8c1db$export$f08f0dca44fa542,
    backendName: 'wasm',
    setupFunc: $bc515f68b5813683$var$setup,
    kernelFunc: $bc515f68b5813683$var$sparseReshape
};





let $dd6c72cce08963ad$var$wasmSparseSegmentReduction;
function $dd6c72cce08963ad$export$de27182ff8187d6c(backend) {
    $dd6c72cce08963ad$var$wasmSparseSegmentReduction = backend.wasm.cwrap('SparseSegmentReduction', null, [
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $dd6c72cce08963ad$export$ecb2b561be9c3ae3(args, isMean) {
    const { backend: backend , inputs: inputs  } = args;
    const { data: data , indices: indices , segmentIds: segmentIds  } = inputs;
    const numIndices = indices.shape[0];
    const segmentIdsBack = backend.readSync(segmentIds.dataId, numIndices - 1, numIndices)[0];
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIdsBack + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) throw new Error($510a55f99d61727a$exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    const outputShape = data.shape.slice();
    outputShape[0] = outputRows;
    const dataId = backend.dataIdMap.get(data.dataId).id;
    const indicesId = backend.dataIdMap.get(indices.dataId).id;
    const segmentIdsId = backend.dataIdMap.get(segmentIds.dataId).id;
    const output = backend.makeOutput(outputShape, data.dtype);
    const outputId = backend.dataIdMap.get(output.dataId).id;
    const exceptionValues = backend.makeOutput([
        4
    ], 'int32');
    const exceptionValuesId = backend.dataIdMap.get(exceptionValues.dataId).id;
    $dd6c72cce08963ad$var$wasmSparseSegmentReduction(dataId, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[data.dtype], data.shape[0], indicesId, segmentIdsId, outputId, exceptionValuesId, isMean, 0);
    const exceptionValuesArray = backend.readSync(exceptionValues.dataId);
    let exceptionMessage;
    switch(exceptionValuesArray[0]){
        case 0:
            exceptionMessage = $510a55f99d61727a$exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
            break;
        case 1:
            exceptionMessage = $510a55f99d61727a$exports.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
            break;
        case 2:
            exceptionMessage = $510a55f99d61727a$exports.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2]);
            break;
        case 3:
            exceptionMessage = $510a55f99d61727a$exports.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(exceptionValuesArray[1], exceptionValuesArray[2], exceptionValuesArray[3]);
            break;
        default:
            exceptionMessage = '';
    }
    backend.disposeData(exceptionValues.dataId);
    if (exceptionMessage) {
        backend.disposeData(output.dataId);
        throw new Error(exceptionMessage);
    }
    return output;
}


function $85534bddea8f3085$var$sparseSegmentMean(args) {
    return $dd6c72cce08963ad$export$ecb2b561be9c3ae3(args, true);
}
const $85534bddea8f3085$export$51e7224ae14d7f78 = {
    kernelName: $2b76be1e72a8c1db$export$610b077aecc2447b,
    backendName: 'wasm',
    setupFunc: $dd6c72cce08963ad$export$de27182ff8187d6c,
    kernelFunc: $85534bddea8f3085$var$sparseSegmentMean
};




function $df2255d2b53cef4b$var$sparseSegmentSum(args) {
    return $dd6c72cce08963ad$export$ecb2b561be9c3ae3(args, false);
}
const $df2255d2b53cef4b$export$73fa0270f28b9555 = {
    kernelName: $2b76be1e72a8c1db$export$68351c28d7116b56,
    backendName: 'wasm',
    setupFunc: $dd6c72cce08963ad$export$de27182ff8187d6c,
    kernelFunc: $df2255d2b53cef4b$var$sparseSegmentSum
};





function $af65dec4979bd53c$export$c0085d48b0a75d8f(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { x: x  } = inputs;
    const { numOrSizeSplits: numOrSizeSplits , axis: axis  } = attrs;
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    const splitSizes = $510a55f99d61727a$exports.prepareSplitSize(x, numOrSizeSplits, $axis);
    const begin = new Array(x.shape.length).fill(0);
    const size = x.shape.slice();
    return splitSizes.map((s)=>{
        const xSliceSize = [
            ...size
        ];
        xSliceSize[$axis] = s;
        const xSlice = $07557125b4fa10ce$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            attrs: {
                begin: begin,
                size: xSliceSize
            },
            backend: backend
        });
        begin[$axis] += s;
        return xSlice;
    });
}
const $af65dec4979bd53c$export$317be24be3af9ea0 = {
    kernelName: $2b76be1e72a8c1db$export$8dffabb4071f05aa,
    backendName: 'wasm',
    kernelFunc: $af65dec4979bd53c$export$c0085d48b0a75d8f
};




const $2a6c702daa7d68ec$export$a592ba9268f10eeb = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$21ab404ab9d512a6);




const $8f1e09469c6ee1e7$export$7c77bece4d51efc4 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$b09fb900337259de);




const $d9f22d55da62dbfa$var$supportsFullBroadcast = true;
const $d9f22d55da62dbfa$export$9ed4691d69db8a43 = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$2f922d20d66089c6, $d9f22d55da62dbfa$var$supportsFullBroadcast);




let $e79a97b2d2f8404f$var$wasmStep;
function $e79a97b2d2f8404f$var$setup(backend) {
    $e79a97b2d2f8404f$var$wasmStep = backend.wasm.cwrap($2b76be1e72a8c1db$export$fd55ce593607084a, null, [
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $e79a97b2d2f8404f$var$step(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { alpha: alpha  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const out = backend.makeOutput(x.shape, x.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $e79a97b2d2f8404f$var$wasmStep(xId, alpha, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], outId);
    return out;
}
const $e79a97b2d2f8404f$export$c42ffaf52eb2647 = {
    kernelName: $2b76be1e72a8c1db$export$fd55ce593607084a,
    backendName: 'wasm',
    setupFunc: $e79a97b2d2f8404f$var$setup,
    kernelFunc: $e79a97b2d2f8404f$var$step
};





let $07be106cb984e291$var$wasmStridedSlice;
function $07be106cb984e291$var$setup(backend) {
    $07be106cb984e291$var$wasmStridedSlice = backend.wasm.cwrap($2b76be1e72a8c1db$export$60c7f9ac271417a9, null, [
        'number',
        'array',
        'number',
        'array',
        'array',
        'array',
        'array',
        'array',
        'number',
        'number', 
    ]);
}
function $07be106cb984e291$export$4ae57224f3b0605c(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { begin: begin , end: end , strides: strides , beginMask: beginMask , endMask: endMask , ellipsisMask: ellipsisMask , newAxisMask: newAxisMask , shrinkAxisMask: shrinkAxisMask  } = attrs;
    const { finalShapeSparse: finalShapeSparse , finalShape: finalShape , isIdentity: isIdentity , sliceDim0: sliceDim0 , isSimpleSlice: isSimpleSlice , begin: $begin , end: $end , strides: $strides  } = $1a8ddf4b5d32c90c$exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) // Optimization #1, slice is a no-op plus reshape
    result = $15ffb328294ad08e$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: finalShape
        }
    });
    else if (sliceDim0 || isSimpleSlice) {
        // Optimization #2, slice is memory contiguous (only occurs in dim 0)
        $f6b55a2021b78f0d$exports.assert(x.shape.length >= 1, ()=>`Input must have rank at least 1, got: ${x.shape.length}`
        );
        const size = $1a8ddf4b5d32c90c$exports.computeOutShape($begin, $end, $strides);
        // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).
        const sliced = $07557125b4fa10ce$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: $begin,
                size: size
            }
        });
        result = $15ffb328294ad08e$export$9eaad88cf88cee2b({
            inputs: {
                x: sliced
            },
            backend: backend,
            attrs: {
                shape: finalShape
            }
        });
        backend.disposeData(sliced.dataId);
    } else {
        const out = backend.makeOutput(finalShapeSparse, 'float32');
        const xId = backend.dataIdMap.get(x.dataId).id;
        const xStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(x.shape)).buffer);
        const beginBytes = new Uint8Array(new Int32Array($begin).buffer);
        const endBytes = new Uint8Array(new Int32Array($end).buffer);
        const stridesBytes = new Uint8Array(new Int32Array($strides).buffer);
        const outputShapeBytes = new Uint8Array(new Int32Array(finalShapeSparse).buffer);
        const outStridesBytes = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(finalShapeSparse)).buffer);
        const outId = backend.dataIdMap.get(out.dataId).id;
        $07be106cb984e291$var$wasmStridedSlice(xId, xStridesBytes, x.shape.length, beginBytes, endBytes, stridesBytes, outputShapeBytes, outStridesBytes, finalShapeSparse.length, outId);
        result = $15ffb328294ad08e$export$9eaad88cf88cee2b({
            inputs: {
                x: out
            },
            backend: backend,
            attrs: {
                shape: finalShape
            }
        });
        backend.disposeData(out.dataId);
    }
    return result;
}
const $07be106cb984e291$export$81773633114187bd = {
    kernelName: $2b76be1e72a8c1db$export$60c7f9ac271417a9,
    backendName: 'wasm',
    setupFunc: $07be106cb984e291$var$setup,
    kernelFunc: $07be106cb984e291$export$4ae57224f3b0605c
};




const $a35fe43b0dada1aa$var$supportsFullBroadcast = true;
const $a35fe43b0dada1aa$export$5d068476dad60c4d = $0e332ad1f17d7d5e$export$643f3601638ef87a($2b76be1e72a8c1db$export$d7a01e11500dfb6f, $a35fe43b0dada1aa$var$supportsFullBroadcast);





let $85c1b41f8b73ba94$var$wasmSum;
function $85c1b41f8b73ba94$var$setup(backend) {
    $85c1b41f8b73ba94$var$wasmSum = backend.wasm.cwrap($2b76be1e72a8c1db$export$534760f50726d5, null, [
        'number',
        'number',
        'number',
        'number', 
    ]);
}
function $85c1b41f8b73ba94$var$sum(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    let inputId = xId;
    let input = x;
    const { transposed: transposed , axes: axes , originalAxes: originalAxes , inputWasTransposed: inputWasTransposed  } = $7c2e049b57785259$export$822718f51723d8ff(x, axis, backend);
    let reductionAxes = axes;
    if (inputWasTransposed) {
        const transposedId = backend.dataIdMap.get(transposed.dataId).id;
        if (transposedId !== xId) {
            // transpose was not a no-op. We will need to dispose of this
            // once we are done.
            input = transposed;
            inputId = transposedId;
            reductionAxes = $510a55f99d61727a$exports.getInnerMostAxes(reductionAxes.length, input.shape.length);
        }
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('sum', reductionAxes, input.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(input.shape, reductionAxes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const out = backend.makeOutput(outShape, input.dtype);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) !== 0) {
        const outId = backend.dataIdMap.get(out.dataId).id;
        $85c1b41f8b73ba94$var$wasmSum(inputId, reduceSize, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[out.dtype], outId);
    }
    if (inputWasTransposed) // dispose of the transposed tensor.
    backend.disposeData(transposed.dataId);
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(out.shape, originalAxes);
        out.shape = newShape;
    }
    return out;
}
const $85c1b41f8b73ba94$export$47edea402251c258 = {
    kernelName: $2b76be1e72a8c1db$export$534760f50726d5,
    backendName: 'wasm',
    setupFunc: $85c1b41f8b73ba94$var$setup,
    kernelFunc: $85c1b41f8b73ba94$var$sum
};




const $7760284a82e53c7b$export$97648844df7611f3 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$115b2d5263ba5985);




const $7e3cd47a8f6fc786$export$a2fc7de1a1e4eee0 = $ac378055f5ed31b0$export$1064a4367d46e10e($2b76be1e72a8c1db$export$893b6e865e352c83);




let $60019c2afff39dc1$var$wasmTile;
function $60019c2afff39dc1$var$setup(backend) {
    $60019c2afff39dc1$var$wasmTile = backend.wasm.cwrap($2b76be1e72a8c1db$export$235cb65c20ad2b7, null, [
        'number',
        'array',
        'number',
        'array',
        'number',
        'number' // out_id
    ]);
}
function $60019c2afff39dc1$var$tile(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const { reps: reps  } = attrs;
    const newShape = new Array(x.shape.length);
    for(let i = 0; i < newShape.length; i++)newShape[i] = x.shape[i] * reps[i];
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    const newShapeBytes = new Uint8Array(new Int32Array(newShape).buffer);
    const out = backend.makeOutput(newShape, x.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    $60019c2afff39dc1$var$wasmTile(xId, xShapeBytes, x.shape.length, newShapeBytes, newShape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[out.dtype], outId);
    return out;
}
const $60019c2afff39dc1$export$a5a9f8050ba7f41e = {
    kernelName: $2b76be1e72a8c1db$export$235cb65c20ad2b7,
    backendName: 'wasm',
    setupFunc: $60019c2afff39dc1$var$setup,
    kernelFunc: $60019c2afff39dc1$var$tile
};




let $c607af14e91c06f3$var$wasmTopK;
function $c607af14e91c06f3$var$setup(backend) {
    $c607af14e91c06f3$var$wasmTopK = backend.wasm.cwrap($2b76be1e72a8c1db$export$c593cd1ea0d02ebd, null, [
        'number',
        'array',
        'number',
        'number',
        'number',
        'bool',
        'number',
        'number', 
    ]);
}
const $c607af14e91c06f3$export$4e6b28a600f8b4df = ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
    const { x: x  } = inputs;
    const { k: k , sorted: sorted  } = attrs;
    const xId = backend.dataIdMap.get(x.dataId).id;
    const xShapeBytes = new Uint8Array(new Int32Array(x.shape).buffer);
    const outputShape = x.shape.slice();
    outputShape[outputShape.length - 1] = k;
    const outValues = backend.makeOutput(outputShape, x.dtype);
    const outValuesId = backend.dataIdMap.get(outValues.dataId).id;
    const outIndices = backend.makeOutput(outputShape, 'int32');
    const outIndicesId = backend.dataIdMap.get(outIndices.dataId).id;
    $c607af14e91c06f3$var$wasmTopK(xId, xShapeBytes, x.shape.length, $1ac51db5370ba6a2$export$7b843996b6cf8ee0[x.dtype], k, sorted, outValuesId, outIndicesId);
    return [
        outValues,
        outIndices
    ];
};
const $c607af14e91c06f3$export$cffaee31213314ce = {
    kernelName: $2b76be1e72a8c1db$export$c593cd1ea0d02ebd,
    backendName: 'wasm',
    setupFunc: $c607af14e91c06f3$var$setup,
    kernelFunc: $c607af14e91c06f3$export$4e6b28a600f8b4df
};



let $9ba47dc6d343f9a1$var$wasmTransform;
function $9ba47dc6d343f9a1$var$setup(backend) {
    $9ba47dc6d343f9a1$var$wasmTransform = backend.wasm.cwrap($2b76be1e72a8c1db$export$563a914cafbdc389, null, [
        'number',
        'number',
        'bool',
        'number',
        'number',
        'number',
        'number',
        'number',
        'number',
        'array',
        'number',
        'number',
        'number',
        'number',
        'number' // outId
    ]);
}
function $9ba47dc6d343f9a1$var$transform(args) {
    const { backend: backend , inputs: inputs , attrs: attrs  } = args;
    const { image: image , transforms: transforms  } = inputs;
    const { interpolation: interpolation , fillMode: fillMode , fillValue: fillValue , outputShape: outputShape  } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [
        imageHeight,
        imageWidth
    ];
    const outShape = [
        batch,
        outHeight,
        outWidth,
        numChannels
    ];
    const strides = new Uint8Array(new Int32Array($f6b55a2021b78f0d$exports.computeStrides(image.shape)).buffer);
    const out = backend.makeOutput(outShape, image.dtype);
    const outId = backend.dataIdMap.get(out.dataId).id;
    const imageData = backend.dataIdMap.get(image.dataId);
    const imageId = imageData.id;
    const transformsData = backend.dataIdMap.get(transforms.dataId);
    const transformsId = transformsData.id;
    const interpolationModeId = interpolation === 'nearest' ? 1 : 2;
    let fillModeId;
    switch(fillMode){
        case 'constant':
            fillModeId = 1;
            break;
        case 'reflect':
            fillModeId = 2;
            break;
        case 'wrap':
            fillModeId = 3;
            break;
        case 'nearest':
            fillModeId = 4;
            break;
        default:
            fillModeId = 1;
            break;
    }
    $9ba47dc6d343f9a1$var$wasmTransform(imageId, transformsId, transforms.shape[0] > 1, batch, outHeight, outWidth, numChannels, imageWidth, imageHeight, strides, image.shape.length - 1, interpolationModeId, fillModeId, fillValue, outId);
    return out;
}
const $9ba47dc6d343f9a1$export$1c7a3de6335954ed = {
    kernelName: $2b76be1e72a8c1db$export$563a914cafbdc389,
    backendName: 'wasm',
    setupFunc: $9ba47dc6d343f9a1$var$setup,
    kernelFunc: $9ba47dc6d343f9a1$var$transform
};





function $545c039306db6e11$var$unpack(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { value: value  } = inputs;
    let { axis: axis  } = attrs;
    if (axis < 0) axis += value.shape.length;
    const numOutputs = value.shape[axis];
    const rank = value.shape.length;
    const outShape = new Array(rank - 1);
    let outIndex = 0;
    for(let i = 0; i < rank; i++)if (i !== axis) outShape[outIndex++] = value.shape[i];
    const outs = new Array(numOutputs);
    const begin = new Array(rank).fill(0);
    const size = value.shape.slice();
    size[axis] = 1;
    for(let i1 = 0; i1 < outs.length; i1++){
        begin[axis] = i1;
        outs[i1] = $07557125b4fa10ce$export$58adb3bec8346d0f({
            inputs: {
                x: value
            },
            attrs: {
                begin: begin,
                size: size
            },
            backend: backend
        });
    }
    return outs.map(({ dataId: dataId , dtype: dtype  })=>({
            dataId: dataId,
            dtype: dtype,
            shape: outShape
        })
    );
}
const $545c039306db6e11$export$d06292128cae50d6 = {
    kernelName: $2b76be1e72a8c1db$export$441ad6bfc5db8ab4,
    backendName: 'wasm',
    kernelFunc: $545c039306db6e11$var$unpack
};



function $8b916883ed6a14d3$var$zerosLike(args) {
    const { inputs: { x: x  } , backend: backend  } = args;
    const out = backend.makeOutput(x.shape, x.dtype);
    const outVals = backend.typedArrayFromHeap(out);
    outVals.fill(0);
    return out;
}
const $8b916883ed6a14d3$export$15368df05c479e41 = {
    kernelName: $2b76be1e72a8c1db$export$430969a37eda1e88,
    backendName: 'wasm',
    kernelFunc: $8b916883ed6a14d3$var$zerosLike
};


// List all kernel configs here
const $19bc91315c0d1054$var$kernelConfigs = [
    $f88b0814e43a2190$export$f70d36da1c218f84,
    $a49d18fa8cce21b2$export$d66f48648b9d5ec7,
    $7dc325cdec1e1476$export$b1f3a580afb68e4c,
    $14510e08281e9f8e$export$ff8000bc6f0313e1,
    $54b2429a14de742e$export$4e3f081eb1a330fa,
    $b3f8c340aca5b6bc$export$1a8ff634f2df3da6,
    $4849af9fb9711c3c$export$ec7419fc9ad0069e,
    $430a8b279a0d0d38$export$6c901824a23e6150,
    $8ddacab274e09b13$export$d0dd993198185538,
    $e91403e9acfb3c4b$export$44e08e19f97e5513,
    $5f61adf1f6e221a6$export$ac4d0f0f3927a8f3,
    $d10dac12345763ee$export$df387212b1898306,
    $8fd9c617d2200619$export$f7ee8f07ce0ff4e1,
    $0e9184a3b7ffed94$export$c8cf96dae25282e5,
    $43c4f630994c7964$export$4a39bf13b4378042,
    $32d507adcf78b818$export$19bbc19fff1ed26f,
    $c3b5681bdd2d8367$export$ff099a1da5235a7e,
    $9ee33fa3fdcfbc6e$export$c5824052b09ba0ed,
    $08e569ab1de6991f$export$f7086edcf0050c7f,
    $5e250da6be6fd779$export$db50d81ed60c5a35,
    $8027aaad2a19feb6$export$2f6196f3316e7ed2,
    $a13983ee83dd5c7b$export$9c5b88dcb1d2008b,
    $7c663e664c42ee7d$export$240667804b7c390e,
    $aff9bcacc9c83cf0$export$b990686634ee3cce,
    $698a9e6f41506fcc$export$3c8bc3d8ee318217,
    $f6c186b41506887e$export$2fd7ea0fcf021f34,
    $8c1575fcdb3c587f$export$86341ba0ce5d8e60,
    $ceb5f9a9a3fa695f$export$c953bf474b2bde62,
    $6bad538bf202dbbb$export$c9ec83cb23304466,
    $e65c855f1cf93e00$export$7e9a0f96fa6bd01c,
    $f24299d1496aac2e$export$7eac933a0c7fd37f,
    $9cc7dfd324f9273c$export$bfc6b905951b4903,
    $7052ee69be0c491f$export$5b64efa829ddf94e,
    $164208bc5c0c2232$export$58481cc3409b412c,
    $ab98cdbcc226bc2a$export$d9700eb1c7f5c969,
    $eea0deee3a607b90$export$b1bd3139c91d8765,
    $c2fc3698976e847e$export$8c4f7e92d92310f8,
    $8f343a93fa6e18e0$export$7a6926f9fcac24ca,
    $2d04234e8e22f7e1$export$c426d3942537ad84,
    $54b8337ea5c90a9b$export$aa04ab963fdf437f,
    $85d884d8ef6fafe0$export$8d4530ce8b6ffc3c,
    $45b8069d467fb1c0$export$9f26bd257393dd8,
    $714bf2c41b253bc4$export$a4ae1f00643ddd14,
    $838c61cff03ff2bd$export$257f1e82e69113fb,
    $7da93261defccda4$export$7d79147246e312bb,
    $06be692ec771ec1a$export$45b97bdc342e72a2,
    $ed8bec49fe41b832$export$45c8263b38f19e33,
    $ad841bfc9e9c9c70$export$b934af0ccd0cdbe1,
    $354f15c871b5f9f0$export$3cd9f9a31b38cf18,
    $b38f0528e95e8aaf$export$ea24ffbbbce8d546,
    $5ff88d381308aa8a$export$2cfd6c6c7daeb5fc,
    $e480075b484d2988$export$745576778aafee88,
    $fb247c951dd503d9$export$cc7b18b8229c3db,
    $a4ab8100f6e8356b$export$549561cd158f260a,
    $835ecb14c3a68c0d$export$906b8fb32c570e9d,
    $fa637e310b940322$export$4c00b682f309701d,
    $80246a0f3e207f5d$export$d003d4d7e1500775,
    $2d53390dfc452cca$export$dde5645b472b80b2,
    $9d30096db190e417$export$d8d7015eb6ab37d0,
    $0c14524ae70d4d85$export$1645fa8803aa1f86,
    $929531b1c09f1ddf$export$b0317e720bfd61fc,
    $6602eada984e14ba$export$b823d49786719761,
    $3a405a5643bdab58$export$a5c4a9b694579636,
    $613c9a9fcac53b4c$export$d556aa935cef5c0c,
    $aab44279a516b85d$export$361c4075706e31c2,
    $ecdfefebed01499e$export$15c5d6176b30b9a6,
    $d6f67b26a49d4218$export$731f9199bde068eb,
    $4a04483a8f11691e$export$92c30890ad649d53,
    $15ffb328294ad08e$export$cfa02e698602aca2,
    $94b5bb1f759f5f26$export$a37a56137abc1357,
    $c23f48e232c70411$export$cab6a4e8d2ed8e8d,
    $4ce6a1bca127238b$export$44ba8c83417ab668,
    $a080ea3221b52801$export$6c09e3291f636503,
    $0508f0fe7e951840$export$941104b789956ef6,
    $fbaa972b09ed0729$export$573371744f044f5,
    $c079902389d4f86f$export$7ff911e710ee72fc,
    $8d2970e1cecc2bc5$export$195d1cf7c59f3ef,
    $080f047c992b94f5$export$d993ec4e5c253b66,
    $07557125b4fa10ce$export$8d8a1e11dd2cc6c4,
    $443a30d32b2d0325$export$c022691f23e2ee69,
    $52f0a50b4a7cee2e$export$2f85417863d2050b,
    $b145ff42e1f40016$export$818286c593224d1a,
    $bc515f68b5813683$export$eb106efc10374803,
    $85534bddea8f3085$export$51e7224ae14d7f78,
    $df2255d2b53cef4b$export$73fa0270f28b9555,
    $af65dec4979bd53c$export$317be24be3af9ea0,
    $2a6c702daa7d68ec$export$a592ba9268f10eeb,
    $8f1e09469c6ee1e7$export$7c77bece4d51efc4,
    $d9f22d55da62dbfa$export$9ed4691d69db8a43,
    $e79a97b2d2f8404f$export$c42ffaf52eb2647,
    $07be106cb984e291$export$81773633114187bd,
    $a35fe43b0dada1aa$export$5d068476dad60c4d,
    $85c1b41f8b73ba94$export$47edea402251c258,
    $7760284a82e53c7b$export$97648844df7611f3,
    $7e3cd47a8f6fc786$export$a2fc7de1a1e4eee0,
    $60019c2afff39dc1$export$a5a9f8050ba7f41e,
    $c607af14e91c06f3$export$cffaee31213314ce,
    $9ba47dc6d343f9a1$export$1c7a3de6335954ed,
    $1c71bf11e4cf3d4a$export$895a002a39b774be,
    $545c039306db6e11$export$d06292128cae50d6,
    $8b916883ed6a14d3$export$15368df05c479e41
];
for (const kernelConfig of $19bc91315c0d1054$var$kernelConfigs)$18a84b897e201316$export$f3f7c443f3a606e6(kernelConfig);



const $86580dac311e8670$var$ENV = $78e7329b437d1e00$export$a7b6bc01c63cdfc3();
/**
 * True if SIMD is supported.
 */ // From: https://github.com/GoogleChromeLabs/wasm-feature-detect
$86580dac311e8670$var$ENV.registerFlag(// This typed array passed in to WebAssembly.validate is WebAssembly binary
// code. In this case it is a small program that contains SIMD
// instructions.
'WASM_HAS_SIMD_SUPPORT', async ()=>WebAssembly.validate(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        4,
        1,
        96,
        0,
        0,
        3,
        2,
        1,
        0,
        10,
        9,
        1,
        7,
        0,
        65,
        0,
        253,
        15,
        26,
        11
    ]))
);
/**
 * True if threads are supported.
 */ // From: https://github.com/GoogleChromeLabs/wasm-feature-detect
$86580dac311e8670$var$ENV.registerFlag('WASM_HAS_MULTITHREAD_SUPPORT', async ()=>{
    // TODO(annxingyuan): Enable node support once this is resolved:
    // https://github.com/tensorflow/tfjs/issues/3830
    if ($86580dac311e8670$var$ENV.get('IS_NODE')) return false;
    try {
        // Test for transferability of SABs (needed for Firefox)
        // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ
        new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        // This typed array is a WebAssembly program containing threaded
        // instructions.
        return WebAssembly.validate(new Uint8Array([
            0,
            97,
            115,
            109,
            1,
            0,
            0,
            0,
            1,
            4,
            1,
            96,
            0,
            0,
            3,
            2,
            1,
            0,
            5,
            4,
            1,
            3,
            1,
            1,
            10,
            11,
            1,
            9,
            0,
            65,
            0,
            254,
            16,
            2,
            0,
            26,
            11
        ]));
    } catch (e) {
        return false;
    }
});





var $45d650a2999915c1$exports = {};
var $45d650a2999915c1$var$__filename = "node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm-threaded-simd.js";

var $3tEm6 = parcelRequire("3tEm6");
var $45d650a2999915c1$var$__dirname = "node_modules/@tensorflow/tfjs-backend-wasm/wasm-out";






var $45d650a2999915c1$var$WasmBackendModuleThreadedSimd = (()=>{
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    if (typeof $45d650a2999915c1$var$__filename !== 'undefined') _scriptDir = _scriptDir || $45d650a2999915c1$var$__filename;
    return function(WasmBackendModuleThreadedSimd) {
        WasmBackendModuleThreadedSimd = WasmBackendModuleThreadedSimd || {};
        function GROWABLE_HEAP_I8() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAP8;
        }
        function GROWABLE_HEAP_U8() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAPU8;
        }
        function GROWABLE_HEAP_I16() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAP16;
        }
        function GROWABLE_HEAP_U16() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAPU16;
        }
        function GROWABLE_HEAP_I32() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAP32;
        }
        function GROWABLE_HEAP_F32() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAPF32;
        }
        function GROWABLE_HEAP_F64() {
            if (wasmMemory.buffer != buffer1) updateGlobalBufferAndViews(wasmMemory.buffer);
            return HEAPF64;
        }
        var Module = typeof WasmBackendModuleThreadedSimd !== "undefined" ? WasmBackendModuleThreadedSimd : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        var beforeListeners;
        if (typeof $3tEm6 !== "undefined" && $3tEm6.listeners) beforeListeners = {
            uncaughtException: $3tEm6.listeners("uncaughtException"),
            unhandledRejection: $3tEm6.listeners("unhandledRejection")
        };
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow)=>{
            throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof $3tEm6 === "object" && typeof $3tEm6.versions === "object" && typeof $3tEm6.versions.node === "string";
        var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) return Module["locateFile"](path, scriptDirectory);
            return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        function logExceptionOnExit(e) {
            if (e instanceof ExitStatus) return;
            let toLog = e;
            err1("exiting due to exception: " + toLog);
        }
        var fs;
        var nodePath;
        var requireNodeFS;
        if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) scriptDirectory = (parcelRequire("ltudh")).dirname(scriptDirectory) + "/";
            else scriptDirectory = $45d650a2999915c1$var$__dirname + "/";
            requireNodeFS = ()=>{
                if (!nodePath) {
                    fs = (parcelRequire("ltudh"));
                    nodePath = (parcelRequire("ltudh"));
                }
            };
            read_ = function shell_read(filename, binary) {
                requireNodeFS();
                filename = nodePath["normalize"](filename);
                return fs.readFileSync(filename, binary ? undefined : "utf8");
            };
            readBinary = (filename)=>{
                var ret = read_(filename, true);
                if (!ret.buffer) ret = new Uint8Array(ret);
                return ret;
            };
            readAsync = (filename, onload, onerror)=>{
                requireNodeFS();
                filename = nodePath["normalize"](filename);
                fs.readFile(filename, function(err, data) {
                    if (err) onerror(err);
                    else onload(data.buffer);
                });
            };
            if ($3tEm6["argv"].length > 1) thisProgram = $3tEm6["argv"][1].replace(/\\/g, "/");
            arguments_ = $3tEm6["argv"].slice(2);
            $3tEm6["on"]("uncaughtException", function(ex) {
                if (!(ex instanceof ExitStatus)) throw ex;
            });
            $3tEm6["on"]("unhandledRejection", function(reason) {
                throw reason;
            });
            quit_ = (status, toThrow)=>{
                if (keepRuntimeAlive()) {
                    $3tEm6["exitCode"] = status;
                    throw toThrow;
                }
                logExceptionOnExit(toThrow);
                $3tEm6["exit"](status);
            };
            Module["inspect"] = function() {
                return "[Emscripten Module object]";
            };
            let nodeWorkerThreads;
            try {
                nodeWorkerThreads = (parcelRequire("ltudh"));
            } catch (e) {
                console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
                throw e;
            }
            $parcel$global.Worker = nodeWorkerThreads.Worker;
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;
            else if (typeof document !== "undefined" && document.currentScript) scriptDirectory = document.currentScript.src;
            if (typeof _scriptDir !== "undefined" && _scriptDir) scriptDirectory = _scriptDir;
            if (scriptDirectory.indexOf("blob:") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            else scriptDirectory = "";
            if (!ENVIRONMENT_IS_NODE) {
                read_ = (url)=>{
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", url, false);
                    xhr.send(null);
                    return xhr.responseText;
                };
                if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", url, false);
                    xhr.responseType = "arraybuffer";
                    xhr.send(null);
                    return new Uint8Array(xhr.response);
                };
                readAsync = (url, onload, onerror)=>{
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", url, true);
                    xhr.responseType = "arraybuffer";
                    xhr.onload = ()=>{
                        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                            onload(xhr.response);
                            return;
                        }
                        onerror();
                    };
                    xhr.onerror = onerror;
                    xhr.send(null);
                };
            }
            setWindowTitle = (title)=>document.title = title
            ;
        }
        if (ENVIRONMENT_IS_NODE) {
            if (typeof performance === "undefined") $parcel$global.performance = (parcelRequire("ltudh")).performance;
        }
        var defaultPrint = console.log.bind(console);
        var defaultPrintErr = console.warn.bind(console);
        if (ENVIRONMENT_IS_NODE) {
            requireNodeFS();
            defaultPrint = (str)=>fs.writeSync(1, str + "\n")
            ;
            defaultPrintErr = (str)=>fs.writeSync(2, str + "\n")
            ;
        }
        var out = Module["print"] || defaultPrint;
        var err1 = Module["printErr"] || defaultPrintErr;
        Object.assign(Module, moduleOverrides);
        moduleOverrides = null;
        if (Module["arguments"]) arguments_ = Module["arguments"];
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        if (Module["quit"]) quit_ = Module["quit"];
        var POINTER_SIZE = 4;
        function warnOnce(text) {
            if (!warnOnce.shown) warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
                warnOnce.shown[text] = 1;
                err1(text);
            }
        }
        function convertJsFunctionToWasm(func, sig) {
            if (typeof WebAssembly.Function === "function") {
                var typeNames = {
                    "i": "i32",
                    "j": "i64",
                    "f": "f32",
                    "d": "f64"
                };
                var type = {
                    parameters: [],
                    results: sig[0] == "v" ? [] : [
                        typeNames[sig[0]]
                    ]
                };
                for(var i = 1; i < sig.length; ++i)type.parameters.push(typeNames[sig[i]]);
                return new WebAssembly.Function(type, func);
            }
            var typeSection = [
                1,
                0,
                1,
                96
            ];
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
                "i": 127,
                "j": 126,
                "f": 125,
                "d": 124
            };
            typeSection.push(sigParam.length);
            for(var i = 0; i < sigParam.length; ++i)typeSection.push(typeCodes[sigParam[i]]);
            if (sigRet == "v") typeSection.push(0);
            else typeSection = typeSection.concat([
                1,
                typeCodes[sigRet]
            ]);
            typeSection[1] = typeSection.length - 2;
            var bytes = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0
            ].concat(typeSection, [
                2,
                7,
                1,
                1,
                101,
                1,
                102,
                0,
                0,
                7,
                5,
                1,
                1,
                102,
                0,
                0
            ]));
            var module = new WebAssembly.Module(bytes);
            var instance = new WebAssembly.Instance(module, {
                "e": {
                    "f": func
                }
            });
            var wrappedFunc = instance.exports["f"];
            return wrappedFunc;
        }
        var freeTableIndexes = [];
        var functionsInTableMap;
        function getEmptyTableSlot() {
            if (freeTableIndexes.length) return freeTableIndexes.pop();
            try {
                wasmTable.grow(1);
            } catch (err) {
                if (!(err instanceof RangeError)) throw err;
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
        }
        function updateTableMap(offset, count) {
            for(var i = offset; i < offset + count; i++){
                var item = getWasmTableEntry(i);
                if (item) functionsInTableMap.set(item, i);
            }
        }
        var tempRet0 = 0;
        var setTempRet0 = (value)=>{
            tempRet0 = value;
        };
        var Atomics_load = Atomics.load;
        var Atomics_store = Atomics.store;
        var Atomics_compareExchange = Atomics.compareExchange;
        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") abort("no native wasm support detected");
        var wasmMemory;
        var wasmModule;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
            if (!condition) abort(text);
        }
        function getCFunc(ident) {
            var func = Module["_" + ident];
            return func;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
            var toC = {
                "string": function(str) {
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) {
                        var len = (str.length << 2) + 1;
                        ret = stackAlloc(len);
                        stringToUTF8(str, ret, len);
                    }
                    return ret;
                },
                "array": function(arr) {
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                }
            };
            function convertReturnValue(ret) {
                if (returnType === "string") return UTF8ToString(ret);
                if (returnType === "boolean") return Boolean(ret);
                return ret;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args) for(var i = 0; i < args.length; i++){
                var converter = toC[argTypes[i]];
                if (converter) {
                    if (stack === 0) stack = stackSave();
                    cArgs[i] = converter(args[i]);
                } else cArgs[i] = args[i];
            }
            var ret1 = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
            }
            ret1 = onDone(ret1);
            return ret1;
        }
        function cwrap(ident, returnType, argTypes, opts) {
            argTypes = argTypes || [];
            var numericArgs = argTypes.every(function(type) {
                return type === "number";
            });
            var numericRet = returnType !== "string";
            if (numericRet && numericArgs && !opts) return getCFunc(ident);
            return function() {
                return ccall(ident, returnType, argTypes, arguments, opts);
            };
        }
        var ALLOC_STACK = 1;
        function TextDecoderWrapper(encoding) {
            var textDecoder = new TextDecoder(encoding);
            this.decode = (data)=>{
                if (data.buffer instanceof SharedArrayBuffer) data = new Uint8Array(data);
                return textDecoder.decode.call(textDecoder, data);
            };
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf8") : undefined;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while(heap[endPtr] && !(endPtr >= endIdx))++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) return UTF8Decoder.decode(heap.subarray(idx, endPtr));
            else {
                var str = "";
                while(idx < endPtr){
                    var u0 = heap[idx++];
                    if (!(u0 & 128)) {
                        str += String.fromCharCode(u0);
                        continue;
                    }
                    var u1 = heap[idx++] & 63;
                    if ((u0 & 224) == 192) {
                        str += String.fromCharCode((u0 & 31) << 6 | u1);
                        continue;
                    }
                    var u2 = heap[idx++] & 63;
                    if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                    else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
                    if (u0 < 65536) str += String.fromCharCode(u0);
                    else {
                        var ch = u0 - 65536;
                        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                    }
                }
            }
            return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for(var i = 0; i < str.length; ++i){
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                    var u1 = str.charCodeAt(++i);
                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;
                }
                if (u <= 127) {
                    if (outIdx >= endIdx) break;
                    heap[outIdx++] = u;
                } else if (u <= 2047) {
                    if (outIdx + 1 >= endIdx) break;
                    heap[outIdx++] = 192 | u >> 6;
                    heap[outIdx++] = 128 | u & 63;
                } else if (u <= 65535) {
                    if (outIdx + 2 >= endIdx) break;
                    heap[outIdx++] = 224 | u >> 12;
                    heap[outIdx++] = 128 | u >> 6 & 63;
                    heap[outIdx++] = 128 | u & 63;
                } else {
                    if (outIdx + 3 >= endIdx) break;
                    heap[outIdx++] = 240 | u >> 18;
                    heap[outIdx++] = 128 | u >> 12 & 63;
                    heap[outIdx++] = 128 | u >> 6 & 63;
                    heap[outIdx++] = 128 | u & 63;
                }
            }
            heap[outIdx] = 0;
            return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
            var len = 0;
            for(var i = 0; i < str.length; ++i){
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
                if (u <= 127) ++len;
                else if (u <= 2047) len += 2;
                else if (u <= 65535) len += 3;
                else len += 4;
            }
            return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf-16le") : undefined;
        function writeArrayToMemory(array, buffer) {
            GROWABLE_HEAP_I8().set(array, buffer);
        }
        function writeAsciiToMemory(str, buffer, dontAddNull) {
            for(var i = 0; i < str.length; ++i)GROWABLE_HEAP_I8()[(buffer++) >> 0] = str.charCodeAt(i);
            if (!dontAddNull) GROWABLE_HEAP_I8()[buffer >> 0] = 0;
        }
        function alignUp(x, multiple) {
            if (x % multiple > 0) x += multiple - x % multiple;
            return x;
        }
        var buffer1, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        if (ENVIRONMENT_IS_PTHREAD) buffer1 = Module["buffer"];
        function updateGlobalBufferAndViews(buf) {
            buffer1 = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (ENVIRONMENT_IS_PTHREAD) {
            wasmMemory = Module["wasmMemory"];
            buffer1 = Module["buffer"];
        } else if (Module["wasmMemory"]) wasmMemory = Module["wasmMemory"];
        else {
            wasmMemory = new WebAssembly.Memory({
                "initial": INITIAL_MEMORY / 65536,
                "maximum": 32768,
                "shared": true
            });
            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
                err1("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
                if (ENVIRONMENT_IS_NODE) console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
                throw Error("bad memory");
            }
        }
        if (wasmMemory) buffer1 = wasmMemory.buffer;
        INITIAL_MEMORY = buffer1.byteLength;
        updateGlobalBufferAndViews(buffer1);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATEXIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [
                    Module["preRun"]
                ];
                while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift());
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
            runtimeInitialized = true;
            if (ENVIRONMENT_IS_PTHREAD) return;
            callRuntimeCallbacks(__ATINIT__);
        }
        function exitRuntime() {
            if (ENVIRONMENT_IS_PTHREAD) return;
            PThread.terminateAllThreads();
            runtimeExited = true;
        }
        function postRun() {
            if (ENVIRONMENT_IS_PTHREAD) return;
            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [
                    Module["postRun"]
                ];
                while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift());
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
        }
        function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (runDependencies == 0) {
                if (runDependencyWatcher !== null) {
                    clearInterval(runDependencyWatcher);
                    runDependencyWatcher = null;
                }
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback();
                }
            }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
            if (ENVIRONMENT_IS_PTHREAD) postMessage({
                "cmd": "onAbort",
                "arg": what
            });
            else if (Module["onAbort"]) Module["onAbort"](what);
            what = "Aborted(" + what + ")";
            err1(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "tfjs-backend-wasm-threaded-simd.wasm";
        if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);
        function getBinary(file) {
            try {
                if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                if (readBinary) return readBinary(file);
                else throw "both async and sync fetching of the wasm failed";
            } catch (err) {
                abort(err);
            }
        }
        function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                }).then(function(response) {
                    if (!response["ok"]) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                    return response["arrayBuffer"]();
                }).catch(function() {
                    return getBinary(wasmBinaryFile);
                });
                else {
                    if (readAsync) return new Promise(function(resolve, reject) {
                        readAsync(wasmBinaryFile, function(response) {
                            resolve(new Uint8Array(response));
                        }, reject);
                    });
                }
            }
            return Promise.resolve().then(function() {
                return getBinary(wasmBinaryFile);
            });
        }
        function createWasm() {
            var info = {
                "env": asmLibraryArg,
                "wasi_snapshot_preview1": asmLibraryArg
            };
            function receiveInstance(instance, module) {
                var exports = instance.exports;
                Module["asm"] = exports;
                registerTlsInit(Module["asm"]["emscripten_tls_init"]);
                wasmTable = Module["asm"]["__indirect_function_table"];
                addOnInit(Module["asm"]["__wasm_call_ctors"]);
                wasmModule = module;
                if (!ENVIRONMENT_IS_PTHREAD) {
                    var numWorkersToLoad = PThread.unusedWorkers.length;
                    PThread.unusedWorkers.forEach(function(w) {
                        PThread.loadWasmModuleToWorker(w, function() {
                            if (!--numWorkersToLoad) removeRunDependency("wasm-instantiate");
                        });
                    });
                }
            }
            if (!ENVIRONMENT_IS_PTHREAD) addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
                receiveInstance(result["instance"], result["module"]);
            }
            function instantiateArrayBuffer(receiver) {
                return getBinaryPromise().then(function(binary) {
                    return WebAssembly.instantiate(binary, info);
                }).then(function(instance) {
                    return instance;
                }).then(receiver, function(reason) {
                    err1("failed to asynchronously prepare wasm: " + reason);
                    abort(reason);
                });
            }
            function instantiateAsync() {
                if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                }).then(function(response) {
                    var result = WebAssembly.instantiateStreaming(response, info);
                    return result.then(receiveInstantiationResult, function(reason) {
                        err1("wasm streaming compile failed: " + reason);
                        err1("falling back to ArrayBuffer instantiation");
                        return instantiateArrayBuffer(receiveInstantiationResult);
                    });
                });
                else return instantiateArrayBuffer(receiveInstantiationResult);
            }
            if (Module["instantiateWasm"]) try {
                var exports1 = Module["instantiateWasm"](info, receiveInstance);
                return exports1;
            } catch (e) {
                err1("Module.instantiateWasm callback failed with error: " + e);
                return false;
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
        }
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = {};
        function callRuntimeCallbacks(callbacks) {
            while(callbacks.length > 0){
                var callback = callbacks.shift();
                if (typeof callback == "function") {
                    callback(Module);
                    continue;
                }
                var func = callback.func;
                if (typeof func === "number") {
                    if (callback.arg === undefined) getWasmTableEntry(func)();
                    else getWasmTableEntry(func)(callback.arg);
                } else func(callback.arg === undefined ? null : callback.arg);
            }
        }
        function withStackSave(f) {
            var stack = stackSave();
            var ret = f();
            stackRestore(stack);
            return ret;
        }
        function demangle(func) {
            return func;
        }
        function demangleAll(text) {
            var regex = /\b_Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
                var y = demangle(x);
                return x === y ? x : y + " [" + x + "]";
            });
        }
        function killThread(pthread_ptr) {
            GROWABLE_HEAP_I32()[pthread_ptr >> 2] = 0;
            var pthread = PThread.pthreads[pthread_ptr];
            delete PThread.pthreads[pthread_ptr];
            pthread.worker.terminate();
            __emscripten_thread_free_data(pthread_ptr);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
            pthread.worker.pthread = undefined;
        }
        function cancelThread(pthread_ptr) {
            var pthread = PThread.pthreads[pthread_ptr];
            pthread.worker.postMessage({
                "cmd": "cancel"
            });
        }
        function cleanupThread(pthread_ptr) {
            var pthread = PThread.pthreads[pthread_ptr];
            if (pthread) {
                GROWABLE_HEAP_I32()[pthread_ptr >> 2] = 0;
                var worker = pthread.worker;
                PThread.returnWorkerToPool(worker);
            }
        }
        function _exit(status) {
            exit(status);
        }
        function handleException(e) {
            if (e instanceof ExitStatus || e == "unwind") return EXITSTATUS;
            quit_(1, e);
        }
        var PThread = {
            unusedWorkers: [],
            runningWorkers: [],
            tlsInitFunctions: [],
            init: function() {
                if (ENVIRONMENT_IS_PTHREAD) PThread.initWorker();
                else PThread.initMainThread();
            },
            initMainThread: function() {
                var pthreadPoolSize = 8;
                for(var i = 0; i < pthreadPoolSize; ++i)PThread.allocateUnusedWorker();
            },
            initWorker: function() {
                noExitRuntime = false;
            },
            pthreads: {},
            setExitStatus: function(status) {
                EXITSTATUS = status;
            },
            terminateAllThreads: function() {
                for(var t in PThread.pthreads){
                    var pthread = PThread.pthreads[t];
                    if (pthread && pthread.worker) PThread.returnWorkerToPool(pthread.worker);
                }
                for(var i = 0; i < PThread.unusedWorkers.length; ++i){
                    var worker = PThread.unusedWorkers[i];
                    worker.terminate();
                }
                PThread.unusedWorkers = [];
            },
            returnWorkerToPool: function(worker) {
                PThread.runWithoutMainThreadQueuedCalls(function() {
                    delete PThread.pthreads[worker.pthread.threadInfoStruct];
                    PThread.unusedWorkers.push(worker);
                    PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
                    __emscripten_thread_free_data(worker.pthread.threadInfoStruct);
                    worker.pthread = undefined;
                });
            },
            runWithoutMainThreadQueuedCalls: function(func) {
                GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >> 2] = 0;
                try {
                    func();
                } finally{
                    GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >> 2] = 1;
                }
            },
            receiveObjectTransfer: function(data) {},
            threadInit: function() {
                for(var i in PThread.tlsInitFunctions)PThread.tlsInitFunctions[i]();
            },
            loadWasmModuleToWorker: function(worker, onFinishedLoading) {
                worker.onmessage = (e)=>{
                    var d = e["data"];
                    var cmd = d["cmd"];
                    if (worker.pthread) PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
                    if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
                        var thread = PThread.pthreads[d.targetThread];
                        if (thread) thread.worker.postMessage(d, d["transferList"]);
                        else err1('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
                        PThread.currentProxiedOperationCallerThread = undefined;
                        return;
                    }
                    if (cmd === "processQueuedMainThreadWork") _emscripten_main_thread_process_queued_calls();
                    else if (cmd === "spawnThread") spawnThread(d);
                    else if (cmd === "cleanupThread") cleanupThread(d["thread"]);
                    else if (cmd === "killThread") killThread(d["thread"]);
                    else if (cmd === "cancelThread") cancelThread(d["thread"]);
                    else if (cmd === "loaded") {
                        worker.loaded = true;
                        if (onFinishedLoading) onFinishedLoading(worker);
                        if (worker.runPthread) {
                            worker.runPthread();
                            delete worker.runPthread;
                        }
                    } else if (cmd === "print") out("Thread " + d["threadId"] + ": " + d["text"]);
                    else if (cmd === "printErr") err1("Thread " + d["threadId"] + ": " + d["text"]);
                    else if (cmd === "alert") alert("Thread " + d["threadId"] + ": " + d["text"]);
                    else if (d.target === "setimmediate") worker.postMessage(d);
                    else if (cmd === "onAbort") {
                        if (Module["onAbort"]) Module["onAbort"](d["arg"]);
                    } else err1("worker sent an unknown command " + cmd);
                    PThread.currentProxiedOperationCallerThread = undefined;
                };
                worker.onerror = (e)=>{
                    var message = "worker sent an error!";
                    err1(message + " " + e.filename + ":" + e.lineno + ": " + e.message);
                    throw e;
                };
                if (ENVIRONMENT_IS_NODE) {
                    worker.on("message", function(data) {
                        worker.onmessage({
                            data: data
                        });
                    });
                    worker.on("error", function(e) {
                        worker.onerror(e);
                    });
                    worker.on("detachedExit", function() {});
                }
                worker.postMessage({
                    "cmd": "load",
                    "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir,
                    "wasmMemory": wasmMemory,
                    "wasmModule": wasmModule
                });
            },
            allocateUnusedWorker: function() {
                var pthreadMainJs = locateFile("tfjs-backend-wasm-threaded-simd.worker.js");
                PThread.unusedWorkers.push(new Worker(pthreadMainJs));
            },
            getNewWorker: function() {
                if (PThread.unusedWorkers.length == 0) {
                    PThread.allocateUnusedWorker();
                    PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
                }
                return PThread.unusedWorkers.pop();
            }
        };
        function establishStackSpace() {
            var pthread_ptr = _pthread_self();
            var stackTop = GROWABLE_HEAP_I32()[pthread_ptr + 44 >> 2];
            var stackSize = GROWABLE_HEAP_I32()[pthread_ptr + 48 >> 2];
            var stackMax = stackTop - stackSize;
            _emscripten_stack_set_limits(stackTop, stackMax);
            stackRestore(stackTop);
        }
        Module["establishStackSpace"] = establishStackSpace;
        function exitOnMainThread(returnCode) {
            if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(1, 0, returnCode);
            try {
                _exit(returnCode);
            } catch (e) {
                handleException(e);
            }
        }
        var wasmTableMirror = [];
        function getWasmTableEntry(funcPtr) {
            var func = wasmTableMirror[funcPtr];
            if (!func) {
                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
            }
            return func;
        }
        function invokeEntryPoint(ptr, arg) {
            return getWasmTableEntry(ptr)(arg);
        }
        Module["invokeEntryPoint"] = invokeEntryPoint;
        function jsStackTrace() {
            var error = new Error;
            if (!error.stack) {
                try {
                    throw new Error;
                } catch (e) {
                    error = e;
                }
                if (!error.stack) return "(no stack trace available)";
            }
            return error.stack.toString();
        }
        function registerTlsInit(tlsInitFunc, moduleExports, metadata) {
            PThread.tlsInitFunctions.push(tlsInitFunc);
        }
        function setWasmTableEntry(idx, func) {
            wasmTable.set(idx, func);
            wasmTableMirror[idx] = func;
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) _emscripten_get_now = ()=>{
            var t = $3tEm6["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
        };
        else if (ENVIRONMENT_IS_PTHREAD) _emscripten_get_now = ()=>performance.now() - Module["__performance_now_clock_drift"]
        ;
        else _emscripten_get_now = ()=>performance.now()
        ;
        var _emscripten_get_now_is_monotonic = true;
        function setErrNo(value) {
            GROWABLE_HEAP_I32()[___errno_location() >> 2] = value;
            return value;
        }
        function _clock_gettime(clk_id, tp) {
            var now;
            if (clk_id === 0) now = Date.now();
            else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) now = _emscripten_get_now();
            else {
                setErrNo(28);
                return -1;
            }
            GROWABLE_HEAP_I32()[tp >> 2] = now / 1e3 | 0;
            GROWABLE_HEAP_I32()[tp + 4 >> 2] = now % 1e3 * 1000000 | 0;
            return 0;
        }
        function ___clock_gettime(a0, a1) {
            return _clock_gettime(a0, a1);
        }
        function ___emscripten_init_main_thread_js(tb) {
            __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1, !ENVIRONMENT_IS_WEB);
            PThread.threadInit();
        }
        function ___emscripten_thread_cleanup(thread) {
            if (!ENVIRONMENT_IS_PTHREAD) cleanupThread(thread);
            else postMessage({
                "cmd": "cleanupThread",
                "thread": thread
            });
        }
        function spawnThread(threadParams) {
            var worker = PThread.getNewWorker();
            if (!worker) return 6;
            PThread.runningWorkers.push(worker);
            var pthread = PThread.pthreads[threadParams.pthread_ptr] = {
                worker: worker,
                threadInfoStruct: threadParams.pthread_ptr
            };
            worker.pthread = pthread;
            var msg = {
                "cmd": "run",
                "start_routine": threadParams.startRoutine,
                "arg": threadParams.arg,
                "threadInfoStruct": threadParams.pthread_ptr
            };
            worker.runPthread = ()=>{
                msg.time = performance.now();
                worker.postMessage(msg, threadParams.transferList);
            };
            if (worker.loaded) {
                worker.runPthread();
                delete worker.runPthread;
            }
            return 0;
        }
        function ___pthread_create_js(pthread_ptr, attr, start_routine, arg) {
            if (typeof SharedArrayBuffer === "undefined") {
                err1("Current environment does not support SharedArrayBuffer, pthreads are not available!");
                return 6;
            }
            var transferList = [];
            var error = 0;
            if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
            if (error) return error;
            var threadParams = {
                startRoutine: start_routine,
                pthread_ptr: pthread_ptr,
                arg: arg,
                transferList: transferList
            };
            if (ENVIRONMENT_IS_PTHREAD) {
                threadParams.cmd = "spawnThread";
                postMessage(threadParams, transferList);
                return 0;
            }
            return spawnThread(threadParams);
        }
        function __emscripten_default_pthread_stack_size() {
            return 2097152;
        }
        function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
            if (targetThreadId == mainThreadId) postMessage({
                "cmd": "processQueuedMainThreadWork"
            });
            else if (ENVIRONMENT_IS_PTHREAD) postMessage({
                "targetThread": targetThreadId,
                "cmd": "processThreadQueue"
            });
            else {
                var pthread = PThread.pthreads[targetThreadId];
                var worker = pthread && pthread.worker;
                if (!worker) return;
                worker.postMessage({
                    "cmd": "processThreadQueue"
                });
            }
            return 1;
        }
        function _abort() {
            abort("");
        }
        function _emscripten_check_blocking_allowed() {
            if (ENVIRONMENT_IS_NODE) return;
            if (ENVIRONMENT_IS_WORKER) return;
            warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
        }
        function _emscripten_get_heap_max() {
            return 2147483648;
        }
        function _emscripten_memcpy_big(dest, src, num) {
            GROWABLE_HEAP_U8().copyWithin(dest, src, src + num);
        }
        function _emscripten_num_logical_cores() {
            if (ENVIRONMENT_IS_NODE) return (parcelRequire("ltudh")).cpus().length;
            return navigator["hardwareConcurrency"];
        }
        function _emscripten_proxy_to_main_thread_js(index, sync) {
            var numCallArgs = arguments.length - 2;
            var outerArgs = arguments;
            return withStackSave(function() {
                var serializedNumCallArgs = numCallArgs;
                var args = stackAlloc(serializedNumCallArgs * 8);
                var b = args >> 3;
                for(var i = 0; i < numCallArgs; i++){
                    var arg = outerArgs[2 + i];
                    GROWABLE_HEAP_F64()[b + i] = arg;
                }
                return _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
            });
        }
        var _emscripten_receive_on_main_thread_js_callArgs = [];
        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
            _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
            var b = args >> 3;
            for(var i = 0; i < numCallArgs; i++)_emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i];
            var isEmAsmConst = index < 0;
            var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
            return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
        }
        function emscripten_realloc_buffer(size) {
            try {
                wasmMemory.grow(size - buffer1.byteLength + 65535 >>> 16);
                updateGlobalBufferAndViews(wasmMemory.buffer);
                return 1;
            } catch (e) {}
        }
        function _emscripten_resize_heap(requestedSize) {
            var oldSize = GROWABLE_HEAP_U8().length;
            requestedSize = requestedSize >>> 0;
            if (requestedSize <= oldSize) return false;
            var maxHeapSize = _emscripten_get_heap_max();
            if (requestedSize > maxHeapSize) return false;
            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){
                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
                var replacement = emscripten_realloc_buffer(newSize);
                if (replacement) return true;
            }
            return false;
        }
        var JSEvents = {
            inEventHandler: 0,
            removeAllEventListeners: function() {
                for(var i = JSEvents.eventHandlers.length - 1; i >= 0; --i)JSEvents._removeHandler(i);
                JSEvents.eventHandlers = [];
                JSEvents.deferredCalls = [];
            },
            registerRemoveEventListeners: function() {
                if (!JSEvents.removeEventListenersRegistered) {
                    __ATEXIT__.push(JSEvents.removeAllEventListeners);
                    JSEvents.removeEventListenersRegistered = true;
                }
            },
            deferredCalls: [],
            deferCall: function(targetFunction, precedence, argsList) {
                function arraysHaveEqualContent(arrA, arrB) {
                    if (arrA.length != arrB.length) return false;
                    for(var i in arrA){
                        if (arrA[i] != arrB[i]) return false;
                    }
                    return true;
                }
                for(var i1 in JSEvents.deferredCalls){
                    var call = JSEvents.deferredCalls[i1];
                    if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) return;
                }
                JSEvents.deferredCalls.push({
                    targetFunction: targetFunction,
                    precedence: precedence,
                    argsList: argsList
                });
                JSEvents.deferredCalls.sort(function(x, y) {
                    return x.precedence < y.precedence;
                });
            },
            removeDeferredCalls: function(targetFunction) {
                for(var i = 0; i < JSEvents.deferredCalls.length; ++i)if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
                    JSEvents.deferredCalls.splice(i, 1);
                    --i;
                }
            },
            canPerformEventHandlerRequests: function() {
                return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
            },
            runDeferredCalls: function() {
                if (!JSEvents.canPerformEventHandlerRequests()) return;
                for(var i = 0; i < JSEvents.deferredCalls.length; ++i){
                    var call = JSEvents.deferredCalls[i];
                    JSEvents.deferredCalls.splice(i, 1);
                    --i;
                    call.targetFunction.apply(null, call.argsList);
                }
            },
            eventHandlers: [],
            removeAllHandlersOnTarget: function(target, eventTypeString) {
                for(var i = 0; i < JSEvents.eventHandlers.length; ++i)if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) JSEvents._removeHandler(i--);
            },
            _removeHandler: function(i) {
                var h = JSEvents.eventHandlers[i];
                h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
                JSEvents.eventHandlers.splice(i, 1);
            },
            registerOrRemoveHandler: function(eventHandler) {
                var jsEventHandler = function jsEventHandler(event) {
                    ++JSEvents.inEventHandler;
                    JSEvents.currentEventHandler = eventHandler;
                    JSEvents.runDeferredCalls();
                    eventHandler.handlerFunc(event);
                    JSEvents.runDeferredCalls();
                    --JSEvents.inEventHandler;
                };
                if (eventHandler.callbackfunc) {
                    eventHandler.eventListenerFunc = jsEventHandler;
                    eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
                    JSEvents.eventHandlers.push(eventHandler);
                    JSEvents.registerRemoveEventListeners();
                } else {
                    for(var i = 0; i < JSEvents.eventHandlers.length; ++i)if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) JSEvents._removeHandler(i--);
                }
            },
            queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
                withStackSave(function() {
                    var varargs = stackAlloc(12);
                    GROWABLE_HEAP_I32()[varargs >> 2] = eventTypeId;
                    GROWABLE_HEAP_I32()[varargs + 4 >> 2] = eventData;
                    GROWABLE_HEAP_I32()[varargs + 8 >> 2] = userData;
                    _emscripten_dispatch_to_thread_(targetThread, 637534208, eventHandlerFunc, eventData, varargs);
                });
            },
            getTargetThreadForEventCallback: function(targetThread) {
                switch(targetThread){
                    case 1:
                        return 0;
                    case 2:
                        return PThread.currentProxiedOperationCallerThread;
                    default:
                        return targetThread;
                }
            },
            getNodeNameForTarget: function(target) {
                if (!target) return "";
                if (target == window) return "#window";
                if (target == screen) return "#screen";
                return target && target.nodeName ? target.nodeName : "";
            },
            fullscreenEnabled: function() {
                return document.fullscreenEnabled || document.webkitFullscreenEnabled;
            }
        };
        function stringToNewUTF8(jsString) {
            var length = lengthBytesUTF8(jsString) + 1;
            var cString = _malloc(length);
            stringToUTF8(jsString, cString, length);
            return cString;
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
            withStackSave(function() {
                var varargs = stackAlloc(12);
                var targetCanvasPtr = 0;
                if (targetCanvas) targetCanvasPtr = stringToNewUTF8(targetCanvas);
                GROWABLE_HEAP_I32()[varargs >> 2] = targetCanvasPtr;
                GROWABLE_HEAP_I32()[varargs + 4 >> 2] = width;
                GROWABLE_HEAP_I32()[varargs + 8 >> 2] = height;
                _emscripten_dispatch_to_thread_(targetThread, 657457152, 0, targetCanvasPtr, varargs);
            });
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
            targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
            _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
        }
        function maybeCStringToJsString(cString) {
            return cString > 2 ? UTF8ToString(cString) : cString;
        }
        var specialHTMLTargets = [
            0,
            typeof document !== "undefined" ? document : 0,
            typeof window !== "undefined" ? window : 0
        ];
        function findEventTarget(target) {
            target = maybeCStringToJsString(target);
            var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : undefined);
            return domElement;
        }
        function findCanvasEventTarget(target) {
            return findEventTarget(target);
        }
        function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (!canvas) return -4;
            if (canvas.canvasSharedPtr) {
                GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >> 2] = width;
                GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >> 2] = height;
            }
            if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
                if (canvas.offscreenCanvas) canvas = canvas.offscreenCanvas;
                var autoResizeViewport = false;
                if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
                    var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
                    autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
                }
                canvas.width = width;
                canvas.height = height;
                if (autoResizeViewport) canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
            } else if (canvas.canvasSharedPtr) {
                var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >> 2];
                _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
                return 1;
            } else return -4;
            return 0;
        }
        function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
            if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(2, 1, target, width, height);
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        }
        function _emscripten_set_canvas_element_size(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (canvas) return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
            else return _emscripten_set_canvas_element_size_main_thread(target, width, height);
        }
        function _emscripten_unwind_to_js_event_loop() {
            throw "unwind";
        }
        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
                ctx["vertexAttribDivisor"] = function(index, divisor) {
                    ext["vertexAttribDivisorANGLE"](index, divisor);
                };
                ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
                    ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
                };
                ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
                    ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
                };
                return 1;
            }
        }
        function __webgl_enable_OES_vertex_array_object(ctx) {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
                ctx["createVertexArray"] = function() {
                    return ext["createVertexArrayOES"]();
                };
                ctx["deleteVertexArray"] = function(vao) {
                    ext["deleteVertexArrayOES"](vao);
                };
                ctx["bindVertexArray"] = function(vao) {
                    ext["bindVertexArrayOES"](vao);
                };
                ctx["isVertexArray"] = function(vao) {
                    return ext["isVertexArrayOES"](vao);
                };
                return 1;
            }
        }
        function __webgl_enable_WEBGL_draw_buffers(ctx) {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
                ctx["drawBuffers"] = function(n, bufs) {
                    ext["drawBuffersWEBGL"](n, bufs);
                };
                return 1;
            }
        }
        function __webgl_enable_WEBGL_multi_draw(ctx) {
            return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }
        var GL = {
            counter: 1,
            buffers: [],
            programs: [],
            framebuffers: [],
            renderbuffers: [],
            textures: [],
            shaders: [],
            vaos: [],
            contexts: {},
            offscreenCanvases: {},
            queries: [],
            stringCache: {},
            unpackAlignment: 4,
            recordError: function recordError(errorCode) {
                if (!GL.lastError) GL.lastError = errorCode;
            },
            getNewId: function(table) {
                var ret = GL.counter++;
                for(var i = table.length; i < ret; i++)table[i] = null;
                return ret;
            },
            getSource: function(shader, count, string, length) {
                var source = "";
                for(var i = 0; i < count; ++i){
                    var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >> 2] : -1;
                    source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >> 2], len < 0 ? undefined : len);
                }
                return source;
            },
            createContext: function(canvas, webGLContextAttributes) {
                if (!canvas.getContextSafariWebGL2Fixed) {
                    canvas.getContextSafariWebGL2Fixed = canvas.getContext;
                    canvas.getContext = function(ver, attrs) {
                        var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                        return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
                    };
                }
                var ctx = canvas.getContext("webgl", webGLContextAttributes);
                if (!ctx) return 0;
                var handle = GL.registerContext(ctx, webGLContextAttributes);
                return handle;
            },
            registerContext: function(ctx, webGLContextAttributes) {
                var handle = _malloc(8);
                GROWABLE_HEAP_I32()[handle + 4 >> 2] = _pthread_self();
                var context = {
                    handle: handle,
                    attributes: webGLContextAttributes,
                    version: webGLContextAttributes.majorVersion,
                    GLctx: ctx
                };
                if (ctx.canvas) ctx.canvas.GLctxObject = context;
                GL.contexts[handle] = context;
                if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) GL.initExtensions(context);
                return handle;
            },
            makeContextCurrent: function(contextHandle) {
                GL.currentContext = GL.contexts[contextHandle];
                Module.ctx = GLctx1 = GL.currentContext && GL.currentContext.GLctx;
                return !(contextHandle && !GLctx1);
            },
            getContext: function(contextHandle) {
                return GL.contexts[contextHandle];
            },
            deleteContext: function(contextHandle) {
                if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
                if (typeof JSEvents === "object") JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
                if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;
                _free(GL.contexts[contextHandle].handle);
                GL.contexts[contextHandle] = null;
            },
            initExtensions: function(context) {
                if (!context) context = GL.currentContext;
                if (context.initExtensionsDone) return;
                context.initExtensionsDone = true;
                var GLctx = context.GLctx;
                __webgl_enable_ANGLE_instanced_arrays(GLctx);
                __webgl_enable_OES_vertex_array_object(GLctx);
                __webgl_enable_WEBGL_draw_buffers(GLctx);
                GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
                __webgl_enable_WEBGL_multi_draw(GLctx);
                var exts = GLctx.getSupportedExtensions() || [];
                exts.forEach(function(ext) {
                    if (!ext.includes("lose_context") && !ext.includes("debug")) GLctx.getExtension(ext);
                });
            }
        };
        var __emscripten_webgl_power_preferences = [
            "default",
            "low-power",
            "high-performance"
        ];
        function _emscripten_webgl_do_create_context(target, attributes) {
            var a = attributes >> 2;
            var powerPreference = GROWABLE_HEAP_I32()[a + 6];
            var contextAttributes = {
                "alpha": !!GROWABLE_HEAP_I32()[a + 0],
                "depth": !!GROWABLE_HEAP_I32()[a + 1],
                "stencil": !!GROWABLE_HEAP_I32()[a + 2],
                "antialias": !!GROWABLE_HEAP_I32()[a + 3],
                "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + 4],
                "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + 5],
                "powerPreference": __emscripten_webgl_power_preferences[powerPreference],
                "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + 7],
                majorVersion: GROWABLE_HEAP_I32()[a + 8],
                minorVersion: GROWABLE_HEAP_I32()[a + 9],
                enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + 10],
                explicitSwapControl: GROWABLE_HEAP_I32()[a + 11],
                proxyContextToMainThread: GROWABLE_HEAP_I32()[a + 12],
                renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + 13]
            };
            var canvas = findCanvasEventTarget(target);
            if (!canvas) return 0;
            if (contextAttributes.explicitSwapControl) return 0;
            var contextHandle = GL.createContext(canvas, contextAttributes);
            return contextHandle;
        }
        function _emscripten_webgl_create_context(a0, a1) {
            return _emscripten_webgl_do_create_context(a0, a1);
        }
        var SYSCALLS = {
            mappings: {},
            buffers: [
                null,
                [],
                []
            ],
            printChar: function(stream, curr) {
                var buffer = SYSCALLS.buffers[stream];
                if (curr === 0 || curr === 10) {
                    (stream === 1 ? out : err1)(UTF8ArrayToString(buffer, 0));
                    buffer.length = 0;
                } else buffer.push(curr);
            },
            varargs: undefined,
            get: function() {
                SYSCALLS.varargs += 4;
                var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >> 2];
                return ret;
            },
            getStr: function(ptr) {
                var ret = UTF8ToString(ptr);
                return ret;
            },
            get64: function(low, high) {
                return low;
            }
        };
        function _fd_close(fd) {
            if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(3, 1, fd);
            return 0;
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(4, 1, fd, offset_low, offset_high, whence, newOffset);
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
            if (ENVIRONMENT_IS_PTHREAD) return _emscripten_proxy_to_main_thread_js(5, 1, fd, iov, iovcnt, pnum);
            var num = 0;
            for(var i = 0; i < iovcnt; i++){
                var ptr = GROWABLE_HEAP_I32()[iov >> 2];
                var len = GROWABLE_HEAP_I32()[iov + 4 >> 2];
                iov += 8;
                for(var j = 0; j < len; j++)SYSCALLS.printChar(fd, GROWABLE_HEAP_U8()[ptr + j]);
                num += len;
            }
            GROWABLE_HEAP_I32()[pnum >> 2] = num;
            return 0;
        }
        function _setTempRet0(val) {
            setTempRet0(val);
        }
        PThread.init();
        var GLctx1;
        var proxiedFunctionTable = [
            null,
            exitOnMainThread,
            _emscripten_set_canvas_element_size_main_thread,
            _fd_close,
            _fd_seek,
            _fd_write
        ];
        var ASSERTIONS = false;
        var asmLibraryArg = {
            "__clock_gettime": ___clock_gettime,
            "__emscripten_init_main_thread_js": ___emscripten_init_main_thread_js,
            "__emscripten_thread_cleanup": ___emscripten_thread_cleanup,
            "__pthread_create_js": ___pthread_create_js,
            "_emscripten_default_pthread_stack_size": __emscripten_default_pthread_stack_size,
            "_emscripten_notify_thread_queue": __emscripten_notify_thread_queue,
            "abort": _abort,
            "emscripten_check_blocking_allowed": _emscripten_check_blocking_allowed,
            "emscripten_get_heap_max": _emscripten_get_heap_max,
            "emscripten_get_now": _emscripten_get_now,
            "emscripten_memcpy_big": _emscripten_memcpy_big,
            "emscripten_num_logical_cores": _emscripten_num_logical_cores,
            "emscripten_receive_on_main_thread_js": _emscripten_receive_on_main_thread_js,
            "emscripten_resize_heap": _emscripten_resize_heap,
            "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
            "emscripten_unwind_to_js_event_loop": _emscripten_unwind_to_js_event_loop,
            "emscripten_webgl_create_context": _emscripten_webgl_create_context,
            "exit": _exit,
            "fd_close": _fd_close,
            "fd_seek": _fd_seek,
            "fd_write": _fd_write,
            "memory": wasmMemory || Module["wasmMemory"],
            "setTempRet0": _setTempRet0
        };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
        };
        var _init = Module["_init"] = function() {
            return (_init = Module["_init"] = Module["asm"]["init"]).apply(null, arguments);
        };
        var _init_with_threads_count = Module["_init_with_threads_count"] = function() {
            return (_init_with_threads_count = Module["_init_with_threads_count"] = Module["asm"]["init_with_threads_count"]).apply(null, arguments);
        };
        var _get_threads_count = Module["_get_threads_count"] = function() {
            return (_get_threads_count = Module["_get_threads_count"] = Module["asm"]["get_threads_count"]).apply(null, arguments);
        };
        var _register_tensor = Module["_register_tensor"] = function() {
            return (_register_tensor = Module["_register_tensor"] = Module["asm"]["register_tensor"]).apply(null, arguments);
        };
        var _dispose_data = Module["_dispose_data"] = function() {
            return (_dispose_data = Module["_dispose_data"] = Module["asm"]["dispose_data"]).apply(null, arguments);
        };
        var _dispose = Module["_dispose"] = function() {
            return (_dispose = Module["_dispose"] = Module["asm"]["dispose"]).apply(null, arguments);
        };
        var _Abs = Module["_Abs"] = function() {
            return (_Abs = Module["_Abs"] = Module["asm"]["Abs"]).apply(null, arguments);
        };
        var _Add = Module["_Add"] = function() {
            return (_Add = Module["_Add"] = Module["asm"]["Add"]).apply(null, arguments);
        };
        var _AddN = Module["_AddN"] = function() {
            return (_AddN = Module["_AddN"] = Module["asm"]["AddN"]).apply(null, arguments);
        };
        var _All = Module["_All"] = function() {
            return (_All = Module["_All"] = Module["asm"]["All"]).apply(null, arguments);
        };
        var _Any = Module["_Any"] = function() {
            return (_Any = Module["_Any"] = Module["asm"]["Any"]).apply(null, arguments);
        };
        var _ArgMax = Module["_ArgMax"] = function() {
            return (_ArgMax = Module["_ArgMax"] = Module["asm"]["ArgMax"]).apply(null, arguments);
        };
        var _AvgPool = Module["_AvgPool"] = function() {
            return (_AvgPool = Module["_AvgPool"] = Module["asm"]["AvgPool"]).apply(null, arguments);
        };
        var _BatchMatMul = Module["_BatchMatMul"] = function() {
            return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["BatchMatMul"]).apply(null, arguments);
        };
        var _Ceil = Module["_Ceil"] = function() {
            return (_Ceil = Module["_Ceil"] = Module["asm"]["Ceil"]).apply(null, arguments);
        };
        var _ClipByValue = Module["_ClipByValue"] = function() {
            return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["ClipByValue"]).apply(null, arguments);
        };
        var _Conv2D = Module["_Conv2D"] = function() {
            return (_Conv2D = Module["_Conv2D"] = Module["asm"]["Conv2D"]).apply(null, arguments);
        };
        var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
            return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["Conv2DBackpropInput"]).apply(null, arguments);
        };
        var _Cos = Module["_Cos"] = function() {
            return (_Cos = Module["_Cos"] = Module["asm"]["Cos"]).apply(null, arguments);
        };
        var _Cosh = Module["_Cosh"] = function() {
            return (_Cosh = Module["_Cosh"] = Module["asm"]["Cosh"]).apply(null, arguments);
        };
        var _CropAndResize = Module["_CropAndResize"] = function() {
            return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["CropAndResize"]).apply(null, arguments);
        };
        var _Cumprod = Module["_Cumprod"] = function() {
            return (_Cumprod = Module["_Cumprod"] = Module["asm"]["Cumprod"]).apply(null, arguments);
        };
        var _Cumsum = Module["_Cumsum"] = function() {
            return (_Cumsum = Module["_Cumsum"] = Module["asm"]["Cumsum"]).apply(null, arguments);
        };
        var _DepthToSpace = Module["_DepthToSpace"] = function() {
            return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["DepthToSpace"]).apply(null, arguments);
        };
        var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
            return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["DepthwiseConv2dNative"]).apply(null, arguments);
        };
        var _Elu = Module["_Elu"] = function() {
            return (_Elu = Module["_Elu"] = Module["asm"]["Elu"]).apply(null, arguments);
        };
        var _Equal = Module["_Equal"] = function() {
            return (_Equal = Module["_Equal"] = Module["asm"]["Equal"]).apply(null, arguments);
        };
        var _Exp = Module["_Exp"] = function() {
            return (_Exp = Module["_Exp"] = Module["asm"]["Exp"]).apply(null, arguments);
        };
        var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
            return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["FlipLeftRight"]).apply(null, arguments);
        };
        var _Floor = Module["_Floor"] = function() {
            return (_Floor = Module["_Floor"] = Module["asm"]["Floor"]).apply(null, arguments);
        };
        var _FloorDiv = Module["_FloorDiv"] = function() {
            return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["FloorDiv"]).apply(null, arguments);
        };
        var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
            return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["FusedBatchNorm"]).apply(null, arguments);
        };
        var _FusedConv2D = Module["_FusedConv2D"] = function() {
            return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["FusedConv2D"]).apply(null, arguments);
        };
        var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
            return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["FusedDepthwiseConv2D"]).apply(null, arguments);
        };
        var _Gather = Module["_Gather"] = function() {
            return (_Gather = Module["_Gather"] = Module["asm"]["Gather"]).apply(null, arguments);
        };
        var _GatherNd = Module["_GatherNd"] = function() {
            return (_GatherNd = Module["_GatherNd"] = Module["asm"]["GatherNd"]).apply(null, arguments);
        };
        var _Greater = Module["_Greater"] = function() {
            return (_Greater = Module["_Greater"] = Module["asm"]["Greater"]).apply(null, arguments);
        };
        var _GreaterEqual = Module["_GreaterEqual"] = function() {
            return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["GreaterEqual"]).apply(null, arguments);
        };
        var _LeakyRelu = Module["_LeakyRelu"] = function() {
            return (_LeakyRelu = Module["_LeakyRelu"] = Module["asm"]["LeakyRelu"]).apply(null, arguments);
        };
        var _Less = Module["_Less"] = function() {
            return (_Less = Module["_Less"] = Module["asm"]["Less"]).apply(null, arguments);
        };
        var _LessEqual = Module["_LessEqual"] = function() {
            return (_LessEqual = Module["_LessEqual"] = Module["asm"]["LessEqual"]).apply(null, arguments);
        };
        var _Log = Module["_Log"] = function() {
            return (_Log = Module["_Log"] = Module["asm"]["Log"]).apply(null, arguments);
        };
        var _LogicalAnd = Module["_LogicalAnd"] = function() {
            return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["LogicalAnd"]).apply(null, arguments);
        };
        var _Max = Module["_Max"] = function() {
            return (_Max = Module["_Max"] = Module["asm"]["Max"]).apply(null, arguments);
        };
        var _MaxPool = Module["_MaxPool"] = function() {
            return (_MaxPool = Module["_MaxPool"] = Module["asm"]["MaxPool"]).apply(null, arguments);
        };
        var _Maximum = Module["_Maximum"] = function() {
            return (_Maximum = Module["_Maximum"] = Module["asm"]["Maximum"]).apply(null, arguments);
        };
        var _Mean = Module["_Mean"] = function() {
            return (_Mean = Module["_Mean"] = Module["asm"]["Mean"]).apply(null, arguments);
        };
        var _Min = Module["_Min"] = function() {
            return (_Min = Module["_Min"] = Module["asm"]["Min"]).apply(null, arguments);
        };
        var _Minimum = Module["_Minimum"] = function() {
            return (_Minimum = Module["_Minimum"] = Module["asm"]["Minimum"]).apply(null, arguments);
        };
        var _MirrorPad = Module["_MirrorPad"] = function() {
            return (_MirrorPad = Module["_MirrorPad"] = Module["asm"]["MirrorPad"]).apply(null, arguments);
        };
        var _Multiply = Module["_Multiply"] = function() {
            return (_Multiply = Module["_Multiply"] = Module["asm"]["Multiply"]).apply(null, arguments);
        };
        var _Neg = Module["_Neg"] = function() {
            return (_Neg = Module["_Neg"] = Module["asm"]["Neg"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
            return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["NonMaxSuppressionV3"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
            return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["NonMaxSuppressionV4"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
            return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["NonMaxSuppressionV5"]).apply(null, arguments);
        };
        var _NotEqual = Module["_NotEqual"] = function() {
            return (_NotEqual = Module["_NotEqual"] = Module["asm"]["NotEqual"]).apply(null, arguments);
        };
        var _OneHot = Module["_OneHot"] = function() {
            return (_OneHot = Module["_OneHot"] = Module["asm"]["OneHot"]).apply(null, arguments);
        };
        var _PadV2 = Module["_PadV2"] = function() {
            return (_PadV2 = Module["_PadV2"] = Module["asm"]["PadV2"]).apply(null, arguments);
        };
        var _Pow = Module["_Pow"] = function() {
            return (_Pow = Module["_Pow"] = Module["asm"]["Pow"]).apply(null, arguments);
        };
        var _Prelu = Module["_Prelu"] = function() {
            return (_Prelu = Module["_Prelu"] = Module["asm"]["Prelu"]).apply(null, arguments);
        };
        var _Prod = Module["_Prod"] = function() {
            return (_Prod = Module["_Prod"] = Module["asm"]["Prod"]).apply(null, arguments);
        };
        var _RealDiv = Module["_RealDiv"] = function() {
            return (_RealDiv = Module["_RealDiv"] = Module["asm"]["RealDiv"]).apply(null, arguments);
        };
        var _Relu = Module["_Relu"] = function() {
            return (_Relu = Module["_Relu"] = Module["asm"]["Relu"]).apply(null, arguments);
        };
        var _Relu6 = Module["_Relu6"] = function() {
            return (_Relu6 = Module["_Relu6"] = Module["asm"]["Relu6"]).apply(null, arguments);
        };
        var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
            return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["ResizeBilinear"]).apply(null, arguments);
        };
        var _Reverse = Module["_Reverse"] = function() {
            return (_Reverse = Module["_Reverse"] = Module["asm"]["Reverse"]).apply(null, arguments);
        };
        var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
            return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["RotateWithOffset"]).apply(null, arguments);
        };
        var _Round = Module["_Round"] = function() {
            return (_Round = Module["_Round"] = Module["asm"]["Round"]).apply(null, arguments);
        };
        var _Rsqrt = Module["_Rsqrt"] = function() {
            return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["Rsqrt"]).apply(null, arguments);
        };
        var _ScatterNd = Module["_ScatterNd"] = function() {
            return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["ScatterNd"]).apply(null, arguments);
        };
        var _SelectV2 = Module["_SelectV2"] = function() {
            return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["SelectV2"]).apply(null, arguments);
        };
        var _Sigmoid = Module["_Sigmoid"] = function() {
            return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["Sigmoid"]).apply(null, arguments);
        };
        var _Sin = Module["_Sin"] = function() {
            return (_Sin = Module["_Sin"] = Module["asm"]["Sin"]).apply(null, arguments);
        };
        var _Softmax = Module["_Softmax"] = function() {
            return (_Softmax = Module["_Softmax"] = Module["asm"]["Softmax"]).apply(null, arguments);
        };
        var _SparseFillEmptyRows = Module["_SparseFillEmptyRows"] = function() {
            return (_SparseFillEmptyRows = Module["_SparseFillEmptyRows"] = Module["asm"]["SparseFillEmptyRows"]).apply(null, arguments);
        };
        var _SparseReshape = Module["_SparseReshape"] = function() {
            return (_SparseReshape = Module["_SparseReshape"] = Module["asm"]["SparseReshape"]).apply(null, arguments);
        };
        var _SparseSegmentReduction = Module["_SparseSegmentReduction"] = function() {
            return (_SparseSegmentReduction = Module["_SparseSegmentReduction"] = Module["asm"]["SparseSegmentReduction"]).apply(null, arguments);
        };
        var _Sqrt = Module["_Sqrt"] = function() {
            return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Sqrt"]).apply(null, arguments);
        };
        var _Square = Module["_Square"] = function() {
            return (_Square = Module["_Square"] = Module["asm"]["Square"]).apply(null, arguments);
        };
        var _SquaredDifference = Module["_SquaredDifference"] = function() {
            return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["SquaredDifference"]).apply(null, arguments);
        };
        var _Step = Module["_Step"] = function() {
            return (_Step = Module["_Step"] = Module["asm"]["Step"]).apply(null, arguments);
        };
        var _StridedSlice = Module["_StridedSlice"] = function() {
            return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["StridedSlice"]).apply(null, arguments);
        };
        var _Sub = Module["_Sub"] = function() {
            return (_Sub = Module["_Sub"] = Module["asm"]["Sub"]).apply(null, arguments);
        };
        var _Sum = Module["_Sum"] = function() {
            return (_Sum = Module["_Sum"] = Module["asm"]["Sum"]).apply(null, arguments);
        };
        var _Tan = Module["_Tan"] = function() {
            return (_Tan = Module["_Tan"] = Module["asm"]["Tan"]).apply(null, arguments);
        };
        var _Tanh = Module["_Tanh"] = function() {
            return (_Tanh = Module["_Tanh"] = Module["asm"]["Tanh"]).apply(null, arguments);
        };
        var _Tile = Module["_Tile"] = function() {
            return (_Tile = Module["_Tile"] = Module["asm"]["Tile"]).apply(null, arguments);
        };
        var _TopK = Module["_TopK"] = function() {
            return (_TopK = Module["_TopK"] = Module["asm"]["TopK"]).apply(null, arguments);
        };
        var _Transform = Module["_Transform"] = function() {
            return (_Transform = Module["_Transform"] = Module["asm"]["Transform"]).apply(null, arguments);
        };
        var _Transpose = Module["_Transpose"] = function() {
            return (_Transpose = Module["_Transpose"] = Module["asm"]["Transpose"]).apply(null, arguments);
        };
        var __FusedMatMul = Module["__FusedMatMul"] = function() {
            return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["_FusedMatMul"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
        };
        var _emscripten_tls_init = Module["_emscripten_tls_init"] = function() {
            return (_emscripten_tls_init = Module["_emscripten_tls_init"] = Module["asm"]["emscripten_tls_init"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
        };
        var _pthread_self = Module["_pthread_self"] = function() {
            return (_pthread_self = Module["_pthread_self"] = Module["asm"]["pthread_self"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
            return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null, arguments);
        };
        var __emscripten_thread_crashed = Module["__emscripten_thread_crashed"] = function() {
            return (__emscripten_thread_crashed = Module["__emscripten_thread_crashed"] = Module["asm"]["_emscripten_thread_crashed"]).apply(null, arguments);
        };
        var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
            return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["_emscripten_thread_init"]).apply(null, arguments);
        };
        var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function() {
            return (_emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["emscripten_current_thread_process_queued_calls"]).apply(null, arguments);
        };
        var _emscripten_main_browser_thread_id = Module["_emscripten_main_browser_thread_id"] = function() {
            return (_emscripten_main_browser_thread_id = Module["_emscripten_main_browser_thread_id"] = Module["asm"]["emscripten_main_browser_thread_id"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_2 = Module["_emscripten_sync_run_in_main_thread_2"] = function() {
            return (_emscripten_sync_run_in_main_thread_2 = Module["_emscripten_sync_run_in_main_thread_2"] = Module["asm"]["emscripten_sync_run_in_main_thread_2"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
            return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["emscripten_sync_run_in_main_thread_4"]).apply(null, arguments);
        };
        var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
            return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["emscripten_run_in_main_runtime_thread_js"]).apply(null, arguments);
        };
        var _emscripten_dispatch_to_thread_ = Module["_emscripten_dispatch_to_thread_"] = function() {
            return (_emscripten_dispatch_to_thread_ = Module["_emscripten_dispatch_to_thread_"] = Module["asm"]["emscripten_dispatch_to_thread_"]).apply(null, arguments);
        };
        var __emscripten_thread_free_data = Module["__emscripten_thread_free_data"] = function() {
            return (__emscripten_thread_free_data = Module["__emscripten_thread_free_data"] = Module["asm"]["_emscripten_thread_free_data"]).apply(null, arguments);
        };
        var __emscripten_thread_exit = Module["__emscripten_thread_exit"] = function() {
            return (__emscripten_thread_exit = Module["__emscripten_thread_exit"] = Module["asm"]["_emscripten_thread_exit"]).apply(null, arguments);
        };
        var _memalign = Module["_memalign"] = function() {
            return (_memalign = Module["_memalign"] = Module["asm"]["memalign"]).apply(null, arguments);
        };
        var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
            return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
            return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
            return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
            return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
        };
        var dynCall_iijjiiii = Module["dynCall_iijjiiii"] = function() {
            return (dynCall_iijjiiii = Module["dynCall_iijjiiii"] = Module["asm"]["dynCall_iijjiiii"]).apply(null, arguments);
        };
        var dynCall_jiji = Module["dynCall_jiji"] = function() {
            return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
        };
        var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 21464;
        Module["cwrap"] = cwrap;
        Module["keepRuntimeAlive"] = keepRuntimeAlive;
        Module["PThread"] = PThread;
        Module["PThread"] = PThread;
        Module["wasmMemory"] = wasmMemory;
        Module["ExitStatus"] = ExitStatus;
        var calledRun;
        function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller;
        };
        function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) return;
            if (ENVIRONMENT_IS_PTHREAD) {
                readyPromiseResolve(Module);
                initRuntime();
                postMessage({
                    "cmd": "loaded"
                });
                return;
            }
            preRun();
            if (runDependencies > 0) return;
            function doRun() {
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT) return;
                initRuntime();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                postRun();
            }
            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function() {
                    setTimeout(function() {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            } else doRun();
        }
        Module["run"] = run;
        function exit(status, implicit) {
            EXITSTATUS = status;
            if (!implicit) {
                if (ENVIRONMENT_IS_PTHREAD) {
                    exitOnMainThread(status);
                    throw "unwind";
                }
            }
            if (keepRuntimeAlive()) ;
            else exitRuntime();
            procExit(status);
        }
        function procExit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
                PThread.terminateAllThreads();
                if (Module["onExit"]) Module["onExit"](code);
                ABORT = true;
            }
            quit_(code, new ExitStatus(code));
        }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [
                Module["preInit"]
            ];
            while(Module["preInit"].length > 0)Module["preInit"].pop()();
        }
        run();
        var listenersAdded;
        if (beforeListeners) listenersAdded = {
            uncaughtException: $3tEm6.listeners("uncaughtException").filter(function(listener) {
                return !beforeListeners.uncaughtException.indexOf(listener) > -1;
            }),
            unhandledRejection: $3tEm6.listeners("unhandledRejection").filter(function(listener) {
                return !beforeListeners.unhandledRejection.indexOf(listener) > -1;
            })
        };
        var actualModule;
        if (typeof WasmBackendModule !== "undefined") actualModule = WasmBackendModule;
        else if (typeof WasmBackendModuleThreadedSimd !== "undefined") actualModule = WasmBackendModuleThreadedSimd;
        else throw new Error("Could not find wasm module in post.js");
        if (listenersAdded) {
            var tmpDispose = actualModule["_dispose"];
            actualModule["_dispose"] = function() {
                tmpDispose();
                listenersAdded.uncaughtException.forEach(function(listener) {
                    $3tEm6.removeListener("uncaughtException", listener);
                });
                listenersAdded.unhandledRejection.forEach(function(listener) {
                    $3tEm6.removeListener("unhandledRejection", listener);
                });
            };
        }
        return WasmBackendModuleThreadedSimd.ready;
    };
})();
$45d650a2999915c1$exports = $45d650a2999915c1$var$WasmBackendModuleThreadedSimd;


const $16ece16e4f044bcd$export$8db778f4bac1cd46 = '"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});';


var $310e6a9481e90f95$exports = {};
var $310e6a9481e90f95$var$__dirname = "node_modules/@tensorflow/tfjs-backend-wasm/wasm-out";

var $3tEm6 = parcelRequire("3tEm6");
var $310e6a9481e90f95$var$__filename = "node_modules/@tensorflow/tfjs-backend-wasm/wasm-out/tfjs-backend-wasm.js";



var $310e6a9481e90f95$var$WasmBackendModule = (()=>{
    var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
    if (typeof $310e6a9481e90f95$var$__filename !== 'undefined') _scriptDir = _scriptDir || $310e6a9481e90f95$var$__filename;
    return function(WasmBackendModule) {
        WasmBackendModule = WasmBackendModule || {};
        var Module = typeof WasmBackendModule !== "undefined" ? WasmBackendModule : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        var beforeListeners;
        if (typeof $3tEm6 !== "undefined" && $3tEm6.listeners) beforeListeners = {
            uncaughtException: $3tEm6.listeners("uncaughtException"),
            unhandledRejection: $3tEm6.listeners("unhandledRejection")
        };
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow)=>{
            throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof $3tEm6 === "object" && typeof $3tEm6.versions === "object" && typeof $3tEm6.versions.node === "string";
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) return Module["locateFile"](path, scriptDirectory);
            return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        function logExceptionOnExit(e) {
            if (e instanceof ExitStatus) return;
            let toLog = e;
            err1("exiting due to exception: " + toLog);
        }
        var fs;
        var nodePath;
        var requireNodeFS;
        if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) scriptDirectory = (parcelRequire("ltudh")).dirname(scriptDirectory) + "/";
            else scriptDirectory = $310e6a9481e90f95$var$__dirname + "/";
            requireNodeFS = ()=>{
                if (!nodePath) {
                    fs = (parcelRequire("ltudh"));
                    nodePath = (parcelRequire("ltudh"));
                }
            };
            read_ = function shell_read(filename, binary) {
                requireNodeFS();
                filename = nodePath["normalize"](filename);
                return fs.readFileSync(filename, binary ? undefined : "utf8");
            };
            readBinary = (filename)=>{
                var ret = read_(filename, true);
                if (!ret.buffer) ret = new Uint8Array(ret);
                return ret;
            };
            readAsync = (filename, onload, onerror)=>{
                requireNodeFS();
                filename = nodePath["normalize"](filename);
                fs.readFile(filename, function(err, data) {
                    if (err) onerror(err);
                    else onload(data.buffer);
                });
            };
            if ($3tEm6["argv"].length > 1) thisProgram = $3tEm6["argv"][1].replace(/\\/g, "/");
            arguments_ = $3tEm6["argv"].slice(2);
            $3tEm6["on"]("uncaughtException", function(ex) {
                if (!(ex instanceof ExitStatus)) throw ex;
            });
            $3tEm6["on"]("unhandledRejection", function(reason) {
                throw reason;
            });
            quit_ = (status, toThrow)=>{
                if (keepRuntimeAlive()) {
                    $3tEm6["exitCode"] = status;
                    throw toThrow;
                }
                logExceptionOnExit(toThrow);
                $3tEm6["exit"](status);
            };
            Module["inspect"] = function() {
                return "[Emscripten Module object]";
            };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) scriptDirectory = self.location.href;
            else if (typeof document !== "undefined" && document.currentScript) scriptDirectory = document.currentScript.src;
            if (_scriptDir) scriptDirectory = _scriptDir;
            if (scriptDirectory.indexOf("blob:") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            else scriptDirectory = "";
            read_ = (url)=>{
                var xhr = new XMLHttpRequest;
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{
                var xhr = new XMLHttpRequest;
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
            };
            readAsync = (url, onload, onerror)=>{
                var xhr = new XMLHttpRequest;
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = ()=>{
                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                        onload(xhr.response);
                        return;
                    }
                    onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
            };
            setWindowTitle = (title)=>document.title = title
            ;
        }
        var out = Module["print"] || console.log.bind(console);
        var err1 = Module["printErr"] || console.warn.bind(console);
        Object.assign(Module, moduleOverrides);
        moduleOverrides = null;
        if (Module["arguments"]) arguments_ = Module["arguments"];
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        if (Module["quit"]) quit_ = Module["quit"];
        var POINTER_SIZE = 4;
        function warnOnce(text) {
            if (!warnOnce.shown) warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
                warnOnce.shown[text] = 1;
                err1(text);
            }
        }
        function convertJsFunctionToWasm(func, sig) {
            if (typeof WebAssembly.Function === "function") {
                var typeNames = {
                    "i": "i32",
                    "j": "i64",
                    "f": "f32",
                    "d": "f64"
                };
                var type = {
                    parameters: [],
                    results: sig[0] == "v" ? [] : [
                        typeNames[sig[0]]
                    ]
                };
                for(var i = 1; i < sig.length; ++i)type.parameters.push(typeNames[sig[i]]);
                return new WebAssembly.Function(type, func);
            }
            var typeSection = [
                1,
                0,
                1,
                96
            ];
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
                "i": 127,
                "j": 126,
                "f": 125,
                "d": 124
            };
            typeSection.push(sigParam.length);
            for(var i = 0; i < sigParam.length; ++i)typeSection.push(typeCodes[sigParam[i]]);
            if (sigRet == "v") typeSection.push(0);
            else typeSection = typeSection.concat([
                1,
                typeCodes[sigRet]
            ]);
            typeSection[1] = typeSection.length - 2;
            var bytes = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0
            ].concat(typeSection, [
                2,
                7,
                1,
                1,
                101,
                1,
                102,
                0,
                0,
                7,
                5,
                1,
                1,
                102,
                0,
                0
            ]));
            var module = new WebAssembly.Module(bytes);
            var instance = new WebAssembly.Instance(module, {
                "e": {
                    "f": func
                }
            });
            var wrappedFunc = instance.exports["f"];
            return wrappedFunc;
        }
        var freeTableIndexes = [];
        var functionsInTableMap;
        function getEmptyTableSlot() {
            if (freeTableIndexes.length) return freeTableIndexes.pop();
            try {
                wasmTable.grow(1);
            } catch (err) {
                if (!(err instanceof RangeError)) throw err;
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
        }
        function updateTableMap(offset, count) {
            for(var i = offset; i < offset + count; i++){
                var item = getWasmTableEntry(i);
                if (item) functionsInTableMap.set(item, i);
            }
        }
        var tempRet0 = 0;
        var setTempRet0 = (value)=>{
            tempRet0 = value;
        };
        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") abort("no native wasm support detected");
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
            if (!condition) abort(text);
        }
        function getCFunc(ident) {
            var func = Module["_" + ident];
            return func;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
            var toC = {
                "string": function(str) {
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) {
                        var len = (str.length << 2) + 1;
                        ret = stackAlloc(len);
                        stringToUTF8(str, ret, len);
                    }
                    return ret;
                },
                "array": function(arr) {
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                }
            };
            function convertReturnValue(ret) {
                if (returnType === "string") return UTF8ToString(ret);
                if (returnType === "boolean") return Boolean(ret);
                return ret;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args) for(var i = 0; i < args.length; i++){
                var converter = toC[argTypes[i]];
                if (converter) {
                    if (stack === 0) stack = stackSave();
                    cArgs[i] = converter(args[i]);
                } else cArgs[i] = args[i];
            }
            var ret1 = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
            }
            ret1 = onDone(ret1);
            return ret1;
        }
        function cwrap(ident, returnType, argTypes, opts) {
            argTypes = argTypes || [];
            var numericArgs = argTypes.every(function(type) {
                return type === "number";
            });
            var numericRet = returnType !== "string";
            if (numericRet && numericArgs && !opts) return getCFunc(ident);
            return function() {
                return ccall(ident, returnType, argTypes, arguments, opts);
            };
        }
        var ALLOC_STACK = 1;
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while(heap[endPtr] && !(endPtr >= endIdx))++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) return UTF8Decoder.decode(heap.subarray(idx, endPtr));
            else {
                var str = "";
                while(idx < endPtr){
                    var u0 = heap[idx++];
                    if (!(u0 & 128)) {
                        str += String.fromCharCode(u0);
                        continue;
                    }
                    var u1 = heap[idx++] & 63;
                    if ((u0 & 224) == 192) {
                        str += String.fromCharCode((u0 & 31) << 6 | u1);
                        continue;
                    }
                    var u2 = heap[idx++] & 63;
                    if ((u0 & 240) == 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                    else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
                    if (u0 < 65536) str += String.fromCharCode(u0);
                    else {
                        var ch = u0 - 65536;
                        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                    }
                }
            }
            return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for(var i = 0; i < str.length; ++i){
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                    var u1 = str.charCodeAt(++i);
                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;
                }
                if (u <= 127) {
                    if (outIdx >= endIdx) break;
                    heap[outIdx++] = u;
                } else if (u <= 2047) {
                    if (outIdx + 1 >= endIdx) break;
                    heap[outIdx++] = 192 | u >> 6;
                    heap[outIdx++] = 128 | u & 63;
                } else if (u <= 65535) {
                    if (outIdx + 2 >= endIdx) break;
                    heap[outIdx++] = 224 | u >> 12;
                    heap[outIdx++] = 128 | u >> 6 & 63;
                    heap[outIdx++] = 128 | u & 63;
                } else {
                    if (outIdx + 3 >= endIdx) break;
                    heap[outIdx++] = 240 | u >> 18;
                    heap[outIdx++] = 128 | u >> 12 & 63;
                    heap[outIdx++] = 128 | u >> 6 & 63;
                    heap[outIdx++] = 128 | u & 63;
                }
            }
            heap[outIdx] = 0;
            return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
            var len = 0;
            for(var i = 0; i < str.length; ++i){
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
                if (u <= 127) ++len;
                else if (u <= 2047) len += 2;
                else if (u <= 65535) len += 3;
                else len += 4;
            }
            return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;
        function writeArrayToMemory(array, buffer) {
            HEAP8.set(array, buffer);
        }
        function writeAsciiToMemory(str, buffer, dontAddNull) {
            for(var i = 0; i < str.length; ++i)HEAP8[(buffer++) >> 0] = str.charCodeAt(i);
            if (!dontAddNull) HEAP8[buffer >> 0] = 0;
        }
        function alignUp(x, multiple) {
            if (x % multiple > 0) x += multiple - x % multiple;
            return x;
        }
        var buffer1, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
            buffer1 = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [
                    Module["preRun"]
                ];
                while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift());
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__ATINIT__);
        }
        function exitRuntime() {
            runtimeExited = true;
        }
        function postRun() {
            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [
                    Module["postRun"]
                ];
                while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift());
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
        }
        function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (runDependencies == 0) {
                if (runDependencyWatcher !== null) {
                    clearInterval(runDependencyWatcher);
                    runDependencyWatcher = null;
                }
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback();
                }
            }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
            if (Module["onAbort"]) Module["onAbort"](what);
            what = "Aborted(" + what + ")";
            err1(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "tfjs-backend-wasm.wasm";
        if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);
        function getBinary(file) {
            try {
                if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
                if (readBinary) return readBinary(file);
                else throw "both async and sync fetching of the wasm failed";
            } catch (err) {
                abort(err);
            }
        }
        function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                }).then(function(response) {
                    if (!response["ok"]) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                    return response["arrayBuffer"]();
                }).catch(function() {
                    return getBinary(wasmBinaryFile);
                });
                else {
                    if (readAsync) return new Promise(function(resolve, reject) {
                        readAsync(wasmBinaryFile, function(response) {
                            resolve(new Uint8Array(response));
                        }, reject);
                    });
                }
            }
            return Promise.resolve().then(function() {
                return getBinary(wasmBinaryFile);
            });
        }
        function createWasm() {
            var info = {
                "env": asmLibraryArg,
                "wasi_snapshot_preview1": asmLibraryArg
            };
            function receiveInstance(instance, module) {
                var exports = instance.exports;
                Module["asm"] = exports;
                wasmMemory = Module["asm"]["memory"];
                updateGlobalBufferAndViews(wasmMemory.buffer);
                wasmTable = Module["asm"]["__indirect_function_table"];
                addOnInit(Module["asm"]["__wasm_call_ctors"]);
                removeRunDependency("wasm-instantiate");
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
                receiveInstance(result["instance"]);
            }
            function instantiateArrayBuffer(receiver) {
                return getBinaryPromise().then(function(binary) {
                    return WebAssembly.instantiate(binary, info);
                }).then(function(instance) {
                    return instance;
                }).then(receiver, function(reason) {
                    err1("failed to asynchronously prepare wasm: " + reason);
                    abort(reason);
                });
            }
            function instantiateAsync() {
                if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") return fetch(wasmBinaryFile, {
                    credentials: "same-origin"
                }).then(function(response) {
                    var result = WebAssembly.instantiateStreaming(response, info);
                    return result.then(receiveInstantiationResult, function(reason) {
                        err1("wasm streaming compile failed: " + reason);
                        err1("falling back to ArrayBuffer instantiation");
                        return instantiateArrayBuffer(receiveInstantiationResult);
                    });
                });
                else return instantiateArrayBuffer(receiveInstantiationResult);
            }
            if (Module["instantiateWasm"]) try {
                var exports1 = Module["instantiateWasm"](info, receiveInstance);
                return exports1;
            } catch (e) {
                err1("Module.instantiateWasm callback failed with error: " + e);
                return false;
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
        }
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) {
            while(callbacks.length > 0){
                var callback = callbacks.shift();
                if (typeof callback == "function") {
                    callback(Module);
                    continue;
                }
                var func = callback.func;
                if (typeof func === "number") {
                    if (callback.arg === undefined) getWasmTableEntry(func)();
                    else getWasmTableEntry(func)(callback.arg);
                } else func(callback.arg === undefined ? null : callback.arg);
            }
        }
        function demangle(func) {
            return func;
        }
        function demangleAll(text) {
            var regex = /\b_Z[\w\d_]+/g;
            return text.replace(regex, function(x) {
                var y = demangle(x);
                return x === y ? x : y + " [" + x + "]";
            });
        }
        var wasmTableMirror = [];
        function getWasmTableEntry(funcPtr) {
            var func = wasmTableMirror[funcPtr];
            if (!func) {
                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
            }
            return func;
        }
        function jsStackTrace() {
            var error = new Error;
            if (!error.stack) {
                try {
                    throw new Error;
                } catch (e) {
                    error = e;
                }
                if (!error.stack) return "(no stack trace available)";
            }
            return error.stack.toString();
        }
        function setWasmTableEntry(idx, func) {
            wasmTable.set(idx, func);
            wasmTableMirror[idx] = func;
        }
        function _abort() {
            abort("");
        }
        function _emscripten_get_heap_max() {
            return 2147483648;
        }
        function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest, src, src + num);
        }
        function emscripten_realloc_buffer(size) {
            try {
                wasmMemory.grow(size - buffer1.byteLength + 65535 >>> 16);
                updateGlobalBufferAndViews(wasmMemory.buffer);
                return 1;
            } catch (e) {}
        }
        function _emscripten_resize_heap(requestedSize) {
            var oldSize = HEAPU8.length;
            requestedSize = requestedSize >>> 0;
            var maxHeapSize = _emscripten_get_heap_max();
            if (requestedSize > maxHeapSize) return false;
            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){
                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
                var replacement = emscripten_realloc_buffer(newSize);
                if (replacement) return true;
            }
            return false;
        }
        var SYSCALLS = {
            mappings: {},
            buffers: [
                null,
                [],
                []
            ],
            printChar: function(stream, curr) {
                var buffer = SYSCALLS.buffers[stream];
                if (curr === 0 || curr === 10) {
                    (stream === 1 ? out : err1)(UTF8ArrayToString(buffer, 0));
                    buffer.length = 0;
                } else buffer.push(curr);
            },
            varargs: undefined,
            get: function() {
                SYSCALLS.varargs += 4;
                var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
                return ret;
            },
            getStr: function(ptr) {
                var ret = UTF8ToString(ptr);
                return ret;
            },
            get64: function(low, high) {
                return low;
            }
        };
        function _fd_close(fd) {
            return 0;
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}
        function _fd_write(fd, iov, iovcnt, pnum) {
            var num = 0;
            for(var i = 0; i < iovcnt; i++){
                var ptr = HEAP32[iov >> 2];
                var len = HEAP32[iov + 4 >> 2];
                iov += 8;
                for(var j = 0; j < len; j++)SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
                num += len;
            }
            HEAP32[pnum >> 2] = num;
            return 0;
        }
        function _setTempRet0(val) {
            setTempRet0(val);
        }
        var ASSERTIONS = false;
        var asmLibraryArg = {
            "abort": _abort,
            "emscripten_get_heap_max": _emscripten_get_heap_max,
            "emscripten_memcpy_big": _emscripten_memcpy_big,
            "emscripten_resize_heap": _emscripten_resize_heap,
            "fd_close": _fd_close,
            "fd_seek": _fd_seek,
            "fd_write": _fd_write,
            "setTempRet0": _setTempRet0
        };
        var asm = createWasm();
        var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
        };
        var _init = Module["_init"] = function() {
            return (_init = Module["_init"] = Module["asm"]["init"]).apply(null, arguments);
        };
        var _init_with_threads_count = Module["_init_with_threads_count"] = function() {
            return (_init_with_threads_count = Module["_init_with_threads_count"] = Module["asm"]["init_with_threads_count"]).apply(null, arguments);
        };
        var _get_threads_count = Module["_get_threads_count"] = function() {
            return (_get_threads_count = Module["_get_threads_count"] = Module["asm"]["get_threads_count"]).apply(null, arguments);
        };
        var _register_tensor = Module["_register_tensor"] = function() {
            return (_register_tensor = Module["_register_tensor"] = Module["asm"]["register_tensor"]).apply(null, arguments);
        };
        var _dispose_data = Module["_dispose_data"] = function() {
            return (_dispose_data = Module["_dispose_data"] = Module["asm"]["dispose_data"]).apply(null, arguments);
        };
        var _dispose = Module["_dispose"] = function() {
            return (_dispose = Module["_dispose"] = Module["asm"]["dispose"]).apply(null, arguments);
        };
        var _Abs = Module["_Abs"] = function() {
            return (_Abs = Module["_Abs"] = Module["asm"]["Abs"]).apply(null, arguments);
        };
        var _Add = Module["_Add"] = function() {
            return (_Add = Module["_Add"] = Module["asm"]["Add"]).apply(null, arguments);
        };
        var _AddN = Module["_AddN"] = function() {
            return (_AddN = Module["_AddN"] = Module["asm"]["AddN"]).apply(null, arguments);
        };
        var _All = Module["_All"] = function() {
            return (_All = Module["_All"] = Module["asm"]["All"]).apply(null, arguments);
        };
        var _Any = Module["_Any"] = function() {
            return (_Any = Module["_Any"] = Module["asm"]["Any"]).apply(null, arguments);
        };
        var _ArgMax = Module["_ArgMax"] = function() {
            return (_ArgMax = Module["_ArgMax"] = Module["asm"]["ArgMax"]).apply(null, arguments);
        };
        var _AvgPool = Module["_AvgPool"] = function() {
            return (_AvgPool = Module["_AvgPool"] = Module["asm"]["AvgPool"]).apply(null, arguments);
        };
        var _BatchMatMul = Module["_BatchMatMul"] = function() {
            return (_BatchMatMul = Module["_BatchMatMul"] = Module["asm"]["BatchMatMul"]).apply(null, arguments);
        };
        var _Ceil = Module["_Ceil"] = function() {
            return (_Ceil = Module["_Ceil"] = Module["asm"]["Ceil"]).apply(null, arguments);
        };
        var _ClipByValue = Module["_ClipByValue"] = function() {
            return (_ClipByValue = Module["_ClipByValue"] = Module["asm"]["ClipByValue"]).apply(null, arguments);
        };
        var _Conv2D = Module["_Conv2D"] = function() {
            return (_Conv2D = Module["_Conv2D"] = Module["asm"]["Conv2D"]).apply(null, arguments);
        };
        var _Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = function() {
            return (_Conv2DBackpropInput = Module["_Conv2DBackpropInput"] = Module["asm"]["Conv2DBackpropInput"]).apply(null, arguments);
        };
        var _Cos = Module["_Cos"] = function() {
            return (_Cos = Module["_Cos"] = Module["asm"]["Cos"]).apply(null, arguments);
        };
        var _Cosh = Module["_Cosh"] = function() {
            return (_Cosh = Module["_Cosh"] = Module["asm"]["Cosh"]).apply(null, arguments);
        };
        var _CropAndResize = Module["_CropAndResize"] = function() {
            return (_CropAndResize = Module["_CropAndResize"] = Module["asm"]["CropAndResize"]).apply(null, arguments);
        };
        var _Cumprod = Module["_Cumprod"] = function() {
            return (_Cumprod = Module["_Cumprod"] = Module["asm"]["Cumprod"]).apply(null, arguments);
        };
        var _Cumsum = Module["_Cumsum"] = function() {
            return (_Cumsum = Module["_Cumsum"] = Module["asm"]["Cumsum"]).apply(null, arguments);
        };
        var _DepthToSpace = Module["_DepthToSpace"] = function() {
            return (_DepthToSpace = Module["_DepthToSpace"] = Module["asm"]["DepthToSpace"]).apply(null, arguments);
        };
        var _DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = function() {
            return (_DepthwiseConv2dNative = Module["_DepthwiseConv2dNative"] = Module["asm"]["DepthwiseConv2dNative"]).apply(null, arguments);
        };
        var _Elu = Module["_Elu"] = function() {
            return (_Elu = Module["_Elu"] = Module["asm"]["Elu"]).apply(null, arguments);
        };
        var _Equal = Module["_Equal"] = function() {
            return (_Equal = Module["_Equal"] = Module["asm"]["Equal"]).apply(null, arguments);
        };
        var _Exp = Module["_Exp"] = function() {
            return (_Exp = Module["_Exp"] = Module["asm"]["Exp"]).apply(null, arguments);
        };
        var _FlipLeftRight = Module["_FlipLeftRight"] = function() {
            return (_FlipLeftRight = Module["_FlipLeftRight"] = Module["asm"]["FlipLeftRight"]).apply(null, arguments);
        };
        var _Floor = Module["_Floor"] = function() {
            return (_Floor = Module["_Floor"] = Module["asm"]["Floor"]).apply(null, arguments);
        };
        var _FloorDiv = Module["_FloorDiv"] = function() {
            return (_FloorDiv = Module["_FloorDiv"] = Module["asm"]["FloorDiv"]).apply(null, arguments);
        };
        var _FusedBatchNorm = Module["_FusedBatchNorm"] = function() {
            return (_FusedBatchNorm = Module["_FusedBatchNorm"] = Module["asm"]["FusedBatchNorm"]).apply(null, arguments);
        };
        var _FusedConv2D = Module["_FusedConv2D"] = function() {
            return (_FusedConv2D = Module["_FusedConv2D"] = Module["asm"]["FusedConv2D"]).apply(null, arguments);
        };
        var _FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = function() {
            return (_FusedDepthwiseConv2D = Module["_FusedDepthwiseConv2D"] = Module["asm"]["FusedDepthwiseConv2D"]).apply(null, arguments);
        };
        var _Gather = Module["_Gather"] = function() {
            return (_Gather = Module["_Gather"] = Module["asm"]["Gather"]).apply(null, arguments);
        };
        var _GatherNd = Module["_GatherNd"] = function() {
            return (_GatherNd = Module["_GatherNd"] = Module["asm"]["GatherNd"]).apply(null, arguments);
        };
        var _Greater = Module["_Greater"] = function() {
            return (_Greater = Module["_Greater"] = Module["asm"]["Greater"]).apply(null, arguments);
        };
        var _GreaterEqual = Module["_GreaterEqual"] = function() {
            return (_GreaterEqual = Module["_GreaterEqual"] = Module["asm"]["GreaterEqual"]).apply(null, arguments);
        };
        var _LeakyRelu = Module["_LeakyRelu"] = function() {
            return (_LeakyRelu = Module["_LeakyRelu"] = Module["asm"]["LeakyRelu"]).apply(null, arguments);
        };
        var _Less = Module["_Less"] = function() {
            return (_Less = Module["_Less"] = Module["asm"]["Less"]).apply(null, arguments);
        };
        var _LessEqual = Module["_LessEqual"] = function() {
            return (_LessEqual = Module["_LessEqual"] = Module["asm"]["LessEqual"]).apply(null, arguments);
        };
        var _Log = Module["_Log"] = function() {
            return (_Log = Module["_Log"] = Module["asm"]["Log"]).apply(null, arguments);
        };
        var _LogicalAnd = Module["_LogicalAnd"] = function() {
            return (_LogicalAnd = Module["_LogicalAnd"] = Module["asm"]["LogicalAnd"]).apply(null, arguments);
        };
        var _Max = Module["_Max"] = function() {
            return (_Max = Module["_Max"] = Module["asm"]["Max"]).apply(null, arguments);
        };
        var _MaxPool = Module["_MaxPool"] = function() {
            return (_MaxPool = Module["_MaxPool"] = Module["asm"]["MaxPool"]).apply(null, arguments);
        };
        var _Maximum = Module["_Maximum"] = function() {
            return (_Maximum = Module["_Maximum"] = Module["asm"]["Maximum"]).apply(null, arguments);
        };
        var _Mean = Module["_Mean"] = function() {
            return (_Mean = Module["_Mean"] = Module["asm"]["Mean"]).apply(null, arguments);
        };
        var _Min = Module["_Min"] = function() {
            return (_Min = Module["_Min"] = Module["asm"]["Min"]).apply(null, arguments);
        };
        var _Minimum = Module["_Minimum"] = function() {
            return (_Minimum = Module["_Minimum"] = Module["asm"]["Minimum"]).apply(null, arguments);
        };
        var _MirrorPad = Module["_MirrorPad"] = function() {
            return (_MirrorPad = Module["_MirrorPad"] = Module["asm"]["MirrorPad"]).apply(null, arguments);
        };
        var _Multiply = Module["_Multiply"] = function() {
            return (_Multiply = Module["_Multiply"] = Module["asm"]["Multiply"]).apply(null, arguments);
        };
        var _Neg = Module["_Neg"] = function() {
            return (_Neg = Module["_Neg"] = Module["asm"]["Neg"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = function() {
            return (_NonMaxSuppressionV3 = Module["_NonMaxSuppressionV3"] = Module["asm"]["NonMaxSuppressionV3"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = function() {
            return (_NonMaxSuppressionV4 = Module["_NonMaxSuppressionV4"] = Module["asm"]["NonMaxSuppressionV4"]).apply(null, arguments);
        };
        var _NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = function() {
            return (_NonMaxSuppressionV5 = Module["_NonMaxSuppressionV5"] = Module["asm"]["NonMaxSuppressionV5"]).apply(null, arguments);
        };
        var _NotEqual = Module["_NotEqual"] = function() {
            return (_NotEqual = Module["_NotEqual"] = Module["asm"]["NotEqual"]).apply(null, arguments);
        };
        var _OneHot = Module["_OneHot"] = function() {
            return (_OneHot = Module["_OneHot"] = Module["asm"]["OneHot"]).apply(null, arguments);
        };
        var _PadV2 = Module["_PadV2"] = function() {
            return (_PadV2 = Module["_PadV2"] = Module["asm"]["PadV2"]).apply(null, arguments);
        };
        var _Pow = Module["_Pow"] = function() {
            return (_Pow = Module["_Pow"] = Module["asm"]["Pow"]).apply(null, arguments);
        };
        var _Prelu = Module["_Prelu"] = function() {
            return (_Prelu = Module["_Prelu"] = Module["asm"]["Prelu"]).apply(null, arguments);
        };
        var _Prod = Module["_Prod"] = function() {
            return (_Prod = Module["_Prod"] = Module["asm"]["Prod"]).apply(null, arguments);
        };
        var _RealDiv = Module["_RealDiv"] = function() {
            return (_RealDiv = Module["_RealDiv"] = Module["asm"]["RealDiv"]).apply(null, arguments);
        };
        var _Relu = Module["_Relu"] = function() {
            return (_Relu = Module["_Relu"] = Module["asm"]["Relu"]).apply(null, arguments);
        };
        var _Relu6 = Module["_Relu6"] = function() {
            return (_Relu6 = Module["_Relu6"] = Module["asm"]["Relu6"]).apply(null, arguments);
        };
        var _ResizeBilinear = Module["_ResizeBilinear"] = function() {
            return (_ResizeBilinear = Module["_ResizeBilinear"] = Module["asm"]["ResizeBilinear"]).apply(null, arguments);
        };
        var _Reverse = Module["_Reverse"] = function() {
            return (_Reverse = Module["_Reverse"] = Module["asm"]["Reverse"]).apply(null, arguments);
        };
        var _RotateWithOffset = Module["_RotateWithOffset"] = function() {
            return (_RotateWithOffset = Module["_RotateWithOffset"] = Module["asm"]["RotateWithOffset"]).apply(null, arguments);
        };
        var _Round = Module["_Round"] = function() {
            return (_Round = Module["_Round"] = Module["asm"]["Round"]).apply(null, arguments);
        };
        var _Rsqrt = Module["_Rsqrt"] = function() {
            return (_Rsqrt = Module["_Rsqrt"] = Module["asm"]["Rsqrt"]).apply(null, arguments);
        };
        var _ScatterNd = Module["_ScatterNd"] = function() {
            return (_ScatterNd = Module["_ScatterNd"] = Module["asm"]["ScatterNd"]).apply(null, arguments);
        };
        var _SelectV2 = Module["_SelectV2"] = function() {
            return (_SelectV2 = Module["_SelectV2"] = Module["asm"]["SelectV2"]).apply(null, arguments);
        };
        var _Sigmoid = Module["_Sigmoid"] = function() {
            return (_Sigmoid = Module["_Sigmoid"] = Module["asm"]["Sigmoid"]).apply(null, arguments);
        };
        var _Sin = Module["_Sin"] = function() {
            return (_Sin = Module["_Sin"] = Module["asm"]["Sin"]).apply(null, arguments);
        };
        var _Softmax = Module["_Softmax"] = function() {
            return (_Softmax = Module["_Softmax"] = Module["asm"]["Softmax"]).apply(null, arguments);
        };
        var _SparseFillEmptyRows = Module["_SparseFillEmptyRows"] = function() {
            return (_SparseFillEmptyRows = Module["_SparseFillEmptyRows"] = Module["asm"]["SparseFillEmptyRows"]).apply(null, arguments);
        };
        var _SparseReshape = Module["_SparseReshape"] = function() {
            return (_SparseReshape = Module["_SparseReshape"] = Module["asm"]["SparseReshape"]).apply(null, arguments);
        };
        var _SparseSegmentReduction = Module["_SparseSegmentReduction"] = function() {
            return (_SparseSegmentReduction = Module["_SparseSegmentReduction"] = Module["asm"]["SparseSegmentReduction"]).apply(null, arguments);
        };
        var _Sqrt = Module["_Sqrt"] = function() {
            return (_Sqrt = Module["_Sqrt"] = Module["asm"]["Sqrt"]).apply(null, arguments);
        };
        var _Square = Module["_Square"] = function() {
            return (_Square = Module["_Square"] = Module["asm"]["Square"]).apply(null, arguments);
        };
        var _SquaredDifference = Module["_SquaredDifference"] = function() {
            return (_SquaredDifference = Module["_SquaredDifference"] = Module["asm"]["SquaredDifference"]).apply(null, arguments);
        };
        var _Step = Module["_Step"] = function() {
            return (_Step = Module["_Step"] = Module["asm"]["Step"]).apply(null, arguments);
        };
        var _StridedSlice = Module["_StridedSlice"] = function() {
            return (_StridedSlice = Module["_StridedSlice"] = Module["asm"]["StridedSlice"]).apply(null, arguments);
        };
        var _Sub = Module["_Sub"] = function() {
            return (_Sub = Module["_Sub"] = Module["asm"]["Sub"]).apply(null, arguments);
        };
        var _Sum = Module["_Sum"] = function() {
            return (_Sum = Module["_Sum"] = Module["asm"]["Sum"]).apply(null, arguments);
        };
        var _Tan = Module["_Tan"] = function() {
            return (_Tan = Module["_Tan"] = Module["asm"]["Tan"]).apply(null, arguments);
        };
        var _Tanh = Module["_Tanh"] = function() {
            return (_Tanh = Module["_Tanh"] = Module["asm"]["Tanh"]).apply(null, arguments);
        };
        var _Tile = Module["_Tile"] = function() {
            return (_Tile = Module["_Tile"] = Module["asm"]["Tile"]).apply(null, arguments);
        };
        var _TopK = Module["_TopK"] = function() {
            return (_TopK = Module["_TopK"] = Module["asm"]["TopK"]).apply(null, arguments);
        };
        var _Transform = Module["_Transform"] = function() {
            return (_Transform = Module["_Transform"] = Module["asm"]["Transform"]).apply(null, arguments);
        };
        var _Transpose = Module["_Transpose"] = function() {
            return (_Transpose = Module["_Transpose"] = Module["asm"]["Transpose"]).apply(null, arguments);
        };
        var __FusedMatMul = Module["__FusedMatMul"] = function() {
            return (__FusedMatMul = Module["__FusedMatMul"] = Module["asm"]["_FusedMatMul"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
            return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
            return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
            return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
            return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
        };
        var dynCall_iijjiiii = Module["dynCall_iijjiiii"] = function() {
            return (dynCall_iijjiiii = Module["dynCall_iijjiiii"] = Module["asm"]["dynCall_iijjiiii"]).apply(null, arguments);
        };
        var dynCall_jiji = Module["dynCall_jiji"] = function() {
            return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
        };
        Module["cwrap"] = cwrap;
        var calledRun;
        function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller;
        };
        function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) return;
            preRun();
            if (runDependencies > 0) return;
            function doRun() {
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT) return;
                initRuntime();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                postRun();
            }
            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function() {
                    setTimeout(function() {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            } else doRun();
        }
        Module["run"] = run;
        function procExit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
                if (Module["onExit"]) Module["onExit"](code);
                ABORT = true;
            }
            quit_(code, new ExitStatus(code));
        }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [
                Module["preInit"]
            ];
            while(Module["preInit"].length > 0)Module["preInit"].pop()();
        }
        run();
        var listenersAdded;
        if (beforeListeners) listenersAdded = {
            uncaughtException: $3tEm6.listeners("uncaughtException").filter(function(listener) {
                return !beforeListeners.uncaughtException.indexOf(listener) > -1;
            }),
            unhandledRejection: $3tEm6.listeners("unhandledRejection").filter(function(listener) {
                return !beforeListeners.unhandledRejection.indexOf(listener) > -1;
            })
        };
        var actualModule;
        if (typeof WasmBackendModule !== "undefined") actualModule = WasmBackendModule;
        else if (typeof WasmBackendModuleThreadedSimd !== "undefined") actualModule = WasmBackendModuleThreadedSimd;
        else throw new Error("Could not find wasm module in post.js");
        if (listenersAdded) {
            var tmpDispose = actualModule["_dispose"];
            actualModule["_dispose"] = function() {
                tmpDispose();
                listenersAdded.uncaughtException.forEach(function(listener) {
                    $3tEm6.removeListener("uncaughtException", listener);
                });
                listenersAdded.unhandledRejection.forEach(function(listener) {
                    $3tEm6.removeListener("unhandledRejection", listener);
                });
            };
        }
        return WasmBackendModule.ready;
    };
})();
$310e6a9481e90f95$exports = $310e6a9481e90f95$var$WasmBackendModule;


class $3f9aee83a734b7cf$export$35f983a360e03cd8 extends $fc3e518cb31152af$export$543916c62202b50a {
    constructor(wasm){
        super();
        this.wasm = wasm;
        // 0 is reserved for null data ids.
        this.dataIdNextNumber = 1;
        this.wasm.tfjs.initWithThreadsCount($3f9aee83a734b7cf$var$threadsCount);
        $3f9aee83a734b7cf$var$actualThreadsCount = this.wasm.tfjs.getThreadsCount();
        this.dataIdMap = new $fc3e518cb31152af$export$e95767ffe2e60cec(this, $307e90c4876a9d4d$export$d3c662a6136faebb());
    }
    write(values, shape, dtype) {
        const dataId = {
            id: this.dataIdNextNumber++
        };
        this.move(dataId, values, shape, dtype, 1);
        return dataId;
    }
    numDataIds() {
        return this.dataIdMap.numDataIds();
    }
    async time(f) {
        const start = $f6b55a2021b78f0d$exports.now();
        f();
        const kernelMs = $f6b55a2021b78f0d$exports.now() - start;
        return {
            kernelMs: kernelMs
        };
    }
    move(dataId, values, shape, dtype, refCount) {
        const id = this.dataIdNextNumber++;
        if (dtype === 'string') {
            const stringBytes = values;
            this.dataIdMap.set(dataId, {
                id: id,
                stringBytes: stringBytes,
                shape: shape,
                dtype: dtype,
                memoryOffset: null,
                refCount: refCount
            });
            return;
        }
        const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
        const numBytes = size * $f6b55a2021b78f0d$exports.bytesPerElement(dtype);
        const memoryOffset = this.wasm._malloc(numBytes);
        this.dataIdMap.set(dataId, {
            id: id,
            memoryOffset: memoryOffset,
            shape: shape,
            dtype: dtype,
            refCount: refCount
        });
        this.wasm.tfjs.registerTensor(id, size, memoryOffset);
        if (values != null) this.wasm.HEAPU8.set(new Uint8Array(values.buffer, values.byteOffset, numBytes), memoryOffset);
    }
    async read(dataId) {
        return this.readSync(dataId);
    }
    readSync(dataId, start, end) {
        const { memoryOffset: memoryOffset , dtype: dtype , shape: shape , stringBytes: stringBytes  } = this.dataIdMap.get(dataId);
        if (dtype === 'string') {
            // Slice all elements.
            if ((start == null || start === 0) && (end == null || end >= stringBytes.length)) return stringBytes;
            return stringBytes.slice(start, end);
        }
        start = start || 0;
        end = end || $f6b55a2021b78f0d$exports.sizeFromShape(shape);
        const bytesPerElement = $f6b55a2021b78f0d$exports.bytesPerElement(dtype);
        const bytes = this.wasm.HEAPU8.slice(memoryOffset + start * bytesPerElement, memoryOffset + end * bytesPerElement);
        return $3f9aee83a734b7cf$var$typedArrayFromBuffer(bytes.buffer, dtype);
    }
    /**
     * Dispose the memory if the dataId has 0 refCount. Return true if the memory
     * is released, false otherwise.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */ disposeData(dataId, force = false) {
        if (this.dataIdMap.has(dataId)) {
            const data = this.dataIdMap.get(dataId);
            data.refCount--;
            if (!force && data.refCount > 0) return false;
            this.wasm._free(data.memoryOffset);
            this.wasm.tfjs.disposeData(data.id);
            this.dataIdMap.delete(dataId);
        }
        return true;
    }
    /** Return refCount of a `TensorData`. */ refCount(dataId) {
        if (this.dataIdMap.has(dataId)) {
            const tensorData = this.dataIdMap.get(dataId);
            return tensorData.refCount;
        }
        return 0;
    }
    incRef(dataId) {
        const data = this.dataIdMap.get(dataId);
        if (data != null) data.refCount++;
    }
    floatPrecision() {
        return 32;
    }
    // Returns the memory offset of a tensor. Useful for debugging and unit
    // testing.
    getMemoryOffset(dataId) {
        return this.dataIdMap.get(dataId).memoryOffset;
    }
    dispose() {
        this.wasm.tfjs.dispose();
        if ('PThread' in this.wasm) this.wasm.PThread.terminateAllThreads();
        this.wasm = null;
    }
    memory() {
        return {
            unreliable: false
        };
    }
    /**
     * Make a tensor info for the output of an op. If `memoryOffset` is not
     * present, this method allocates memory on the WASM heap. If `memoryOffset`
     * is present, the memory was allocated elsewhere (in c++) and we just record
     * the pointer where that memory lives.
     */ makeOutput(shape, dtype, memoryOffset) {
        let dataId;
        if (memoryOffset == null) dataId = this.write(null, shape, dtype);
        else {
            const id = this.dataIdNextNumber++;
            dataId = {
                id: id
            };
            this.dataIdMap.set(dataId, {
                id: id,
                memoryOffset: memoryOffset,
                shape: shape,
                dtype: dtype,
                refCount: 1
            });
            const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
            this.wasm.tfjs.registerTensor(id, size, memoryOffset);
        }
        return {
            dataId: dataId,
            shape: shape,
            dtype: dtype
        };
    }
    typedArrayFromHeap({ shape: shape , dtype: dtype , dataId: dataId  }) {
        const buffer = this.wasm.HEAPU8.buffer;
        const { memoryOffset: memoryOffset  } = this.dataIdMap.get(dataId);
        const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
        switch(dtype){
            case 'float32':
                return new Float32Array(buffer, memoryOffset, size);
            case 'int32':
                return new Int32Array(buffer, memoryOffset, size);
            case 'bool':
                return new Uint8Array(buffer, memoryOffset, size);
            default:
                throw new Error(`Unknown dtype ${dtype}`);
        }
    }
}
function $3f9aee83a734b7cf$var$createInstantiateWasmFunc(path) {
    // this will be replace by rollup plugin patchWechatWebAssembly in
    // minprogram's output.
    // tslint:disable-next-line:no-any
    return (imports, callback)=>{
        $f6b55a2021b78f0d$exports.fetch(path, {
            credentials: 'same-origin'
        }).then((response)=>{
            if (!response['ok']) imports.env.a(`failed to load wasm binary file at '${path}'`);
            response.arrayBuffer().then((binary)=>{
                WebAssembly.instantiate(binary, imports).then((output)=>{
                    callback(output.instance, output.module);
                });
            });
        });
        return {};
    };
}
/**
 * Returns the path of the WASM binary.
 * @param simdSupported whether SIMD is supported
 * @param threadsSupported whether multithreading is supported
 * @param wasmModuleFolder the directory containing the WASM binaries.
 */ function $3f9aee83a734b7cf$var$getPathToWasmBinary(simdSupported, threadsSupported, wasmModuleFolder) {
    if ($3f9aee83a734b7cf$var$wasmPath != null) // If wasmPath is defined, the user has supplied a full path to
    // the vanilla .wasm binary.
    return $3f9aee83a734b7cf$var$wasmPath;
    let path = 'tfjs-backend-wasm.wasm';
    if (simdSupported && threadsSupported) path = 'tfjs-backend-wasm-threaded-simd.wasm';
    else if (simdSupported) path = 'tfjs-backend-wasm-simd.wasm';
    if ($3f9aee83a734b7cf$var$wasmFileMap != null) {
        if ($3f9aee83a734b7cf$var$wasmFileMap[path] != null) return $3f9aee83a734b7cf$var$wasmFileMap[path];
    }
    return wasmModuleFolder + path;
}
async function $3f9aee83a734b7cf$export$2cd8252107eb640b() {
    const [simdSupported, threadsSupported] = await Promise.all([
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getAsync('WASM_HAS_SIMD_SUPPORT'),
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getAsync('WASM_HAS_MULTITHREAD_SUPPORT')
    ]);
    return new Promise((resolve, reject)=>{
        const factoryConfig = {};
        /**
         * This function overrides the Emscripten module locateFile utility.
         * @param path The relative path to the file that needs to be loaded.
         * @param prefix The path to the main JavaScript file's directory.
         */ factoryConfig.locateFile = (path, prefix)=>{
            if (path.endsWith('.worker.js')) {
                // Escape '\n' because Blob will turn it into a newline.
                // There should be a setting for this, but 'endings: "native"' does
                // not seem to work.
                const response = $16ece16e4f044bcd$export$8db778f4bac1cd46.replace(/\n/g, '\\n');
                const blob = new Blob([
                    response
                ], {
                    type: 'application/javascript'
                });
                return URL.createObjectURL(blob);
            }
            if (path.endsWith('.wasm')) return $3f9aee83a734b7cf$var$getPathToWasmBinary(simdSupported, threadsSupported, $3f9aee83a734b7cf$var$wasmPathPrefix != null ? $3f9aee83a734b7cf$var$wasmPathPrefix : prefix);
            return prefix + path;
        };
        // Use the instantiateWasm override when system fetch is not available.
        // Reference:
        // https://github.com/emscripten-core/emscripten/blob/2bca083cbbd5a4133db61fbd74d04f7feecfa907/tests/manual_wasm_instantiate.html#L170
        if ($3f9aee83a734b7cf$var$customFetch) factoryConfig.instantiateWasm = $3f9aee83a734b7cf$var$createInstantiateWasmFunc($3f9aee83a734b7cf$var$getPathToWasmBinary(simdSupported, threadsSupported, $3f9aee83a734b7cf$var$wasmPathPrefix != null ? $3f9aee83a734b7cf$var$wasmPathPrefix : ''));
        let initialized = false;
        factoryConfig.onAbort = ()=>{
            if (initialized) // Emscripten already called console.warn so no need to double log.
            return;
            if ($3f9aee83a734b7cf$var$initAborted) // Emscripten calls `onAbort` twice, resulting in double error
            // messages.
            return;
            $3f9aee83a734b7cf$var$initAborted = true;
            const rejectMsg = "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers";
            reject({
                message: rejectMsg
            });
        };
        let wasm;
        // If `wasmPath` has been defined we must initialize the vanilla module.
        if (threadsSupported && simdSupported && $3f9aee83a734b7cf$var$wasmPath == null) {
            factoryConfig.mainScriptUrlOrBlob = new Blob([
                `var WasmBackendModuleThreadedSimd = ` + (/*@__PURE__*/$parcel$interopDefault($45d650a2999915c1$exports)).toString()
            ], {
                type: 'text/javascript'
            });
            wasm = (/*@__PURE__*/$parcel$interopDefault($45d650a2999915c1$exports))(factoryConfig);
        } else // The wasmFactory works for both vanilla and SIMD binaries.
        wasm = (/*@__PURE__*/$parcel$interopDefault($310e6a9481e90f95$exports))(factoryConfig);
        // The WASM module has been successfully created by the factory.
        // Any error will be caught by the onAbort callback defined above.
        wasm.then((module)=>{
            initialized = true;
            $3f9aee83a734b7cf$var$initAborted = false;
            const voidReturnType = null;
            // Using the tfjs namespace to avoid conflict with emscripten's API.
            module.tfjs = {
                init: module.cwrap('init', null, []),
                initWithThreadsCount: module.cwrap('init_with_threads_count', null, [
                    'number'
                ]),
                getThreadsCount: module.cwrap('get_threads_count', 'number', []),
                registerTensor: module.cwrap('register_tensor', null, [
                    'number',
                    'number',
                    'number', 
                ]),
                disposeData: module.cwrap('dispose_data', voidReturnType, [
                    'number'
                ]),
                dispose: module.cwrap('dispose', voidReturnType, [])
            };
            resolve({
                wasm: module
            });
        });
    });
}
function $3f9aee83a734b7cf$var$typedArrayFromBuffer(buffer, dtype) {
    switch(dtype){
        case 'float32':
            return new Float32Array(buffer);
        case 'int32':
            return new Int32Array(buffer);
        case 'bool':
            return new Uint8Array(buffer);
        default:
            throw new Error(`Unknown dtype ${dtype}`);
    }
}
const $3f9aee83a734b7cf$var$wasmBinaryNames = [
    'tfjs-backend-wasm.wasm',
    'tfjs-backend-wasm-simd.wasm',
    'tfjs-backend-wasm-threaded-simd.wasm'
];
let $3f9aee83a734b7cf$var$wasmPath = null;
let $3f9aee83a734b7cf$var$wasmPathPrefix = null;
let $3f9aee83a734b7cf$var$wasmFileMap = {};
let $3f9aee83a734b7cf$var$initAborted = false;
let $3f9aee83a734b7cf$var$customFetch = false;
function $3f9aee83a734b7cf$export$3371aa6d4a43b6cf(path, usePlatformFetch = false) {
    $307e90c4876a9d4d$export$e46eea6a629d2da5("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release.");
    if ($3f9aee83a734b7cf$var$initAborted) throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
    $3f9aee83a734b7cf$var$wasmPath = path;
    $3f9aee83a734b7cf$var$customFetch = usePlatformFetch;
}
function $3f9aee83a734b7cf$export$96f76c6576699053(prefixOrFileMap, usePlatformFetch = false) {
    if ($3f9aee83a734b7cf$var$initAborted) throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
    if (typeof prefixOrFileMap === 'string') $3f9aee83a734b7cf$var$wasmPathPrefix = prefixOrFileMap;
    else {
        $3f9aee83a734b7cf$var$wasmFileMap = prefixOrFileMap;
        const missingPaths = $3f9aee83a734b7cf$var$wasmBinaryNames.filter((name)=>$3f9aee83a734b7cf$var$wasmFileMap[name] == null
        );
        if (missingPaths.length > 0) throw new Error(`There were no entries found for the following binaries: ` + `${missingPaths.join(',')}. Please either call setWasmPaths with a ` + `map providing a path for each binary, or with a string indicating ` + `the directory where all the binaries can be found.`);
    }
    $3f9aee83a734b7cf$var$customFetch = usePlatformFetch;
}
function $3f9aee83a734b7cf$export$ed26752bf42aea79() {
    $3f9aee83a734b7cf$var$wasmPath = null;
    $3f9aee83a734b7cf$var$wasmPathPrefix = null;
    $3f9aee83a734b7cf$var$wasmFileMap = {};
    $3f9aee83a734b7cf$var$customFetch = false;
    $3f9aee83a734b7cf$var$initAborted = false;
}
let $3f9aee83a734b7cf$var$threadsCount = -1;
let $3f9aee83a734b7cf$var$actualThreadsCount = -1;
function $3f9aee83a734b7cf$export$b13f278778f0c389(numThreads) {
    $3f9aee83a734b7cf$var$threadsCount = numThreads;
}
function $3f9aee83a734b7cf$export$2878a7293fa21941() {
    if ($3f9aee83a734b7cf$var$actualThreadsCount === -1) throw new Error(`WASM backend not initialized.`);
    return $3f9aee83a734b7cf$var$actualThreadsCount;
}




const $fd75162515b0a9a7$var$WASM_PRIORITY = 2;
$307e90c4876a9d4d$export$1ac8c3a90eff05d('wasm', async ()=>{
    const { wasm: wasm  } = await $3f9aee83a734b7cf$export$2cd8252107eb640b();
    return new $3f9aee83a734b7cf$export$35f983a360e03cd8(wasm);
}, $fd75162515b0a9a7$var$WASM_PRIORITY);




function $3021ccad43dbee2d$export$2a73984e4f41e1c1(size) {
    const array = new Float32Array(size);
    for(let i = 0; i < size; i++)array[i] = Math.random();
    return array;
}
function $3021ccad43dbee2d$export$58fde443e4317a86(times) {
    const count = times.length;
    const sum_time = times.reduce((sum, current)=>sum + current
    , 0);
    const avg_time = sum_time / count;
    const standard_deviation = Math.sqrt(times.reduce((sum, current)=>sum + Math.pow(current - avg_time, 2)
    ) / (count - 1));
    const sem = standard_deviation / Math.sqrt(count);
    const confidence_interval = 1.96 * sem;
    return {
        mean: avg_time,
        confidence_interval: confidence_interval
    };
}






const $301f7bf4101118e6$export$796b583dd79d8524 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$64636e173424d83d, (xi)=>xi >= 0 ? xi : Math.exp(xi) - 1
);
const $301f7bf4101118e6$export$b990686634ee3cce = {
    kernelName: $2b76be1e72a8c1db$export$64636e173424d83d,
    backendName: 'cpu',
    kernelFunc: $301f7bf4101118e6$export$796b583dd79d8524
};





function $ff0b67d8ce18003d$export$23a860e40a2c6b61(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { alpha: alpha  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x
    ], 'leakyRelu');
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const xVals = backend.data.get(x.dataId).values;
    const outVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('float32', xSize);
    for(let i = 0; i < xVals.length; i++)outVals[i] = xVals[i] < 0 ? alpha * xVals[i] : xVals[i];
    return backend.makeTensorInfo(x.shape, 'float32', outVals);
}
const $ff0b67d8ce18003d$export$aa04ab963fdf437f = {
    kernelName: $2b76be1e72a8c1db$export$f0c7162bb7af1a2d,
    backendName: 'cpu',
    kernelFunc: $ff0b67d8ce18003d$export$23a860e40a2c6b61
};





const $4ed127e19443316b$var$preluImpl = $c0c4b4b9f56d6853$export$28de919591fae5d9((xValue, aValue)=>xValue < 0 ? aValue * xValue : xValue
);
function $4ed127e19443316b$export$5882f235222e6729(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x , alpha: alpha  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        alpha
    ], 'prelu');
    const aVals = backend.data.get(x.dataId).values;
    const bVals = backend.data.get(alpha.dataId).values;
    const [resultData, resultShape] = $4ed127e19443316b$var$preluImpl(x.shape, alpha.shape, aVals, bVals, 'float32');
    return backend.makeTensorInfo(resultShape, 'float32', resultData);
}
const $4ed127e19443316b$export$a5c4a9b694579636 = {
    kernelName: $2b76be1e72a8c1db$export$a42f35f308fc2fa3,
    backendName: 'cpu',
    kernelFunc: $4ed127e19443316b$export$5882f235222e6729
};




const $77b59f61b1ecd495$export$16d1e4612cc0139f = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$9a6ff968bf961432, (xi)=>Math.max(0, xi)
);
const $77b59f61b1ecd495$export$731f9199bde068eb = {
    kernelName: $2b76be1e72a8c1db$export$9a6ff968bf961432,
    backendName: 'cpu',
    kernelFunc: $77b59f61b1ecd495$export$16d1e4612cc0139f
};




const $46f3e8e0610dbf6c$export$4a62bcb95e9c44c4 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$3be9e924f629054e, (xi)=>Math.min(Math.max(0, xi), 6)
);
const $46f3e8e0610dbf6c$export$92c30890ad649d53 = {
    kernelName: $2b76be1e72a8c1db$export$3be9e924f629054e,
    backendName: 'cpu',
    kernelFunc: $46f3e8e0610dbf6c$export$4a62bcb95e9c44c4
};



function $7a87657b07beec11$export$a0f250a2ba84196(backend, x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === 'linear') return $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    else if (activation === 'relu') return $77b59f61b1ecd495$export$16d1e4612cc0139f({
        inputs: {
            x: x
        },
        backend: backend
    });
    else if (activation === 'elu') return $301f7bf4101118e6$export$796b583dd79d8524({
        inputs: {
            x: x
        },
        backend: backend
    });
    else if (activation === 'relu6') return $46f3e8e0610dbf6c$export$4a62bcb95e9c44c4({
        inputs: {
            x: x
        },
        backend: backend
    });
    else if (activation === 'prelu') return $4ed127e19443316b$export$5882f235222e6729({
        inputs: {
            x: x,
            alpha: preluActivationWeights
        },
        backend: backend
    });
    else if (activation === 'leakyrelu') return $ff0b67d8ce18003d$export$23a860e40a2c6b61({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            alpha: leakyreluAlpha
        }
    });
    else if (activation === 'sigmoid') return $f57eef2a9f713d28$export$3b295495ca3cad7c({
        inputs: {
            x: x
        },
        backend: backend
    });
    throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`);
}






function $2386a2b74ddbe498$export$9eaad88cf88cee2b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { shape: shape  } = attrs;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const $shape = $f6b55a2021b78f0d$exports.inferFromImplicitShape(shape, xSize);
    const $xSize = $f6b55a2021b78f0d$exports.sizeFromShape($shape);
    $f6b55a2021b78f0d$exports.assert(xSize === $xSize, ()=>`The new shape (${$shape}) has ${$xSize} elements and the old ` + `shape (${x.shape}) has ${xSize} elements. The new shape and old ` + `shape must have the same number of elements.`
    );
    backend.incRef(x.dataId);
    const xData = backend.data.get(x.dataId);
    if (xData.complexTensorInfos != null) {
        const real = xData.complexTensorInfos.real;
        const imag = xData.complexTensorInfos.imag;
        real.shape = $shape;
        imag.shape = $shape;
    }
    return {
        dataId: x.dataId,
        shape: $shape,
        dtype: x.dtype
    };
}
const $2386a2b74ddbe498$export$cfa02e698602aca2 = {
    kernelName: $2b76be1e72a8c1db$export$755ddd847e5abe03,
    backendName: 'cpu',
    kernelFunc: $2386a2b74ddbe498$export$9eaad88cf88cee2b
};


function $295c0101af9de7b7$export$8f97894b482227f0(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b  } = inputs;
    const { transposeA: transposeA , transposeB: transposeB  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        a,
        b
    ], 'matMul');
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsA);
    const batchDimB = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsB);
    const outShapeOuterDims = $c374f26140f3eb6b$exports.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([
        outerShapeA,
        outerShapeB
    ]);
    $f6b55a2021b78f0d$exports.assert(innerShapeA === innerShapeB, ()=>`Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`
    );
    const a3dShape = transposeA ? [
        batchDimA,
        innerShapeA,
        outerShapeA
    ] : [
        batchDimA,
        outerShapeA,
        innerShapeA
    ];
    const b3dShape = transposeB ? [
        batchDimB,
        outerShapeB,
        innerShapeB
    ] : [
        batchDimB,
        innerShapeB,
        outerShapeB
    ];
    // The rest of the implementation is designed to operate on rank-3 tensors
    const a3d = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: a
        },
        backend: backend,
        attrs: {
            shape: a3dShape
        }
    });
    const b3d = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: b
        },
        backend: backend,
        attrs: {
            shape: b3dShape
        }
    });
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
    const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
    const batchDim = Math.max(batchDimA, batchDimB);
    const a3dValues = backend.data.get(a3d.dataId).values;
    const b3dValues = backend.data.get(b3d.dataId).values;
    const a3dStrides = $f6b55a2021b78f0d$exports.computeStrides(a3d.shape);
    const b3dStrides = $f6b55a2021b78f0d$exports.computeStrides(b3d.shape);
    const [aBatch, aOuterStep, aInnerStep] = transposeA ? [
        a3dStrides[0],
        1,
        a3dStrides[1]
    ] : [
        a3dStrides[0],
        a3dStrides[1],
        1
    ];
    const [bInnerStep, bOuterStep, bBatch] = transposeB ? [
        1,
        b3dStrides[1],
        b3dStrides[0]
    ] : [
        b3dStrides[1],
        1,
        b3dStrides[0]
    ];
    const size = leftDim * rightDim;
    const result = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        batchDim,
        leftDim,
        rightDim
    ], a3d.dtype);
    const resVals = result.values;
    const blockSize = backend.blockSize;
    for(let bi = 0; bi < batchDim; bi++)for(let i0 = 0; i0 < leftDim; i0 += blockSize){
        for(let j0 = 0; j0 < rightDim; j0 += blockSize)for(let k0 = 0; k0 < sharedDim; k0 += blockSize){
            // for when blockSize doesn't evenly divide the input
            const iBlock = Math.min(i0 + blockSize, leftDim);
            const jBlock = Math.min(j0 + blockSize, rightDim);
            const kBlock = Math.min(k0 + blockSize, sharedDim);
            for(let i = i0; i < iBlock; i++)for(let j = j0; j < jBlock; j++){
                let sum = 0.0;
                for(let k = k0; k < kBlock; k++){
                    const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;
                    const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;
                    const aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];
                    const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];
                    sum += aVal * bVal;
                }
                resVals[bi * size + (i * rightDim + j)] += sum;
            }
        }
    }
    backend.disposeIntermediateTensorInfo(a3d);
    backend.disposeIntermediateTensorInfo(b3d);
    // set correct shape on output.
    return backend.makeTensorInfo(outShape, result.dtype, result.values);
}
const $295c0101af9de7b7$export$d0dd993198185538 = {
    kernelName: $2b76be1e72a8c1db$export$9a3bf60b23f63c8,
    backendName: 'cpu',
    kernelFunc: $295c0101af9de7b7$export$8f97894b482227f0
};


function $96128b73937fa9ec$export$d86ca0bbe0236889(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { transposeA: transposeA , transposeB: transposeB , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    let current;
    let addRes;
    let activationRes;
    const intermediates = [];
    const matMulRes = $295c0101af9de7b7$export$8f97894b482227f0({
        inputs: {
            a: a,
            b: b
        },
        attrs: {
            transposeA: transposeA,
            transposeB: transposeB
        },
        backend: backend
    });
    current = matMulRes;
    if (bias) {
        addRes = $cbaec80dd34f96bb$export$e16d8520af44a096({
            inputs: {
                a: current,
                b: bias
            },
            backend: backend
        });
        intermediates.push(current);
        current = addRes;
    }
    if (activation) {
        activationRes = $7a87657b07beec11$export$a0f250a2ba84196(backend, current, activation, preluActivationWeights, leakyreluAlpha);
        intermediates.push(current);
        current = activationRes;
    }
    for (const i of intermediates)backend.disposeIntermediateTensorInfo(i);
    return current;
}
const $96128b73937fa9ec$export$f70d36da1c218f84 = {
    kernelName: $2b76be1e72a8c1db$export$8d1af0f7c2a4da9e,
    backendName: 'cpu',
    kernelFunc: $96128b73937fa9ec$export$d86ca0bbe0236889
};





const $5734363ba4c798dd$export$fd6306be3fde5b04 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$3b952c9980dac550, (xi)=>Math.acos(xi)
);
const $5734363ba4c798dd$export$255826ca70737275 = {
    kernelName: $2b76be1e72a8c1db$export$3b952c9980dac550,
    backendName: 'cpu',
    kernelFunc: $5734363ba4c798dd$export$fd6306be3fde5b04
};




const $378191978be14204$export$b26caf0f29211d08 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$987da490b7c2e7dd, (xi)=>Math.acosh(xi)
);
const $378191978be14204$export$3f520b71a56c9e70 = {
    kernelName: $2b76be1e72a8c1db$export$987da490b7c2e7dd,
    backendName: 'cpu',
    kernelFunc: $378191978be14204$export$b26caf0f29211d08
};





function $27f84d1db31021f6$export$37b75d0026f96b8d(args) {
    const { inputs: inputs , backend: backend  } = args;
    const tensors = inputs;
    $2f54d733028161b9$export$1412c17b2531581a(inputs, 'addN');
    const vals = tensors.map((t)=>backend.data.get(t.dataId).values
    );
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(tensors[0].shape, tensors[0].dtype);
    const outVals = outBuf.values;
    for(let i = 0; i < tensors.length; i++){
        const currVals = vals[i];
        for(let j = 0; j < outVals.length; j++)outVals[j] += currVals[j];
    }
    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
const $27f84d1db31021f6$export$ff8000bc6f0313e1 = {
    kernelName: $2b76be1e72a8c1db$export$eef235ad06d3226a,
    backendName: 'cpu',
    kernelFunc: $27f84d1db31021f6$export$37b75d0026f96b8d
};






function $5f1027d384ff24cd$export$84bf76cd7afc7469(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'all');
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
        $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('all', axes, $x.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(outShape), $x.dtype);
    const aVals = backend.data.get($x.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let $5f1027d384ff24cd$export$84bf76cd7afc7469 = aVals[offset];
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            $5f1027d384ff24cd$export$84bf76cd7afc7469 = $5f1027d384ff24cd$export$84bf76cd7afc7469 && value;
        }
        vals[i] = $5f1027d384ff24cd$export$84bf76cd7afc7469;
    }
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo($x);
    const result = backend.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
        const expandedShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        const reshapedResult = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                shape: expandedShape
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        return reshapedResult;
    }
    return result;
}
const $5f1027d384ff24cd$export$4e3f081eb1a330fa = {
    kernelName: $2b76be1e72a8c1db$export$5dceb1ab650a1776,
    backendName: 'cpu',
    kernelFunc: $5f1027d384ff24cd$export$84bf76cd7afc7469
};






function $3e6148c078fcdc73$export$4154a199d7d90455(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'any');
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
        $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('any', axes, $x.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(outShape), $x.dtype);
    const aVals = backend.data.get($x.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let anyVal = aVals[offset];
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            anyVal = anyVal || value;
        }
        vals[i] = anyVal;
    }
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo($x);
    const result = backend.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
        const expandedShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        const reshapedResult = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                shape: expandedShape
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        return reshapedResult;
    }
    return result;
}
const $3e6148c078fcdc73$export$1a8ff634f2df3da6 = {
    kernelName: $2b76be1e72a8c1db$export$b24b633b1364b94b,
    backendName: 'cpu',
    kernelFunc: $3e6148c078fcdc73$export$4154a199d7d90455
};





function $f2e299e0b0085db3$export$7980a683c1b852b4(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'argMax');
    let axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        intermediateTensorInfos.push($x);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    axes = [
        axes[0]
    ];
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('argMax', axes, $x.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes($x.shape, axes);
    const outSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShape);
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray(outSize, 'int32');
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const aVals = backend.data.get($x.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let max = aVals[offset];
        let maxIndex = 0;
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            if (value > max) {
                max = value;
                maxIndex = j;
            }
        }
        vals[i] = maxIndex;
    }
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return backend.makeTensorInfo(outShape, 'int32', vals);
}
const $f2e299e0b0085db3$export$ec7419fc9ad0069e = {
    kernelName: $2b76be1e72a8c1db$export$17612294a1503e1c,
    backendName: 'cpu',
    kernelFunc: $f2e299e0b0085db3$export$7980a683c1b852b4
};





function $0f130ad1245e066f$export$ec99a91cddfb29a2(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'argMin');
    let axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        intermediateTensorInfos.push($x);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    axes = [
        axes[0]
    ];
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('argMin', axes, $x.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes($x.shape, axes);
    const outSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShape);
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray(outSize, 'int32');
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const aVals = backend.data.get($x.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let min = aVals[offset];
        let minIndex = 0;
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            if (value < min) {
                min = value;
                minIndex = j;
            }
        }
        vals[i] = minIndex;
    }
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return backend.makeTensorInfo(outShape, 'int32', vals);
}
const $0f130ad1245e066f$export$21836a5e5fa09eb4 = {
    kernelName: $2b76be1e72a8c1db$export$baabd09270cbbd94,
    backendName: 'cpu',
    kernelFunc: $0f130ad1245e066f$export$ec99a91cddfb29a2
};




const $3026227daa64c21b$export$41726bdb1fc63f = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$664c8ca7e7e5c126, (xi)=>Math.asin(xi)
);
const $3026227daa64c21b$export$de5cb0ef95dd6700 = {
    kernelName: $2b76be1e72a8c1db$export$664c8ca7e7e5c126,
    backendName: 'cpu',
    kernelFunc: $3026227daa64c21b$export$41726bdb1fc63f
};




const $cee1c3e33d50740b$export$839d8a01b6af4fc0 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$847c88940cb7dcb5, (xi)=>Math.asinh(xi)
);
const $cee1c3e33d50740b$export$20d424616c76166 = {
    kernelName: $2b76be1e72a8c1db$export$847c88940cb7dcb5,
    backendName: 'cpu',
    kernelFunc: $cee1c3e33d50740b$export$839d8a01b6af4fc0
};




const $bb29989adafd3c66$export$628dc4eed22b0fbd = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$bac667d46ac043ae, (xi)=>Math.atan(xi)
);
const $bb29989adafd3c66$export$159d632e3ff13624 = {
    kernelName: $2b76be1e72a8c1db$export$bac667d46ac043ae,
    backendName: 'cpu',
    kernelFunc: $bb29989adafd3c66$export$628dc4eed22b0fbd
};





const $473ae5fcac9bfdc7$export$2420f4f902e099a2 = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>Math.atan2(aValue, bValue)
);
const $473ae5fcac9bfdc7$export$b8b770ee6a0d9760 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$3bf4c619ce589f4b, $473ae5fcac9bfdc7$export$2420f4f902e099a2);
const $473ae5fcac9bfdc7$export$c53c7ab019edb8a0 = {
    kernelName: $2b76be1e72a8c1db$export$3bf4c619ce589f4b,
    backendName: 'cpu',
    kernelFunc: $473ae5fcac9bfdc7$export$b8b770ee6a0d9760
};




const $adc8bfcccd56744d$export$21ea955025ceb08b = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$98981a86fa2b1366, (xi)=>Math.atanh(xi)
);
const $adc8bfcccd56744d$export$e9ce1ba75fc9b746 = {
    kernelName: $2b76be1e72a8c1db$export$98981a86fa2b1366,
    backendName: 'cpu',
    kernelFunc: $adc8bfcccd56744d$export$21ea955025ceb08b
};





function $ac1c9a98a3d54919$export$7a0e2789ec54f0db(xValues, xShape, dtype, strides, convInfo, poolType) {
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    const output = $034bc04874ecb003$export$ab1029bcae9ddb4a(convInfo.outShape, dtype);
    const outputVals = output.values;
    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];
    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];
    const outputColStrides = convInfo.outShape[3];
    for(let b = 0; b < convInfo.batchSize; ++b){
        const outputBatchOffset = b * outputBatchStrides;
        const inputBatchOffset = b * strides[0];
        for(let d = 0; d < convInfo.inChannels; ++d)for(let yR = 0; yR < convInfo.outHeight; ++yR){
            const xRCorner = yR * strideHeight - padTop;
            const xRMin = Math.max(0, xRCorner);
            const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
            const outputRowOffset = outputBatchOffset + yR * outputRowStrides;
            for(let yC = 0; yC < convInfo.outWidth; ++yC){
                const xCCorner = yC * strideWidth - padLeft;
                const xCMin = Math.max(0, xCCorner);
                const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
                let minMaxValue = initialValue;
                let avgValue = 0;
                let count = 0;
                for(let xR = xRMin; xR < xRMax; xR += dilationHeight){
                    const xROffset = inputBatchOffset + xR * strides[1];
                    for(let xC = xCMin; xC < xCMax; xC += dilationWidth){
                        const xCOffset = xROffset + xC * strides[2];
                        const pixel = xValues[xCOffset + d];
                        if (poolType === 'max' && pixel > minMaxValue) minMaxValue = pixel;
                        else if (poolType === 'avg') {
                            avgValue += pixel;
                            count++;
                        }
                    }
                    if (isNaN(minMaxValue)) break;
                }
                const outputOffset = outputRowOffset + yC * outputColStrides + d;
                outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;
            }
        }
    }
    return output;
}
function $ac1c9a98a3d54919$export$60b78444d0fe518d(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {
    const maxPositions = $034bc04874ecb003$export$ab1029bcae9ddb4a(convInfo.outShape, 'int32');
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const xBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(xShape, dtype, xValues);
    for(let b = 0; b < convInfo.batchSize; ++b){
        for(let d = 0; d < convInfo.inChannels; ++d)for(let yR = 0; yR < convInfo.outHeight; ++yR){
            const xRCorner = yR * strideHeight - padTop;
            let xRMin = xRCorner;
            while(xRMin < 0)xRMin += dilationHeight;
            // const xRMin = Math.max(0, xRCorner);
            const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
            for(let yC = 0; yC < convInfo.outWidth; ++yC){
                const xCCorner = yC * strideWidth - padLeft;
                let xCMin = xCCorner;
                while(xCMin < 0)xCMin += dilationWidth;
                const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
                let maxValue = Number.NEGATIVE_INFINITY;
                let maxPosition = -1;
                for(let xR = xRMin; xR < xRMax; xR += dilationHeight){
                    const wR = xR - xRCorner;
                    for(let xC = xCMin; xC < xCMax; xC += dilationWidth){
                        const wC = xC - xCCorner;
                        const pixel = xBuf.get(b, xR, xC, d);
                        if (pixel > maxValue) {
                            maxValue = pixel;
                            if (flattenPositions) maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;
                            else maxPosition = wR * effectiveFilterWidth + wC;
                        }
                    }
                }
                maxPositions.set(maxPosition, b, yR, yC, d);
            }
        }
    }
    return maxPositions;
}
function $ac1c9a98a3d54919$export$3712ebf21d29ff82(xValues, xShape, dtype, strides, convInfo, poolType) {
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    const output = $034bc04874ecb003$export$ab1029bcae9ddb4a(convInfo.outShape, dtype);
    const outputVals = output.values;
    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];
    const outputColStrides = convInfo.outShape[4];
    for(let batch = 0; batch < convInfo.batchSize; ++batch){
        const outputBatchOffset = batch * outputBatchStrides;
        const inputBatchOffset = batch * strides[0];
        for(let channel = 0; channel < convInfo.inChannels; ++channel)for(let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth){
            const xDepthCorner = yDepth * strideDepth - padFront;
            let xDepthMin = xDepthCorner;
            while(xDepthMin < 0)xDepthMin += dilationDepth;
            const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
            const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;
            for(let yRow = 0; yRow < convInfo.outHeight; ++yRow){
                const xRowCorner = yRow * strideHeight - padTop;
                let xRowMin = xRowCorner;
                while(xRowMin < 0)xRowMin += dilationHeight;
                const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
                const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;
                for(let yCol = 0; yCol < convInfo.outWidth; ++yCol){
                    const xColCorner = yCol * strideWidth - padLeft;
                    let xColMin = xColCorner;
                    while(xColMin < 0)xColMin += dilationWidth;
                    const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
                    // Shader code begins
                    const outputColOffset = outputRowOffset + yCol * outputColStrides;
                    let minMaxValue = initialValue;
                    let avgValue = 0;
                    let count = 0;
                    for(let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth){
                        const xDepthOffset = inputBatchOffset + xDepth * strides[1];
                        for(let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight){
                            const xRowOffset = xDepthOffset + xRow * strides[2];
                            for(let xCol = xColMin; xCol < xColMax; xCol += dilationWidth){
                                const xColOffset = xRowOffset + xCol * strides[3];
                                const pixel = xValues[xColOffset + channel];
                                if (poolType === 'max' && pixel > minMaxValue) minMaxValue = pixel;
                                else if (poolType === 'avg') {
                                    avgValue += pixel;
                                    count++;
                                }
                                if (isNaN(minMaxValue)) break;
                            }
                            if (isNaN(minMaxValue)) break;
                        }
                        if (isNaN(minMaxValue)) break;
                    }
                    const outputOffset = outputColOffset + channel;
                    outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;
                }
            }
        }
    }
    return output;
}
function $ac1c9a98a3d54919$export$e389a84eda2bb69e(xBuf, convInfo) {
    const maxPositions = $034bc04874ecb003$export$ab1029bcae9ddb4a(convInfo.outShape, 'int32');
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    for(let batch = 0; batch < convInfo.batchSize; ++batch){
        for(let channel = 0; channel < convInfo.inChannels; ++channel)for(let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth){
            const xDepthCorner = yDepth * strideDepth - padFront;
            let xDepthMin = xDepthCorner;
            while(xDepthMin < 0)xDepthMin += dilationDepth;
            const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
            for(let yRow = 0; yRow < convInfo.outHeight; ++yRow){
                const xRowCorner = yRow * strideHeight - padTop;
                let xRowMin = xRowCorner;
                while(xRowMin < 0)xRowMin += dilationHeight;
                const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
                for(let yCol = 0; yCol < convInfo.outWidth; ++yCol){
                    const xColCorner = yCol * strideWidth - padLeft;
                    let xColMin = xColCorner;
                    while(xColMin < 0)xColMin += dilationWidth;
                    const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
                    // Shader code begins
                    let maxValue = Number.NEGATIVE_INFINITY;
                    let maxPosition = -1;
                    for(let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth){
                        const wDepth = xDepth - xDepthCorner;
                        for(let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight){
                            const wRow = xRow - xRowCorner;
                            for(let xCol = xColMin; xCol < xColMax; xCol += dilationWidth){
                                const wCol = xCol - xColCorner;
                                const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);
                                if (pixel >= maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;
                                }
                            }
                        }
                    }
                    maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);
                }
            }
        }
    }
    return maxPositions;
}



function $301e1cadb387a462$export$d5c65a2abd3d97dc(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'avgPool');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = 1;
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, dilations), ()=>'Error in avgPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    let res;
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && $f6b55a2021b78f0d$exports.arraysEqual(convInfo.inShape, convInfo.outShape)) res = $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    else {
        const xValues = backend.data.get(x.dataId).values;
        const strides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
        const buffer = $ac1c9a98a3d54919$export$7a0e2789ec54f0db(xValues, x.shape, x.dtype, strides, convInfo, 'avg');
        res = backend.makeTensorInfo(convInfo.outShape, x.dtype, buffer.values);
    }
    return res;
}
const $301e1cadb387a462$export$6c901824a23e6150 = {
    kernelName: $2b76be1e72a8c1db$export$37f2cc7be1add88c,
    backendName: 'cpu',
    kernelFunc: $301e1cadb387a462$export$d5c65a2abd3d97dc
};





function $a09e80632f7d870d$export$8e92f7d23b27f144(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode , dataFormat: dataFormat  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'avgPool3d');
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode, dataFormat);
    const xValues = backend.data.get(x.dataId).values;
    const outBuf = $ac1c9a98a3d54919$export$3712ebf21d29ff82(xValues, x.shape, x.dtype, $f6b55a2021b78f0d$exports.computeStrides(x.shape), convInfo, 'avg');
    return backend.makeTensorInfo(outBuf.shape, 'float32', outBuf.values);
}
const $a09e80632f7d870d$export$5a9c81d240244392 = {
    kernelName: $2b76be1e72a8c1db$export$390ecb697af103f6,
    backendName: 'cpu',
    kernelFunc: $a09e80632f7d870d$export$8e92f7d23b27f144
};




function $4d597c11a1dfe02b$export$798cb4034e996ff4(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        input
    ], 'avgPool3DGrad');
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(input.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = $034bc04874ecb003$export$ab1029bcae9ddb4a(input.shape, 'float32');
    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
    const dyBuf = backend.bufferSync(dy);
    for(let batch = 0; batch < convInfo.batchSize; ++batch){
        for(let channel = 0; channel < convInfo.inChannels; ++channel)for(let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth){
            for(let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow)for(let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol){
                // Shader code begins.
                const dyDepthCorner = dxDepth - padFront;
                const dyRowCorner = dxRow - padTop;
                const dyColCorner = dxCol - padLeft;
                let dotProd = 0;
                for(let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth){
                    const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                    if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) continue;
                    for(let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight){
                        const dyRow = (dyRowCorner + wRow) / strideHeight;
                        if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) continue;
                        for(let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth){
                            const dyCol = (dyColCorner + wCol) / strideWidth;
                            if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) continue;
                            const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                            dotProd += pixel;
                        }
                    }
                }
                dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);
            }
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $4d597c11a1dfe02b$export$1eeb8780807d0508 = {
    kernelName: $2b76be1e72a8c1db$export$7163112adf28c062,
    backendName: 'cpu',
    kernelFunc: $4d597c11a1dfe02b$export$798cb4034e996ff4
};




function $fa7019251f9c8291$export$2f098171d1c79aea(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const x = input;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        input
    ], 'avgPoolGrad');
    const { filterSize: filterSize , strides: strides , pad: pad  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad);
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = $034bc04874ecb003$export$ab1029bcae9ddb4a(x.shape, 'float32');
    const avgMultiplier = 1 / (filterHeight * filterWidth);
    const dyData = backend.data.get(dy.dataId).values;
    const dyBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(dy.shape, 'float32', dyData);
    for(let b = 0; b < convInfo.batchSize; ++b)for(let d = 0; d < convInfo.inChannels; ++d){
        for(let dxR = 0; dxR < convInfo.inHeight; ++dxR)for(let dxC = 0; dxC < convInfo.inWidth; ++dxC){
            // Shader code begins.
            const dyRCorner = dxR - padTop;
            const dyCCorner = dxC - padLeft;
            let dotProd = 0;
            for(let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight){
                const dyR = (dyRCorner + wR) / strideHeight;
                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) continue;
                for(let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth){
                    const dyC = (dyCCorner + wC) / strideWidth;
                    if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) continue;
                    const pixel = dyBuf.get(b, dyR, dyC, d);
                    dotProd += pixel;
                }
            }
            dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $fa7019251f9c8291$export$ac3f8709351ab225 = {
    kernelName: $2b76be1e72a8c1db$export$9873fd6046cd6951,
    backendName: 'cpu',
    kernelFunc: $fa7019251f9c8291$export$2f098171d1c79aea
};





function $42795d94dc35f3df$export$8ea8088e6d0cdd02(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , scale: scale , offset: offset , mean: mean , variance: variance  } = inputs;
    $f6b55a2021b78f0d$exports.assert(mean.shape.length === variance.shape.length, ()=>"Batch normalization gradient requires mean and variance to have equal ranks."
    );
    $f6b55a2021b78f0d$exports.assert(offset == null || mean.shape.length === offset.shape.length, ()=>"Batch normalization gradient requires mean and offset to have equal ranks."
    );
    $f6b55a2021b78f0d$exports.assert(scale == null || mean.shape.length === scale.shape.length, ()=>"Batch normalization gradient requires mean and scale to have equal ranks."
    );
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        mean,
        variance,
        scale,
        offset
    ], 'batchNorm');
    let { varianceEpsilon: varianceEpsilon  } = attrs;
    if (varianceEpsilon == null) varianceEpsilon = 0.001;
    const xVals = backend.data.get(x.dataId).values;
    const mVals = backend.data.get(mean.dataId).values;
    const varVals = backend.data.get(variance.dataId).values;
    const sVals = scale ? backend.data.get(scale.dataId).values : new Float32Array([
        1
    ]);
    const offVals = offset ? backend.data.get(offset.dataId).values : new Float32Array([
        0
    ]);
    const outVals = new Float32Array(xVals.length);
    const offValsLength = offVals.length;
    const sValsLength = sVals.length;
    const varValsLength = varVals.length;
    const mValsLength = mVals.length;
    let offi = 0;
    let mi = 0;
    let si = 0;
    let vi = 0;
    for(let i = 0; i < xVals.length; ++i){
        outVals[i] = offVals[offi++] + (xVals[i] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);
        if (offi >= offValsLength) offi = 0;
        if (mi >= mValsLength) mi = 0;
        if (si >= sValsLength) si = 0;
        if (vi >= varValsLength) vi = 0;
    }
    return backend.makeTensorInfo(x.shape, x.dtype, outVals);
}
const $42795d94dc35f3df$export$df2dc5c7a755e418 = {
    kernelName: $2b76be1e72a8c1db$export$3821a0416660aaa2,
    backendName: 'cpu',
    kernelFunc: $42795d94dc35f3df$export$8ea8088e6d0cdd02
};







function $1e70ec225283da48$export$ea37d960c1808536(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , crops: crops  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x
    ], 'batchToSpaceND');
    const prod = blockShape.reduce((a, b)=>a * b
    );
    const reshaped = $510a55f99d61727a$exports.getReshaped(x.shape, blockShape, prod);
    const permuted = $510a55f99d61727a$exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = $510a55f99d61727a$exports.getReshapedPermuted(x.shape, blockShape, prod);
    const sliceBeginCoords = $510a55f99d61727a$exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = $510a55f99d61727a$exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const xReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: reshaped
        }
    });
    const xTransposed = $a2ad71a3b184be14$export$9cb09a71b7d66923({
        inputs: {
            x: xReshaped
        },
        backend: backend,
        attrs: {
            perm: permuted
        }
    });
    const xTransposedReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: xTransposed
        },
        backend: backend,
        attrs: {
            shape: reshapedPermuted
        }
    });
    const result = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
        inputs: {
            x: xTransposedReshaped
        },
        backend: backend,
        attrs: {
            begin: sliceBeginCoords,
            size: sliceSize
        }
    });
    backend.disposeIntermediateTensorInfo(xReshaped);
    backend.disposeIntermediateTensorInfo(xTransposed);
    backend.disposeIntermediateTensorInfo(xTransposedReshaped);
    return result;
}
const $1e70ec225283da48$export$44e08e19f97e5513 = {
    kernelName: $2b76be1e72a8c1db$export$e2743f47f61cca1f,
    backendName: 'cpu',
    kernelFunc: $1e70ec225283da48$export$ea37d960c1808536
};




function $5d5fcec67371ad3c$export$7e474bab088ed182(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , weights: weights  } = inputs;
    const { size: size  } = attrs;
    const xVals = backend.data.get(x.dataId).values;
    const weightsVals = backend.data.get(weights.dataId).values;
    const outVals = $169583b362c12f18$export$8e4da6ec633bf0a6(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend.makeTensorInfo([
        size
    ], weights.dtype, outVals);
}
const $5d5fcec67371ad3c$export$af9f0093738840fb = {
    kernelName: $2b76be1e72a8c1db$export$45dfbbff595c32aa,
    backendName: 'cpu',
    kernelFunc: $5d5fcec67371ad3c$export$7e474bab088ed182
};



function $1cde87ca9443367e$export$d226d344aedce941(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { s0: s0 , s1: s1  } = inputs;
    const s0Vals = backend.data.get(s0.dataId).values;
    const s1Vals = backend.data.get(s1.dataId).values;
    const broadcastShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend.makeTensorInfo([
        broadcastShape.length
    ], 'int32', Int32Array.from(broadcastShape));
}
const $1cde87ca9443367e$export$8f7b2ec0c6f08fb2 = {
    kernelName: $2b76be1e72a8c1db$export$32877b1d6d497805,
    backendName: 'cpu',
    kernelFunc: $1cde87ca9443367e$export$d226d344aedce941
};






const $18a85a0e2893e700$export$fa97baf70ad024c0 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$611c0e357ac37f7d, (xi, attrs)=>{
    const clipAttrs = attrs;
    if (xi > clipAttrs.clipValueMax) return clipAttrs.clipValueMax;
    return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;
});
const $18a85a0e2893e700$export$f7ee8f07ce0ff4e1 = {
    kernelName: $2b76be1e72a8c1db$export$611c0e357ac37f7d,
    backendName: 'cpu',
    kernelFunc: $18a85a0e2893e700$export$fa97baf70ad024c0
};




const $0f5e47a77f78fdfb$export$2837bc62566f8808 = (args)=>{
    const { x: x  } = args.inputs;
    const cpuBackend = args.backend;
    const resultValues = new Float32Array($f6b55a2021b78f0d$exports.sizeFromShape(x.shape));
    const complexVals = cpuBackend.data.get(x.dataId);
    const real = complexVals.complexTensorInfos.real;
    const imag = complexVals.complexTensorInfos.imag;
    const realVals = cpuBackend.data.get(real.dataId).values;
    const imagVals = cpuBackend.data.get(imag.dataId).values;
    for(let i = 0; i < realVals.length; i++){
        const real = realVals[i];
        const imag = imagVals[i];
        resultValues[i] = Math.hypot(real, imag);
    }
    return cpuBackend.makeOutput(resultValues, x.shape, 'float32');
};
const $0f5e47a77f78fdfb$export$a4817d2978acc054 = {
    kernelName: $2b76be1e72a8c1db$export$32902e58f1b48f4b,
    backendName: 'cpu',
    kernelFunc: $0f5e47a77f78fdfb$export$2837bc62566f8808
};







function $febe76d18fc2e7a2$export$d78fab5778ab392b(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const $febe76d18fc2e7a2$export$d78fab5778ab392b = backend.data.get(input.dataId).complexTensorInfos.imag;
    const imagVal = backend.data.get($febe76d18fc2e7a2$export$d78fab5778ab392b.dataId).values;
    // When complex tensor is disposed, its underlying parts will be disposed too.
    // Make new tensor out of the imag value of the complex. This makes sure the
    // value is still accessible even if complex tensor is disposed.
    return backend.makeTensorInfo($febe76d18fc2e7a2$export$d78fab5778ab392b.shape, $febe76d18fc2e7a2$export$d78fab5778ab392b.dtype, imagVal);
}
const $febe76d18fc2e7a2$export$ddfc128c2801add7 = {
    kernelName: $2b76be1e72a8c1db$export$303b4473993a24f,
    backendName: 'cpu',
    kernelFunc: $febe76d18fc2e7a2$export$d78fab5778ab392b
};




function $69f14ff8decf8b5f$export$ee1b3e54f0441b22(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, inputs[0].shape)[0];
    let outShape = $510a55f99d61727a$exports.computeOutShape(inputs.map((t)=>t.shape
    ), $axis);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(outShape) === 0) return backend.makeTensorInfo(outShape, inputs[0].dtype, []);
    // Keep only non-empty tensors (ignore tensors with 0 in their shape).
    const $inputs = inputs.filter((t)=>$f6b55a2021b78f0d$exports.sizeFromShape(t.shape) > 0
    );
    if ($inputs.length === 1) return $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: $inputs[0]
        },
        backend: backend
    });
    const shapes = $inputs.map((t)=>t.shape
    );
    $510a55f99d61727a$exports.assertParamsConsistent(shapes, $axis);
    if ($inputs[0].dtype === 'complex64') {
        const reals = $inputs.map((t)=>$cca3c2d597694263$export$9fc57fb453bdbd67({
                inputs: {
                    input: t
                },
                backend: backend
            })
        );
        const imags = $inputs.map((t)=>$febe76d18fc2e7a2$export$d78fab5778ab392b({
                inputs: {
                    input: t
                },
                backend: backend
            })
        );
        const realConcated = $69f14ff8decf8b5f$export$ee1b3e54f0441b22({
            inputs: reals,
            backend: backend,
            attrs: {
                axis: $axis
            }
        });
        const imagConcated = $69f14ff8decf8b5f$export$ee1b3e54f0441b22({
            inputs: imags,
            backend: backend,
            attrs: {
                axis: $axis
            }
        });
        const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: realConcated,
                imag: imagConcated
            },
            backend: backend
        });
        reals.forEach((r)=>backend.disposeIntermediateTensorInfo(r)
        );
        imags.forEach((i)=>backend.disposeIntermediateTensorInfo(i)
        );
        backend.disposeIntermediateTensorInfo(realConcated);
        backend.disposeIntermediateTensorInfo(imagConcated);
        return result;
    }
    // Any concat of n-dimensional tensors across any axis can be reduced to
    // a concatenation of two-dimensional tensors across the axis 1 by first
    // partitioning the axes of the original tensors into those less than the
    // axis to be concatenated and the rest. Then reshape the tensors
    // into a two-dimensional tensor by collapsing these two sets of axes and
    // concatenate the resulting matrices across the axis 1, finally reshaping
    // the result to have the proper shape.
    const inputs2D = $inputs.map((t)=>{
        const innerSize = $f6b55a2021b78f0d$exports.sizeFromShape(t.shape.slice($axis));
        const shape = [
            -1,
            innerSize
        ];
        return $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: t
            },
            backend: backend,
            attrs: {
                shape: shape
            }
        });
    });
    const inputsValShapes = inputs2D.map((t)=>{
        return {
            vals: backend.data.get(t.dataId).values,
            shape: t.shape
        };
    });
    // Concats 2d tensors along axis=1.
    outShape = $510a55f99d61727a$exports.computeOutShape(inputs2D.map((t)=>t.shape
    ), 1 /* axis */ );
    const simplyConcat = inputs2D[0].shape[0] === 1;
    const outVals = $8c0fda6ef00eb49d$export$777da59f594f497d(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
    const finalOutShape = $510a55f99d61727a$exports.computeOutShape($inputs.map((t)=>t.shape
    ), $axis);
    const outInfo = backend.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);
    inputs2D.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return outInfo;
}
const $69f14ff8decf8b5f$export$c8cf96dae25282e5 = {
    kernelName: $2b76be1e72a8c1db$export$936bbfc007425eea,
    backendName: 'cpu',
    kernelFunc: $69f14ff8decf8b5f$export$ee1b3e54f0441b22
};




function $3425cac70d3f2ad3$export$5a2ce5b05041d9e4(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dilations: dilations , dimRoundingMode: dimRoundingMode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        filter
    ], 'conv2d');
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const padLeft = convInfo.padInfo.left;
    const padTop = convInfo.padInfo.top;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const y = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.outShape, x.dtype);
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    const xBatchStride = xStrides[0];
    const xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];
    const xColStride = isChannelsLast ? xStrides[2] : 1;
    const xChannelStride = isChannelsLast ? 1 : xStrides[1];
    const yBatchStride = y.strides[0];
    const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];
    const yColStride = isChannelsLast ? y.strides[2] : 1;
    const yChannelStride = isChannelsLast ? 1 : y.strides[1];
    const xVals = backend.data.get(x.dataId).values;
    const wVals = backend.data.get(filter.dataId).values;
    const yVals = y.values;
    for(let b = 0; b < convInfo.batchSize; ++b){
        const xOffset1 = b * xBatchStride;
        const yOffset1 = b * yBatchStride;
        for(let yR = 0; yR < convInfo.outHeight; ++yR){
            const yOffset2 = yOffset1 + yR * yRowStride;
            const xRCorner = yR * convInfo.strideHeight - padTop;
            for(let wR = 0; wR < filterHeight; ++wR){
                const xR = xRCorner + wR * dilationHeight;
                if (xR < 0 || xR >= convInfo.inHeight) continue;
                const wOffset1 = wR * filterStrides[0];
                const xOffset2 = xOffset1 + xR * xRowStride;
                for(let yC = 0; yC < convInfo.outWidth; ++yC){
                    const yOffset3 = yOffset2 + yC * yColStride;
                    const xCCorner = yC * convInfo.strideWidth - padLeft;
                    for(let wC = 0; wC < filterWidth; ++wC){
                        const xC = xCCorner + wC * dilationWidth;
                        if (xC < 0 || xC >= convInfo.inWidth) continue;
                        const wOffset2 = wOffset1 + wC * filterStrides[1];
                        const xOffset3 = xOffset2 + xC * xColStride;
                        let wOffset3 = wOffset2;
                        for(let d1 = 0; d1 < convInfo.inChannels; ++d1){
                            const xVal = xVals[xOffset3 + d1 * xChannelStride];
                            for(let d2 = 0; d2 < convInfo.outChannels; ++d2)yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];
                            wOffset3 += convInfo.outChannels;
                        }
                    }
                }
            }
        }
    }
    return backend.makeTensorInfo(y.shape, y.dtype, yVals);
}
const $3425cac70d3f2ad3$export$4a39bf13b4378042 = {
    kernelName: $2b76be1e72a8c1db$export$57742e605d475795,
    backendName: 'cpu',
    kernelFunc: $3425cac70d3f2ad3$export$5a2ce5b05041d9e4
};




function $968a46dcd4a4cd34$export$652a30c9379f3de7(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode , filterShape: filterShape  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        dy
    ], 'conv2dBackpropFilter');
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */ , pad, dimRoundingMode, false, $dataFormat);
    const { strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth  } = convInfo;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const dW = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.filterShape, 'float32');
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    const xVals = backend.data.get(x.dataId).values;
    const dyVals = backend.data.get(dy.dataId).values;
    const xBuf = new $c341eb4171cc0419$export$350df26cd52e08e1(x.shape, x.dtype, xVals);
    const dyBuf = new $c341eb4171cc0419$export$350df26cd52e08e1(dy.shape, dy.dtype, dyVals);
    for(let wR = 0; wR < filterHeight; ++wR){
        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
        for(let wC = 0; wC < filterWidth; ++wC){
            const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
            const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
            for(let d1 = 0; d1 < convInfo.inChannels; ++d1)for(let d2 = 0; d2 < convInfo.outChannels; ++d2){
                let dotProd = 0;
                for(let b = 0; b < convInfo.batchSize; ++b)for(let yR = yRMin; yR < yRMax; ++yR){
                    const xR = wR + yR * strideHeight - topPad;
                    for(let yC = yCMin; yC < yCMax; ++yC){
                        const xC = wC + yC * strideWidth - leftPad;
                        if (isChannelsLast) dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                        else dotProd += xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);
                    }
                }
                dW.set(dotProd, wR, wC, d1, d2);
            }
        }
    }
    return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
const $968a46dcd4a4cd34$export$7a95f55d2d2e7d24 = {
    kernelName: $2b76be1e72a8c1db$export$32a8943c0f1ca5a7,
    backendName: 'cpu',
    kernelFunc: $968a46dcd4a4cd34$export$652a30c9379f3de7
};




function $7d91ae3474fe590a$export$633310eed0c26e72(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { inputShape: inputShape , strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        filter
    ], 'conv2dBackpropInput');
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    let $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */ , pad, dimRoundingMode, false, $dataFormat);
    const dx = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.inShape, 'float32');
    const dxValues = dx.values;
    const dyValues = backend.data.get(dy.dataId).values;
    const fltValues = backend.data.get(filter.dataId).values;
    const [fltS0, fltS1, fltS2] = filterStrides;
    const { batchSize: batchSize , filterHeight: filterHeight , filterWidth: filterWidth , inChannels: inChannels , inHeight: inHeight , inWidth: inWidth , outChannels: outChannels , outHeight: outHeight , outWidth: outWidth , strideHeight: strideHeight , strideWidth: strideWidth  } = convInfo;
    $dataFormat = convInfo.dataFormat;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    const isChannelsLast = $dataFormat === 'channelsLast';
    const xBatchStride = dx.strides[0];
    const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];
    const xColStride = isChannelsLast ? dx.strides[2] : 1;
    const xChannelStride = isChannelsLast ? 1 : dx.strides[1];
    const yBatchStride = dyStrides[0];
    const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
    const yColStride = isChannelsLast ? dyStrides[2] : 1;
    const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
    for(let b = 0; b < batchSize; ++b){
        for(let d1 = 0; d1 < inChannels; ++d1)for(let xR = 0; xR < inHeight; ++xR){
            const xRCorner = xR - topPad;
            const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
            const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
            for(let xC = 0; xC < inWidth; ++xC){
                const xCCorner = xC - leftPad;
                const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                let dotProd = 0;
                for(let yR = xRMin; yR < yRMax; ++yR){
                    const wR = yR * strideHeight - xRCorner;
                    for(let yC = xCMin; yC < yCMax; ++yC){
                        const wC = yC * strideWidth - xCCorner;
                        const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;
                        const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                        for(let d2 = 0; d2 < outChannels; ++d2){
                            const pixel = dyValues[dyOffset + yChannelStride * d2];
                            const weight = fltValues[fltOffset + d2];
                            dotProd += pixel * weight;
                        }
                    }
                }
                const dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;
                dxValues[dxOffset] = dotProd;
            }
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $7d91ae3474fe590a$export$19bbc19fff1ed26f = {
    kernelName: $2b76be1e72a8c1db$export$e26961e8ed0eb404,
    backendName: 'cpu',
    kernelFunc: $7d91ae3474fe590a$export$633310eed0c26e72
};




function $4b0b7423cce0fbbd$export$1929932f31d07956(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        filter
    ], 'conv3d');
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);
    const { filterDepth: filterDepth , filterHeight: filterHeight , filterWidth: filterWidth , dilationDepth: dilationDepth , dilationHeight: dilationHeight , dilationWidth: dilationWidth , padInfo: padInfo  } = convInfo;
    const padFront = padInfo.front;
    const padLeft = padInfo.left;
    const padTop = padInfo.top;
    const y = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.outShape, x.dtype);
    const xVals = backend.data.get(x.dataId).values;
    const wVals = backend.data.get(filter.dataId).values;
    const yVals = y.values;
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    for(let b = 0; b < convInfo.batchSize; ++b){
        const xOffset1 = b * xStrides[0];
        const yOffset1 = b * y.strides[0];
        for(let yF = 0; yF < convInfo.outDepth; ++yF){
            const yOffset2 = yOffset1 + yF * y.strides[1];
            const xFCorner = yF * convInfo.strideDepth - padFront;
            for(let wF = 0; wF < filterDepth; ++wF){
                const xF = xFCorner + wF * dilationDepth;
                if (xF < 0 || xF >= convInfo.inDepth) continue;
                const wOffset1 = wF * filterStrides[0];
                const xOffset2 = xOffset1 + xF * xStrides[1];
                for(let yR = 0; yR < convInfo.outHeight; ++yR){
                    const yOffset3 = yOffset2 + yR * y.strides[2];
                    const xRCorner = yR * convInfo.strideHeight - padTop;
                    for(let wR = 0; wR < filterHeight; ++wR){
                        const xR = xRCorner + wR * dilationHeight;
                        if (xR < 0 || xR >= convInfo.inHeight) continue;
                        const wOffset2 = wOffset1 + wR * filterStrides[1];
                        const xOffset3 = xOffset2 + xR * xStrides[2];
                        for(let yC = 0; yC < convInfo.outWidth; ++yC){
                            const yOffset4 = yOffset3 + yC * convInfo.outChannels;
                            const xCCorner = yC * convInfo.strideWidth - padLeft;
                            for(let wC = 0; wC < filterWidth; ++wC){
                                const xC = xCCorner + wC * dilationWidth;
                                if (xC < 0 || xC >= convInfo.inWidth) continue;
                                const wOffset3 = wOffset2 + wC * filterStrides[2];
                                const xOffset4 = xOffset3 + xC * convInfo.inChannels;
                                let wOffset4 = wOffset3;
                                for(let d1 = 0; d1 < convInfo.inChannels; ++d1){
                                    const xVal = xVals[xOffset4 + d1];
                                    for(let d2 = 0; d2 < convInfo.outChannels; ++d2)yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];
                                    wOffset4 += convInfo.outChannels;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return backend.makeTensorInfo(y.shape, y.dtype, y.values);
}
const $4b0b7423cce0fbbd$export$1fe590fda0829040 = {
    kernelName: $2b76be1e72a8c1db$export$9d3874201dd21933,
    backendName: 'cpu',
    kernelFunc: $4b0b7423cce0fbbd$export$1929932f31d07956
};




function $84371c6b69968cee$export$b57760dc3101cea7(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , pad: pad , filterShape: filterShape  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        dy
    ], 'conv3dBackpropFilterV2');
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */ , pad);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dw = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.filterShape, 'float32');
    const dwValues = dw.values;
    const [dwS0, dwS1, dwS2, dwS3] = dw.strides;
    const dyValues = backend.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
    const xValues = backend.data.get(x.dataId).values;
    const [xS0, xS1, xS2, xS3] = xStrides;
    const frontPad = convInfo.padInfo.front;
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    for(let wF = 0; wF < filterDepth; ++wF){
        const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));
        const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);
        const wOffset1 = wF * dwS0;
        for(let wR = 0; wR < filterHeight; ++wR){
            const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            const wOffset2 = wR * dwS1 + wOffset1;
            for(let wC = 0; wC < filterWidth; ++wC){
                const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                const wOffset3 = wC * dwS2 + wOffset2;
                for(let d1 = 0; d1 < convInfo.inChannels; ++d1){
                    const wOffset4 = d1 * dwS3 + wOffset3;
                    for(let d2 = 0; d2 < convInfo.outChannels; ++d2){
                        let dotProd = 0;
                        for(let b = 0; b < convInfo.batchSize; ++b){
                            const xOffset1 = b * xS0;
                            const yOffset1 = b * dyS0;
                            for(let yF = yFMin; yF < yFMax; ++yF){
                                const xF = wF + yF * strideDepth - frontPad;
                                const xOffset2 = xF * xS1 + xOffset1;
                                const yOffset2 = yF * dyS1 + yOffset1;
                                for(let yR = yRMin; yR < yRMax; ++yR){
                                    const xR = wR + yR * strideHeight - topPad;
                                    const xOffset3 = xR * xS2 + xOffset2;
                                    const yOffset3 = yR * dyS2 + yOffset2;
                                    for(let yC = yCMin; yC < yCMax; ++yC){
                                        const xC = wC + yC * strideWidth - leftPad;
                                        const xOffset4 = xC * xS3 + xOffset3;
                                        const yOffset4 = yC * dyS3 + yOffset3;
                                        dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];
                                    }
                                }
                            }
                        }
                        dwValues[wOffset4 + d2] = dotProd;
                    }
                }
            }
        }
    }
    return backend.makeTensorInfo(dw.shape, dw.dtype, dw.values);
}
const $84371c6b69968cee$export$6dce9169640850fa = {
    kernelName: $2b76be1e72a8c1db$export$dd2885efe6043eee,
    backendName: 'cpu',
    kernelFunc: $84371c6b69968cee$export$b57760dc3101cea7
};




function $1186a4e8e5a77410$export$ab31b884dc9f0971(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { pad: pad , strides: strides , inputShape: inputShape  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy
    ], 'conv3dBackpropInputV2');
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */ , pad);
    const dx = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.inShape, 'float32');
    const dxValues = dx.values;
    const [dxS0, dxS1, dxS2, dxS3] = dx.strides;
    const dyValues = backend.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
    const fltValues = backend.data.get(filter.dataId).values;
    const [fltS0, fltS1, fltS2, fltS3] = filterStrides;
    const { batchSize: batchSize , filterDepth: filterDepth , filterHeight: filterHeight , filterWidth: filterWidth , inChannels: inChannels , inDepth: inDepth , inHeight: inHeight , inWidth: inWidth , outChannels: outChannels , outDepth: outDepth , outHeight: outHeight , outWidth: outWidth , strideDepth: strideDepth , strideHeight: strideHeight , strideWidth: strideWidth  } = convInfo;
    const frontPad = filterDepth - 1 - convInfo.padInfo.front;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    for(let b = 0; b < batchSize; ++b){
        for(let d1 = 0; d1 < inChannels; ++d1)// Frames of depth
        for(let xF = 0; xF < inDepth; ++xF){
            const xFCorner = xF - frontPad;
            const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));
            const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);
            // Rows as per standard 2d matrix notation
            for(let xR = 0; xR < inHeight; ++xR){
                const xRCorner = xR - topPad;
                const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
                // Columns as per standard 2d matrix notation
                for(let xC = 0; xC < inWidth; ++xC){
                    const xCCorner = xC - leftPad;
                    const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                    const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                    let dotProd = 0;
                    for(let yF = xFMin; yF < yFMax; ++yF){
                        const wF = yF * strideDepth - xFCorner;
                        for(let yR = xRMin; yR < yRMax; ++yR){
                            const wR = yR * strideHeight - xRCorner;
                            for(let yC = xCMin; yC < yCMax; ++yC){
                                const wC = yC * strideWidth - xCCorner;
                                const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;
                                const fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;
                                for(let d2 = 0; d2 < outChannels; ++d2){
                                    const pixel = dyValues[dyOffset + d2];
                                    const weight = fltValues[fltOffset + d2];
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                    }
                    dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;
                }
            }
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $1186a4e8e5a77410$export$40ece1caaaf084b2 = {
    kernelName: $2b76be1e72a8c1db$export$a54f552d6d7d521f,
    backendName: 'cpu',
    kernelFunc: $1186a4e8e5a77410$export$ab31b884dc9f0971
};




const $72dd2cadd4da2b33$export$50d414a77b60d802 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$ddfd0a983d257666, (xi)=>Math.cos(xi)
);
const $72dd2cadd4da2b33$export$ff099a1da5235a7e = {
    kernelName: $2b76be1e72a8c1db$export$ddfd0a983d257666,
    backendName: 'cpu',
    kernelFunc: $72dd2cadd4da2b33$export$50d414a77b60d802
};




const $271b1942b7c056c5$export$2e2fd1ad24e4d350 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$5e311a1c57b0d27c, (xi)=>Math.cosh(xi)
);
const $271b1942b7c056c5$export$c5824052b09ba0ed = {
    kernelName: $2b76be1e72a8c1db$export$5e311a1c57b0d27c,
    backendName: 'cpu',
    kernelFunc: $271b1942b7c056c5$export$2e2fd1ad24e4d350
};



function $b8496ede399cfff6$export$6f0f0090e1f6cd3c(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { image: image , boxes: boxes , boxInd: boxInd  } = inputs;
    const { cropSize: cropSize , method: method , extrapolationValue: extrapolationValue  } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    const numBoxes = boxes.shape[0];
    const [cropHeight, cropWidth] = cropSize;
    const output = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        numBoxes,
        cropHeight,
        cropWidth,
        numChannels
    ], 'float32');
    const boxVals = backend.data.get(boxes.dataId).values;
    const boxIndVals = backend.data.get(boxInd.dataId).values;
    const imageVals = backend.data.get(image.dataId).values;
    const inStride = $f6b55a2021b78f0d$exports.computeStrides(image.shape); // to calculate flat indexes into image
    const outStride = $f6b55a2021b78f0d$exports.computeStrides(output.shape); // to calculate flat indexes into output
    // Reference implementation
    // tslint:disable-next-line:max-line-length
    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op.cc
    for(let b = 0; b < numBoxes; b++){
        const startInd = b * 4;
        const y1 = boxVals[startInd];
        const x1 = boxVals[startInd + 1];
        const y2 = boxVals[startInd + 2];
        const x2 = boxVals[startInd + 3];
        const bInd = boxIndVals[b];
        if (bInd >= batch) continue;
        const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;
        const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
        for(let y = 0; y < cropHeight; y++){
            const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);
            if (yInd < 0 || yInd > imageHeight - 1) {
                for(let x = 0; x < cropWidth; x++)for(let c = 0; c < numChannels; c++){
                    const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                    output.values[ind] = extrapolationValue;
                }
                continue;
            }
            if (method === 'bilinear') {
                const topInd = Math.floor(yInd);
                const bottomInd = Math.ceil(yInd);
                const yLerp = yInd - topInd;
                for(let x = 0; x < cropWidth; x++){
                    const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
                    if (xInd < 0 || xInd > imageWidth - 1) {
                        for(let c = 0; c < numChannels; c++){
                            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                            output.values[ind] = extrapolationValue;
                        }
                        continue;
                    }
                    const leftInd = Math.floor(xInd);
                    const rightInd = Math.ceil(xInd);
                    const xLerp = xInd - leftInd;
                    for(let c = 0; c < numChannels; c++){
                        let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
                        const topLeft = imageVals[ind];
                        ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
                        const topRight = imageVals[ind];
                        ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
                        const bottomLeft = imageVals[ind];
                        ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
                        const bottomRight = imageVals[ind];
                        const top = topLeft + (topRight - topLeft) * xLerp;
                        const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
                        ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                        output.values[ind] = top + (bottom - top) * yLerp;
                    }
                }
            } else for(let x = 0; x < cropWidth; ++x){
                const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
                if (xInd < 0 || xInd > imageWidth - 1) {
                    for(let c = 0; c < numChannels; c++){
                        const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                        output.values[ind] = extrapolationValue;
                    }
                    continue;
                }
                const closestX = Math.round(xInd);
                const closestY = Math.round(yInd);
                for(let c = 0; c < numChannels; c++){
                    const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];
                    const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                    output.values[outInd] = imageVals[inInd];
                }
            }
        }
    }
    return backend.makeTensorInfo(output.shape, output.dtype, output.values);
}
const $b8496ede399cfff6$export$f7086edcf0050c7f = {
    kernelName: $2b76be1e72a8c1db$export$50bc9557793c2e04,
    backendName: 'cpu',
    kernelFunc: $b8496ede399cfff6$export$6f0f0090e1f6cd3c
};





function $c2aa3ef4c892bfd0$export$dc7513e907e94b8d(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'cumprod');
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], x.shape.length);
    let $x = x;
    if (permutation != null) $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            perm: permutation
        }
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, x.shape.length)[0];
    if (permutedAxis !== $x.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most ` + `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
    const resultDtype = $993b52a5dd76e458$export$7bcca02d1a156bdf($x.dtype, 'int32');
    const vals = $f6b55a2021b78f0d$exports.makeOnesTypedArray($f6b55a2021b78f0d$exports.sizeFromShape($x.shape), resultDtype);
    const aVals = backend.data.get($x.dataId).values;
    const finalDim = $x.shape[$x.shape.length - 1];
    const indexAdjuster = reverse ? (i, j)=>i + finalDim - j - 1
     : (i, j)=>i + j
    ;
    for(let i1 = 0; i1 < aVals.length; i1 += finalDim)for(let j1 = 0; j1 < finalDim; j1++){
        const idx = indexAdjuster(i1, j1);
        if (j1 === 0) vals[idx] = exclusive ? 1 : aVals[idx];
        else {
            const prevIdx = indexAdjuster(i1, j1 - 1);
            vals[idx] = exclusive ? aVals[prevIdx] * vals[prevIdx] : aVals[idx] * vals[prevIdx];
        }
    }
    const result = backend.makeTensorInfo($x.shape, resultDtype, vals);
    if (permutation != null) {
        const reversePermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                perm: reversePermutation
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        backend.disposeIntermediateTensorInfo($x);
        return reverseTransposedResult;
    }
    return result;
}
const $c2aa3ef4c892bfd0$export$db50d81ed60c5a35 = {
    kernelName: $2b76be1e72a8c1db$export$e581acc6014c47a,
    backendName: 'cpu',
    kernelFunc: $c2aa3ef4c892bfd0$export$dc7513e907e94b8d
};





function $af834ffdfcdc6b29$export$71990b1e1c4912fe(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'cumsum');
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], x.shape.length);
    let $x = x;
    if (permutation != null) $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            perm: permutation
        }
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, x.shape.length)[0];
    if (permutedAxis !== $x.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most ` + `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
    const resultDtype = $993b52a5dd76e458$export$7bcca02d1a156bdf($x.dtype, 'int32');
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape($x.shape), resultDtype);
    const aVals = backend.data.get($x.dataId).values;
    const finalDim = $x.shape[$x.shape.length - 1];
    const indexAdjuster = reverse ? (i, j)=>i + finalDim - j - 1
     : (i, j)=>i + j
    ;
    for(let i1 = 0; i1 < aVals.length; i1 += finalDim)for(let j1 = 0; j1 < finalDim; j1++){
        const idx = indexAdjuster(i1, j1);
        if (j1 === 0) vals[idx] = exclusive ? 0 : aVals[idx];
        else {
            const prevIdx = indexAdjuster(i1, j1 - 1);
            vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];
        }
    }
    const result = backend.makeTensorInfo($x.shape, resultDtype, vals);
    if (permutation != null) {
        const reversePermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                perm: reversePermutation
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        backend.disposeIntermediateTensorInfo($x);
        return reverseTransposedResult;
    }
    return result;
}
const $af834ffdfcdc6b29$export$2f6196f3316e7ed2 = {
    kernelName: $2b76be1e72a8c1db$export$706617d894ad63da,
    backendName: 'cpu',
    kernelFunc: $af834ffdfcdc6b29$export$71990b1e1c4912fe
};




function $e7f3febada6ba204$export$436934e6cf1946f1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , weights: weights  } = inputs;
    const { size: size , binaryOutput: binaryOutput  } = attrs;
    if (x.shape.length === 1) {
        const xVals = backend.data.get(x.dataId).values;
        const weightsVals = backend.data.get(weights.dataId).values;
        const outVals = $169583b362c12f18$export$8e4da6ec633bf0a6(xVals, weightsVals, weights.dtype, weights.shape, size);
        return backend.makeTensorInfo([
            size
        ], weights.dtype, outVals);
    } else if (x.shape.length === 2) {
        const xBuf = backend.bufferSync(x);
        const weightsBuf = backend.bufferSync(weights);
        const outBuf = $169583b362c12f18$export$486b8d48edd28ba5(xBuf, weightsBuf, size, binaryOutput);
        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` + `${x.shape.length}.`);
}
const $e7f3febada6ba204$export$88ba267b84334692 = {
    kernelName: $2b76be1e72a8c1db$export$5bab6834954299c5,
    backendName: 'cpu',
    kernelFunc: $e7f3febada6ba204$export$436934e6cf1946f1
};



function $b11b48c1213fc64f$export$3b50daec0f185f12(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockSize: blockSize , dataFormat: dataFormat  } = attrs;
    $f6b55a2021b78f0d$exports.assert(dataFormat === 'NHWC', ()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`
    );
    const batchSize = x.shape[0];
    const inputHeight = x.shape[1];
    const inputWidth = x.shape[2];
    const inputDepth = x.shape[3];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const xValues = backend.data.get(x.dataId).values;
    const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
    let outputIdx = 0;
    for(let b = 0; b < batchSize; ++b)for(let h = 0; h < outputHeight; ++h){
        const inH = Math.floor(h / blockSize);
        const offsetH = h % blockSize;
        for(let w = 0; w < outputWidth; ++w){
            const inW = Math.floor(w / blockSize);
            const offsetW = w % blockSize;
            const offsetD = (offsetH * blockSize + offsetW) * outputDepth;
            for(let d = 0; d < outputDepth; ++d){
                const inD = d + offsetD;
                const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));
                result[outputIdx++] = xValues[inputIdx];
            }
        }
    }
    return backend.makeTensorInfo([
        batchSize,
        outputHeight,
        outputWidth,
        outputDepth
    ], x.dtype, result);
}
const $b11b48c1213fc64f$export$9c5b88dcb1d2008b = {
    kernelName: $2b76be1e72a8c1db$export$fb0ee52d0cd6f233,
    backendName: 'cpu',
    kernelFunc: $b11b48c1213fc64f$export$3b50daec0f185f12
};




function $a1422c7835b8f6d8$export$14e793fe8822afd1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations , dimRoundingMode: dimRoundingMode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        filter
    ], 'depthwiseConv2DNative');
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    let $dilations = dilations;
    if ($dilations == null) $dilations = [
        1,
        1
    ];
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, $dilations), ()=>'Error in depthwiseConv2d: Either strides or dilations must be ' + `1. Got strides ${strides} and dilations '${$dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
    const { filterHeight: filterHeight , filterWidth: filterWidth , dilationHeight: dilationHeight , dilationWidth: dilationWidth , padInfo: padInfo  } = convInfo;
    const padLeft = padInfo.left;
    const padTop = padInfo.top;
    const chMul = convInfo.outChannels / convInfo.inChannels;
    const y = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.outShape, x.dtype);
    const xVals = backend.data.get(x.dataId).values;
    const wVals = backend.data.get(filter.dataId).values;
    const yVals = y.values;
    for(let b = 0; b < convInfo.batchSize; ++b){
        const xOffset1 = b * xStrides[0];
        const yOffset1 = b * y.strides[0];
        for(let yR = 0; yR < convInfo.outHeight; ++yR){
            const yOffset2 = yOffset1 + yR * y.strides[1];
            const xRCorner = yR * convInfo.strideHeight - padTop;
            for(let wR = 0; wR < filterHeight; ++wR){
                const xR = xRCorner + wR * dilationHeight;
                if (xR < 0 || xR >= convInfo.inHeight) continue;
                const wOffset1 = wR * filterStrides[0];
                const xOffset2 = xOffset1 + xR * xStrides[1];
                for(let yC = 0; yC < convInfo.outWidth; ++yC){
                    const yOffset3 = yOffset2 + yC * y.strides[2];
                    const xCCorner = yC * convInfo.strideWidth - padLeft;
                    for(let wC = 0; wC < filterWidth; ++wC){
                        const xC = xCCorner + wC * dilationWidth;
                        if (xC < 0 || xC >= convInfo.inWidth) continue;
                        const wOffset2 = wOffset1 + wC * filterStrides[1];
                        const xOffset3 = xOffset2 + xC * convInfo.inChannels;
                        let yOffset4 = yOffset3;
                        let wOffset3 = wOffset2;
                        for(let d1 = 0; d1 < convInfo.inChannels; ++d1){
                            const xVal = xVals[xOffset3 + d1];
                            for(let q = 0; q < chMul; ++q)yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];
                            yOffset4 += chMul;
                            wOffset3 += chMul;
                        }
                    }
                }
            }
        }
    }
    return backend.makeTensorInfo(y.shape, y.dtype, y.values);
}
const $a1422c7835b8f6d8$export$240667804b7c390e = {
    kernelName: $2b76be1e72a8c1db$export$7c0fc590ff9e156f,
    backendName: 'cpu',
    kernelFunc: $a1422c7835b8f6d8$export$14e793fe8822afd1
};




function $2c2363e1f4470d1b$export$cc0ae65e9edc7e1a(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode , filterShape: filterShape  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        dy
    ], 'depthwiseConv2dNativeBackpropFilter');
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true);
    const { strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth  } = convInfo;
    const dW = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.filterShape, 'float32');
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    const chMul = convInfo.outChannels / convInfo.inChannels;
    const xVals = backend.data.get(x.dataId).values;
    const xBuf = new $c341eb4171cc0419$export$350df26cd52e08e1(x.shape, x.dtype, xVals);
    const dyVals = backend.data.get(dy.dataId).values;
    const dyBuf = new $c341eb4171cc0419$export$350df26cd52e08e1(dy.shape, dy.dtype, dyVals);
    for(let wR = 0; wR < filterHeight; ++wR){
        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
        for(let wC = 0; wC < filterWidth; ++wC){
            const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
            const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
            for(let d2 = 0; d2 < convInfo.outChannels; ++d2){
                const d1 = Math.trunc(d2 / chMul);
                const dm = d2 % chMul;
                let dotProd = 0;
                for(let b = 0; b < convInfo.batchSize; ++b)for(let yR = yRMin; yR < yRMax; ++yR){
                    const xR = wR + yR * strideHeight - topPad;
                    for(let yC = yCMin; yC < yCMax; ++yC){
                        const xC = wC + yC * strideWidth - leftPad;
                        dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                    }
                }
                dW.set(dotProd, wR, wC, d1, dm);
            }
        }
    }
    return backend.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
const $2c2363e1f4470d1b$export$30bc0ac3775583fc = {
    kernelName: $2b76be1e72a8c1db$export$c99f139e0d4d1833,
    backendName: 'cpu',
    kernelFunc: $2c2363e1f4470d1b$export$cc0ae65e9edc7e1a
};




function $8f2ac7cc2c494a79$export$37e2ab95a4a4c24b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode , inputShape: inputShape  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        filter
    ], 'depthwiseConv2DNativeBackpropInput');
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    const filterStrides = $f6b55a2021b78f0d$exports.computeStrides(filter.shape);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
    const dx = new $c341eb4171cc0419$export$350df26cd52e08e1(convInfo.inShape, 'float32');
    const dxValues = dx.values;
    const [dxS0, dxS1, dxS2] = dx.strides;
    const dyValues = backend.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2] = dyStrides;
    const fltValues = backend.data.get(filter.dataId).values;
    const [fltS0, fltS1, fltS2] = filterStrides;
    const { batchSize: batchSize , filterHeight: filterHeight , filterWidth: filterWidth , inChannels: inChannels , inHeight: inHeight , inWidth: inWidth , outChannels: outChannels , outHeight: outHeight , outWidth: outWidth , strideHeight: strideHeight , strideWidth: strideWidth  } = convInfo;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    const chMul = outChannels / inChannels;
    for(let b = 0; b < batchSize; ++b){
        for(let d1 = 0; d1 < inChannels; ++d1)for(let xR = 0; xR < inHeight; ++xR){
            const xRCorner = xR - topPad;
            const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
            const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
            for(let xC = 0; xC < inWidth; ++xC){
                const xCCorner = xC - leftPad;
                const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
                let dotProd = 0;
                for(let yR = xRMin; yR < yRMax; ++yR){
                    const wR = yR * strideHeight - xRCorner;
                    for(let yC = xCMin; yC < yCMax; ++yC){
                        const wC = yC * strideWidth - xCCorner;
                        const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                        const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                        for(let dm = 0; dm < chMul; ++dm){
                            const d2 = d1 * chMul + dm;
                            const pixel = dyValues[dyOffset + d2];
                            const weight = fltValues[fltOffset + dm];
                            dotProd += pixel * weight;
                        }
                    }
                }
                dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
            }
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $8f2ac7cc2c494a79$export$55d12409e744bebe = {
    kernelName: $2b76be1e72a8c1db$export$8649ca3b17033a24,
    backendName: 'cpu',
    kernelFunc: $8f2ac7cc2c494a79$export$37e2ab95a4a4c24b
};



function $a630f9ff21b293a6$export$c042e7c2f59bc046(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const xVals = backend.data.get(x.dataId).values;
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a([
        xSize,
        xSize
    ], x.dtype);
    const vals = outBuf.values;
    for(let i = 0; i < xVals.length; i++)vals[i * xSize + i] = xVals[i];
    const outShape = [
        ...x.shape,
        ...x.shape
    ];
    return backend.makeTensorInfo(outShape, outBuf.dtype, outBuf.values);
}
const $a630f9ff21b293a6$export$56dc5d812a22748f = {
    kernelName: $2b76be1e72a8c1db$export$ca73a25315ddeb7f,
    backendName: 'cpu',
    kernelFunc: $a630f9ff21b293a6$export$c042e7c2f59bc046
};



const $cd61098d3404af32$export$36d3c11f61a8891a = {
    kernelName: $2b76be1e72a8c1db$export$dbbb7830c6497701,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
        const { x: x , filter: filter  } = inputs;
        const { strides: strides , pad: pad , dilations: dilations  } = attrs;
        const cpuBackend = backend;
        const xVals = cpuBackend.data.get(x.dataId).values;
        const xRank = x.shape.length;
        const filterVals = cpuBackend.data.get(filter.dataId).values;
        const filterRank = filter.shape.length;
        const { batchSize: batchSize , inHeight: inHeight , inWidth: inWidth , inChannels: inChannels , outHeight: outHeight , outWidth: outWidth , padInfo: padInfo , strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth , dilationHeight: dilationHeight , dilationWidth: dilationWidth , outShape: outShape  } = $510a55f99d61727a$exports.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */ , dilations);
        const outSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShape);
        const outRank = outShape.length;
        const outputVals = $f6b55a2021b78f0d$exports.getArrayFromDType(x.dtype, outSize);
        // Upsampling the input by fill in `dilation size - 1` values between each
        // input value.
        // This implementation follows the TF c++ implementation:
        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc
        for(let b = 0; b < batchSize; ++b)for(let hOut = 0; hOut < outHeight; ++hOut){
            const hBeg = hOut * strideHeight - padInfo.top;
            for(let wOut = 0; wOut < outWidth; ++wOut){
                const wBeg = wOut * strideWidth - padInfo.left;
                for(let d = 0; d < inChannels; ++d){
                    let curVal = Number.MIN_SAFE_INTEGER;
                    for(let h = 0; h < filterHeight; ++h){
                        const hIn = hBeg + h * dilationHeight;
                        if (hIn >= 0 && hIn < inHeight) for(let w = 0; w < filterWidth; ++w){
                            const wIn = wBeg + w * dilationWidth;
                            if (wIn >= 0 && wIn < inWidth) {
                                const xIndex = $f6b55a2021b78f0d$exports.locToIndex([
                                    b,
                                    hIn,
                                    wIn,
                                    d
                                ], xRank, $f6b55a2021b78f0d$exports.computeStrides(x.shape));
                                const filterIndex = $f6b55a2021b78f0d$exports.locToIndex([
                                    h,
                                    w,
                                    d
                                ], filterRank, $f6b55a2021b78f0d$exports.computeStrides(filter.shape));
                                const val = xVals[xIndex] + filterVals[filterIndex];
                                if (val > curVal) curVal = val;
                            }
                        }
                    }
                    const outputIndex = $f6b55a2021b78f0d$exports.locToIndex([
                        b,
                        hOut,
                        wOut,
                        d
                    ], outRank, $f6b55a2021b78f0d$exports.computeStrides(outShape));
                    outputVals[outputIndex] = curVal;
                }
            }
        }
        const dataId = cpuBackend.write($f6b55a2021b78f0d$exports.toTypedArray(outputVals, x.dtype), outShape, x.dtype);
        return {
            dataId: dataId,
            shape: outShape,
            dtype: x.dtype
        };
    }
};



const $3e859e5c2fd52838$export$cf83abe0e8c87ce8 = {
    kernelName: $2b76be1e72a8c1db$export$91add972be69d592,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
        const { x: x , filter: filter , dy: dy  } = inputs;
        const { strides: strides , pad: pad , dilations: dilations  } = attrs;
        const cpuBackend = backend;
        const $x = $f6b55a2021b78f0d$exports.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
        const $filter = $f6b55a2021b78f0d$exports.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
        const { batchSize: batchSize , inHeight: inHeight , inWidth: inWidth , inChannels: inChannels , outHeight: outHeight , outWidth: outWidth , padInfo: padInfo , strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth , dilationHeight: dilationHeight , dilationWidth: dilationWidth , outShape: outShape  } = $510a55f99d61727a$exports.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */ , dilations);
        $f6b55a2021b78f0d$exports.assert(dy.rank === outShape.length, ()=>`Error in ${$2b76be1e72a8c1db$export$91add972be69d592}, dy ` + `must have the same rank as output ${outShape.length}, but got ` + `${dy.rank}`
        );
        const $dy = $f6b55a2021b78f0d$exports.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
        // The computed filter gradients has the same dimensions as the filter:
        // [filterHeight, filterWidth, depth]
        const gradients = $f6b55a2021b78f0d$exports.makeZerosNestedTypedArray(filter.shape, filter.dtype);
        // In the case of multiple argmax branches, we only back-propagate along the
        // last branch, i.e., the one with largest value of `h * filter_cols + w`,
        // similarly to the max-pooling backward routines.
        // This implementation follows the TF c++ implementation:
        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc
        for(let b = 0; b < batchSize; ++b)for(let hOut = 0; hOut < outHeight; ++hOut){
            const hBeg = hOut * strideHeight - padInfo.top;
            for(let wOut = 0; wOut < outWidth; ++wOut){
                const wBeg = wOut * strideWidth - padInfo.left;
                for(let d = 0; d < inChannels; ++d){
                    let curVal = Number.MIN_SAFE_INTEGER;
                    let hMax = 0;
                    let wMax = 0;
                    for(let h = 0; h < filterHeight; ++h){
                        const hIn = hBeg + h * dilationHeight;
                        if (hIn >= 0 && hIn < inHeight) for(let w = 0; w < filterWidth; ++w){
                            const wIn = wBeg + w * dilationWidth;
                            if (wIn >= 0 && wIn < inWidth) {
                                const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                                if (val > curVal) {
                                    curVal = val;
                                    hMax = h;
                                    wMax = w;
                                }
                            }
                        }
                    }
                    gradients[hMax][wMax][d] += $dy[b][hOut][wOut][d];
                }
            }
        }
        const dataId = cpuBackend.write($f6b55a2021b78f0d$exports.toTypedArray(gradients, x.dtype), filter.shape, filter.dtype);
        return {
            dataId: dataId,
            shape: filter.shape,
            dtype: filter.dtype
        };
    }
};



const $f1f612ad696632e8$export$42e4451417dc5ea0 = {
    kernelName: $2b76be1e72a8c1db$export$5dd675a6b0f37e17,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
        const { x: x , filter: filter , dy: dy  } = inputs;
        const { strides: strides , pad: pad , dilations: dilations  } = attrs;
        const cpuBackend = backend;
        const $x = $f6b55a2021b78f0d$exports.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
        const $filter = $f6b55a2021b78f0d$exports.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
        const { batchSize: batchSize , inHeight: inHeight , inWidth: inWidth , inChannels: inChannels , outHeight: outHeight , outWidth: outWidth , padInfo: padInfo , strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth , dilationHeight: dilationHeight , dilationWidth: dilationWidth , outShape: outShape  } = $510a55f99d61727a$exports.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */ , dilations);
        $f6b55a2021b78f0d$exports.assert(dy.rank === outShape.length, ()=>`Error in ${$2b76be1e72a8c1db$export$5dd675a6b0f37e17}, dy ` + `must have the same rank as output ${outShape.length}, but got ` + `${dy.rank}`
        );
        const $dy = $f6b55a2021b78f0d$exports.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
        // The computed gradients has the same dimensions as the input:
        // [batch, inputHeight, inputCols, inChannel]
        const gradients = $f6b55a2021b78f0d$exports.makeZerosNestedTypedArray(x.shape, x.dtype);
        // In the case of multiple argmax branches, we only back-propagate along the
        // last branch, i.e., the one with largest value of `h * filter_cols + w`,
        // similarly to the max-pooling backward routines.
        // This implementation follows the TF c++ implementation:
        // https://github.com/tensorflow/tensorflow/blob/d9a3a849edc198e90172bc58eb293de457f9d986/tensorflow/core/kernels/dilation_ops.cc
        for(let b = 0; b < batchSize; ++b)for(let hOut = 0; hOut < outHeight; ++hOut){
            const hBeg = hOut * strideHeight - padInfo.top;
            for(let wOut = 0; wOut < outWidth; ++wOut){
                const wBeg = wOut * strideWidth - padInfo.left;
                for(let d = 0; d < inChannels; ++d){
                    let curVal = Number.MIN_SAFE_INTEGER;
                    let hInMax = hBeg < 0 ? 0 : hBeg;
                    let wInMax = wBeg < 0 ? 0 : wBeg;
                    for(let h = 0; h < filterHeight; ++h){
                        const hIn = hBeg + h * dilationHeight;
                        if (hIn >= 0 && hIn < inHeight) for(let w = 0; w < filterWidth; ++w){
                            const wIn = wBeg + w * dilationWidth;
                            if (wIn >= 0 && wIn < inWidth) {
                                const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                                if (val > curVal) {
                                    curVal = val;
                                    hInMax = hIn;
                                    wInMax = wIn;
                                }
                            }
                        }
                    }
                    gradients[b][hInMax][wInMax][d] += $dy[b][hOut][wOut][d];
                }
            }
        }
        const dataId = cpuBackend.write($f6b55a2021b78f0d$exports.toTypedArray(gradients, x.dtype), x.shape, x.dtype);
        return {
            dataId: dataId,
            shape: x.shape,
            dtype: x.dtype
        };
    }
};












function $e5bd7c780dd66c27$export$8a63f25cc62965f1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'sum');
    let $x;
    if (x.dtype === 'bool') $x = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            dtype: 'int32'
        }
    });
    else $x = $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const xRank = $x.shape.length;
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, $x.shape);
    const permutation = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let reductionAxes = axes;
    let permutedX = $x;
    if (permutation != null) {
        permutedX = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: $x
            },
            backend: backend,
            attrs: {
                perm: permutation
            }
        });
        reductionAxes = $510a55f99d61727a$exports.getInnerMostAxes(reductionAxes.length, xRank);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('sum', reductionAxes, permutedX.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(permutedX.shape, reductionAxes);
    const resultDtype = $510a55f99d61727a$exports.upcastType(permutedX.dtype, 'int32');
    let result = $9d20a34f1f5e2714$export$4445a00dafa2633b(backend, outShape, resultDtype);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const vals = backend.data.get(result.dataId).values;
    const aVals = backend.data.get(permutedX.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let $e5bd7c780dd66c27$export$8a63f25cc62965f1 = 0;
        for(let j = 0; j < reduceSize; ++j)$e5bd7c780dd66c27$export$8a63f25cc62965f1 += aVals[offset + j];
        vals[i] = $e5bd7c780dd66c27$export$8a63f25cc62965f1;
    }
    if (keepDims) {
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(result.shape, axes);
        const oldResult = result;
        result = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                shape: newShape
            }
        });
        backend.disposeIntermediateTensorInfo(oldResult);
    }
    backend.disposeIntermediateTensorInfo($x);
    if (permutation != null) backend.disposeIntermediateTensorInfo(permutedX);
    return result;
}
const $e5bd7c780dd66c27$export$47edea402251c258 = {
    kernelName: $2b76be1e72a8c1db$export$534760f50726d5,
    backendName: 'cpu',
    kernelFunc: $e5bd7c780dd66c27$export$8a63f25cc62965f1
};



function $9b821a714428c611$export$27265e7daac5c403(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { equation: equation  } = attrs;
    const tensors = inputs;
    const { allDims: allDims , summedDims: summedDims , idDims: idDims  } = $510a55f99d61727a$exports.decodeEinsumEquation(equation, tensors.length);
    $510a55f99d61727a$exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path: path , steps: steps  } = $510a55f99d61727a$exports.getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for(let i = 0; i < nSteps; ++i){
        for (const idTerm of steps[i]){
            const { permutationIndices: perm , expandDims: dimsToExpand  } = $510a55f99d61727a$exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
            let x;
            if ($510a55f99d61727a$exports.isIdentityPermutation(perm)) x = tensors[idTerm];
            else {
                x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
                    inputs: {
                        x: tensors[idTerm]
                    },
                    backend: backend,
                    attrs: {
                        perm: perm
                    }
                });
                tensorsToDispose.push(x);
            }
            const targetShape = x.shape.slice();
            for(let k = 0; k < dimsToExpand.length; ++k)targetShape.splice(dimsToExpand[k], 0, 1);
            if (!$f6b55a2021b78f0d$exports.arraysEqual(x.shape, targetShape)) {
                x = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
                    inputs: {
                        x: x
                    },
                    backend: backend,
                    attrs: {
                        shape: targetShape
                    }
                });
                tensorsToDispose.push(x);
            }
            if (out === null) out = x;
            else {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                out = $84b5dd89fe629858$export$2060d2db72cce88f({
                    inputs: {
                        a: x,
                        b: out
                    },
                    backend: backend
                });
                tensorsToDispose.push(out);
            }
        }
        if (i < nSteps - 1) {
            if (path[i] >= 0) {
                out = $e5bd7c780dd66c27$export$8a63f25cc62965f1({
                    inputs: {
                        x: out
                    },
                    backend: backend,
                    attrs: {
                        axis: path[i] - (allDims.length - numDimsRemaining),
                        keepDims: false
                    }
                });
                tensorsToDispose.push(out);
            }
            numDimsRemaining--;
        }
    }
    // Clean up intermediate tensors.
    for (const tensorInfo of tensorsToDispose){
        if (tensorInfo === out) continue;
        backend.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
}
const $9b821a714428c611$export$40bbf341885a23b7 = {
    kernelName: $2b76be1e72a8c1db$export$2541d8be32f3c641,
    backendName: 'cpu',
    kernelFunc: $9b821a714428c611$export$27265e7daac5c403
};





function $1fa5083ecf49b853$export$a346244024505ff9(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { dy: dy , y: y  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        y
    ], 'eluGrad');
    const resultValues = new Float32Array($f6b55a2021b78f0d$exports.sizeFromShape(y.shape));
    const values = backend.data.get(y.dataId).values;
    const dyValues = backend.data.get(dy.dataId).values;
    for(let i = 0; i < values.length; ++i){
        const v = values[i];
        if (v >= 1) resultValues[i] = dyValues[i];
        else resultValues[i] = dyValues[i] * (v + 1);
    }
    return backend.makeTensorInfo(y.shape, 'float32', resultValues);
}
const $1fa5083ecf49b853$export$59bb07dd04647a1d = {
    kernelName: $2b76be1e72a8c1db$export$9906be4699a73c53,
    backendName: 'cpu',
    kernelFunc: $1fa5083ecf49b853$export$a346244024505ff9
};





const $c9e0b56da52c781d$var$p = $510a55f99d61727a$exports.ERF_P;
const $c9e0b56da52c781d$var$a1 = $510a55f99d61727a$exports.ERF_A1;
const $c9e0b56da52c781d$var$a2 = $510a55f99d61727a$exports.ERF_A2;
const $c9e0b56da52c781d$var$a3 = $510a55f99d61727a$exports.ERF_A3;
const $c9e0b56da52c781d$var$a4 = $510a55f99d61727a$exports.ERF_A4;
const $c9e0b56da52c781d$var$a5 = $510a55f99d61727a$exports.ERF_A5;
const $c9e0b56da52c781d$export$d3896f355fc09423 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$c2ee2551ce71f1d0, (xi)=>{
    const sign = Math.sign(xi);
    const v = Math.abs(xi);
    const t = 1.0 / (1.0 + $c9e0b56da52c781d$var$p * v);
    return sign * (1.0 - (((($c9e0b56da52c781d$var$a5 * t + $c9e0b56da52c781d$var$a4) * t + $c9e0b56da52c781d$var$a3) * t + $c9e0b56da52c781d$var$a2) * t + $c9e0b56da52c781d$var$a1) * t * Math.exp(-v * v));
});
const $c9e0b56da52c781d$export$d044ffef16079bd = {
    kernelName: $2b76be1e72a8c1db$export$c2ee2551ce71f1d0,
    backendName: 'cpu',
    kernelFunc: $c9e0b56da52c781d$export$d3896f355fc09423
};





function $6eaa90d1c0232879$export$d660d8ed21f46635(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { input: input  } = inputs;
    const { dim: dim  } = attrs;
    const inputRank = input.shape.length;
    const newShape = input.shape.slice();
    let $dim = dim;
    if (dim < 0) {
        // Negative value is counted from the tail of rank.
        $f6b55a2021b78f0d$exports.assert(-(inputRank + 1) <= dim, ()=>`Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`
        );
        $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: input
        },
        backend: backend,
        attrs: {
            shape: newShape
        }
    });
}
const $6eaa90d1c0232879$export$86341ba0ce5d8e60 = {
    kernelName: $2b76be1e72a8c1db$export$2391750b1d901146,
    backendName: 'cpu',
    kernelFunc: $6eaa90d1c0232879$export$d660d8ed21f46635
};















const $477f2b66f539027f$export$967709f6160bacde = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a / b
);
const $477f2b66f539027f$export$159d9494db57879b = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$b9880b86e1014bb8, $477f2b66f539027f$export$967709f6160bacde);
const $477f2b66f539027f$export$15c5d6176b30b9a6 = {
    kernelName: $2b76be1e72a8c1db$export$b9880b86e1014bb8,
    backendName: 'cpu',
    kernelFunc: $477f2b66f539027f$export$159d9494db57879b
};




function $6b13317856823dc7$export$3f1645f616cf26f8(input, inverse, cpuBackend) {
    const inputShape = input.shape;
    const batch = inputShape[0];
    const innerDim = inputShape[1];
    const inputVals = cpuBackend.data.get(input.dataId);
    const real2D = inputVals.complexTensorInfos.real;
    const imag2D = inputVals.complexTensorInfos.imag;
    // Collects real and imaginary values separately.
    const resultShape = [
        batch,
        innerDim
    ];
    const resultSize = $f6b55a2021b78f0d$exports.sizeFromShape(resultShape);
    const resultReal = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('float32', resultSize);
    const resultImag = $f6b55a2021b78f0d$exports.getTypedArrayFromDType('float32', resultSize);
    for(let b = 0; b < batch; b++){
        // TODO: Support slice ops for complex type.
        const r = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
            inputs: {
                x: real2D
            },
            backend: cpuBackend,
            attrs: {
                begin: [
                    b,
                    0
                ],
                size: [
                    1,
                    innerDim
                ]
            }
        });
        const i = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
            inputs: {
                x: imag2D
            },
            backend: cpuBackend,
            attrs: {
                begin: [
                    b,
                    0
                ],
                size: [
                    1,
                    innerDim
                ]
            }
        });
        const input = $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: r,
                imag: i
            },
            backend: cpuBackend
        });
        // Run FFT by batch element.
        const { real: real , imag: imag  } = $6b13317856823dc7$export$75d3742a7578721e(input, inverse, cpuBackend);
        const res = $510a55f99d61727a$exports.mergeRealAndImagArrays(real, imag);
        for(let d = 0; d < innerDim; d++){
            const c = $510a55f99d61727a$exports.getComplexWithIndex(res, d);
            resultReal[b * innerDim + d] = c.real;
            resultImag[b * innerDim + d] = c.imag;
        }
        cpuBackend.disposeIntermediateTensorInfo(r);
        cpuBackend.disposeIntermediateTensorInfo(i);
        cpuBackend.disposeIntermediateTensorInfo(input);
    }
    const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);
    const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);
    const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: $realInfo,
            imag: $imagInfo
        },
        backend: cpuBackend
    });
    cpuBackend.disposeIntermediateTensorInfo($realInfo);
    cpuBackend.disposeIntermediateTensorInfo($imagInfo);
    return result;
}
function $6b13317856823dc7$export$75d3742a7578721e(input, inverse, cpuBackend) {
    const inputSize = $f6b55a2021b78f0d$exports.sizeFromShape(input.shape);
    const inputVals = cpuBackend.data.get(input.dataId);
    const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;
    const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;
    if ($6b13317856823dc7$var$isExponentOf2(inputSize)) {
        const result = $6b13317856823dc7$var$fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);
        const resultShape = [
            input.shape[0],
            input.shape[1]
        ];
        if (inverse) {
            const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);
            const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);
            const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(inputSize, 'float32'));
            const sizeInfoCopy = $cac0f9b7f5ef2746$export$f0954fd7d5368655({
                inputs: {
                    x: sizeInfo
                },
                backend: cpuBackend
            });
            const divRealInfo = $477f2b66f539027f$export$15c5d6176b30b9a6.kernelFunc({
                inputs: {
                    a: realInfo,
                    b: sizeInfo
                },
                backend: cpuBackend
            });
            const divImagInfo = $477f2b66f539027f$export$15c5d6176b30b9a6.kernelFunc({
                inputs: {
                    a: imagInfo,
                    b: sizeInfoCopy
                },
                backend: cpuBackend
            });
            const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;
            const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;
            cpuBackend.disposeIntermediateTensorInfo(realInfo);
            cpuBackend.disposeIntermediateTensorInfo(imagInfo);
            cpuBackend.disposeIntermediateTensorInfo(sizeInfo);
            cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);
            cpuBackend.disposeIntermediateTensorInfo(divRealInfo);
            cpuBackend.disposeIntermediateTensorInfo(divImagInfo);
            return {
                real: divRealVals,
                imag: divImagVals
            };
        }
        return result;
    } else {
        const data = $510a55f99d61727a$exports.mergeRealAndImagArrays(realVals, imagVals);
        const rawOutput = $6b13317856823dc7$var$fourierTransformByMatmul(data, inputSize, inverse);
        return $510a55f99d61727a$exports.splitRealAndImagArrays(rawOutput);
    }
}
function $6b13317856823dc7$var$isExponentOf2(size) {
    return (size & size - 1) === 0;
}
// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.
function $6b13317856823dc7$var$fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {
    if (size === 1) return {
        real: realVals,
        imag: imagVals
    };
    const data = $510a55f99d61727a$exports.mergeRealAndImagArrays(realVals, imagVals);
    const half = size / 2;
    const evenComplex = $510a55f99d61727a$exports.complexWithEvenIndex(data);
    const evenRealVals = evenComplex.real;
    const evenImagVals = evenComplex.imag;
    const evenShape = [
        evenRealVals.length
    ];
    const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);
    const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);
    const evenTensorInfo = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: evenRealInfo,
            imag: evenImagInfo
        },
        backend: cpuBackend
    });
    const oddComplex = $510a55f99d61727a$exports.complexWithOddIndex(data);
    const oddRealVals = oddComplex.real;
    const oddImagVals = oddComplex.imag;
    const oddShape = [
        oddRealVals.length
    ];
    const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);
    const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);
    const oddTensorInfo = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: oddRealInfo,
            imag: oddImagInfo
        },
        backend: cpuBackend
    });
    // Recursive call for half part of original input.
    const $evenComplex = $6b13317856823dc7$var$fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);
    const $evenRealVals = $evenComplex.real;
    const $evenImagVals = $evenComplex.imag;
    const $evenShape = [
        $evenRealVals.length
    ];
    const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);
    const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);
    const $evenTensorInfo = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: $evenRealInfo,
            imag: $evenImagInfo
        },
        backend: cpuBackend
    });
    const $oddComplex = $6b13317856823dc7$var$fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);
    const $oddRealVals = $oddComplex.real;
    const $oddImagVals = $oddComplex.imag;
    const $oddShape = [
        $oddRealVals.length
    ];
    const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);
    const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);
    const $oddTensorInfo = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: $oddRealInfo,
            imag: $oddImagInfo
        },
        backend: cpuBackend
    });
    const e = $510a55f99d61727a$exports.exponents(size, inverse);
    const eShape = [
        e.real.length
    ];
    const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);
    const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);
    const complexInfo = $4bf097831c9b1d30$export$83a0e34f1302825b({
        inputs: {
            real: eRealInfo,
            imag: eImagInfo
        },
        backend: cpuBackend
    });
    const exponentInfo = $84b5dd89fe629858$export$2060d2db72cce88f({
        inputs: {
            a: complexInfo,
            b: $oddTensorInfo
        },
        backend: cpuBackend
    });
    const addPart = $cbaec80dd34f96bb$export$e16d8520af44a096({
        inputs: {
            a: $evenTensorInfo,
            b: exponentInfo
        },
        backend: cpuBackend
    });
    const subPart = $1fbda794b513f6c9$export$f93b5905241a7cca({
        inputs: {
            a: $evenTensorInfo,
            b: exponentInfo
        },
        backend: cpuBackend
    });
    const addPartReal = $cca3c2d597694263$export$9fc57fb453bdbd67({
        inputs: {
            input: addPart
        },
        backend: cpuBackend
    });
    const subPartReal = $cca3c2d597694263$export$9fc57fb453bdbd67({
        inputs: {
            input: subPart
        },
        backend: cpuBackend
    });
    const addPartImag = $febe76d18fc2e7a2$export$d78fab5778ab392b({
        inputs: {
            input: addPart
        },
        backend: cpuBackend
    });
    const subPartImag = $febe76d18fc2e7a2$export$d78fab5778ab392b({
        inputs: {
            input: subPart
        },
        backend: cpuBackend
    });
    const $real = $69f14ff8decf8b5f$export$ee1b3e54f0441b22({
        inputs: [
            addPartReal,
            subPartReal
        ],
        backend: cpuBackend,
        attrs: {
            axis: 0
        }
    });
    const $imag = $69f14ff8decf8b5f$export$ee1b3e54f0441b22({
        inputs: [
            addPartImag,
            subPartImag
        ],
        backend: cpuBackend,
        attrs: {
            axis: 0
        }
    });
    const $realVals = cpuBackend.data.get($real.dataId).values;
    const $imagVals = cpuBackend.data.get($imag.dataId).values;
    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(complexInfo);
    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);
    cpuBackend.disposeIntermediateTensorInfo(addPart);
    cpuBackend.disposeIntermediateTensorInfo(subPart);
    cpuBackend.disposeIntermediateTensorInfo(addPartReal);
    cpuBackend.disposeIntermediateTensorInfo(addPartImag);
    cpuBackend.disposeIntermediateTensorInfo(subPartReal);
    cpuBackend.disposeIntermediateTensorInfo(subPartImag);
    cpuBackend.disposeIntermediateTensorInfo($real);
    cpuBackend.disposeIntermediateTensorInfo($imag);
    return {
        real: $realVals,
        imag: $imagVals
    };
}
// Calculate fourier transform by multplying sinusoid matrix.
function $6b13317856823dc7$var$fourierTransformByMatmul(data, size, inverse) {
    const ret = new Float32Array(size * 2);
    // TODO: Use matmul instead once it supports complex64 type.
    for(let r = 0; r < size; r++){
        let real = 0.0;
        let imag = 0.0;
        for(let c = 0; c < size; c++){
            const e = $510a55f99d61727a$exports.exponent(r * c, size, inverse);
            const term = $510a55f99d61727a$exports.getComplexWithIndex(data, c);
            real += term.real * e.real - term.imag * e.imag;
            imag += term.real * e.imag + term.imag * e.real;
        }
        if (inverse) {
            real /= size;
            imag /= size;
        }
        $510a55f99d61727a$exports.assignToTypedArray(ret, real, imag, r);
    }
    return ret;
}



function $fba10a33c00fe3e0$export$a535ef183b6128fa(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const inputSize = $f6b55a2021b78f0d$exports.sizeFromShape(input.shape);
    // Collapse all outer dimensions to a single batch dimension.
    const innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: input
        },
        backend: backend,
        attrs: {
            shape: [
                batch,
                innerDimensionSize
            ]
        }
    });
    const result = $6b13317856823dc7$export$3f1645f616cf26f8(input2D, false, backend);
    const resultReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: result
        },
        backend: backend,
        attrs: {
            shape: input.shape
        }
    });
    backend.disposeIntermediateTensorInfo(input2D);
    backend.disposeIntermediateTensorInfo(result);
    return resultReshaped;
}
const $fba10a33c00fe3e0$export$a4d564e380763c78 = {
    kernelName: $2b76be1e72a8c1db$export$677347237c014ba,
    backendName: 'cpu',
    kernelFunc: $fba10a33c00fe3e0$export$a535ef183b6128fa
};



function $2400098b1cc400be$export$9563e054e6f787fb(args) {
    const { backend: backend , attrs: attrs  } = args;
    const { shape: shape , value: value , dtype: dtype  } = attrs;
    const $dtype = dtype || $f6b55a2021b78f0d$exports.inferDtype(value);
    const values = $f6b55a2021b78f0d$exports.getArrayFromDType($dtype, $f6b55a2021b78f0d$exports.sizeFromShape(shape));
    $2400098b1cc400be$var$fillValues(values, value, $dtype);
    return backend.makeTensorInfo(shape, $dtype, values);
}
const $2400098b1cc400be$export$c953bf474b2bde62 = {
    kernelName: $2b76be1e72a8c1db$export$ffffe40bfa0649a3,
    backendName: 'cpu',
    kernelFunc: $2400098b1cc400be$export$9563e054e6f787fb
};
function $2400098b1cc400be$var$fillValues(values, value, dtype) {
    if (dtype === 'string') values.fill(value);
    else values.fill(value);
}



const $f7158ab3b655cbce$export$c9ec83cb23304466 = {
    kernelName: $2b76be1e72a8c1db$export$34e7296fc8558df5,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { image: image  } = inputs;
        const cpuBackend = backend;
        const output = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(image.dtype, $f6b55a2021b78f0d$exports.sizeFromShape(image.shape));
        const [batch, imageHeight, imageWidth, numChannels] = image.shape;
        const imageVals = cpuBackend.data.get(image.dataId).values;
        for(let batchIdx = 0; batchIdx < batch; batchIdx++){
            const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
            for(let row = 0; row < imageHeight; row++){
                const rowOffset = row * (imageWidth * numChannels);
                for(let col = 0; col < imageWidth; col++){
                    const colOffset = col * numChannels;
                    for(let channel = 0; channel < numChannels; channel++){
                        const coordX = Math.round(imageWidth - col - 1);
                        const outIdx = batchOffset + rowOffset + colOffset + channel;
                        let outputValue = imageVals[outIdx];
                        // If the coordinate position falls within the image boundaries...
                        if (coordX >= 0 && coordX < imageWidth) {
                            // set the output to the image value at the coordinate position.
                            const rotatedColOffset = coordX * numChannels;
                            const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;
                            outputValue = imageVals[imageIdx];
                        }
                        output[outIdx] = outputValue;
                    }
                }
            }
        }
        const dataId = cpuBackend.write(output, image.shape, image.dtype);
        return {
            dataId: dataId,
            shape: image.shape,
            dtype: image.dtype
        };
    }
};






const $c244fa16d30c8b7f$export$9b7f64e28e98c78e = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>Math.floor(a / b)
);
const $c244fa16d30c8b7f$export$112397bc52715a8 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$d79b5692ede26c2f, $c244fa16d30c8b7f$export$9b7f64e28e98c78e, null, 'int32');
const $c244fa16d30c8b7f$export$7eac933a0c7fd37f = {
    kernelName: $2b76be1e72a8c1db$export$d79b5692ede26c2f,
    backendName: 'cpu',
    kernelFunc: $c244fa16d30c8b7f$export$112397bc52715a8
};






function $5b9f5960e6c9464d$export$8db45c19fd28b6b8(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dilations: dilations , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    let result = $3425cac70d3f2ad3$export$5a2ce5b05041d9e4({
        inputs: {
            x: x,
            filter: filter
        },
        backend: backend,
        attrs: {
            strides: strides,
            pad: pad,
            dataFormat: dataFormat,
            dilations: dilations,
            dimRoundingMode: dimRoundingMode
        }
    });
    if (bias) {
        const resultOld = result;
        result = $cbaec80dd34f96bb$export$e16d8520af44a096({
            inputs: {
                a: result,
                b: bias
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(resultOld);
    }
    if (activation) {
        const resultOld = result;
        result = $7a87657b07beec11$export$a0f250a2ba84196(backend, result, activation, preluActivationWeights, leakyreluAlpha);
        backend.disposeIntermediateTensorInfo(resultOld);
    }
    return result;
}
const $5b9f5960e6c9464d$export$5b64efa829ddf94e = {
    kernelName: $2b76be1e72a8c1db$export$86f8a8e3a8f2a8f2,
    backendName: 'cpu',
    kernelFunc: $5b9f5960e6c9464d$export$8db45c19fd28b6b8
};






function $18066e1f0d0edff3$export$d61de7729228094b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dilations: dilations , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    let result = $a1422c7835b8f6d8$export$14e793fe8822afd1({
        inputs: {
            x: x,
            filter: filter
        },
        backend: backend,
        attrs: {
            strides: strides,
            pad: pad,
            dataFormat: dataFormat,
            dilations: dilations,
            dimRoundingMode: dimRoundingMode
        }
    });
    if (bias) {
        const oldResult = result;
        result = $cbaec80dd34f96bb$export$e16d8520af44a096({
            inputs: {
                a: result,
                b: bias
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(oldResult);
    }
    if (activation) {
        const oldResult = result;
        result = $7a87657b07beec11$export$a0f250a2ba84196(backend, result, activation, preluActivationWeights, leakyreluAlpha);
        backend.disposeIntermediateTensorInfo(oldResult);
    }
    return result;
}
const $18066e1f0d0edff3$export$58481cc3409b412c = {
    kernelName: $2b76be1e72a8c1db$export$5a249e8f498c02c1,
    backendName: 'cpu',
    kernelFunc: $18066e1f0d0edff3$export$d61de7729228094b
};




function $9861804c9e3df3e0$export$3c586830e482d2b9(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { params: params , indices: indices  } = inputs;
    const paramsSize = $f6b55a2021b78f0d$exports.sizeFromShape(params.shape);
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const [resultShape, numSlices, sliceSize, strides] = $510a55f99d61727a$exports.prepareAndValidate(params, indices);
    if (numSlices === 0) return backend.makeTensorInfo(resultShape, params.dtype, []);
    const indicesData = backend.data.get(indices.dataId).values;
    const paramsBuf = backend.bufferSync(params);
    const outBuf = $b5f6308f114a9bb4$export$eed1912b07a3c4d5(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend.makeTensorInfo(resultShape, params.dtype, outBuf.values);
}
const $9861804c9e3df3e0$export$d9700eb1c7f5c969 = {
    kernelName: $2b76be1e72a8c1db$export$4ef6e37a23721703,
    backendName: 'cpu',
    kernelFunc: $9861804c9e3df3e0$export$3c586830e482d2b9
};






function $16f906fb337610ff$export$3d75b4295ded9925(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , indices: indices  } = inputs;
    const { axis: axis , batchDims: batchDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x,
        indices
    ], 'gatherV2');
    // Throw error when any index is out of bound.
    const parsedAxis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    const indicesVals = backend.data.get(indices.dataId).values;
    const axisDim = x.shape[parsedAxis];
    for(let i = 0; i < indicesVals.length; ++i){
        const index = indicesVals[i];
        $f6b55a2021b78f0d$exports.assert(index <= axisDim - 1 && index >= 0, ()=>`GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`
        );
    }
    let $batchDims = batchDims;
    if (batchDims == null) $batchDims = 0;
    const indicesSize = $f6b55a2021b78f0d$exports.sizeFromShape(indices.shape);
    const shapeInfo = $510a55f99d61727a$exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, $batchDims);
    const flattenX = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: [
                shapeInfo.batchSize,
                shapeInfo.outerSize,
                shapeInfo.dimSize,
                shapeInfo.sliceSize
            ]
        }
    });
    const flattenIndex = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            shape: [
                shapeInfo.batchSize,
                indicesSize / shapeInfo.batchSize
            ]
        }
    });
    const flattenOutputShape = [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
    ];
    const indicesBuf = backend.bufferSync(flattenIndex);
    const xBuf = backend.bufferSync(flattenX);
    const outBuf = $8d57ce41c39b729c$export$d7b732f2e62ccc09(xBuf, indicesBuf, flattenOutputShape);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(flattenIndex);
    return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
}
const $16f906fb337610ff$export$b1bd3139c91d8765 = {
    kernelName: $2b76be1e72a8c1db$export$ccd988942e5c0181,
    backendName: 'cpu',
    kernelFunc: $16f906fb337610ff$export$3d75b4295ded9925
};








function $6ff9b5a1de85c52f$export$776649b0bf8ce1fd(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const inputSize = $f6b55a2021b78f0d$exports.sizeFromShape(input.shape);
    // Collapse all outer dimensions to a single batch dimension.
    const innerDimensionSize = input.shape[input.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: input
        },
        backend: backend,
        attrs: {
            shape: [
                batch,
                innerDimensionSize
            ]
        }
    });
    const result = $6b13317856823dc7$export$3f1645f616cf26f8(input2D, true, backend);
    const resultReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: result
        },
        backend: backend,
        attrs: {
            shape: input.shape
        }
    });
    backend.disposeIntermediateTensorInfo(input2D);
    backend.disposeIntermediateTensorInfo(result);
    return resultReshaped;
}
const $6ff9b5a1de85c52f$export$dc267425bf21b465 = {
    kernelName: $2b76be1e72a8c1db$export$21c6f576ae8100e8,
    backendName: 'cpu',
    kernelFunc: $6ff9b5a1de85c52f$export$776649b0bf8ce1fd
};





const $f4d701cd2771830b$export$65f0b13f2f82375a = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$b9fcc0946d7d485e, (xi)=>Number.isFinite(xi) ? 1 : 0
, 'bool');
const $f4d701cd2771830b$export$4d45c8f7b9ffdaf1 = {
    kernelName: $2b76be1e72a8c1db$export$b9fcc0946d7d485e,
    backendName: 'cpu',
    kernelFunc: $f4d701cd2771830b$export$65f0b13f2f82375a
};




const $f8dbd10592735a48$export$e5d3415c656f7096 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$74b5a3bc735b152, (xi)=>Math.abs(xi) === Infinity ? 1 : 0
, 'bool');
const $f8dbd10592735a48$export$bc383b82282e9b5a = {
    kernelName: $2b76be1e72a8c1db$export$74b5a3bc735b152,
    backendName: 'cpu',
    kernelFunc: $f8dbd10592735a48$export$e5d3415c656f7096
};




const $18c6ffc99c03786a$export$c9f5652083b8129d = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$9912dc4fc649dbec, (xi)=>Number.isNaN(xi) ? 1 : 0
, 'bool');
const $18c6ffc99c03786a$export$d58ff790c765c1f0 = {
    kernelName: $2b76be1e72a8c1db$export$9912dc4fc649dbec,
    backendName: 'cpu',
    kernelFunc: $18c6ffc99c03786a$export$c9f5652083b8129d
};







function $cec748ba240624b0$export$865a19adce4d7a46(args) {
    const { backend: backend , attrs: attrs  } = args;
    const { start: start , stop: stop , num: num  } = attrs;
    const outVals = $bb0c259378aaff95$export$31412d657cd1cc08(start, stop, num);
    return backend.makeTensorInfo([
        outVals.length
    ], 'float32', outVals);
}
const $cec748ba240624b0$export$46b96f742c70959b = {
    kernelName: $2b76be1e72a8c1db$export$34f0ab8eba543ee6,
    backendName: 'cpu',
    kernelFunc: $cec748ba240624b0$export$865a19adce4d7a46
};





const $5053d6eaa6790617$export$144dcf16adfb9698 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$70f05bf9ddcfca68, (xi)=>Math.log1p(xi)
);
const $5053d6eaa6790617$export$c458b9e5ba980198 = {
    kernelName: $2b76be1e72a8c1db$export$70f05bf9ddcfca68,
    backendName: 'cpu',
    kernelFunc: $5053d6eaa6790617$export$144dcf16adfb9698
};





const $50b0765db66fa60e$export$e75adbe8a6aa8c40 = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a && b
);
const $50b0765db66fa60e$export$db5dd0ef9d505f = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$8a27ff10dff4d6e5, $50b0765db66fa60e$export$e75adbe8a6aa8c40, null, 'bool');
const $50b0765db66fa60e$export$257f1e82e69113fb = {
    kernelName: $2b76be1e72a8c1db$export$8a27ff10dff4d6e5,
    backendName: 'cpu',
    kernelFunc: $50b0765db66fa60e$export$db5dd0ef9d505f
};




const $090b46a3ad165929$export$c836ff7b605b1617 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$4393bee5596c68c2, (xi)=>xi ? 0 : 1
, 'bool');
const $090b46a3ad165929$export$68e2dd0840056271 = {
    kernelName: $2b76be1e72a8c1db$export$4393bee5596c68c2,
    backendName: 'cpu',
    kernelFunc: $090b46a3ad165929$export$c836ff7b605b1617
};





const $d60ebe15d6f644ef$export$9b10f32fda33cd6f = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>a || b
);
const $d60ebe15d6f644ef$export$e2a73975983cadd8 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$c49f9f5ffc6f678c, $d60ebe15d6f644ef$export$9b10f32fda33cd6f, null, 'bool');
const $d60ebe15d6f644ef$export$ce04b6546987ef43 = {
    kernelName: $2b76be1e72a8c1db$export$c49f9f5ffc6f678c,
    backendName: 'cpu',
    kernelFunc: $d60ebe15d6f644ef$export$e2a73975983cadd8
};




function $3432f1f0bef26917$export$ac78e832c121c629(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { depthRadius: depthRadius , bias: bias , alpha: alpha , beta: beta  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'LRN');
    const channels = x.shape[3];
    const maxD = channels - 1;
    const xValues = backend.data.get(x.dataId).values;
    const size = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const result = new Float32Array(size);
    function sumAcrossChannels(offset) {
        const currentChannel = offset % channels;
        let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
        const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);
        let sum = 0.0;
        for(; beginSumOffset <= endSumOffset; beginSumOffset++){
            const z = xValues[beginSumOffset];
            sum += z * z;
        }
        return sum;
    }
    for(let offset1 = 0; offset1 < size; offset1++){
        const sum = sumAcrossChannels(offset1);
        const val = xValues[offset1] * Math.pow(bias + alpha * sum, -beta);
        result[offset1] = val;
    }
    return backend.makeTensorInfo(x.shape, x.dtype, result);
}
const $3432f1f0bef26917$export$6fb124d5a6994734 = {
    kernelName: $2b76be1e72a8c1db$export$eb2f713fc3e1ca9a,
    backendName: 'cpu',
    kernelFunc: $3432f1f0bef26917$export$ac78e832c121c629
};




function $0bdac2993cf1aaee$export$c4c981cfebdcf90(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , y: y , dy: dy  } = inputs;
    const { depthRadius: depthRadius , bias: bias , alpha: alpha , beta: beta  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(dy, 'LRNGrad');
    const dySize = $f6b55a2021b78f0d$exports.sizeFromShape(dy.shape);
    const channels = dy.shape[3];
    const dyValues = backend.data.get(dy.dataId).values;
    const xValues = backend.data.get(x.dataId).values;
    const yValues = backend.data.get(y.dataId).values;
    const result = new Float32Array(dySize);
    const size = dySize;
    for(let offset = 0; offset < size; offset++){
        const currentChannel = offset % channels;
        const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
        const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);
        let norm = 0;
        for(let k = depthBegin; k < depthEnd; k++)norm += Math.pow(xValues[k], 2);
        norm = alpha * norm + bias;
        for(let k1 = depthBegin; k1 < depthEnd; k1++){
            let dyi = -2 * alpha * beta * xValues[k1] * yValues[offset] / norm;
            if (offset === k1) dyi += Math.pow(norm, -beta);
            dyi *= dyValues[offset];
            result[k1] += dyi;
        }
    }
    return backend.makeTensorInfo(dy.shape, x.dtype, result);
}
const $0bdac2993cf1aaee$export$99a62fc039d7aca0 = {
    kernelName: $2b76be1e72a8c1db$export$73ba43cd0ce95b10,
    backendName: 'cpu',
    kernelFunc: $0bdac2993cf1aaee$export$c4c981cfebdcf90
};








function $de0da6f2c4de6447$export$8960430cfd85939f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { reductionIndices: reductionIndices , keepDims: keepDims  } = attrs;
    const cpuBackend = backend;
    let xShape = x.shape;
    const xRank = xShape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(reductionIndices, xShape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let xVals = cpuBackend.data.get(x.dataId).values;
    if (permutedAxes != null) {
        const newShape = new Array(xRank);
        for(let i = 0; i < newShape.length; i++)newShape[i] = xShape[permutedAxes[i]];
        xVals = $81b92e00647b9a32$export$986b9e65182e08d(xVals, xShape, x.dtype, permutedAxes, newShape);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
        xShape = newShape;
    }
    $2f54d733028161b9$export$1412c17b2531581a(x, 'max');
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('max', axes, xRank);
    const [maxOutShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(xShape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const result = $290cb3a8bc723624$export$23c9b99bdac85be0(xVals, reduceSize, maxOutShape, x.dtype);
    const dataId = cpuBackend.write(result, maxOutShape, x.dtype);
    let outShape = maxOutShape;
    if (keepDims) {
        // reshape
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(maxOutShape, origAxes);
        outShape = newShape;
    }
    return {
        dataId: dataId,
        shape: outShape,
        dtype: x.dtype
    };
}
const $de0da6f2c4de6447$export$7d79147246e312bb = {
    kernelName: $2b76be1e72a8c1db$export$d36c09e5d02927e7,
    backendName: 'cpu',
    kernelFunc: $de0da6f2c4de6447$export$8960430cfd85939f
};







function $49fdfd288724a79a$export$e4aadcf115842782(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'maxPool');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = 1;
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, dilations), ()=>'Error in maxPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    let res;
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && $f6b55a2021b78f0d$exports.arraysEqual(convInfo.inShape, convInfo.outShape)) res = $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    else {
        const xValues = backend.data.get(x.dataId).values;
        const strides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
        const buffer = $ac1c9a98a3d54919$export$7a0e2789ec54f0db(xValues, x.shape, x.dtype, strides, convInfo, 'max');
        res = backend.makeTensorInfo(convInfo.outShape, x.dtype, buffer.values);
    }
    return res;
}
const $49fdfd288724a79a$export$45c8263b38f19e33 = {
    kernelName: $2b76be1e72a8c1db$export$39ea33024ddd5cf,
    backendName: 'cpu',
    kernelFunc: $49fdfd288724a79a$export$e4aadcf115842782
};





function $db7193b60972d024$export$bf5a4705068838e7(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode , dataFormat: dataFormat  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'maxPool3d');
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode, dataFormat);
    const xValues = backend.data.get(x.dataId).values;
    const outBuf = $ac1c9a98a3d54919$export$3712ebf21d29ff82(xValues, x.shape, x.dtype, $f6b55a2021b78f0d$exports.computeStrides(x.shape), convInfo, 'max');
    return backend.makeTensorInfo(outBuf.shape, 'float32', outBuf.values);
}
const $db7193b60972d024$export$91a8fc5da39ec855 = {
    kernelName: $2b76be1e72a8c1db$export$88fdc64af890fc53,
    backendName: 'cpu',
    kernelFunc: $db7193b60972d024$export$bf5a4705068838e7
};





function $ea0bc4a42d0bef67$export$e68b9bef571dd4ea(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        input
    ], 'maxPool3DGrad');
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(input.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const inputBuf = backend.bufferSync(input);
    const maxPosBuf = $ac1c9a98a3d54919$export$e389a84eda2bb69e(inputBuf, convInfo);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = $034bc04874ecb003$export$ab1029bcae9ddb4a(input.shape, 'float32');
    const dyBuf = backend.bufferSync(dy);
    for(let batch = 0; batch < convInfo.batchSize; ++batch){
        for(let channel = 0; channel < convInfo.inChannels; ++channel)for(let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth){
            for(let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow)for(let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol){
                // Shader code begins
                const dyDepthCorner = dxDepth - padFront;
                const dyRowCorner = dxRow - padTop;
                const dyColCorner = dxCol - padLeft;
                let dotProd = 0;
                for(let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth){
                    const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                    if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) continue;
                    for(let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight){
                        const dyRow = (dyRowCorner + wRow) / strideHeight;
                        if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) continue;
                        for(let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth){
                            const dyCol = (dyColCorner + wCol) / strideWidth;
                            if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) continue;
                            const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                            const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;
                            const mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) continue;
                            const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                            dotProd += pixel * mask;
                        }
                    }
                }
                dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);
            }
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $ea0bc4a42d0bef67$export$5201426bb10bd5eb = {
    kernelName: $2b76be1e72a8c1db$export$52be2c00371a1350,
    backendName: 'cpu',
    kernelFunc: $ea0bc4a42d0bef67$export$e68b9bef571dd4ea
};





function $2c793d5c19fff804$export$85dfd1121f049514(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input , output: output  } = inputs;
    const x = input;
    $2f54d733028161b9$export$1412c17b2531581a([
        input,
        output
    ], 'maxPoolGrad');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const xValues = backend.data.get(x.dataId).values;
    const maxPosBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(convInfo.outShape, x.dtype, $ac1c9a98a3d54919$export$60b78444d0fe518d(xValues, x.shape, x.dtype, convInfo).values);
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = $034bc04874ecb003$export$ab1029bcae9ddb4a(x.shape, 'float32');
    const dyData = backend.data.get(dy.dataId).values;
    const dyBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(dy.shape, 'float32', dyData);
    for(let b = 0; b < convInfo.batchSize; ++b)for(let d = 0; d < convInfo.inChannels; ++d){
        for(let dxR = 0; dxR < convInfo.inHeight; ++dxR)for(let dxC = 0; dxC < convInfo.inWidth; ++dxC){
            // Shader code begins.
            const dyRCorner = dxR - padTop;
            const dyCCorner = dxC - padLeft;
            let dotProd = 0;
            for(let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight){
                const dyR = (dyRCorner + wR) / strideHeight;
                if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) continue;
                for(let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth){
                    const dyC = (dyCCorner + wC) / strideWidth;
                    if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) continue;
                    const maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b, dyR, dyC, d);
                    const curPos = wR * effectiveFilterWidth + wC;
                    const mask = maxPos === curPos ? 1 : 0;
                    if (mask === 0) continue;
                    const pixel = dyBuf.get(b, dyR, dyC, d);
                    dotProd += pixel * mask;
                }
            }
            dx.set(dotProd, b, dxR, dxC, d);
        }
    }
    return backend.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
const $2c793d5c19fff804$export$e01a7f8dbee29127 = {
    kernelName: $2b76be1e72a8c1db$export$f0f010b1d1db8a46,
    backendName: 'cpu',
    kernelFunc: $2c793d5c19fff804$export$85dfd1121f049514
};







function $3d4ad5df3f62f18f$export$3cc34964a47e7a3f(xValues, xShape, dtype, includeBatchInIndex, convInfo) {
    const strides = $f6b55a2021b78f0d$exports.computeStrides(xShape);
    const maxPools = $ac1c9a98a3d54919$export$7a0e2789ec54f0db(xValues, xShape, dtype, strides, convInfo, 'max');
    const maxPositions = $ac1c9a98a3d54919$export$60b78444d0fe518d(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);
    return [
        maxPools.values,
        maxPositions.values
    ];
}


const $7ce74b3c3cf449c7$export$a069ee2247a7d1ce = {
    kernelName: $2b76be1e72a8c1db$export$deac4b7497b4047f,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { x: x  } = inputs;
        const { filterSize: filterSize , strides: strides , pad: pad , includeBatchInIndex: includeBatchInIndex  } = attrs;
        const cpuBackend = backend;
        $2f54d733028161b9$export$1412c17b2531581a(x, 'MaxPoolWithArgmax');
        const values = cpuBackend.data.get(x.dataId).values;
        const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, [
            1,
            1
        ], pad);
        const [pooled, indexes] = $3d4ad5df3f62f18f$export$3cc34964a47e7a3f(values, x.shape, x.dtype, includeBatchInIndex, convInfo);
        const pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x.dtype);
        const indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x.dtype);
        return [
            {
                dataId: pooledDataId,
                shape: convInfo.outShape,
                dtype: x.dtype
            },
            {
                dataId: indexesDataId,
                shape: convInfo.outShape,
                dtype: 'int32'
            }
        ];
    }
};






function $7f91b0830e170cf1$export$1ce691f85baaa52(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const shapes = $510a55f99d61727a$exports.computeOutAndReduceShapes(x.shape, axes);
    const reduceShape = shapes[1];
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const toDispose = [];
    const reduceSizeScalar = backend.makeTensorInfo([], 'float32', new Float32Array([
        reduceSize
    ]));
    toDispose.push(reduceSizeScalar);
    const $x = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            dtype: 'float32'
        }
    });
    toDispose.push($x);
    const res = $477f2b66f539027f$export$159d9494db57879b({
        inputs: {
            a: $x,
            b: reduceSizeScalar
        },
        backend: backend
    });
    toDispose.push(res);
    const result = $e5bd7c780dd66c27$export$8a63f25cc62965f1({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            axis: axis,
            keepDims: keepDims
        }
    });
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
}
const $7f91b0830e170cf1$export$b934af0ccd0cdbe1 = {
    kernelName: $2b76be1e72a8c1db$export$1c2d59c4b681fbd8,
    backendName: 'cpu',
    kernelFunc: $7f91b0830e170cf1$export$1ce691f85baaa52
};






function $373bdb8044647581$export$96ec731ed4dcb222(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'min');
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
        $x = $a2ad71a3b184be14$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('min', axes, $x.shape.length);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const vals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(outShape), $x.dtype);
    const aVals = backend.data.get($x.dataId).values;
    for(let i = 0; i < vals.length; ++i){
        const offset = i * reduceSize;
        let $373bdb8044647581$export$96ec731ed4dcb222 = aVals[offset];
        for(let j = 0; j < reduceSize; ++j){
            const value = aVals[offset + j];
            if (Number.isNaN(value) || value < $373bdb8044647581$export$96ec731ed4dcb222) $373bdb8044647581$export$96ec731ed4dcb222 = value;
        }
        vals[i] = $373bdb8044647581$export$96ec731ed4dcb222;
    }
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo($x);
    const result = backend.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
        const expandedShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        const reshapedResult = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                shape: expandedShape
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        return reshapedResult;
    }
    return result;
}
const $373bdb8044647581$export$3cd9f9a31b38cf18 = {
    kernelName: $2b76be1e72a8c1db$export$dfed19fabc75a31d,
    backendName: 'cpu',
    kernelFunc: $373bdb8044647581$export$96ec731ed4dcb222
};





function $149e37cbcb36dc5f$export$c0b11600e90b86ae(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { paddings: paddings , mode: mode  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'mirrorPad');
    const outShape = paddings.map((p, i)=>p[0] + x.shape[i] + p[1]
    );
    const start = paddings.map((p)=>p[0]
    );
    const end = paddings.map((p, i)=>p[0] + x.shape[i]
    );
    const offset = mode === 'reflect' ? 0 : 1;
    const xVals = backend.data.get(x.dataId).values;
    const xRank = x.shape.length;
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const resultSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShape);
    const resultRank = outShape.length;
    const resultStrides = $f6b55a2021b78f0d$exports.computeStrides(outShape);
    const resVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(x.dtype, resultSize);
    for(let i1 = 0; i1 < resultSize; i1++){
        let coords = $f6b55a2021b78f0d$exports.indexToLoc(i1, resultRank, resultStrides);
        for(let i2 = 0; i2 < resultRank; i2++){
            if (coords[i2] < start[i2]) coords[i2] = start[i2] * 2 - coords[i2] - offset;
            else if (coords[i2] >= end[i2]) coords[i2] = (end[i2] - 1) * 2 - coords[i2] + offset;
        }
        coords = coords.map((c, i)=>c - start[i]
        );
        const inIndex = $f6b55a2021b78f0d$exports.locToIndex(coords, xRank, xStrides);
        resVals[i1] = xVals[inIndex];
    }
    const outId = backend.write(resVals, outShape, x.dtype);
    return {
        dataId: outId,
        shape: outShape,
        dtype: x.dtype
    };
}
const $149e37cbcb36dc5f$export$2cfd6c6c7daeb5fc = {
    kernelName: $2b76be1e72a8c1db$export$f4c0e95fd7fd31e5,
    backendName: 'cpu',
    kernelFunc: $149e37cbcb36dc5f$export$c0b11600e90b86ae
};





const $a3e42730e2b23823$export$fc31b6ef8ca4db11 = $c0c4b4b9f56d6853$export$28de919591fae5d9((aValue, bValue)=>{
    const rem = aValue % bValue;
    if (aValue < 0 && bValue < 0 || aValue >= 0 && bValue >= 0) return rem;
    else return (rem + bValue) % bValue;
});
const $a3e42730e2b23823$export$842a2cf37af977e1 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$e4835a5e3f3674d5, $a3e42730e2b23823$export$fc31b6ef8ca4db11);
const $a3e42730e2b23823$export$9037685a81180a9c = {
    kernelName: $2b76be1e72a8c1db$export$e4835a5e3f3674d5,
    backendName: 'cpu',
    kernelFunc: $a3e42730e2b23823$export$842a2cf37af977e1
};



var $023fc18e5e8a297c$exports = {};

var $7LzWx = parcelRequire("7LzWx");

var $2QjKb = parcelRequire("2QjKb");

var $iLjOb = parcelRequire("iLjOb");

var $fIzdX = parcelRequire("fIzdX");

var $cMOEe = parcelRequire("cMOEe");

var $9knOD = parcelRequire("9knOD");
var $ef91071e3a4149fc$exports = {};

/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/ (function(pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
    var global = this, width = 256, chunks = 6, digits = 52, rngname = 'random', startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.
    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed1, options, callback) {
        var key = [];
        options = options == true ? {
            entropy: true
        } : options || {};
        // Flatten the seed string or build one from local entropy if needed.
        var shortseed = mixkey(flatten(options.entropy ? [
            seed1,
            tostring(pool)
        ] : seed1 == null ? autoseed() : seed1, 3), key);
        // Use the seed to initialize an ARC4 generator.
        var arc4 = new ARC4(key);
        // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.
        var prng1 = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0; //   and no 'extra last byte'.
            while(n < significance){
                n = (n + x) * width; //   shifting numerator and
                d *= width; //   denominator and generating a
                x = arc4.g(1); //   new least-significant-byte.
            }
            while(n >= overflow){
                n /= 2; //   last byte, shift everything
                d /= 2; //   right using integer math until
                x >>>= 1; //   we have exactly the desired bits.
            }
            return (n + x) / d; // Form the number within [0, 1).
        };
        prng1.int32 = function() {
            return arc4.g(4) | 0;
        };
        prng1.quick = function() {
            return arc4.g(4) / 0x100000000;
        };
        prng1.double = prng1;
        // Mix the randomness into accumulated entropy.
        mixkey(tostring(arc4.S), pool);
        // Calling convention: what to return as a function of prng, seed, is_math.
        return (options.pass || callback || function(prng, seed, is_math_call, state) {
            if (state) {
                // Load the arc4 state from the given state if it has an S array.
                if (state.S) copy(state, arc4);
                // Only provide the .state method if requested via options.state.
                prng.state = function() {
                    return copy(arc4, {});
                };
            }
            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) {
                math[rngname] = prng;
                return seed;
            } else return prng;
        })(prng1, shortseed, 'global' in options ? options.global : this == math, options.state);
    }
    math['seed' + rngname] = seedrandom;
    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
        var t1, keylen = key.length, me = this, i1 = 0, j1 = me.i = me.j = 0, s1 = me.S = [];
        // The empty key [] is treated as [0].
        if (!keylen) key = [
            keylen++
        ];
        // Set up S using the standard key scheduling algorithm.
        while(i1 < width)s1[i1] = i1++;
        for(i1 = 0; i1 < width; i1++){
            s1[i1] = s1[j1 = mask & j1 + key[i1 % keylen] + (t1 = s1[i1])];
            s1[j1] = t1;
        }
        // The "g" method returns the next (count) outputs as one number.
        (me.g = function(count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t, r = 0, i = me.i, j = me.j, s = me.S;
            while(count--){
                t = s[i = mask & i + 1];
                r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
            }
            me.i = i;
            me.j = j;
            return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
        })(width);
    }
    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == 'object') {
            for(prop in obj)try {
                result.push(flatten(obj[prop], depth - 1));
            } catch (e) {}
        }
        return result.length ? result : typ == 'string' ? obj : obj + '\0';
    }
    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
        var stringseed = seed + '', smear, j = 0;
        while(j < stringseed.length)key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        return tostring(key);
    }
    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
        try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) // The use of 'out' to remember randomBytes makes tight minified code.
            out = out(width);
            else {
                out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
        } catch (e) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [
                +new Date,
                global,
                plugins,
                global.screen,
                tostring(pool)
            ];
        }
    }
    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
        return String.fromCharCode.apply(0, a);
    }
    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);
    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if ($ef91071e3a4149fc$exports) {
        $ef91071e3a4149fc$exports = seedrandom;
        // When in node.js, try using crypto package for autoseeding.
        try {
            nodecrypto = (parcelRequire("ltudh"));
        } catch (ex) {}
    } else if (typeof define == 'function' && define.amd) define(function() {
        return seedrandom;
    });
// End anonymous scope, and pass initial values.
})([], Math // math: package containing random, pow, and seedrandom
);


$ef91071e3a4149fc$exports.alea = $7LzWx;
$ef91071e3a4149fc$exports.xor128 = $2QjKb;
$ef91071e3a4149fc$exports.xorwow = $iLjOb;
$ef91071e3a4149fc$exports.xorshift7 = $fIzdX;
$ef91071e3a4149fc$exports.xor4096 = $cMOEe;
$ef91071e3a4149fc$exports.tychei = $9knOD;
$023fc18e5e8a297c$exports = $ef91071e3a4149fc$exports;










function $3ef4706d6a56c37c$export$e008137e76238601(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { logits: logits  } = inputs;
    const { dim: dim  } = attrs;
    const logitsRank = logits.shape.length;
    let $dim = dim;
    if ($dim === -1) $dim = logitsRank - 1;
    if ($dim !== logitsRank - 1) throw Error('Softmax along a non-last dimension is not yet supported. ' + `Logits was rank ${logitsRank} and dim was ${$dim}`);
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam([
        $dim
    ], logits.shape);
    const maxLogit = $de0da6f2c4de6447$export$8960430cfd85939f({
        inputs: {
            x: logits
        },
        backend: backend,
        attrs: {
            reductionIndices: axes,
            keepDims: false
        }
    });
    const expandedShape = $510a55f99d61727a$exports.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: maxLogit
        },
        backend: backend,
        attrs: {
            shape: expandedShape
        }
    });
    const a = $1fbda794b513f6c9$export$f93b5905241a7cca({
        inputs: {
            a: logits,
            b: maxLogitReshaped
        },
        backend: backend
    });
    const b = $4e30044b6b67a663$export$b310ec824aaee37f({
        inputs: {
            x: a
        },
        backend: backend
    });
    const sumExp = $e5bd7c780dd66c27$export$8a63f25cc62965f1({
        inputs: {
            x: b
        },
        backend: backend,
        attrs: {
            axis: axes,
            keepDims: false
        }
    });
    const sumReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: sumExp
        },
        backend: backend,
        attrs: {
            shape: expandedShape
        }
    });
    const result = $477f2b66f539027f$export$159d9494db57879b({
        inputs: {
            a: b,
            b: sumReshaped
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(maxLogit);
    backend.disposeIntermediateTensorInfo(maxLogitReshaped);
    backend.disposeIntermediateTensorInfo(a);
    backend.disposeIntermediateTensorInfo(b);
    backend.disposeIntermediateTensorInfo(sumExp);
    backend.disposeIntermediateTensorInfo(sumReshaped);
    return result;
}
const $3ef4706d6a56c37c$export$c022691f23e2ee69 = {
    kernelName: $2b76be1e72a8c1db$export$350a526055d3ca6e,
    backendName: 'cpu',
    kernelFunc: $3ef4706d6a56c37c$export$e008137e76238601
};


function $7f48b34de3e85532$export$f4d580f3101a1c7e(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { logits: logits  } = inputs;
    const { numSamples: numSamples , seed: seed , normalized: normalized  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(logits, 'multinomial');
    const probabilities = normalized ? logits : $3ef4706d6a56c37c$export$e008137e76238601({
        inputs: {
            logits: logits
        },
        backend: backend,
        attrs: {
            dim: -1
        }
    });
    const batchSize = probabilities.shape[0];
    const numEvents = probabilities.shape[1];
    const probVals = backend.data.get(probabilities.dataId).values;
    const resShape = [
        batchSize,
        numSamples
    ];
    const resVals = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(resShape), 'int32');
    for(let b = 0; b < batchSize; ++b){
        const offset = b * numEvents;
        // The cdf won't include the last event. It will be implicit if no other
        // event happened.
        const cdf = new Float32Array(numEvents - 1);
        cdf[0] = probVals[offset];
        for(let event = 1; event < cdf.length; ++event)cdf[event] = cdf[event - 1] + probVals[offset + event];
        const random = $023fc18e5e8a297c$exports.alea(seed.toString());
        const outOffset = b * numSamples;
        for(let sampleId = 0; sampleId < numSamples; ++sampleId){
            const r = random();
            // Assume last event happened by default.
            resVals[outOffset + sampleId] = cdf.length;
            for(let event = 0; event < cdf.length; event++)if (r < cdf[event]) {
                resVals[outOffset + sampleId] = event;
                break;
            }
        }
    }
    if (!normalized) backend.disposeIntermediateTensorInfo(probabilities);
    return backend.makeTensorInfo(resShape, 'int32', resVals);
}
const $7f48b34de3e85532$export$ad960e364767f0e2 = {
    kernelName: $2b76be1e72a8c1db$export$ee0a8cfb693e0e3f,
    backendName: 'cpu',
    kernelFunc: $7f48b34de3e85532$export$f4d580f3101a1c7e
};






const $10c3f309467887ff$var$nonMaxSuppressionV3Impl = $c0ded10581046f08$exports.nonMaxSuppressionV3Impl;
function $10c3f309467887ff$export$8917e4bf7f7f5d42(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(boxes, 'NonMaxSuppression');
    const boxesVals = backend.data.get(boxes.dataId).values;
    const scoresVals = backend.data.get(scores.dataId).values;
    const { selectedIndices: selectedIndices  } = $10c3f309467887ff$var$nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend.makeTensorInfo([
        selectedIndices.length
    ], 'int32', new Int32Array(selectedIndices));
}
const $10c3f309467887ff$export$549561cd158f260a = {
    kernelName: $2b76be1e72a8c1db$export$5e11788439c2f04,
    backendName: 'cpu',
    kernelFunc: $10c3f309467887ff$export$8917e4bf7f7f5d42
};




const $22657141f9fa7cab$var$nonMaxSuppressionV4Impl = $c0ded10581046f08$exports.nonMaxSuppressionV4Impl;
function $22657141f9fa7cab$export$ad519bdebe8f4dcf(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold , padToMaxOutputSize: padToMaxOutputSize  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(boxes, 'NonMaxSuppressionPadded');
    const boxesVals = backend.data.get(boxes.dataId).values;
    const scoresVals = backend.data.get(scores.dataId).values;
    const { selectedIndices: selectedIndices , validOutputs: validOutputs  } = $22657141f9fa7cab$var$nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
        backend.makeTensorInfo([
            selectedIndices.length
        ], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([], 'int32', new Int32Array([
            validOutputs
        ]))
    ];
}
const $22657141f9fa7cab$export$906b8fb32c570e9d = {
    kernelName: $2b76be1e72a8c1db$export$7df908154366fe7f,
    backendName: 'cpu',
    kernelFunc: $22657141f9fa7cab$export$ad519bdebe8f4dcf
};




const $383b22c9183d2a97$var$nonMaxSuppressionV5Impl = $c0ded10581046f08$exports.nonMaxSuppressionV5Impl;
function $383b22c9183d2a97$export$49e389fdbe01a534(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold , softNmsSigma: softNmsSigma  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(boxes, 'NonMaxSuppressionWithScore');
    const boxesVals = backend.data.get(boxes.dataId).values;
    const scoresVals = backend.data.get(scores.dataId).values;
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices: selectedIndices , selectedScores: selectedScores  } = $383b22c9183d2a97$var$nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
        backend.makeTensorInfo([
            selectedIndices.length
        ], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([
            selectedScores.length
        ], 'float32', new Float32Array(selectedScores))
    ];
}
const $383b22c9183d2a97$export$4c00b682f309701d = {
    kernelName: $2b76be1e72a8c1db$export$cb45d3fcefce2ef0,
    backendName: 'cpu',
    kernelFunc: $383b22c9183d2a97$export$49e389fdbe01a534
};





function $74f25e081de1c0ff$export$341b5490a776d041(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { indices: indices  } = inputs;
    const { depth: depth , onValue: onValue , offValue: offValue  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(indices, 'oneHot');
    const indicesSize = $f6b55a2021b78f0d$exports.sizeFromShape(indices.shape);
    const res = new Float32Array(indicesSize * depth);
    res.fill(offValue);
    const indicesVal = backend.data.get(indices.dataId).values;
    for(let event = 0; event < indicesSize; ++event)if (indicesVal[event] >= 0 && indicesVal[event] < depth) res[event * depth + indicesVal[event]] = onValue;
    return backend.makeTensorInfo([
        ...indices.shape,
        depth
    ], 'int32', res);
}
const $74f25e081de1c0ff$export$dde5645b472b80b2 = {
    kernelName: $2b76be1e72a8c1db$export$18982b43ba8c02e9,
    backendName: 'cpu',
    kernelFunc: $74f25e081de1c0ff$export$341b5490a776d041
};












function $73af2eeca8538e7a$export$cb1f824e7733584d(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    if (x.dtype === 'string') throw new Error('zerosLike is not supported for string tensors');
    else if (x.dtype === 'complex64') {
        const realPart = $cca3c2d597694263$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const r = $73af2eeca8538e7a$export$cb1f824e7733584d({
            inputs: {
                x: realPart
            },
            backend: backend
        });
        const imagPart = $febe76d18fc2e7a2$export$d78fab5778ab392b({
            inputs: {
                input: x
            },
            backend: backend
        });
        const i = $73af2eeca8538e7a$export$cb1f824e7733584d({
            inputs: {
                x: imagPart
            },
            backend: backend
        });
        const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: r,
                imag: i
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    } else return $2400098b1cc400be$export$9563e054e6f787fb({
        backend: backend,
        attrs: {
            shape: x.shape,
            value: 0,
            dtype: x.dtype
        }
    });
}
const $73af2eeca8538e7a$export$15368df05c479e41 = {
    kernelName: $2b76be1e72a8c1db$export$430969a37eda1e88,
    backendName: 'cpu',
    kernelFunc: $73af2eeca8538e7a$export$cb1f824e7733584d
};


function $b1f245838633e277$export$fb6afd6214fee9e9(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    if (x.dtype === 'string') throw new Error('onesLike is not supported for string tensors');
    else if (x.dtype === 'complex64') {
        const realPart = $cca3c2d597694263$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const r = $b1f245838633e277$export$fb6afd6214fee9e9({
            inputs: {
                x: realPart
            },
            backend: backend
        });
        const imagPart = $febe76d18fc2e7a2$export$d78fab5778ab392b({
            inputs: {
                input: x
            },
            backend: backend
        });
        const i = $73af2eeca8538e7a$export$cb1f824e7733584d({
            inputs: {
                x: imagPart
            },
            backend: backend
        });
        const result = $4bf097831c9b1d30$export$83a0e34f1302825b({
            inputs: {
                real: r,
                imag: i
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    } else return $2400098b1cc400be$export$9563e054e6f787fb({
        backend: backend,
        attrs: {
            shape: x.shape,
            value: 1,
            dtype: x.dtype
        }
    });
}
const $b1f245838633e277$export$d8d7015eb6ab37d0 = {
    kernelName: $2b76be1e72a8c1db$export$a2962e735c809d91,
    backendName: 'cpu',
    kernelFunc: $b1f245838633e277$export$fb6afd6214fee9e9
};





function $5589309a61ad787b$export$2a703dbb0cb35339(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    if (inputs.length === 1) return $6eaa90d1c0232879$export$d660d8ed21f46635({
        inputs: {
            input: inputs[0]
        },
        backend: backend,
        attrs: {
            dim: axis
        }
    });
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t)=>{
        $f6b55a2021b78f0d$exports.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        $f6b55a2021b78f0d$exports.assert(dtype === t.dtype, ()=>'All tensors passed to stack must have matching dtypes'
        );
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t)=>{
        const expandedT = $6eaa90d1c0232879$export$d660d8ed21f46635({
            inputs: {
                input: t
            },
            backend: backend,
            attrs: {
                dim: axis
            }
        });
        intermediateTensorInfos.push(expandedT);
        return expandedT;
    });
    const result = $69f14ff8decf8b5f$export$ee1b3e54f0441b22({
        inputs: expandedTensors,
        backend: backend,
        attrs: {
            axis: axis
        }
    });
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
}
const $5589309a61ad787b$export$1645fa8803aa1f86 = {
    kernelName: $2b76be1e72a8c1db$export$c26f40b29201e5b7,
    backendName: 'cpu',
    kernelFunc: $5589309a61ad787b$export$2a703dbb0cb35339
};




function $959bbd7412ba5d3a$export$f676d6ad4f38bb89(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { paddings: paddings , constantValue: constantValue  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'pad');
    const outShape = paddings.map((p, i)=>p[0] + x.shape[i] + p[1]
    );
    const start = paddings.map((p)=>p[0]
    );
    const xVals = backend.data.get(x.dataId).values;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const xRank = x.shape.length;
    const xStrides = $f6b55a2021b78f0d$exports.computeStrides(x.shape);
    const resultSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShape);
    const resultRank = outShape.length;
    const resultStrides = $f6b55a2021b78f0d$exports.computeStrides(outShape);
    const resVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(x.dtype, resultSize);
    if (constantValue !== 0) resVals.fill(constantValue);
    for(let i1 = 0; i1 < xSize; i1++){
        const coords = $f6b55a2021b78f0d$exports.indexToLoc(i1, xRank, xStrides);
        const outCoords = coords.map((c, i)=>c + start[i]
        );
        const outIndex = $f6b55a2021b78f0d$exports.locToIndex(outCoords, resultRank, resultStrides);
        resVals[outIndex] = xVals[i1];
    }
    const outId = backend.write(resVals, outShape, x.dtype);
    return {
        dataId: outId,
        shape: outShape,
        dtype: x.dtype
    };
}
const $959bbd7412ba5d3a$export$b0317e720bfd61fc = {
    kernelName: $2b76be1e72a8c1db$export$5d47ba206577f0f2,
    backendName: 'cpu',
    kernelFunc: $959bbd7412ba5d3a$export$f676d6ad4f38bb89
};





const $114cbadcef87d6f5$export$92051c71bb41bd8a = $c0c4b4b9f56d6853$export$28de919591fae5d9((a, b)=>Math.pow(a, b)
);
const $114cbadcef87d6f5$export$9c297f60e22e3389 = $bed1816d9b4c970d$export$29353c66e70e3e16($2b76be1e72a8c1db$export$ce28d653ec559ee, $114cbadcef87d6f5$export$92051c71bb41bd8a);
const $114cbadcef87d6f5$export$b823d49786719761 = {
    kernelName: $2b76be1e72a8c1db$export$ce28d653ec559ee,
    backendName: 'cpu',
    kernelFunc: $114cbadcef87d6f5$export$9c297f60e22e3389
};






function $2972a3fe0ca60372$export$d02631cccf789723(args) {
    const { backend: backend , attrs: attrs  } = args;
    const { start: start , stop: stop , dtype: dtype , step: step  } = attrs;
    const values = $1752da38d99a9db0$export$3561205b7dff20bf(start, stop, step, dtype);
    return backend.makeTensorInfo([
        values.length
    ], dtype, values);
}
const $2972a3fe0ca60372$export$361c4075706e31c2 = {
    kernelName: $2b76be1e72a8c1db$export$9a58ef0d7ad3278c,
    backendName: 'cpu',
    kernelFunc: $2972a3fe0ca60372$export$d02631cccf789723
};






const $3a2bfcd862ccc743$export$163bc8c839a1ac04 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$c6e4a23ed5e0415b, (xi)=>1 / xi
);
const $3a2bfcd862ccc743$export$412a6b66203fdf72 = {
    kernelName: $2b76be1e72a8c1db$export$c6e4a23ed5e0415b,
    backendName: 'cpu',
    kernelFunc: $3a2bfcd862ccc743$export$163bc8c839a1ac04
};







function $de1208feca6ad282$export$1f1cbc7da93d06a0(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images  } = inputs;
    const { alignCorners: alignCorners , halfPixelCenters: halfPixelCenters , size: size  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(images, 'resizeBilinear');
    const imagesStrides = $f6b55a2021b78f0d$exports.computeStrides(images.shape);
    const [newHeight, newWidth] = size;
    const [batch, oldHeight, oldWidth, numChannels] = images.shape;
    const xValues = backend.data.get(images.dataId).values;
    const result = new Float32Array($f6b55a2021b78f0d$exports.sizeFromShape([
        batch,
        newHeight,
        newWidth,
        numChannels
    ]));
    const effectiveInputSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutputSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let outputIdx = 0;
    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
    for(let b = 0; b < batch; b++)for(let r = 0; r < newHeight; r++){
        let sourceFracRow;
        if (halfPixelCenters) sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;
        else sourceFracRow = effectiveRowSizeRatio * r;
        const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));
        const rowFrac = sourceFracRow - sourceRowFloor;
        const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
        const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];
        const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];
        for(let c = 0; c < newWidth; c++){
            let sourceFracCol;
            if (halfPixelCenters) sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;
            else sourceFracCol = effectiveColSizeRatio * c;
            const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));
            const colFrac = sourceFracCol - sourceColFloor;
            const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
            const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];
            const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];
            const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];
            const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];
            for(let d = 0; d < numChannels; d++){
                // Begin shader.
                // Compute the fractional index of the source.
                const topLeft = xValues[topLeftOffest + d];
                const bottomLeft = xValues[botLeftOffset + d];
                const topRight = xValues[topRightOffset + d];
                const bottomRight = xValues[botRightOffest + d];
                const top = topLeft + (topRight - topLeft) * colFrac;
                const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                const newValue = top + (bottom - top) * rowFrac;
                result[outputIdx++] = newValue;
            }
        }
    }
    return backend.makeTensorInfo([
        batch,
        newHeight,
        newWidth,
        numChannels
    ], 'float32', result);
}
const $de1208feca6ad282$export$a37a56137abc1357 = {
    kernelName: $2b76be1e72a8c1db$export$24f2f15d869e0fd,
    backendName: 'cpu',
    kernelFunc: $de1208feca6ad282$export$1f1cbc7da93d06a0
};




function $64f187e0b1eadbef$export$8899506794ec394(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images , dy: dy  } = inputs;
    const { alignCorners: alignCorners  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        images
    ], 'resizeBilinearGrad');
    const imagesStrides = $f6b55a2021b78f0d$exports.computeStrides(images.shape);
    const [batch, xHeight, xWidth, depth] = images.shape;
    const [, yHeight, yWidth] = dy.shape;
    const output = new Float32Array(batch * xHeight * xWidth * depth);
    // In the backwards pass, we want to find the pixels that were generated
    // for each pixel in the input image the forward pass and add the
    // corresponding coefficient from dy to the gradient (with some
    // interpolation).
    const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    // Reference implementation
    // tslint:disable-next-line:max-line-length
    // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275
    const dyValues = backend.data.get(dy.dataId).values;
    let offset = 0;
    for(let b = 0; b < batch; b++){
        const bOffset = b * imagesStrides[0];
        for(let r = 0; r < yHeight; r++){
            const dxR = r * heightScale;
            const topDxRIndex = Math.floor(dxR);
            const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
            const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];
            const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];
            const dxRLerp = dxR - topDxRIndex;
            const inverseDxRLerp = 1.0 - dxRLerp;
            for(let c = 0; c < yWidth; c++){
                const dxC = c * widthScale;
                const leftDxCIndex = Math.floor(dxC);
                const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
                const dxCLerp = dxC - leftDxCIndex;
                const inverseDxCLerp = 1.0 - dxCLerp;
                const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];
                const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];
                const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];
                const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];
                const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
                const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
                const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
                const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
                for(let d = 0; d < depth; d++){
                    const dyVal = dyValues[offset++];
                    output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;
                    output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;
                    output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;
                    output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;
                }
            }
        }
    }
    return backend.makeTensorInfo([
        batch,
        xWidth,
        xHeight,
        depth
    ], 'float32', output);
}
const $64f187e0b1eadbef$export$51f84ca614e84763 = {
    kernelName: $2b76be1e72a8c1db$export$2d3cf759f1538c13,
    backendName: 'cpu',
    kernelFunc: $64f187e0b1eadbef$export$8899506794ec394
};




function $a4f9e69975435993$export$74a902ae74ac2560(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images  } = inputs;
    const { alignCorners: alignCorners , halfPixelCenters: halfPixelCenters , size: size  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(images, 'resizeNearestNeighbor');
    const imagesStrides = $f6b55a2021b78f0d$exports.computeStrides(images.shape);
    const [newHeight, newWidth] = size;
    const [batch, oldHeight, oldWidth, numChannels] = images.shape;
    const xValues = backend.data.get(images.dataId).values;
    const output = new Float32Array(batch * newHeight * newWidth * numChannels);
    const effectiveInputSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutputSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
    let outputOffset = 0;
    for(let b = 0; b < batch; b++){
        const batchOffset = b * imagesStrides[0];
        for(let r = 0; r < newHeight; r++){
            const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;
            let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
            if (halfPixelCenters) sourceNearestRow = Math.max(0, sourceNearestRow);
            const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];
            for(let c = 0; c < newWidth; c++){
                const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;
                let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
                if (halfPixelCenters) sourceNearestCol = Math.max(0, sourceNearestCol);
                const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];
                for(let d = 0; d < numChannels; d++){
                    // Begin shader.
                    // Compute the fractional index of the source.
                    const newVal = xValues[colOffset + d];
                    output[outputOffset++] = newVal;
                }
            }
        }
    }
    return backend.makeTensorInfo([
        batch,
        newHeight,
        newWidth,
        numChannels
    ], images.dtype, output);
}
const $a4f9e69975435993$export$2b6a92caba113b89 = {
    kernelName: $2b76be1e72a8c1db$export$6c8d8ec26192bb18,
    backendName: 'cpu',
    kernelFunc: $a4f9e69975435993$export$74a902ae74ac2560
};




function $a8da46f61e20ec09$export$2b75795f158f1b18(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images , dy: dy  } = inputs;
    const { alignCorners: alignCorners  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        dy,
        images
    ], 'resizeNearestNeighborGrad');
    const imagesStrides = $f6b55a2021b78f0d$exports.computeStrides(images.shape);
    const dyStrides = $f6b55a2021b78f0d$exports.computeStrides(dy.shape);
    const [batch, xHeight, xWidth, depth] = images.shape;
    const [, yHeight, yWidth] = dy.shape;
    const output = new Float32Array(batch * xHeight * xWidth * depth);
    const dyValues = backend.data.get(dy.dataId).values;
    // In the backwards pass, we want to find the pixels that were generated
    // for each pixel in the input image the forward pass
    const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    // This defines the size of the window of values around a particular
    // index in dy that we want to search for contributions to dx.
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    // Loop over the output space.
    for(let b = 0; b < batch; b++){
        const batchOffset = b * imagesStrides[0];
        for(let r = 0; r < xHeight; r++){
            const rowOffset = batchOffset + r * imagesStrides[1];
            // Compute bounds for where in dy we will look
            const startRLerp = Math.floor(r * invHeightScale);
            const startDyR = Math.floor(startRLerp - winHeight / 2);
            for(let c = 0; c < xWidth; c++){
                const colOffset = rowOffset + c * imagesStrides[2];
                // Compute bounds for where in dy we will look
                const startCLerp = Math.floor(c * invWidthScale);
                const startDyC = Math.floor(startCLerp - winWidth / 2);
                for(let d = 0; d < depth; d++){
                    let accum = 0;
                    // loop over dy
                    for(let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++){
                        const dyR = dyRIndex + startDyR;
                        // Guard against the window exceeding the bounds of dy
                        if (dyR < 0 || dyR >= yHeight) continue;
                        const dyROffset = batchOffset + dyR * dyStrides[1];
                        const sourceFracRow = dyR * heightScale;
                        const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
                        if (r !== sourceNearestRow) continue;
                        for(let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++){
                            const dyC = dyCIndex + startDyC;
                            // Guard against the window exceeding the bounds of dy
                            if (dyC < 0 || dyC >= yWidth) continue;
                            const dyCOffset = dyROffset + dyC * dyStrides[2];
                            const sourceFracCol = dyC * widthScale;
                            const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
                            if (c === sourceNearestCol) accum += dyValues[dyCOffset + d];
                        }
                    }
                    output[colOffset + d] = accum;
                }
            }
        }
    }
    return backend.makeTensorInfo(images.shape, images.dtype, output);
}
const $a8da46f61e20ec09$export$2b08d810b5090fe1 = {
    kernelName: $2b76be1e72a8c1db$export$b84ac31c55aa023b,
    backendName: 'cpu',
    kernelFunc: $a8da46f61e20ec09$export$2b75795f158f1b18
};





function $64729dd35a844d49$export$66c1ae025e96b4bc(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { dims: dims  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'reverse');
    const xRank = x.shape.length;
    const $dims = $f6b55a2021b78f0d$exports.parseAxisParam(dims, x.shape);
    if (xRank === 0) return $cac0f9b7f5ef2746$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const outBuf = new $c341eb4171cc0419$export$350df26cd52e08e1(x.shape, x.dtype);
    const xBuf = backend.bufferSync(x);
    for(let i = 0; i < outBuf.size; i++){
        const outLoc = outBuf.indexToLoc(i);
        const inLoc = outLoc.slice();
        $dims.forEach((d)=>inLoc[d] = x.shape[d] - 1 - inLoc[d]
        );
        outBuf.set(xBuf.get(...inLoc), ...outLoc);
    }
    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
const $64729dd35a844d49$export$cab6a4e8d2ed8e8d = {
    kernelName: $2b76be1e72a8c1db$export$53c81f36b32e1bba,
    backendName: 'cpu',
    kernelFunc: $64729dd35a844d49$export$66c1ae025e96b4bc
};



const $a3db32fa954e54a4$export$44ba8c83417ab668 = {
    kernelName: $2b76be1e72a8c1db$export$c5a44649815d1c3,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { image: image  } = inputs;
        const { radians: radians , fillValue: fillValue , center: center  } = attrs;
        const cpuBackend = backend;
        const output = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(image.dtype, $f6b55a2021b78f0d$exports.sizeFromShape(image.shape));
        const [batch, imageHeight, imageWidth, numChannels] = image.shape;
        const [centerX, centerY] = $510a55f99d61727a$exports.getImageCenter(center, imageHeight, imageWidth);
        const fullOpacityValue = 255;
        const sinFactor = Math.sin(radians);
        const cosFactor = Math.cos(radians);
        const imageVals = cpuBackend.data.get(image.dataId).values;
        for(let batchIdx = 0; batchIdx < batch; batchIdx++){
            const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
            for(let row = 0; row < imageHeight; row++){
                const rowOffset = row * (imageWidth * numChannels);
                for(let col = 0; col < imageWidth; col++){
                    const colOffset = col * numChannels;
                    for(let channel = 0; channel < numChannels; channel++){
                        const coords = [
                            batch,
                            row,
                            col,
                            channel
                        ];
                        const x = coords[2];
                        const y = coords[1];
                        // coordX/coordY are the result of rotating and translating x/y.
                        let coordX = (x - centerX) * cosFactor - (y - centerY) * sinFactor;
                        let coordY = (x - centerX) * sinFactor + (y - centerY) * cosFactor;
                        coordX = Math.round(coordX + centerX);
                        coordY = Math.round(coordY + centerY);
                        let outputValue = fillValue;
                        if (typeof fillValue !== 'number') {
                            if (channel === 3) outputValue = fullOpacityValue;
                            else outputValue = fillValue[channel];
                        }
                        // If the coordinate position falls within the image boundaries...
                        if (coordX >= 0 && coordX < imageWidth && coordY >= 0 && coordY < imageHeight) {
                            // set the output to the image value at the coordinate position.
                            const rotatedRowOffset = coordY * (imageWidth * numChannels);
                            const rotatedColOffset = coordX * numChannels;
                            const imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;
                            outputValue = imageVals[imageIdx];
                        }
                        const outIdx = batchOffset + rowOffset + colOffset + channel;
                        output[outIdx] = outputValue;
                    }
                }
            }
        }
        const dataId = cpuBackend.write(output, image.shape, image.dtype);
        return {
            dataId: dataId,
            shape: image.shape,
            dtype: image.dtype
        };
    }
};




const $96adb33c0ff0fba6$export$2077e0241d6afd3c = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$c5ed3eef16c0612f, (xi)=>{
    // The algorithm is based on banker's rounding.
    const base = Math.floor(xi);
    if (xi - base < 0.5) return Math.floor(xi);
    else if (xi - base > 0.5) return Math.ceil(xi);
    else {
        if (base % 2.0 === 0.0) return base;
        else return base + 1.0;
    }
});
const $96adb33c0ff0fba6$export$6c09e3291f636503 = {
    kernelName: $2b76be1e72a8c1db$export$c5ed3eef16c0612f,
    backendName: 'cpu',
    kernelFunc: $96adb33c0ff0fba6$export$2077e0241d6afd3c
};





function $5242a74965c49dbc$export$5fc9b0358a19bd54(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
    const flattenShape = [
        outputSize / sliceSize,
        sliceSize
    ];
    const indicesData = indices.values;
    const updatesData = updates.values;
    if (outputSize === 0) return $034bc04874ecb003$export$ab1029bcae9ddb4a(shape, updates.dtype);
    const outBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(flattenShape, updates.dtype);
    outBuf.values.fill(defaultValue);
    for(let i = 0; i < numUpdates; i++){
        const index = [];
        let flattenIndex = 0;
        for(let j = 0; j < sliceRank; j++){
            const dim = indicesData[i * sliceRank + j];
            index.push(dim);
            flattenIndex += dim * strides[j];
        }
        if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) throw new Error(`Invalid indices: ${index} does not index into ${shape}`);
        for(let k = 0; k < sliceSize; k++)if (sumDupeIndices) outBuf.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];
        else outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];
    }
    return outBuf;
}


function $a88301c0597b3524$export$b6f42038a536d877(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { indices: indices , updates: updates  } = inputs;
    const { shape: shape  } = attrs;
    const { sliceRank: sliceRank , numUpdates: numUpdates , sliceSize: sliceSize , strides: strides , outputSize: outputSize  } = $510a55f99d61727a$exports.calculateShapes(updates, indices, shape);
    const sumDupeIndices = true;
    const indicesBuf = backend.bufferSync(indices);
    const updatesBuf = backend.bufferSync(updates);
    const outBuf = $5242a74965c49dbc$export$5fc9b0358a19bd54(indicesBuf, updatesBuf, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, 0 /* defaultValue */ , sumDupeIndices);
    return backend.makeTensorInfo(shape, outBuf.dtype, outBuf.values);
}
const $a88301c0597b3524$export$573371744f044f5 = {
    kernelName: $2b76be1e72a8c1db$export$28eef6f0168af686,
    backendName: 'cpu',
    kernelFunc: $a88301c0597b3524$export$b6f42038a536d877
};




function $2c7b069309c33794$export$2e6c959c16ff56b8(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { condition: condition , t: t , e: e  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a([
        condition,
        t,
        e
    ], 'select');
    const conditionRank = condition.shape.length;
    const values = backend.data.get(condition.dataId).values;
    const tValues = backend.data.get(t.dataId).values;
    const eValues = backend.data.get(e.dataId).values;
    const resultDtype = $993b52a5dd76e458$export$7bcca02d1a156bdf(t.dtype, e.dtype);
    const newValues = $f6b55a2021b78f0d$exports.makeZerosTypedArray($f6b55a2021b78f0d$exports.sizeFromShape(t.shape), resultDtype);
    let index = 0;
    const offset = conditionRank === 0 || conditionRank > 1 || t.shape.length === 1 ? 1 : $f6b55a2021b78f0d$exports.sizeFromShape(t.shape.slice(1));
    for(let i = 0; i < values.length; i++){
        for(let j = 0; j < offset; j++)if (values[i] === 1) newValues[index++] = tValues[i];
        else newValues[index++] = eValues[i];
    }
    return backend.makeTensorInfo(t.shape, resultDtype, newValues);
}
const $2c7b069309c33794$export$7ff911e710ee72fc = {
    kernelName: $2b76be1e72a8c1db$export$ef9b1a59e592288f,
    backendName: 'cpu',
    kernelFunc: $2c7b069309c33794$export$2e6c959c16ff56b8
};




const $dd623bcfad44f552$var$scaleAlpha = $510a55f99d61727a$exports.SELU_SCALEALPHA;
const $dd623bcfad44f552$var$scale = $510a55f99d61727a$exports.SELU_SCALE;
const $dd623bcfad44f552$export$a5f8240d9e99b438 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$6760d858e6f2594a, (xi)=>{
    if (xi >= 0) return $dd623bcfad44f552$var$scale * xi;
    else return $dd623bcfad44f552$var$scaleAlpha * (Math.exp(xi) - 1);
});
const $dd623bcfad44f552$export$8afc8558705c1a39 = {
    kernelName: $2b76be1e72a8c1db$export$6760d858e6f2594a,
    backendName: 'cpu',
    kernelFunc: $dd623bcfad44f552$export$a5f8240d9e99b438
};





const $a058d7f1581f1b9a$export$c5552dfdbc7cec71 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$1db683ad541682f6, (xi)=>{
    if (xi < 0) return -1;
    else if (xi > 0) return 1;
    else return 0;
});
const $a058d7f1581f1b9a$export$9c0fb3eb2124ceb7 = {
    kernelName: $2b76be1e72a8c1db$export$1db683ad541682f6,
    backendName: 'cpu',
    kernelFunc: $a058d7f1581f1b9a$export$c5552dfdbc7cec71
};




const $a34583fba52340c2$export$5de3937cb4b592ed = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$75be1b631f7687, (xi)=>Math.sin(xi)
);
const $a34583fba52340c2$export$d993ec4e5c253b66 = {
    kernelName: $2b76be1e72a8c1db$export$75be1b631f7687,
    backendName: 'cpu',
    kernelFunc: $a34583fba52340c2$export$5de3937cb4b592ed
};




const $4b1f34b3c4e5261c$export$545004b505d7c555 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$b8c187376329d79b, (xi)=>Math.sinh(xi)
);
const $4b1f34b3c4e5261c$export$b92766b47f18ac85 = {
    kernelName: $2b76be1e72a8c1db$export$b8c187376329d79b,
    backendName: 'cpu',
    kernelFunc: $4b1f34b3c4e5261c$export$545004b505d7c555
};






// mirrors the implementation of tf.nn.softplus: https://goo.gl/vkcvwX
// epsilon is the difference between 1.0 and the next representable float.
// For a single precision 32 bit float this should be 2^-23, see:
// https://math.byu.edu/~schow/work/IEEEFloatingPoint.htm
const $66fe0060f7b389f9$var$epsilon = 1.1920928955078125e-7;
const $66fe0060f7b389f9$var$threshold = Math.log($66fe0060f7b389f9$var$epsilon) + 2.0;
const $66fe0060f7b389f9$export$76aa560a8c2b0055 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$c5af433747f1fd0a, (xi)=>{
    // Value above which exp(x) may overflow, but softplus(x) == x
    // is within machine epsilon.
    const tooLarge = xi > -$66fe0060f7b389f9$var$threshold;
    // Value below which exp(x) may underflow, but softplus(x) == exp(x)
    // is within machine epsilon.
    const tooSmall = xi < $66fe0060f7b389f9$var$threshold;
    const expX = Math.exp(xi);
    let result;
    if (tooSmall) result = expX;
    else if (tooLarge) result = xi;
    else result = Math.log(1.0 + expX);
    return result;
});
const $66fe0060f7b389f9$export$d9bcfe553d12d9e3 = {
    kernelName: $2b76be1e72a8c1db$export$c5af433747f1fd0a,
    backendName: 'cpu',
    kernelFunc: $66fe0060f7b389f9$export$76aa560a8c2b0055
};







function $984f8a020f19900b$export$effb9d7cae92012f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , paddings: paddings  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a([
        x
    ], 'spaceToBatchND');
    const prod = $f6b55a2021b78f0d$exports.sizeFromShape(blockShape);
    const completePaddings = [
        [
            0,
            0
        ]
    ];
    completePaddings.push(...paddings);
    for(let i = 1 + blockShape.length; i < x.shape.length; ++i)completePaddings.push([
        0,
        0
    ]);
    const paddedX = $959bbd7412ba5d3a$export$b0317e720bfd61fc.kernelFunc({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            paddings: completePaddings,
            constantValue: 0
        }
    });
    const reshapedPaddedShape = $510a55f99d61727a$exports.getReshaped(paddedX.shape, blockShape, prod, false);
    const permutedReshapedPaddedPermutation = $510a55f99d61727a$exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = $510a55f99d61727a$exports.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
    const reshapeInputs = {
        x: paddedX
    };
    const reshapeAttrs = {
        shape: reshapedPaddedShape
    };
    const paddedXReshaped = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: reshapeInputs,
        backend: backend,
        attrs: reshapeAttrs
    });
    const transposeInputs = {
        x: paddedXReshaped
    };
    const transposeAttrs = {
        perm: permutedReshapedPaddedPermutation
    };
    const paddedXT = $a2ad71a3b184be14$export$9cb09a71b7d66923({
        inputs: transposeInputs,
        backend: backend,
        attrs: transposeAttrs
    });
    const resultReshapeInputs = {
        x: paddedXT
    };
    const resultReshapeAttrs = {
        shape: flattenShape
    };
    const result = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: resultReshapeInputs,
        backend: backend,
        attrs: resultReshapeAttrs
    });
    backend.disposeIntermediateTensorInfo(paddedX);
    backend.disposeIntermediateTensorInfo(paddedXReshaped);
    backend.disposeIntermediateTensorInfo(paddedXT);
    return result;
}
const $984f8a020f19900b$export$2f85417863d2050b = {
    kernelName: $2b76be1e72a8c1db$export$f63ac5409312707c,
    backendName: 'cpu',
    kernelFunc: $984f8a020f19900b$export$effb9d7cae92012f
};




function $c3aaf2089a25ae8b$export$c82a1904a15b5028(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { indices: indices , values: values , denseShape: denseShape , defaultValue: defaultValue  } = inputs;
    if (denseShape.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
        ${denseShape.shape}`);
    if (indices.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
        ${indices.shape}`);
    if (values.shape.length !== 1) throw new Error(`Values must be a vector, saw:
        ${values.shape}`);
    if (defaultValue.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    const $indices = backend.data.get(indices.dataId).values;
    const $values = backend.data.get(values.dataId).values;
    const $denseShape = backend.data.get(denseShape.dataId).values;
    const $defaultValue = backend.data.get(defaultValue.dataId).values[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = $a1ecb873653da6fc$export$9db01208a1bec190($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
    return [
        backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
        backend.makeTensorInfo([
            outputIndicesShape[0]
        ], values.dtype, outputValues),
        backend.makeTensorInfo([
            emptyRowIndicator.length
        ], 'bool', new Uint8Array(emptyRowIndicator.map((value)=>Number(value)
        ))),
        backend.makeTensorInfo([
            reverseIndexMap.length
        ], indices.dtype, new Int32Array(reverseIndexMap)), 
    ];
}
const $c3aaf2089a25ae8b$export$818286c593224d1a = {
    kernelName: $2b76be1e72a8c1db$export$8f1933853a5c8cca,
    backendName: 'cpu',
    kernelFunc: $c3aaf2089a25ae8b$export$c82a1904a15b5028
};




function $3f9bc959ff3c068d$export$1408c45865e11fc6(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { inputIndices: inputIndices , inputShape: inputShape , newShape: newShape  } = inputs;
    if (inputIndices.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${inputIndices.shape}`);
    if (inputShape.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${inputShape.shape}`);
    if (newShape.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    const $inputShape = Array.from(backend.data.get(inputShape.dataId).values);
    const $inputIndices = backend.data.get(inputIndices.dataId).values;
    const targetShape = Array.from(backend.data.get(newShape.dataId).values);
    const [newIndices, indicesShape, outputShape] = $576be96eb9be5e86$export$a65a15ebab81f5cd($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
        backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
        backend.makeTensorInfo([
            outputShape.length
        ], newShape.dtype, new Int32Array(outputShape)), 
    ];
}
const $3f9bc959ff3c068d$export$eb106efc10374803 = {
    kernelName: $2b76be1e72a8c1db$export$f08f0dca44fa542,
    backendName: 'cpu',
    kernelFunc: $3f9bc959ff3c068d$export$1408c45865e11fc6
};




function $f97fbb1bd280ed98$export$dbc0c9096869d04e(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { data: data , indices: indices , segmentIds: segmentIds  } = inputs;
    if (data.shape.length < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if (indices.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
          ${indices.shape}`);
    if (segmentIds.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
          ${segmentIds.shape}`);
    if (indices.shape[0] !== segmentIds.shape[0]) throw new Error(`segmentIds and indices should have same size.`);
    const $data = backend.data.get(data.dataId).values;
    const $indices = backend.data.get(indices.dataId).values;
    const $segmentIds = backend.data.get(segmentIds.dataId).values;
    const [outputData, outputDataShape] = $22121e811d80d726$export$7d3f7130c4245e65($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
const $f97fbb1bd280ed98$export$51e7224ae14d7f78 = {
    kernelName: $2b76be1e72a8c1db$export$610b077aecc2447b,
    backendName: 'cpu',
    kernelFunc: $f97fbb1bd280ed98$export$dbc0c9096869d04e
};




function $420b9391f3a79a7c$export$2255ce53fc777865(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { data: data , indices: indices , segmentIds: segmentIds  } = inputs;
    if (data.shape.length < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if (indices.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
         ${indices.shape}`);
    if (segmentIds.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
         ${segmentIds.shape}`);
    if (indices.shape[0] !== segmentIds.shape[0]) throw new Error(`segmentIds and indices should have same size.`);
    const $data = backend.data.get(data.dataId).values;
    const $indices = backend.data.get(indices.dataId).values;
    const $segmentIds = backend.data.get(segmentIds.dataId).values;
    const [outputData, outputDataShape] = $22121e811d80d726$export$7d3f7130c4245e65($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
const $420b9391f3a79a7c$export$73fa0270f28b9555 = {
    kernelName: $2b76be1e72a8c1db$export$68351c28d7116b56,
    backendName: 'cpu',
    kernelFunc: $420b9391f3a79a7c$export$2255ce53fc777865
};




function $5956de300497a57e$export$1be4b823dd1a3080(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { sparseIndices: sparseIndices , sparseValues: sparseValues , defaultValue: defaultValue  } = inputs;
    const { outputShape: outputShape  } = attrs;
    const { sliceRank: sliceRank , numUpdates: numUpdates , sliceSize: sliceSize , strides: strides , outputSize: outputSize  } = $510a55f99d61727a$exports.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    const indicesBuf = backend.bufferSync(sparseIndices);
    const updatesBuf = backend.bufferSync(sparseValues);
    const $defaultValue = backend.data.get(defaultValue.dataId).values[0];
    const outBuf = $5242a74965c49dbc$export$5fc9b0358a19bd54(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
    return backend.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
}
const $5956de300497a57e$export$7bc088f8ad44ef99 = {
    kernelName: $2b76be1e72a8c1db$export$2c426709a9332421,
    backendName: 'cpu',
    kernelFunc: $5956de300497a57e$export$1be4b823dd1a3080
};





function $21215de00d1056c8$export$c0085d48b0a75d8f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { numOrSizeSplits: numOrSizeSplits , axis: axis  } = attrs;
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    const splitSizes = $510a55f99d61727a$exports.prepareSplitSize(x, numOrSizeSplits, $axis);
    const begin = new Array(x.shape.length).fill(0);
    const size = x.shape.slice();
    return splitSizes.map((s)=>{
        const sliceSize = [
            ...size
        ];
        sliceSize[$axis] = s;
        const sliceT = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: begin,
                size: sliceSize
            }
        });
        begin[$axis] += s;
        return sliceT;
    });
}
const $21215de00d1056c8$export$317be24be3af9ea0 = {
    kernelName: $2b76be1e72a8c1db$export$8dffabb4071f05aa,
    backendName: 'cpu',
    kernelFunc: $21215de00d1056c8$export$c0085d48b0a75d8f
};





const $c661682951de6831$export$7c77bece4d51efc4 = {
    kernelName: $2b76be1e72a8c1db$export$b09fb900337259de,
    backendName: 'cpu',
    kernelFunc: ({ inputs: inputs , backend: backend  })=>{
        const { x: x  } = inputs;
        const cpuBackend = backend;
        $2f54d733028161b9$export$1412c17b2531581a(x, 'square');
        const values = cpuBackend.data.get(x.dataId).values;
        const newValues = new Float32Array(values.length);
        for(let i = 0; i < values.length; ++i){
            const value = values[i];
            newValues[i] = value * value;
        }
        const dataId = cpuBackend.write(newValues, x.shape, x.dtype);
        return {
            dataId: dataId,
            shape: x.shape,
            dtype: x.dtype
        };
    }
};





const $5cbe3f63060a34f8$export$35d34bc0ed591a92 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$fd55ce593607084a, (xi, attrs)=>{
    const stepAttrs = attrs;
    if (isNaN(xi)) return NaN;
    else return xi > 0 ? 1 : stepAttrs.alpha;
});
const $5cbe3f63060a34f8$export$c42ffaf52eb2647 = {
    kernelName: $2b76be1e72a8c1db$export$fd55ce593607084a,
    backendName: 'cpu',
    kernelFunc: $5cbe3f63060a34f8$export$35d34bc0ed591a92
};







function $476a22377500ba51$export$4ae57224f3b0605c(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { begin: begin , end: end , strides: strides , beginMask: beginMask , endMask: endMask , ellipsisMask: ellipsisMask , newAxisMask: newAxisMask , shrinkAxisMask: shrinkAxisMask  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'stridedSlice');
    const { finalShapeSparse: finalShapeSparse , finalShape: finalShape , isIdentity: isIdentity , sliceDim0: sliceDim0 , isSimpleSlice: isSimpleSlice , begin: $begin , end: $end , strides: $strides  } = $1a8ddf4b5d32c90c$exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    // ref:
    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/strided_slice_op.cc
    if (isIdentity) // Optimization #1, slice is a no-op plus reshape
    result = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: finalShape
        }
    });
    else if (sliceDim0 || isSimpleSlice) {
        // Optimization #2, slice is memory contiguous (only occurs in dim 0)
        $f6b55a2021b78f0d$exports.assert(x.shape.length >= 1, ()=>`Input must have rank at least 1, got: ${x.shape.length}`
        );
        const size = $1a8ddf4b5d32c90c$exports.computeOutShape($begin, $end, $strides);
        // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).
        const sliced = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: $begin,
                size: size
            }
        });
        result = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: sliced
            },
            backend: backend,
            attrs: {
                shape: finalShape
            }
        });
        backend.disposeIntermediateTensorInfo(sliced);
    } else {
        const xBuf = backend.bufferSync(x);
        const outBuf = $a2de56570dbafe39$export$b7c450ffe7e10d88(finalShapeSparse, xBuf, $strides, $begin);
        result = backend.makeTensorInfo(finalShape, outBuf.dtype, outBuf.values);
    }
    return result;
}
const $476a22377500ba51$export$81773633114187bd = {
    kernelName: $2b76be1e72a8c1db$export$60c7f9ac271417a9,
    backendName: 'cpu',
    kernelFunc: $476a22377500ba51$export$4ae57224f3b0605c
};




function $57a1455209b73bcd$export$3490514dcc63b044(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { separator: separator , nGramWidths: nGramWidths , leftPad: leftPad , rightPad: rightPad , padWidth: padWidth , preserveShortSequences: preserveShortSequences  } = attrs;
    const { data: data , dataSplits: dataSplits  } = inputs;
    const $data = backend.data.get(data.dataId).values;
    const $dataSplits = backend.data.get(dataSplits.dataId).values;
    const [nGrams, nGramsSplits] = $e61066bf26e590dd$export$67c0958e8184138b($data, $dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences);
    return [
        backend.makeTensorInfo([
            nGrams.length
        ], 'string', nGrams),
        backend.makeTensorInfo(dataSplits.shape, 'int32', nGramsSplits), 
    ];
}
const $57a1455209b73bcd$export$35e13284eed34c22 = {
    kernelName: $2b76be1e72a8c1db$export$11a7f4af7d96ad41,
    backendName: 'cpu',
    kernelFunc: $57a1455209b73bcd$export$3490514dcc63b044
};




function $dff797ae31171e75$export$aa7f8babb17e7672(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { skipEmpty: skipEmpty  } = attrs;
    const { input: input , delimiter: delimiter  } = inputs;
    if (input.dtype !== 'string') throw new Error('Input must be of datatype string');
    if (input.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${input.shape}`);
    if (delimiter.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    const $input = backend.data.get(input.dataId).values;
    const $delimiter = backend.data.get(delimiter.dataId).values[0];
    const [indices, values, shape] = $ec69ed0754ce0772$export$c3b08e43aa36d65d($input, $delimiter, skipEmpty);
    const outputSize = values.length;
    return [
        backend.makeTensorInfo([
            outputSize,
            2
        ], 'int32', indices),
        backend.makeTensorInfo([
            outputSize
        ], 'string', values),
        backend.makeTensorInfo([
            2
        ], 'int32', new Int32Array(shape))
    ];
}
const $dff797ae31171e75$export$c51cbbd627a96532 = {
    kernelName: $2b76be1e72a8c1db$export$7e266f7223b9d396,
    backendName: 'cpu',
    kernelFunc: $dff797ae31171e75$export$aa7f8babb17e7672
};




function $276e3d73daac5d44$export$6195616d6fd0c848(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { numBuckets: numBuckets  } = attrs;
    const { input: input  } = inputs;
    if (input.dtype !== 'string') throw new Error('Input must be of datatype string');
    if (numBuckets <= 0) throw new Error(`Number of buckets must be at least 1`);
    const $input = backend.data.get(input.dataId).values;
    const output = $3e3cb1423d6599f6$export$37cbed4d0b2fe56a($input, numBuckets);
    return backend.makeTensorInfo(input.shape, 'int32', output);
}
const $276e3d73daac5d44$export$a88a78b2b233f507 = {
    kernelName: $2b76be1e72a8c1db$export$a5639899909bc8ae,
    backendName: 'cpu',
    kernelFunc: $276e3d73daac5d44$export$6195616d6fd0c848
};






const $c29272d4ab2e4105$export$fcdd3b0b3246a325 = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$115b2d5263ba5985, (xi)=>Math.tan(xi)
);
const $c29272d4ab2e4105$export$97648844df7611f3 = {
    kernelName: $2b76be1e72a8c1db$export$115b2d5263ba5985,
    backendName: 'cpu',
    kernelFunc: $c29272d4ab2e4105$export$fcdd3b0b3246a325
};




const $8fef8071eaf749a3$export$7128670e45beef9a = $9b8349e3cbf56231$export$ba4daf5748026fba($2b76be1e72a8c1db$export$893b6e865e352c83, (xi)=>Math.tanh(xi)
);
const $8fef8071eaf749a3$export$a2fc7de1a1e4eee0 = {
    kernelName: $2b76be1e72a8c1db$export$893b6e865e352c83,
    backendName: 'cpu',
    kernelFunc: $8fef8071eaf749a3$export$7128670e45beef9a
};





function $94bc4f5aa3e4fcd3$export$3c17558da18e4d75(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { reps: reps  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'tile');
    const outBuf = $f61428d0206617c9$export$f3e554b937559516(backend.bufferSync(x), reps);
    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
const $94bc4f5aa3e4fcd3$export$a5a9f8050ba7f41e = {
    kernelName: $2b76be1e72a8c1db$export$235cb65c20ad2b7,
    backendName: 'cpu',
    kernelFunc: $94bc4f5aa3e4fcd3$export$3c17558da18e4d75
};





function $f628e4c9850b4f74$export$7e641efc73a2d81(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { k: k , sorted: sorted  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'topk');
    const xVals = backend.data.get(x.dataId).values;
    const [allTopKVals, allTopKIndices] = $3334846189799256$export$b083239978762299(xVals, x.shape, x.dtype, k, sorted);
    return [
        backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
}
const $f628e4c9850b4f74$export$cffaee31213314ce = {
    kernelName: $2b76be1e72a8c1db$export$c593cd1ea0d02ebd,
    backendName: 'cpu',
    kernelFunc: $f628e4c9850b4f74$export$7e641efc73a2d81
};



function $a68639558b50ceee$export$51186ad6e864892a(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { image: image , transforms: transforms  } = inputs;
    const { interpolation: interpolation , fillMode: fillMode , fillValue: fillValue , outputShape: outputShape  } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [
        imageHeight,
        imageWidth
    ];
    const outShape = [
        batch,
        outHeight,
        outWidth,
        numChannels
    ];
    const strides = $f6b55a2021b78f0d$exports.computeStrides(image.shape);
    const batchStride = strides[0];
    const rowStride = strides[1];
    const colStride = strides[2];
    const outVals = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(image.dtype, $f6b55a2021b78f0d$exports.sizeFromShape(outShape));
    outVals.fill(fillValue);
    const imageVals = backend.data.get(image.dataId).values;
    const transformVals = backend.data.get(transforms.dataId).values;
    // Ref TF implementation:
    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h
    for(let b = 0; b < batch; ++b){
        const $a68639558b50ceee$export$51186ad6e864892a = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);
        for(let outY = 0; outY < outHeight; ++outY){
            for(let outX = 0; outX < outWidth; ++outX)for(let channel = 0; channel < numChannels; ++channel){
                let val;
                const projection = $a68639558b50ceee$export$51186ad6e864892a[6] * outX + $a68639558b50ceee$export$51186ad6e864892a[7] * outY + 1;
                if (projection === 0) continue;
                const inX = ($a68639558b50ceee$export$51186ad6e864892a[0] * outX + $a68639558b50ceee$export$51186ad6e864892a[1] * outY + $a68639558b50ceee$export$51186ad6e864892a[2]) / projection;
                const inY = ($a68639558b50ceee$export$51186ad6e864892a[3] * outX + $a68639558b50ceee$export$51186ad6e864892a[4] * outY + $a68639558b50ceee$export$51186ad6e864892a[5]) / projection;
                const x = $a68639558b50ceee$var$mapCoord(inX, imageWidth, fillMode);
                const y = $a68639558b50ceee$var$mapCoord(inY, imageHeight, fillMode);
                switch(interpolation){
                    case 'nearest':
                        val = $a68639558b50ceee$var$nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);
                        break;
                    case 'bilinear':
                        val = $a68639558b50ceee$var$bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);
                        break;
                    default:
                        throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);
                }
                const ind = b * batchStride + outY * rowStride + outX * colStride + channel;
                outVals[ind] = val;
            }
        }
        return backend.makeTensorInfo(outShape, image.dtype, outVals);
    }
    const dataId = backend.write(outVals, outShape, image.dtype);
    return {
        dataId: dataId,
        shape: image.shape,
        dtype: image.dtype
    };
}
const $a68639558b50ceee$export$1c7a3de6335954ed = {
    kernelName: $2b76be1e72a8c1db$export$563a914cafbdc389,
    backendName: 'cpu',
    kernelFunc: $a68639558b50ceee$export$51186ad6e864892a
};
function $a68639558b50ceee$var$mapCoord(outCoord, len, mode) {
    switch(mode){
        case 'reflect':
            return $a68639558b50ceee$var$mapCoordReflect(outCoord, len);
        case 'wrap':
            return $a68639558b50ceee$var$mapCoordWrap(outCoord, len);
        case 'nearest':
            return $a68639558b50ceee$var$mapCoordNearest(outCoord, len);
        case 'constant':
        default:
            return $a68639558b50ceee$var$mapCoordConstant(outCoord, len);
    }
}
function $a68639558b50ceee$var$mapCoordReflect(outCoord, len) {
    // Reflect [abcd] to [dcba|abcd|dcba].
    let inCoord = outCoord;
    if (inCoord < 0) {
        if (len <= 1) inCoord = 0;
        else {
            const sz2 = 2 * len;
            if (inCoord < sz2) inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;
            inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;
        }
    } else if (inCoord > len - 1) {
        if (len <= 1) inCoord = 0;
        else {
            const sz2 = 2 * len;
            inCoord -= sz2 * Math.trunc(inCoord / sz2);
            if (inCoord >= len) inCoord = sz2 - inCoord - 1;
        }
    }
    // clamp is necessary because when outCoord = 3.5 and len = 4,
    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.
    return $f6b55a2021b78f0d$exports.clamp(0, inCoord, len - 1);
}
function $a68639558b50ceee$var$mapCoordWrap(outCoord, len) {
    // Wrap [abcd] to [abcd|abcd|abcd].
    let inCoord = outCoord;
    if (inCoord < 0) {
        if (len <= 1) inCoord = 0;
        else {
            const sz = len - 1;
            inCoord += len * (Math.trunc(-inCoord / sz) + 1);
        }
    } else if (inCoord > len - 1) {
        if (len <= 1) inCoord = 0;
        else {
            const sz = len - 1;
            inCoord -= len * Math.trunc(inCoord / sz);
        }
    }
    // clamp is necessary because when outCoord = -0.5 and len = 4,
    // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.
    return $f6b55a2021b78f0d$exports.clamp(0, inCoord, len - 1);
}
function $a68639558b50ceee$var$mapCoordConstant(outCoord, len) {
    return outCoord;
}
function $a68639558b50ceee$var$mapCoordNearest(outCoord, len) {
    return $f6b55a2021b78f0d$exports.clamp(0, outCoord, len - 1);
}
function $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const ind = batch * batchStride + y * rowStride + x * colStride + channel;
    if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) return imageVals[ind];
    else return fillValue;
}
function $a68639558b50ceee$var$nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const $y = Math.round(y);
    const $x = Math.round(x);
    return $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);
}
function $a68639558b50ceee$var$bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const yFloor = Math.floor(y);
    const xFloor = Math.floor(x);
    const yCeil = yFloor + 1;
    const xCeil = xFloor + 1;
    // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)
    //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)
    const valueYFloor = (xCeil - x) * $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);
    // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)
    //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)
    const valueYCeil = (xCeil - x) * $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * $a68639558b50ceee$var$readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);
    // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)
    //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)
    return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;
}






function $7e141c9d93e7c5c2$export$7a5d5c156e7dc406(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { axis: axis  } = attrs;
    const { x: x  } = inputs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'unique');
    const values = backend.data.get(x.dataId).values;
    const { outputValues: outputValues , outputShape: outputShape , indices: indices  } = $0f857a49f2c266d0$export$58be9cc013c994e(values, axis, x.shape, x.dtype);
    return [
        backend.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend.makeTensorInfo([
            indices.length
        ], 'int32', indices), 
    ];
}
const $7e141c9d93e7c5c2$export$78cd70dcd092910e = {
    kernelName: $2b76be1e72a8c1db$export$8e3adf126971a183,
    backendName: 'cpu',
    kernelFunc: $7e141c9d93e7c5c2$export$7a5d5c156e7dc406
};





function $21172dbcd8a19355$export$417857010dc9287f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { value: value  } = inputs;
    let { axis: axis  } = attrs;
    if (axis < 0) axis += value.shape.length;
    const valueRank = value.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(valueRank - 1);
    let outIndex = 0;
    for(let i = 0; i < valueRank; i++)if (i !== axis) outShape[outIndex++] = value.shape[i];
    const begin = new Array(valueRank).fill(0);
    const size = value.shape.slice();
    size[axis] = 1;
    const res = new Array(num);
    for(let i1 = 0; i1 < res.length; i1++){
        begin[axis] = i1;
        const tempRes = $3f463099ff6ccc0b$export$58adb3bec8346d0f({
            inputs: {
                x: value
            },
            backend: backend,
            attrs: {
                begin: begin,
                size: size
            }
        });
        res[i1] = $2386a2b74ddbe498$export$9eaad88cf88cee2b({
            inputs: {
                x: tempRes
            },
            backend: backend,
            attrs: {
                shape: outShape
            }
        });
        backend.disposeIntermediateTensorInfo(tempRes);
    }
    return res;
}
const $21172dbcd8a19355$export$d06292128cae50d6 = {
    kernelName: $2b76be1e72a8c1db$export$441ad6bfc5db8ab4,
    backendName: 'cpu',
    kernelFunc: $21172dbcd8a19355$export$417857010dc9287f
};










function $fe5de5066c810172$export$ba7c4d144d85a309(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , segmentIds: segmentIds  } = inputs;
    const { numSegments: numSegments  } = attrs;
    $2f54d733028161b9$export$1412c17b2531581a(x, 'unsortedSegmentSum');
    const xRank = x.shape.length;
    const segmentIdsRank = segmentIds.shape.length;
    const res = [];
    const intermediates = [];
    // Reshape the segment id's so that they can be broadcast with
    // x. The new shape should be [segmentIds.shape, 1, ..., 1]
    const numIters = xRank - segmentIdsRank;
    let $segmentIds = segmentIds;
    for(let i = 0; i < numIters; ++i){
        const expanded = $6eaa90d1c0232879$export$d660d8ed21f46635({
            inputs: {
                input: $segmentIds
            },
            backend: backend,
            attrs: {
                dim: i + 1
            }
        });
        $segmentIds = expanded;
        intermediates.push(expanded);
    }
    for(let i1 = 0; i1 < numSegments; ++i1){
        const scalarValue = $f6b55a2021b78f0d$exports.createScalarValue(i1, 'int32');
        const segmentId = backend.makeTensorInfo([], 'int32', scalarValue);
        const mask = $114a5f7d44a64c41$export$411ce8e5a71e3069({
            inputs: {
                a: segmentId,
                b: $segmentIds
            },
            backend: backend
        });
        const maskCasted = $bf6d67cb764aa536$export$f2db7d5238e1d23f({
            inputs: {
                x: mask
            },
            backend: backend,
            attrs: {
                dtype: 'float32'
            }
        });
        const mul = $84b5dd89fe629858$export$2060d2db72cce88f({
            inputs: {
                a: maskCasted,
                b: x
            },
            backend: backend
        });
        const sumTensorInfo = $e5bd7c780dd66c27$export$8a63f25cc62965f1({
            inputs: {
                x: mul
            },
            backend: backend,
            attrs: {
                axis: 0,
                keepDims: false
            }
        });
        res.push(sumTensorInfo);
        intermediates.push(segmentId);
        intermediates.push(mask);
        intermediates.push(maskCasted);
        intermediates.push(mul);
        intermediates.push(sumTensorInfo);
    }
    const result = $5589309a61ad787b$export$2a703dbb0cb35339({
        inputs: res,
        backend: backend,
        attrs: {
            axis: 0
        }
    });
    intermediates.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
}
const $fe5de5066c810172$export$71e3626a4ca29968 = {
    kernelName: $2b76be1e72a8c1db$export$af810663cded5fe2,
    backendName: 'cpu',
    kernelFunc: $fe5de5066c810172$export$ba7c4d144d85a309
};



// List all kernel configs here
const $66fface56171242d$var$kernelConfigs = [
    $96128b73937fa9ec$export$f70d36da1c218f84,
    $e1d7b31057aa8a7a$export$d66f48648b9d5ec7,
    $5734363ba4c798dd$export$255826ca70737275,
    $378191978be14204$export$3f520b71a56c9e70,
    $cbaec80dd34f96bb$export$b1f3a580afb68e4c,
    $27f84d1db31021f6$export$ff8000bc6f0313e1,
    $5f1027d384ff24cd$export$4e3f081eb1a330fa,
    $3e6148c078fcdc73$export$1a8ff634f2df3da6,
    $f2e299e0b0085db3$export$ec7419fc9ad0069e,
    $0f130ad1245e066f$export$21836a5e5fa09eb4,
    $3026227daa64c21b$export$de5cb0ef95dd6700,
    $cee1c3e33d50740b$export$20d424616c76166,
    $bb29989adafd3c66$export$159d632e3ff13624,
    $473ae5fcac9bfdc7$export$c53c7ab019edb8a0,
    $adc8bfcccd56744d$export$e9ce1ba75fc9b746,
    $301e1cadb387a462$export$6c901824a23e6150,
    $a09e80632f7d870d$export$5a9c81d240244392,
    $4d597c11a1dfe02b$export$1eeb8780807d0508,
    $fa7019251f9c8291$export$ac3f8709351ab225,
    $295c0101af9de7b7$export$d0dd993198185538,
    $42795d94dc35f3df$export$df2dc5c7a755e418,
    $1e70ec225283da48$export$44e08e19f97e5513,
    $5d5fcec67371ad3c$export$af9f0093738840fb,
    $1cde87ca9443367e$export$8f7b2ec0c6f08fb2,
    $bf6d67cb764aa536$export$ac4d0f0f3927a8f3,
    $a100094c89dd6d5d$export$df387212b1898306,
    $18a85a0e2893e700$export$f7ee8f07ce0ff4e1,
    $4bf097831c9b1d30$export$67917f7910d27fd8,
    $0f5e47a77f78fdfb$export$a4817d2978acc054,
    $69f14ff8decf8b5f$export$c8cf96dae25282e5,
    $3425cac70d3f2ad3$export$4a39bf13b4378042,
    $968a46dcd4a4cd34$export$7a95f55d2d2e7d24,
    $7d91ae3474fe590a$export$19bbc19fff1ed26f,
    $4b0b7423cce0fbbd$export$1fe590fda0829040,
    $84371c6b69968cee$export$6dce9169640850fa,
    $1186a4e8e5a77410$export$40ece1caaaf084b2,
    $72dd2cadd4da2b33$export$ff099a1da5235a7e,
    $271b1942b7c056c5$export$c5824052b09ba0ed,
    $b8496ede399cfff6$export$f7086edcf0050c7f,
    $c2aa3ef4c892bfd0$export$db50d81ed60c5a35,
    $af834ffdfcdc6b29$export$2f6196f3316e7ed2,
    $e7f3febada6ba204$export$88ba267b84334692,
    $b11b48c1213fc64f$export$9c5b88dcb1d2008b,
    $a1422c7835b8f6d8$export$240667804b7c390e,
    $2c2363e1f4470d1b$export$30bc0ac3775583fc,
    $8f2ac7cc2c494a79$export$55d12409e744bebe,
    $a630f9ff21b293a6$export$56dc5d812a22748f,
    $cd61098d3404af32$export$36d3c11f61a8891a,
    $3e859e5c2fd52838$export$cf83abe0e8c87ce8,
    $f1f612ad696632e8$export$42e4451417dc5ea0,
    $9b821a714428c611$export$40bbf341885a23b7,
    $301f7bf4101118e6$export$b990686634ee3cce,
    $1fa5083ecf49b853$export$59bb07dd04647a1d,
    $114a5f7d44a64c41$export$3c8bc3d8ee318217,
    $c9e0b56da52c781d$export$d044ffef16079bd,
    $4e30044b6b67a663$export$2fd7ea0fcf021f34,
    $6eaa90d1c0232879$export$86341ba0ce5d8e60,
    $dda94f97a8e1daf8$export$16db8a08b36f938,
    $fba10a33c00fe3e0$export$a4d564e380763c78,
    $2400098b1cc400be$export$c953bf474b2bde62,
    $f7158ab3b655cbce$export$c9ec83cb23304466,
    $5b144f27164f1f4e$export$7e9a0f96fa6bd01c,
    $c244fa16d30c8b7f$export$7eac933a0c7fd37f,
    $5b9f5960e6c9464d$export$5b64efa829ddf94e,
    $18066e1f0d0edff3$export$58481cc3409b412c,
    $9861804c9e3df3e0$export$d9700eb1c7f5c969,
    $16f906fb337610ff$export$b1bd3139c91d8765,
    $92c0e9ae9f959176$export$8c4f7e92d92310f8,
    $a4bf2833f8178a9b$export$7a6926f9fcac24ca,
    $cac0f9b7f5ef2746$export$c426d3942537ad84,
    $6ff9b5a1de85c52f$export$dc267425bf21b465,
    $febe76d18fc2e7a2$export$ddfc128c2801add7,
    $f4d701cd2771830b$export$4d45c8f7b9ffdaf1,
    $f8dbd10592735a48$export$bc383b82282e9b5a,
    $18c6ffc99c03786a$export$d58ff790c765c1f0,
    $ff0b67d8ce18003d$export$aa04ab963fdf437f,
    $38fa0ec3880a2dc4$export$8d4530ce8b6ffc3c,
    $c2830dac3543b869$export$9f26bd257393dd8,
    $cec748ba240624b0$export$46b96f742c70959b,
    $d97da17f52ed975d$export$a4ae1f00643ddd14,
    $5053d6eaa6790617$export$c458b9e5ba980198,
    $50b0765db66fa60e$export$257f1e82e69113fb,
    $090b46a3ad165929$export$68e2dd0840056271,
    $d60ebe15d6f644ef$export$ce04b6546987ef43,
    $3432f1f0bef26917$export$6fb124d5a6994734,
    $0bdac2993cf1aaee$export$99a62fc039d7aca0,
    $de0da6f2c4de6447$export$7d79147246e312bb,
    $387d080214918c74$export$45b97bdc342e72a2,
    $49fdfd288724a79a$export$45c8263b38f19e33,
    $db7193b60972d024$export$91a8fc5da39ec855,
    $ea0bc4a42d0bef67$export$5201426bb10bd5eb,
    $2c793d5c19fff804$export$e01a7f8dbee29127,
    $7ce74b3c3cf449c7$export$a069ee2247a7d1ce,
    $7f91b0830e170cf1$export$b934af0ccd0cdbe1,
    $373bdb8044647581$export$3cd9f9a31b38cf18,
    $5928be63ba34a1a4$export$ea24ffbbbce8d546,
    $149e37cbcb36dc5f$export$2cfd6c6c7daeb5fc,
    $a3e42730e2b23823$export$9037685a81180a9c,
    $7f48b34de3e85532$export$ad960e364767f0e2,
    $84b5dd89fe629858$export$745576778aafee88,
    $c4c77c008a62d83d$export$cc7b18b8229c3db,
    $10c3f309467887ff$export$549561cd158f260a,
    $22657141f9fa7cab$export$906b8fb32c570e9d,
    $383b22c9183d2a97$export$4c00b682f309701d,
    $b96c4ec4fa331740$export$d003d4d7e1500775,
    $74f25e081de1c0ff$export$dde5645b472b80b2,
    $b1f245838633e277$export$d8d7015eb6ab37d0,
    $5589309a61ad787b$export$1645fa8803aa1f86,
    $959bbd7412ba5d3a$export$b0317e720bfd61fc,
    $114cbadcef87d6f5$export$b823d49786719761,
    $4ed127e19443316b$export$a5c4a9b694579636,
    $a511c99458739875$export$d556aa935cef5c0c,
    $2972a3fe0ca60372$export$361c4075706e31c2,
    $cca3c2d597694263$export$4b7bce57557ae68b,
    $477f2b66f539027f$export$15c5d6176b30b9a6,
    $3a2bfcd862ccc743$export$412a6b66203fdf72,
    $77b59f61b1ecd495$export$731f9199bde068eb,
    $46f3e8e0610dbf6c$export$92c30890ad649d53,
    $2386a2b74ddbe498$export$cfa02e698602aca2,
    $de1208feca6ad282$export$a37a56137abc1357,
    $64f187e0b1eadbef$export$51f84ca614e84763,
    $a4f9e69975435993$export$2b6a92caba113b89,
    $a8da46f61e20ec09$export$2b08d810b5090fe1,
    $64729dd35a844d49$export$cab6a4e8d2ed8e8d,
    $a3db32fa954e54a4$export$44ba8c83417ab668,
    $96adb33c0ff0fba6$export$6c09e3291f636503,
    $e4ff695093678829$export$941104b789956ef6,
    $a88301c0597b3524$export$573371744f044f5,
    $2c7b069309c33794$export$7ff911e710ee72fc,
    $dd623bcfad44f552$export$8afc8558705c1a39,
    $f57eef2a9f713d28$export$195d1cf7c59f3ef,
    $a058d7f1581f1b9a$export$9c0fb3eb2124ceb7,
    $a34583fba52340c2$export$d993ec4e5c253b66,
    $4b1f34b3c4e5261c$export$b92766b47f18ac85,
    $3f463099ff6ccc0b$export$8d8a1e11dd2cc6c4,
    $3ef4706d6a56c37c$export$c022691f23e2ee69,
    $66fe0060f7b389f9$export$d9bcfe553d12d9e3,
    $984f8a020f19900b$export$2f85417863d2050b,
    $c3aaf2089a25ae8b$export$818286c593224d1a,
    $3f9bc959ff3c068d$export$eb106efc10374803,
    $f97fbb1bd280ed98$export$51e7224ae14d7f78,
    $420b9391f3a79a7c$export$73fa0270f28b9555,
    $5956de300497a57e$export$7bc088f8ad44ef99,
    $21215de00d1056c8$export$317be24be3af9ea0,
    $1bdf881481671c57$export$a592ba9268f10eeb,
    $c661682951de6831$export$7c77bece4d51efc4,
    $bf9ce837076b486f$export$9ed4691d69db8a43,
    $5cbe3f63060a34f8$export$c42ffaf52eb2647,
    $476a22377500ba51$export$81773633114187bd,
    $57a1455209b73bcd$export$35e13284eed34c22,
    $dff797ae31171e75$export$c51cbbd627a96532,
    $276e3d73daac5d44$export$a88a78b2b233f507,
    $1fbda794b513f6c9$export$5d068476dad60c4d,
    $e5bd7c780dd66c27$export$47edea402251c258,
    $c29272d4ab2e4105$export$97648844df7611f3,
    $8fef8071eaf749a3$export$a2fc7de1a1e4eee0,
    $94bc4f5aa3e4fcd3$export$a5a9f8050ba7f41e,
    $f628e4c9850b4f74$export$cffaee31213314ce,
    $a68639558b50ceee$export$1c7a3de6335954ed,
    $a2ad71a3b184be14$export$895a002a39b774be,
    $7e141c9d93e7c5c2$export$78cd70dcd092910e,
    $21172dbcd8a19355$export$d06292128cae50d6,
    $fe5de5066c810172$export$71e3626a4ca29968,
    $73af2eeca8538e7a$export$15368df05c479e41
];
for (const kernelConfig of $66fface56171242d$var$kernelConfigs)$18a84b897e201316$export$f3f7c443f3a606e6(kernelConfig);





const $e7a12bde2bee58b4$var$whereImpl = $c0ded10581046f08$exports.whereImpl;
class $e7a12bde2bee58b4$export$65286aecbd5a8de9 extends $fc3e518cb31152af$export$543916c62202b50a {
    constructor(){
        super();
        this.blockSize = 48;
        this.firstUse = true;
        this.data = new $fc3e518cb31152af$export$e95767ffe2e60cec(this, $307e90c4876a9d4d$export$d3c662a6136faebb());
    }
    nextDataId() {
        return $e7a12bde2bee58b4$export$65286aecbd5a8de9.nextDataId++;
    }
    write(values, shape, dtype) {
        if (this.firstUse) {
            this.firstUse = false;
            if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('IS_NODE')) $510a55f99d61727a$exports.warn("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================");
        }
        const dataId = {
            id: this.nextDataId()
        };
        this.data.set(dataId, {
            values: values,
            dtype: dtype,
            refCount: 1
        });
        return dataId;
    }
    /**
     * Create a data bucket in cpu backend.
     * @param shape Shape of the `TensorInfo`.
     * @param dtype DType of the `TensorInfo`.
     * @param values The value of the `TensorInfo` stored as a flattened array.
     */ makeTensorInfo(shape, dtype, values) {
        let outId;
        if (dtype === 'string' && values != null && values.length > 0 && $f6b55a2021b78f0d$exports.isString(values[0])) {
            const encodedValues = values.map((d)=>$f6b55a2021b78f0d$exports.encodeString(d)
            );
            outId = this.write(encodedValues, shape, dtype);
        } else outId = this.write(values, shape, dtype);
        return {
            dataId: outId,
            shape: shape,
            dtype: dtype
        };
    }
    /** Return refCount of a `TensorData`. */ refCount(dataId) {
        if (this.data.has(dataId)) {
            const tensorData = this.data.get(dataId);
            return tensorData.refCount;
        }
        return 0;
    }
    /** Increase refCount of a `TensorData`. */ incRef(dataId) {
        const tensorData = this.data.get(dataId);
        tensorData.refCount++;
    }
    /** Decrease refCount of a `TensorData`. */ decRef(dataId) {
        if (this.data.has(dataId)) {
            const tensorData = this.data.get(dataId);
            tensorData.refCount--;
        }
    }
    move(dataId, values, shape, dtype, refCount) {
        this.data.set(dataId, {
            values: values,
            dtype: dtype,
            refCount: refCount
        });
    }
    numDataIds() {
        return this.data.numDataIds();
    }
    async read(dataId) {
        return this.readSync(dataId);
    }
    readSync(dataId) {
        const { dtype: dtype , complexTensorInfos: complexTensorInfos  } = this.data.get(dataId);
        if (dtype === 'complex64') {
            const realValues = this.readSync(complexTensorInfos.real.dataId);
            const imagValues = this.readSync(complexTensorInfos.imag.dataId);
            return $510a55f99d61727a$exports.mergeRealAndImagArrays(realValues, imagValues);
        }
        return this.data.get(dataId).values;
    }
    bufferSync(t) {
        const data = this.readSync(t.dataId);
        let decodedData = data;
        if (t.dtype === 'string') try {
            // Decode the bytes into string.
            decodedData = data.map((d)=>$f6b55a2021b78f0d$exports.decodeString(d)
            );
        } catch (_a) {
            throw new Error('Failed to decode encoded string bytes into utf-8');
        }
        return $034bc04874ecb003$export$ab1029bcae9ddb4a(t.shape, t.dtype, decodedData);
    }
    makeOutput(values, shape, dtype) {
        const dataId = this.write(values, shape, dtype);
        return $307e90c4876a9d4d$export$d3c662a6136faebb().makeTensorFromDataId(dataId, shape, dtype, this);
    }
    /**
     * Dispose the memory if the dataId has 0 refCount. Return true if the memory
     * is released or memory is not managed in this backend, false if memory is
     * not cleared.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */ disposeData(dataId, force = false) {
        if (this.data.has(dataId)) {
            this.data.get(dataId).refCount--;
            if (!force && this.data.get(dataId).refCount > 0) return false;
            const { complexTensorInfos: complexTensorInfos  } = this.data.get(dataId);
            if (complexTensorInfos != null) {
                this.disposeData(complexTensorInfos.real.dataId, true);
                this.disposeData(complexTensorInfos.imag.dataId, true);
            }
            this.data.delete(dataId);
        }
        return true;
    }
    disposeIntermediateTensorInfo(tensorInfo) {
        this.disposeData(tensorInfo.dataId);
    }
    async time(f) {
        const start = $f6b55a2021b78f0d$exports.now();
        f();
        const kernelMs = $f6b55a2021b78f0d$exports.now() - start;
        return {
            kernelMs: kernelMs
        };
    }
    memory() {
        return {
            // Unreliable due to automatic gc. The numbers above are cumulative.
            unreliable: true,
            reasons: [
                "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."
            ]
        };
    }
    where(condition) {
        $2f54d733028161b9$export$1412c17b2531581a([
            condition
        ], 'where');
        const condVals = this.readSync(condition.dataId);
        return $e7a12bde2bee58b4$var$whereImpl(condition.shape, condVals);
    }
    dispose() {}
    floatPrecision() {
        return 32;
    }
    /** Returns the smallest representable number.  */ epsilon() {
        return super.epsilon();
    }
}
$e7a12bde2bee58b4$export$65286aecbd5a8de9.nextDataId = 0;





// Side effects for default initialization of MathBackendCPU
$307e90c4876a9d4d$export$1ac8c3a90eff05d('cpu', ()=>new $e7a12bde2bee58b4$export$65286aecbd5a8de9()
, 1 /* priority */ );












function $3fd32f5baad8d391$export$3ebf4a18d6319f7a() {
    let version;
    let attribute;
    let varyingVs;
    let varyingFs;
    let texture2D;
    let output;
    let defineOutput;
    let defineSpecialNaN;
    let defineSpecialInf;
    let defineRound;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) {
        version = '#version 300 es';
        attribute = 'in';
        varyingVs = 'out';
        varyingFs = 'in';
        texture2D = 'texture';
        output = 'outputColor';
        defineOutput = 'out vec4 outputColor;';
        // Use custom isnan definition to work across differences between
        // implementations on various platforms. While this should happen in ANGLE
        // we still see differences between android and windows (on chrome) when
        // using isnan directly. Since WebGL2 supports uint type and
        // floatBitsToUinT built-in function, we could implment isnan following
        // IEEE 754 rules.
        // NaN defination in IEEE 754-1985 is :
        //   - sign = either 0 or 1.
        //   - biased exponent = all 1 bits.
        //   - fraction = anything except all 0 bits (since all 0 bits represents
        //   infinity).
        // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
        defineSpecialNaN = `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `;
        // In webgl 2 we do not need to specify a custom isinf so there is no
        // need for a special INFINITY constant.
        defineSpecialInf = ``;
        defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    } else {
        version = '';
        attribute = 'attribute';
        varyingVs = 'varying';
        varyingFs = 'varying';
        texture2D = 'texture2D';
        output = 'gl_FragColor';
        defineOutput = '';
        // WebGL1 has no built in isnan so we define one here.
        defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
        defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
        defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    return {
        version: version,
        attribute: attribute,
        varyingVs: varyingVs,
        varyingFs: varyingFs,
        texture2D: texture2D,
        output: output,
        defineOutput: defineOutput,
        defineSpecialNaN: defineSpecialNaN,
        defineSpecialInf: defineSpecialInf,
        defineRound: defineRound
    };
}



function $ee41ed15b893490d$export$53c37f67510642ce(coords, shape, index = 'index') {
    const strides = $f6b55a2021b78f0d$exports.computeStrides(shape);
    return strides.map((stride, i)=>{
        const line1 = `int ${coords[i]} = ${index} / ${stride}`;
        const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
        return `${line1}; ${line2};`;
    }).join('');
}
function $ee41ed15b893490d$export$ae684ebb20c3e80c(coords, shape, index = 'index') {
    const strides = $f6b55a2021b78f0d$exports.computeStrides(shape);
    return strides.map((_, i)=>{
        const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;
        const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${i}]` : `index -= ${coords[i]} * outShapeStrides[${i}]`;
        return `${line1}; ${line2};`;
    }).join('');
}
// Produces GLSL code that computes strides.
function $ee41ed15b893490d$var$symbolicallyComputeStrides(indicesArr, variableName) {
    const numCoords = indicesArr.length;
    const shape = indicesArr.map((d)=>`${variableName}[${d}]`
    );
    const strides = new Array(numCoords - 1);
    strides[numCoords - 2] = shape[numCoords - 1];
    for(let i = numCoords - 3; i >= 0; --i)strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;
    return strides;
}
function $ee41ed15b893490d$export$a1b266196cc2d8ea(coords, variableName, index = 'index') {
    const indicesArray = coords.map((_, i)=>i
    );
    const strides = $ee41ed15b893490d$var$symbolicallyComputeStrides(indicesArray, variableName);
    return strides.map((_, i)=>{
        const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;
        const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` : `index -= ${coords[i]} * ${strides[i]}`;
        return `${line1}; ${line2};`;
    }).join('');
}
function $ee41ed15b893490d$var$buildVec(x) {
    if (x.length === 1) return `${x[0]}`;
    return `vec${x.length}(${x.join(',')})`;
}
function $ee41ed15b893490d$export$fe4cd89a7b9cb48b(x, y) {
    if (x.length !== y.length) throw new Error(`Vectors to be dotted must be of the same length -` + `got ${x.length} and ${y.length}`);
    const slices = [];
    const nearestVec4 = Math.floor(x.length / 4);
    const nearestVec4Remainder = x.length % 4;
    for(let i = 0; i < nearestVec4; i++){
        const xSlice = x.slice(i * 4, i * 4 + 4);
        const ySlice = y.slice(i * 4, i * 4 + 4);
        slices.push(`${$ee41ed15b893490d$var$buildVec(xSlice)}, ${$ee41ed15b893490d$var$buildVec(ySlice)}`);
    }
    if (nearestVec4Remainder !== 0) {
        let xSlice = x.slice(nearestVec4 * 4);
        let ySlice = y.slice(nearestVec4 * 4);
        if (xSlice.length === 1) {
            xSlice = xSlice.map((d)=>`float(${d})`
            );
            ySlice = ySlice.map((d)=>`float(${d})`
            );
        }
        slices.push(`${$ee41ed15b893490d$var$buildVec(xSlice)}, ${$ee41ed15b893490d$var$buildVec(ySlice)}`);
    }
    return slices.map((d, i)=>`dot(${d})`
    ).join('+');
}
function $ee41ed15b893490d$export$4c68558c71205a01(shape) {
    const strides = $f6b55a2021b78f0d$exports.computeStrides(shape).map((d)=>d.toString()
    );
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
}
function $ee41ed15b893490d$export$4ec1e3f6361de451() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
const $ee41ed15b893490d$export$2ac12a308a563905 = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;


const { getBroadcastDims: $fbbfeeecbf2420a1$var$getBroadcastDims  } = $510a55f99d61727a$exports;
function $fbbfeeecbf2420a1$export$37f33ba844563dd2(inputsInfo, outputShape, program) {
    const prefixSnippets = [];
    inputsInfo.forEach((x)=>{
        const size = $f6b55a2021b78f0d$exports.sizeFromShape(x.shapeInfo.logicalShape);
        // Snippet when we decided to upload the values as uniform.
        if (x.shapeInfo.isUniform) prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);
        else {
            prefixSnippets.push(`uniform sampler2D ${x.name};`);
            prefixSnippets.push(`uniform int offset${x.name};`);
        }
        if (program.enableShapeUniforms) {
            const { uniformShape: uniformShape  } = $fbbfeeecbf2420a1$export$19e35a0844e29cf9(program.packedInputs, x.shapeInfo.logicalShape, x.shapeInfo.texShape);
            switch(uniformShape.length){
                case 1:
                    prefixSnippets.push(`uniform int ${x.name}Shape;`);
                    break;
                case 2:
                    prefixSnippets.push(`uniform ivec2 ${x.name}Shape;`);
                    break;
                case 3:
                    prefixSnippets.push(`uniform ivec3 ${x.name}Shape;`);
                    break;
                case 4:
                    prefixSnippets.push(`uniform ivec4 ${x.name}Shape;`);
                    break;
                default:
                    break;
            }
            prefixSnippets.push(`uniform ivec2 ${x.name}TexShape;`);
        }
    });
    if (program.enableShapeUniforms) {
        switch(outputShape.logicalShape.length){
            case 1:
                prefixSnippets.push(`uniform int outShape;`);
                break;
            case 2:
                prefixSnippets.push(`uniform ivec2 outShape;`);
                prefixSnippets.push(`uniform int outShapeStrides;`);
                break;
            case 3:
                prefixSnippets.push(`uniform ivec3 outShape;`);
                prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
                break;
            case 4:
                prefixSnippets.push(`uniform ivec4 outShape;`);
                prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
                break;
            default:
                break;
        }
        prefixSnippets.push(`uniform ivec2 outTexShape;`);
    }
    if (program.customUniforms) program.customUniforms.forEach((d)=>{
        prefixSnippets.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ''};`);
    });
    const inputPrefixSnippet = prefixSnippets.join('\n');
    const inputSamplingSnippet = inputsInfo.map((x)=>$fbbfeeecbf2420a1$var$getInputSamplingSnippet(x, outputShape, program.packedInputs, program.enableShapeUniforms)
    ).join('\n');
    const outTexShape = outputShape.texShape;
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    const floatTextureSampleSnippet = $fbbfeeecbf2420a1$var$getFloatTextureSampleSnippet(glsl);
    let outputSamplingSnippet;
    let floatTextureSetOutputSnippet;
    let shaderPrefix = $fbbfeeecbf2420a1$var$getShaderPrefix(glsl);
    if (outputShape.isPacked) {
        outputSamplingSnippet = $fbbfeeecbf2420a1$var$getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
        floatTextureSetOutputSnippet = $fbbfeeecbf2420a1$var$getFloatTextureSetRGBASnippet(glsl);
    } else {
        outputSamplingSnippet = $fbbfeeecbf2420a1$var$getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
        floatTextureSetOutputSnippet = $fbbfeeecbf2420a1$var$getFloatTextureSetRSnippet(glsl);
    }
    if (program.packedInputs) shaderPrefix += $fbbfeeecbf2420a1$var$SHADER_PACKED_PREFIX;
    const source = [
        shaderPrefix,
        floatTextureSampleSnippet,
        floatTextureSetOutputSnippet,
        inputPrefixSnippet,
        outputSamplingSnippet,
        inputSamplingSnippet,
        program.userCode
    ].join('\n');
    return source;
}
function $fbbfeeecbf2420a1$var$getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch(shape.length){
        case 0:
            return $fbbfeeecbf2420a1$var$getSamplerScalar(inInfo, enableShapeUniforms);
        case 1:
            return $fbbfeeecbf2420a1$var$getSampler1D(inInfo, enableShapeUniforms);
        case 2:
            return $fbbfeeecbf2420a1$var$getSampler2D(inInfo, enableShapeUniforms);
        case 3:
            return $fbbfeeecbf2420a1$var$getSampler3D(inInfo, enableShapeUniforms);
        case 4:
            return $fbbfeeecbf2420a1$var$getSampler4D(inInfo, enableShapeUniforms);
        case 5:
            return $fbbfeeecbf2420a1$var$getSampler5D(inInfo);
        case 6:
            return $fbbfeeecbf2420a1$var$getSampler6D(inInfo);
        default:
            throw new Error(`${shape.length}-D input sampling` + ` is not yet supported`);
    }
}
function $fbbfeeecbf2420a1$var$getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch(shape.length){
        case 0:
            return $fbbfeeecbf2420a1$var$getPackedSamplerScalar(inInfo);
        case 1:
            return $fbbfeeecbf2420a1$var$getPackedSampler1D(inInfo, enableShapeUniforms);
        case 2:
            return $fbbfeeecbf2420a1$var$getPackedSampler2D(inInfo, enableShapeUniforms);
        case 3:
            return $fbbfeeecbf2420a1$var$getPackedSampler3D(inInfo, enableShapeUniforms);
        default:
            return $fbbfeeecbf2420a1$var$getPackedSamplerND(inInfo, enableShapeUniforms);
    }
}
function $fbbfeeecbf2420a1$var$getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
    let res = '';
    if (usesPackedTextures) res += $fbbfeeecbf2420a1$var$getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
    else res += $fbbfeeecbf2420a1$var$getSamplerFromInInfo(inInfo, enableShapeUniforms);
    const inShape = inInfo.shapeInfo.logicalShape;
    const outShape = outShapeInfo.logicalShape;
    if (inShape.length <= outShape.length) {
        if (usesPackedTextures) res += $fbbfeeecbf2420a1$var$getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
        else res += $fbbfeeecbf2420a1$var$getSamplerAtOutputCoords(inInfo, outShapeInfo);
    }
    return res;
}
function $fbbfeeecbf2420a1$var$getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch(outShape.length){
        case 0:
            return $fbbfeeecbf2420a1$var$getOutputScalarCoords();
        case 1:
            return $fbbfeeecbf2420a1$var$getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
        case 2:
            return $fbbfeeecbf2420a1$var$getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
        case 3:
            return $fbbfeeecbf2420a1$var$getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
        default:
            return $fbbfeeecbf2420a1$var$getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
    }
}
function $fbbfeeecbf2420a1$var$getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch(outShape.length){
        case 0:
            return $fbbfeeecbf2420a1$var$getOutputScalarCoords();
        case 1:
            return $fbbfeeecbf2420a1$var$getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
        case 2:
            return $fbbfeeecbf2420a1$var$getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
        case 3:
            return $fbbfeeecbf2420a1$var$getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
        case 4:
            return $fbbfeeecbf2420a1$var$getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
        case 5:
            return $fbbfeeecbf2420a1$var$getOutput5DCoords(outShape, outTexShape);
        case 6:
            return $fbbfeeecbf2420a1$var$getOutput6DCoords(outShape, outTexShape);
        default:
            throw new Error(`${outShape.length}-D output sampling is not yet supported`);
    }
}
function $fbbfeeecbf2420a1$var$getFloatTextureSampleSnippet(glsl) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getFloatTextureSetRSnippet(glsl) {
    return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getFloatTextureSetRGBASnippet(glsl) {
    return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getShaderPrefix(glsl) {
    const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${$fbbfeeecbf2420a1$var$SAMPLE_1D_SNIPPET}
    ${$fbbfeeecbf2420a1$var$SAMPLE_2D_SNIPPET}
    ${$fbbfeeecbf2420a1$var$SAMPLE_3D_SNIPPET}
  `;
    return SHADER_PREFIX;
}
const $fbbfeeecbf2420a1$var$SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const $fbbfeeecbf2420a1$var$SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const $fbbfeeecbf2420a1$var$SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
const $fbbfeeecbf2420a1$var$SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function $fbbfeeecbf2420a1$var$getOutputScalarCoords() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    if (packedTexShape[0] === 1) {
        if (enableShapeUniforms) return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
    }
    if (packedTexShape[1] === 1) {
        if (enableShapeUniforms) return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput1DCoords(shape, texShape, enableShapeUniforms) {
    if (texShape[0] === 1) {
        if (enableShapeUniforms) return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
        return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
    }
    if (texShape[1] === 1) {
        if (enableShapeUniforms) return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
        return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    const texelsInLogicalRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
        const coordsFromIndexSnippet = $ee41ed15b893490d$export$ae684ebb20c3e80c([
            'r',
            'c',
            'd'
        ], shape);
        return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet}
    return ivec3(r, c, d);
  }
`;
    }
    const coordsFromIndexSnippet = $ee41ed15b893490d$export$53c37f67510642ce([
        'r',
        'c',
        'd'
    ], shape);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) // TODO: support 5d and 6d
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
    let texelsInBatchN = texelsInBatch;
    let batches = ``;
    let coords = 'b, r, c';
    for(let b = 2; b < shape.length - 1; b++){
        texelsInBatchN *= shape[shape.length - b - 1];
        batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
        coords = `b${b}, ` + coords;
    }
    return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords});
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput4DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
        const coordsFromIndexSnippet = $ee41ed15b893490d$export$ae684ebb20c3e80c([
            'r',
            'c',
            'd',
            'd2'
        ], shape);
        return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
    }
    const coordsFromIndexSnippet = $ee41ed15b893490d$export$53c37f67510642ce([
        'r',
        'c',
        'd',
        'd2'
    ], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput5DCoords(shape, texShape) {
    const coordsFromIndexSnippet = $ee41ed15b893490d$export$53c37f67510642ce([
        'r',
        'c',
        'd',
        'd2',
        'd3'
    ], shape);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput6DCoords(shape, texShape) {
    const coordsFromIndexSnippet = $ee41ed15b893490d$export$53c37f67510642ce([
        'r',
        'c',
        'd',
        'd2',
        'd3',
        'd4'
    ], shape);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    if ($f6b55a2021b78f0d$exports.arraysEqual(shape, texShape)) {
        if (enableShapeUniforms) return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
        return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
    }
    // texels needed to accommodate a logical row
    const texelsInLogicalRow = Math.ceil(shape[1] / 2);
    /**
     * getOutputCoords
     *
     * resTexRC: The rows and columns of the texels. If you move over one
     * texel to the right in the packed texture, you are moving over one column
     * (not two).
     *
     * index: The texel index
     */ if (enableShapeUniforms) return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getOutput2DCoords(shape, texShape, enableShapeUniforms) {
    if ($f6b55a2021b78f0d$exports.arraysEqual(shape, texShape)) {
        if (enableShapeUniforms) return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
    }
    if (shape[1] === 1) {
        if (enableShapeUniforms) return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    if (shape[0] === 1) {
        if (enableShapeUniforms) return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    if (enableShapeUniforms) return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName) {
    return `offset${texName}`;
}
function $fbbfeeecbf2420a1$var$getPackedSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSamplerScalar(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) return `float ${funcName}() {return ${texName};}`;
    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
    if (texNumR === 1 && texNumC === 1) return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getPackedSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    if (enableShapeUniforms) return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int index) {
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const texShape = inputInfo.shapeInfo.texShape;
    const tNumR = texShape[0];
    const tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    if (tNumC === 1) {
        if (enableShapeUniforms) return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (tNumR === 1) {
        if (enableShapeUniforms) return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getPackedSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    if (texShape != null && $f6b55a2021b78f0d$exports.arraysEqual(shape, texShape)) {
        if (enableShapeUniforms) return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    const valuesPerRow = Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && $f6b55a2021b78f0d$exports.arraysEqual(shape, texShape)) {
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
        const texNumR = texShape[0];
        const texNumC = texShape[1];
        return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, squeezedShape);
        const params = [
            'row',
            'col'
        ];
        return `
      ${$fbbfeeecbf2420a1$var$getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    if (texNumC === 1) {
        // index is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (texNumR === 1) {
        // index is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (enableShapeUniforms) return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
    return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
}
function $fbbfeeecbf2420a1$var$getPackedSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    if (shape[0] === 1) {
        const squeezedShape = shape.slice(1);
        const keptDims = [
            1,
            2
        ];
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, squeezedShape);
        const params = [
            'b',
            'row',
            'col'
        ];
        return `
        ${$fbbfeeecbf2420a1$var$getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
        }
      `;
    }
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    if (enableShapeUniforms) return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride0 = shape[1] * shape[2];
    const stride1 = shape[2];
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, squeezedShape);
        const params = [
            'row',
            'col',
            'depth'
        ];
        return `
        ${$fbbfeeecbf2420a1$var$getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
        }
      `;
    }
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
    }
    if (texNumC === stride1 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
    return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
}
function $fbbfeeecbf2420a1$var$getPackedSamplerND(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    if (enableShapeUniforms) // TODO: support 5d and 6d
    return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    const shape = inputInfo.shapeInfo.logicalShape;
    const rank = shape.length;
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [
        Math.ceil(texShape[0] / 2),
        Math.ceil(texShape[1] / 2)
    ];
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
    let params = `int b, int row, int col`;
    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
    for(let b = 2; b < rank - 1; b++){
        params = `int b${b}, ` + params;
        texelsInBatch *= shape[rank - b - 1];
        index = `b${b} * ${texelsInBatch} + ` + index;
    }
    return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler4D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride2 = shape[3];
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, newShape);
        const params = [
            'row',
            'col',
            'depth',
            'depth2'
        ];
        return `
      ${$fbbfeeecbf2420a1$var$getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const stride2Str = `int stride2 = ${texName}Shape[3];`;
    const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
    const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
    if (texNumC === stride0 && flatOffset == null) {
        // texC is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride2 && flatOffset == null) {
        // texR is used directly as physical (no risk of float16 overflow).
        if (enableShapeUniforms) return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler5D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride3 = shape[4];
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, newShape);
        const params = [
            'row',
            'col',
            'depth',
            'depth2',
            'depth3'
        ];
        return `
      ${$fbbfeeecbf2420a1$var$getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) // texC is used directly as physical (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    if (texNumC === stride3 && flatOffset == null) // texR is used directly as physical (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSampler6D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    if (newShape.length < shape.length) {
        const newInputInfo = $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inputInfo, newShape);
        const params = [
            'row',
            'col',
            'depth',
            'depth2',
            'depth3',
            'depth4'
        ];
        return `
      ${$fbbfeeecbf2420a1$var$getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${$fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims)});
      }
    `;
    }
    const stride4 = shape[5];
    const stride3 = shape[4] * stride4;
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    if (inputInfo.shapeInfo.isUniform) // Uniform arrays will be less than 65505 (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${$fbbfeeecbf2420a1$var$getUniformSampler(inputInfo)}
      }
    `;
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) // texC is used directly as physical (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    if (texNumC === stride4 && flatOffset == null) // texR is used directly as physical (no risk of float16 overflow).
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    const offset = $fbbfeeecbf2420a1$var$getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function $fbbfeeecbf2420a1$var$getUniformSampler(inputInfo) {
    const texName = inputInfo.name;
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inSize < 2) return `return ${texName};`;
    return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
}
function $fbbfeeecbf2420a1$var$getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    const broadcastDims = $fbbfeeecbf2420a1$var$getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const type = $fbbfeeecbf2420a1$export$859efd105c10c755(outRank);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = [
        'x',
        'y',
        'z',
        'w',
        'u',
        'v'
    ];
    if (inRank === 0) coordsSnippet = '';
    else if (outRank < 2 && broadcastDims.length >= 1) coordsSnippet = 'coords = 0;';
    else coordsSnippet = broadcastDims.map((d)=>`coords.${fields[d + rankDiff]} = 0;`
    ).join('\n');
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) unpackedCoordsSnippet = 'coords';
    else unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i)=>`coords.${fields[i + rankDiff]}`
    ).join(', ');
    let output = `return outputValue;`;
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    const isInputScalar = inSize === 1;
    const outSize = $f6b55a2021b78f0d$exports.sizeFromShape(outShapeInfo.logicalShape);
    const isOutputScalar = outSize === 1;
    if (inRank === 1 && !isInputScalar && !isOutputScalar) output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    else if (isInputScalar && !isOutputScalar) {
        if (outRank === 1) output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
        else output = `
        return vec4(outputValue.x);
      `;
    } else if (broadcastDims.length) {
        const rows = inRank - 2;
        const cols = inRank - 1;
        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) output = `return vec4(outputValue.x);`;
        else if (broadcastDims.indexOf(rows) > -1) output = `return vec4(outputValue.x, outputValue.y, ` + `outputValue.x, outputValue.y);`;
        else if (broadcastDims.indexOf(cols) > -1) output = `return vec4(outputValue.xx, outputValue.zz);`;
    }
    return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
}
function $fbbfeeecbf2420a1$var$getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    const outTexShape = outShapeInfo.texShape;
    const inTexShape = inputInfo.shapeInfo.texShape;
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && $f6b55a2021b78f0d$exports.arraysEqual(inTexShape, outTexShape)) return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
    const type = $fbbfeeecbf2420a1$export$859efd105c10c755(outRank);
    const broadcastDims = $fbbfeeecbf2420a1$var$getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = [
        'x',
        'y',
        'z',
        'w',
        'u',
        'v'
    ];
    if (inRank === 0) coordsSnippet = '';
    else if (outRank < 2 && broadcastDims.length >= 1) coordsSnippet = 'coords = 0;';
    else coordsSnippet = broadcastDims.map((d)=>`coords.${fields[d + rankDiff]} = 0;`
    ).join('\n');
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) unpackedCoordsSnippet = 'coords';
    else unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i)=>`coords.${fields[i + rankDiff]}`
    ).join(', ');
    return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
}
function $fbbfeeecbf2420a1$export$859efd105c10c755(rank) {
    if (rank <= 1) return 'int';
    else if (rank === 2) return 'ivec2';
    else if (rank === 3) return 'ivec3';
    else if (rank === 4) return 'ivec4';
    else if (rank === 5) return 'ivec5';
    else if (rank === 6) return 'ivec6';
    else throw Error(`GPU for rank ${rank} is not yet supported`);
}
function $fbbfeeecbf2420a1$export$19e35a0844e29cf9(isPacked, shape, texShape) {
    const { newShape: newShape , keptDims: keptDims  } = $f6b55a2021b78f0d$exports.squeezeShape(shape);
    const rank = shape.length;
    const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
    const squeezeShape = useSqueezePackedShape ? shape.slice(1) : newShape;
    const useSqueezeShape = !isPacked && rank > 1 && !$f6b55a2021b78f0d$exports.arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
    const uniformShape = useSqueezeShape ? squeezeShape : shape;
    return {
        useSqueezeShape: useSqueezeShape,
        uniformShape: uniformShape,
        keptDims: keptDims
    };
}
function $fbbfeeecbf2420a1$export$5d06d3f48295bf13(inInfo, squeezedShape) {
    // Deep copy.
    const newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function $fbbfeeecbf2420a1$var$getSqueezedParams(params, keptDims) {
    return keptDims.map((d)=>params[d]
    ).join(', ');
}



/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ const $9ee1746afacd745d$var$contexts = {};
const $9ee1746afacd745d$var$WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
};
function $9ee1746afacd745d$export$c5302deff3a07920(webGLVersion) {
    delete $9ee1746afacd745d$var$contexts[webGLVersion];
}
function $9ee1746afacd745d$export$4b8d5e1525955c68(webGLVersion, gl) {
    $9ee1746afacd745d$var$contexts[webGLVersion] = gl;
}
function $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion, customCanvas) {
    if (!(webGLVersion in $9ee1746afacd745d$var$contexts) || customCanvas != null) {
        const newCtx = $9ee1746afacd745d$var$getWebGLRenderingContext(webGLVersion, customCanvas);
        if (newCtx !== null) $9ee1746afacd745d$var$contexts[webGLVersion] = newCtx;
        else {
            console.log('Could not get context for WebGL version', webGLVersion);
            return null;
        }
    }
    const gl = $9ee1746afacd745d$var$contexts[webGLVersion];
    if (gl == null || gl.isContextLost()) {
        delete $9ee1746afacd745d$var$contexts[webGLVersion];
        return $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return $9ee1746afacd745d$var$contexts[webGLVersion];
}
function $9ee1746afacd745d$var$createCanvas(webGLVersion) {
    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) return new OffscreenCanvas(300, 150);
    else if (typeof document !== 'undefined') return document.createElement('canvas');
    else throw new Error('Cannot create a canvas in this context');
}
function $9ee1746afacd745d$var$getWebGLRenderingContext(webGLVersion, customCanvas) {
    if (webGLVersion !== 1 && webGLVersion !== 2) throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    const canvas = customCanvas == null ? $9ee1746afacd745d$var$createCanvas(webGLVersion) : customCanvas;
    canvas.addEventListener('webglcontextlost', (ev)=>{
        ev.preventDefault();
        delete $9ee1746afacd745d$var$contexts[webGLVersion];
    }, false);
    if (webGLVersion === 1) return canvas.getContext('webgl', $9ee1746afacd745d$var$WEBGL_ATTRIBUTES) || canvas.getContext('experimental-webgl', $9ee1746afacd745d$var$WEBGL_ATTRIBUTES);
    return canvas.getContext('webgl2', $9ee1746afacd745d$var$WEBGL_ATTRIBUTES);
}



var $7ea242d526563f56$export$81d5c79efa1086f2;
(function($7ea242d526563f56$export$81d5c79efa1086f2) {
    /**
     * All values in a single texel are densely packed without any constraints.
     *
     * This is how the shader encodes a tensor with shape = [2, 3, 4]
     * (indices are [batch, row, col]).
     *
     * 000|001   010|011   020|021
     * -------   -------   -------
     * 002|003   012|013   022|023
     *
     * 100|101   110|111   120|121
     * -------   -------   -------
     * 102|103   112|113   122|123
     *
     */ $7ea242d526563f56$export$81d5c79efa1086f2[$7ea242d526563f56$export$81d5c79efa1086f2["DENSE"] = 0] = "DENSE";
    /**
     * Single texels contain only values from the same batch, and from adjacent
     * rows and columns.
     *
     * This is how the shader encodes a tensor with shape = [2, 3, 5]
     * (indices are [batch, row, col]).
     *
     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx
     * -------   -------   -------   -------   -------   -------
     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx
     *
     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx
     * -------   -------   -------   -------   -------   -------
     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx
     *
     */ $7ea242d526563f56$export$81d5c79efa1086f2[$7ea242d526563f56$export$81d5c79efa1086f2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
})($7ea242d526563f56$export$81d5c79efa1086f2 || ($7ea242d526563f56$export$81d5c79efa1086f2 = {}));
var $7ea242d526563f56$export$6bf4bd1b6beb0bfd;
(function($7ea242d526563f56$export$6bf4bd1b6beb0bfd) {
    $7ea242d526563f56$export$6bf4bd1b6beb0bfd[$7ea242d526563f56$export$6bf4bd1b6beb0bfd["RENDER"] = 0] = "RENDER";
    $7ea242d526563f56$export$6bf4bd1b6beb0bfd[$7ea242d526563f56$export$6bf4bd1b6beb0bfd["UPLOAD"] = 1] = "UPLOAD";
    $7ea242d526563f56$export$6bf4bd1b6beb0bfd[$7ea242d526563f56$export$6bf4bd1b6beb0bfd["PIXELS"] = 2] = "PIXELS";
    $7ea242d526563f56$export$6bf4bd1b6beb0bfd[$7ea242d526563f56$export$6bf4bd1b6beb0bfd["DOWNLOAD"] = 3] = "DOWNLOAD";
})($7ea242d526563f56$export$6bf4bd1b6beb0bfd || ($7ea242d526563f56$export$6bf4bd1b6beb0bfd = {}));
var $7ea242d526563f56$export$bde70ab3692e385c;
(function($7ea242d526563f56$export$bde70ab3692e385c) {
    $7ea242d526563f56$export$bde70ab3692e385c[$7ea242d526563f56$export$bde70ab3692e385c["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    $7ea242d526563f56$export$bde70ab3692e385c[$7ea242d526563f56$export$bde70ab3692e385c["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    $7ea242d526563f56$export$bde70ab3692e385c[$7ea242d526563f56$export$bde70ab3692e385c["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    $7ea242d526563f56$export$bde70ab3692e385c[$7ea242d526563f56$export$bde70ab3692e385c["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    $7ea242d526563f56$export$bde70ab3692e385c[$7ea242d526563f56$export$bde70ab3692e385c["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
})($7ea242d526563f56$export$bde70ab3692e385c || ($7ea242d526563f56$export$bde70ab3692e385c = {}));
function $7ea242d526563f56$export$95fb8493b25f77a4(rows, columns) {
    return [
        columns,
        rows
    ];
}
function $7ea242d526563f56$export$9427543edb6e188a(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
function $7ea242d526563f56$export$bb1043669f490840(rows, columns) {
    return [
        columns * 4,
        rows
    ];
}
function $7ea242d526563f56$export$2cc7cc972aa2533d(shape) {
    const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
    const texelsNeeded = Math.ceil(size / 4);
    return $f6b55a2021b78f0d$exports.sizeToSquarishShape(texelsNeeded);
}
function $7ea242d526563f56$export$4c2d3be5c837367c(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ` + `${channelsPerTexture}`);
    return unpackedSize / channelsPerTexture;
}
function $7ea242d526563f56$export$ccf59730cad262bd(unpackedArray, matrix, channels) {
    const requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);
    let dst = 0;
    for(let src = 0; src < unpackedArray.length; src += 4)for(let c = 0; c < channels; c++)matrix[dst++] = unpackedArray[src + c];
}
function $7ea242d526563f56$export$2754e02fa98f5582(rows, columns) {
    return [
        Math.max(1, Math.ceil(columns / 2)),
        Math.max(1, Math.ceil(rows / 2))
    ];
}
function $7ea242d526563f56$export$12d4e412f879b1d4(rows, columns) {
    const [w, h] = $7ea242d526563f56$export$2754e02fa98f5582(rows, columns);
    return w * h * 4;
}
function $7ea242d526563f56$export$129d92ae6e74c416(// tslint:disable-next-line:no-any
gl, textureHalfFloatExtension) {
    // tslint:disable-next-line:no-any
    const glany = gl;
    let internalFormatFloat;
    let internalFormatHalfFloat;
    let internalFormatPackedHalfFloat;
    let internalFormatPackedFloat;
    let textureFormatFloat;
    let downloadTextureFormat;
    let downloadUnpackNumChannels;
    let defaultNumChannels;
    let textureTypeHalfFloat;
    let textureTypeFloat;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) {
        internalFormatFloat = glany.R32F;
        internalFormatHalfFloat = glany.R16F;
        internalFormatPackedHalfFloat = glany.RGBA16F;
        internalFormatPackedFloat = glany.RGBA32F;
        textureFormatFloat = glany.RED;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 1;
        textureTypeHalfFloat = glany.HALF_FLOAT;
        textureTypeFloat = glany.FLOAT;
        downloadTextureFormat = glany.RGBA8;
    } else {
        internalFormatFloat = gl.RGBA;
        internalFormatHalfFloat = gl.RGBA;
        internalFormatPackedHalfFloat = gl.RGBA;
        internalFormatPackedFloat = glany.RGBA;
        textureFormatFloat = gl.RGBA;
        downloadUnpackNumChannels = 4;
        defaultNumChannels = 4;
        textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
        textureTypeFloat = gl.FLOAT;
        downloadTextureFormat = gl.RGBA;
    }
    return {
        internalFormatFloat: internalFormatFloat,
        internalFormatHalfFloat: internalFormatHalfFloat,
        internalFormatPackedHalfFloat: internalFormatPackedHalfFloat,
        internalFormatPackedFloat: internalFormatPackedFloat,
        textureFormatFloat: textureFormatFloat,
        downloadTextureFormat: downloadTextureFormat,
        downloadUnpackNumChannels: downloadUnpackNumChannels,
        defaultNumChannels: defaultNumChannels,
        textureTypeHalfFloat: textureTypeHalfFloat,
        textureTypeFloat: textureTypeFloat
    };
}


function $7428f53c4d4be222$export$7642ac97981532b8(gl, func) {
    const returnValue = func();
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) $7428f53c4d4be222$var$checkWebGLError(gl);
    return returnValue;
}
function $7428f53c4d4be222$var$checkWebGLError(gl) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) throw new Error('WebGL Error: ' + $7428f53c4d4be222$export$ee3c7ff80964e13e(gl, error));
}
// https://en.wikipedia.org/wiki/Half-precision_floating-point_format
const $7428f53c4d4be222$var$MIN_FLOAT16 = 5.96e-8;
const $7428f53c4d4be222$var$MAX_FLOAT16 = 65504;
function $7428f53c4d4be222$export$829768a5b7625879(num) {
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || $7428f53c4d4be222$var$MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < $7428f53c4d4be222$var$MAX_FLOAT16) return true;
    return false;
}
function $7428f53c4d4be222$export$ee3c7ff80964e13e(gl, status) {
    switch(status){
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return `Unknown error code ${status}`;
    }
}
function $7428f53c4d4be222$export$3a5e7a891790a26c(gl, extensionName) {
    return $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.getExtension(extensionName)
    , 'Extension "' + extensionName + '" not supported on this browser.');
}
function $7428f53c4d4be222$export$4ca6704ce1875929(gl, vertexShaderSource) {
    const vertexShader = $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createShader(gl.VERTEX_SHADER)
    , 'Unable to create vertex WebGLShader.');
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.shaderSource(vertexShader, vertexShaderSource)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.compileShader(vertexShader)
    );
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
function $7428f53c4d4be222$export$a8ab0e04b20572c0(gl, fragmentShaderSource) {
    const fragmentShader = $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createShader(gl.FRAGMENT_SHADER)
    , 'Unable to create fragment WebGLShader.');
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.shaderSource(fragmentShader, fragmentShaderSource)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.compileShader(fragmentShader)
    );
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('ENGINE_COMPILE_ONLY')) return fragmentShader;
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        $7428f53c4d4be222$export$f7b23987b58d218(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
const $7428f53c4d4be222$var$lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function $7428f53c4d4be222$export$f7b23987b58d218(shaderSource, shaderInfoLog) {
    const lineNumberRegexResult = $7428f53c4d4be222$var$lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
        console.log(shaderSource);
        return;
    }
    const lineNumber1 = +lineNumberRegexResult[1];
    const shaderLines = shaderSource.split('\n');
    const pad = shaderLines.length.toString().length + 2;
    const linesWithLineNumbers = shaderLines.map((line, lineNumber)=>$f6b55a2021b78f0d$exports.rightPad((lineNumber + 1).toString(), pad) + line
    );
    let maxLineLength = 0;
    for(let i = 0; i < linesWithLineNumbers.length; i++)maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber1 - 1);
    const errorLine = linesWithLineNumbers.slice(lineNumber1 - 1, lineNumber1);
    const afterErrorLines = linesWithLineNumbers.slice(lineNumber1);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log(`%c ${$f6b55a2021b78f0d$exports.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function $7428f53c4d4be222$export$327d24a04cd0dc17(gl) {
    return $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createProgram()
    , 'Unable to create WebGLProgram.');
}
function $7428f53c4d4be222$export$d879afae78b531a5(gl, program) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.linkProgram(program)
    );
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('ENGINE_COMPILE_ONLY')) return;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
function $7428f53c4d4be222$export$e2dfaf93681cde16(gl, program) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.validateProgram(program)
    );
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
function $7428f53c4d4be222$export$3871e1d1e28ac6cb(gl, data) {
    const buffer = $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createBuffer()
    , 'Unable to create WebGLBuffer');
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
    );
    return buffer;
}
function $7428f53c4d4be222$export$f9b26b97ca2b25e9(gl, data) {
    const buffer = $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createBuffer()
    , 'Unable to create WebGLBuffer');
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW)
    );
    return buffer;
}
function $7428f53c4d4be222$export$45c2ce5fe87dcf0f() {
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) return 1;
    return 4;
}
function $7428f53c4d4be222$export$37b981a8c575f415(gl) {
    return $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createTexture()
    , 'Unable to create WebGLTexture.');
}
function $7428f53c4d4be222$export$3543950a45505554(width, height) {
    const maxTextureSize = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_MAX_TEXTURE_SIZE');
    if (width <= 0 || height <= 0) {
        const requested = `[${width}x${height}]`;
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if (width > maxTextureSize || height > maxTextureSize) {
        const requested = `[${width}x${height}]`;
        const max = `[${maxTextureSize}x${maxTextureSize}]`;
        throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
function $7428f53c4d4be222$export$366d1e3e32f5a700(gl) {
    return $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.createFramebuffer()
    , 'Unable to create WebGLFramebuffer.');
}
function $7428f53c4d4be222$export$4c858b3c953a013f(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    const loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) // The GPU compiler decided to strip out this attribute because it's unused,
    // thus no need to bind.
    return false;
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.enableVertexAttribArray(loc)
    );
    return true;
}
function $7428f53c4d4be222$export$520907fe7b2c7a2d(gl, texture, textureUnit) {
    $7428f53c4d4be222$var$validateTextureUnit(gl, textureUnit);
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.activeTexture(gl.TEXTURE0 + textureUnit)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, texture)
    );
}
function $7428f53c4d4be222$export$9bed01c46f4769b6(gl, textureUnit) {
    $7428f53c4d4be222$var$validateTextureUnit(gl, textureUnit);
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.activeTexture(gl.TEXTURE0 + textureUnit)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, null)
    );
}
function $7428f53c4d4be222$export$748cafa2cdf50d8(gl, program, uniformName) {
    return $7428f53c4d4be222$var$throwIfNull(gl, ()=>gl.getUniformLocation(program, uniformName)
    , 'uniform "' + uniformName + '" not present in program.');
}
function $7428f53c4d4be222$export$d27256445dd7e8dd(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
function $7428f53c4d4be222$export$f9ffd997f3c8b98f(gl, texture, uniformSamplerLocation, textureUnit) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>$7428f53c4d4be222$export$520907fe7b2c7a2d(gl, texture, textureUnit)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.uniform1i(uniformSamplerLocation, textureUnit)
    );
}
function $7428f53c4d4be222$export$2e43f6b5d575e241(gl) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindFramebuffer(gl.FRAMEBUFFER, null)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.scissor(0, 0, gl.canvas.width, gl.canvas.height)
    );
}
function $7428f53c4d4be222$export$4e154f0d71f19013(gl, texture, framebuffer) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)
    );
}
function $7428f53c4d4be222$export$d3c809959a3c24fa(gl, framebuffer) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0)
    );
}
function $7428f53c4d4be222$export$ca09b577525e6519(gl) {
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) throw new Error('Error binding framebuffer: ' + $7428f53c4d4be222$export$851c7fde035f5bf6(gl, status));
}
function $7428f53c4d4be222$export$851c7fde035f5bf6(gl, status) {
    switch(status){
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return `unknown error ${status}`;
    }
}
function $7428f53c4d4be222$var$throwIfNull(gl, returnTOrNull, failureMessage) {
    const tOrNull = $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>returnTOrNull()
    );
    if (tOrNull == null) throw new Error(failureMessage);
    return tOrNull;
}
function $7428f53c4d4be222$var$validateTextureUnit(gl, textureUnit) {
    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    const glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
        throw new Error(`textureUnit must be in ${textureUnitRange}.`);
    }
}
function $7428f53c4d4be222$export$4dfd7bc0667970e0(shape, dimsToSkip = 2) {
    return $f6b55a2021b78f0d$exports.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
function $7428f53c4d4be222$export$e8f6c350b57b8270(shape) {
    if (shape.length === 0) throw Error('Cannot get rows and columns of an empty shape array.');
    return [
        shape.length > 1 ? shape[shape.length - 2] : 1,
        shape[shape.length - 1]
    ];
}
function $7428f53c4d4be222$export$f944c0101b593a79(shape) {
    let shapeAs3D = [
        1,
        1,
        1
    ];
    const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
    if (!isScalar) shapeAs3D = [
        $7428f53c4d4be222$export$4dfd7bc0667970e0(shape),
        ...$7428f53c4d4be222$export$e8f6c350b57b8270(shape)
    ];
    return shapeAs3D;
}
function $7428f53c4d4be222$export$80bf57c6927be1d9(logShape, isPacked = false) {
    let maxTexSize = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_MAX_TEXTURE_SIZE');
    if (isPacked) {
        maxTexSize = maxTexSize * 2;
        // This logic ensures we accurately count the number of packed texels needed
        // to accommodate the tensor. We can only pack values in the same texel if
        // they are from adjacent pairs of rows/cols within the same batch. So if a
        // tensor has 3 rows, we pretend it has 4 rows in order to account for the
        // fact that the texels containing the third row are half empty.
        logShape = logShape.map((d, i)=>i >= logShape.length - 2 ? $f6b55a2021b78f0d$exports.nearestLargerEven(logShape[i]) : logShape[i]
        );
        // Packed texture height is at least 2 (the channel height of a single
        // texel).
        if (logShape.length === 1) logShape = [
            2,
            logShape[0]
        ];
    }
    // If logical shape is 2, we don't squeeze, since we want to match physical.
    if (logShape.length !== 2) {
        const squeezeResult = $f6b55a2021b78f0d$exports.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    let size = $f6b55a2021b78f0d$exports.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) return [
        1,
        size
    ];
    else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) return logShape;
    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) return [
        logShape[0] * logShape[1],
        logShape[2]
    ];
    else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) return [
        logShape[0],
        logShape[1] * logShape[2]
    ];
    else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) return [
        logShape[0] * logShape[1] * logShape[2],
        logShape[3]
    ];
    else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) return [
        logShape[0],
        logShape[1] * logShape[2] * logShape[3]
    ];
    else {
        if (isPacked) {
            // For packed textures size equals the number of channels required to
            // accommodate the texture data. However in order to squarify such that
            // inner dimensions stay even, we rewrite size to equal the number of
            // texels. Then in the return statement we rehydrate the squarified
            // dimensions to channel units.
            const batchDim = $7428f53c4d4be222$export$4dfd7bc0667970e0(logShape);
            let rows = 2, cols = 2;
            if (logShape.length) [rows, cols] = $7428f53c4d4be222$export$e8f6c350b57b8270(logShape);
            size = batchDim * (rows / 2) * (cols / 2);
            return $f6b55a2021b78f0d$exports.sizeToSquarishShape(size).map((d)=>d * 2
            );
        }
        return $f6b55a2021b78f0d$exports.sizeToSquarishShape(size);
    }
}
function $7428f53c4d4be222$var$isEven(n) {
    return n % 2 === 0;
}
function $7428f53c4d4be222$export$951b388203a0422d(shape1, shape2) {
    shape1 = shape1.slice(-2);
    shape2 = shape2.slice(-2);
    if ($f6b55a2021b78f0d$exports.arraysEqual(shape1, shape2)) return true;
    if (!shape1.length || !shape2.length) return true;
    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) return true;
    if (shape1.length !== shape2.length) {
        const shape1Cols = shape1.slice(-1)[0];
        const shape2Cols = shape2.slice(-1)[0];
        if (shape1Cols === shape2Cols) return true;
        if ($7428f53c4d4be222$var$isEven(shape1Cols) && $7428f53c4d4be222$var$isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) return true;
    }
    return shape1[1] === shape2[1] && $7428f53c4d4be222$var$isEven(shape1[0]) && $7428f53c4d4be222$var$isEven(shape2[0]);
}
// We cache webgl params because the environment gets reset between
// unit tests and we don't want to constantly query the WebGLContext for
// MAX_TEXTURE_SIZE.
let $7428f53c4d4be222$var$MAX_TEXTURE_SIZE;
let $7428f53c4d4be222$var$MAX_TEXTURES_IN_SHADER;
function $7428f53c4d4be222$export$9dbf32263e41ec5(webGLVersion) {
    if ($7428f53c4d4be222$var$MAX_TEXTURE_SIZE == null) {
        const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
        $7428f53c4d4be222$var$MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }
    return $7428f53c4d4be222$var$MAX_TEXTURE_SIZE;
}
function $7428f53c4d4be222$export$3bb3363a1d77ce11() {
    $7428f53c4d4be222$var$MAX_TEXTURE_SIZE = null;
}
function $7428f53c4d4be222$export$295b7d11bb89e671() {
    $7428f53c4d4be222$var$MAX_TEXTURES_IN_SHADER = null;
}
function $7428f53c4d4be222$export$ce91baf6aebded89(webGLVersion) {
    if ($7428f53c4d4be222$var$MAX_TEXTURES_IN_SHADER == null) {
        const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
        $7428f53c4d4be222$var$MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    }
    // We cap at 16 to avoid spurious runtime "memory exhausted" error.
    return Math.min(16, $7428f53c4d4be222$var$MAX_TEXTURES_IN_SHADER);
}
function $7428f53c4d4be222$export$8a49d28f4bb7b8a0(webGLVersion) {
    if (webGLVersion === 0) return 0;
    let queryTimerVersion;
    const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
    if ($7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) queryTimerVersion = 2;
    else if ($7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'EXT_disjoint_timer_query')) queryTimerVersion = 1;
    else queryTimerVersion = 0;
    return queryTimerVersion;
}
function $7428f53c4d4be222$export$4f402f57c05c9ec3(gl, extensionName) {
    const ext = gl.getExtension(extensionName);
    return ext != null;
}
function $7428f53c4d4be222$export$9232c111e2230c00(webGLVersion) {
    try {
        const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
        if (gl != null) return true;
    } catch (e) {
        console.log('Error when getting WebGL context: ', e);
        return false;
    }
    return false;
}
function $7428f53c4d4be222$export$d571cb60e9b5ec74(webGLVersion) {
    if (webGLVersion === 0) return false;
    const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
    if (webGLVersion === 1) {
        if (!$7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'OES_texture_float')) return false;
    } else {
        if (!$7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'EXT_color_buffer_float')) return false;
    }
    const isFrameBufferComplete = $7428f53c4d4be222$var$createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
}
function $7428f53c4d4be222$export$9cd61c8662dbbc66(webGLVersion) {
    if (webGLVersion === 0) return false;
    const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
    if (webGLVersion === 1) {
        if (!$7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'OES_texture_float')) return false;
        if (!$7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'WEBGL_color_buffer_float')) return false;
    } else {
        if ($7428f53c4d4be222$export$4f402f57c05c9ec3(gl, 'EXT_color_buffer_float')) return $7428f53c4d4be222$var$createFloatTextureAndBindToFramebuffer(gl);
        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';
        if ($7428f53c4d4be222$export$4f402f57c05c9ec3(gl, COLOR_BUFFER_HALF_FLOAT)) {
            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
            return $7428f53c4d4be222$var$createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
        }
        return false;
    }
    const isFrameBufferComplete = $7428f53c4d4be222$var$createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
}
function $7428f53c4d4be222$var$createFloatTextureAndBindToFramebuffer(gl) {
    const texConfig = $7ea242d526563f56$export$129d92ae6e74c416(gl);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
}
function $7428f53c4d4be222$var$createHalfFloatTextureAndBindToFramebuffer(// tslint:disable-next-line:no-any
gl, textureHalfFloatExtension) {
    const texConfig = $7ea242d526563f56$export$129d92ae6e74c416(gl, textureHalfFloatExtension);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
}
function $7428f53c4d4be222$export$77efcdc20b17e5f2(webGLVersion) {
    if (webGLVersion !== 2) return false;
    const gl = $9ee1746afacd745d$export$c7a808a518b9a146(webGLVersion);
    // tslint:disable-next-line:no-any
    const isEnabled = gl.fenceSync != null;
    return isEnabled;
}
function $7428f53c4d4be222$export$1412c17b2531581a(tensor, opName) {
    if (!Array.isArray(tensor)) tensor = [
        tensor
    ];
    tensor.forEach((t)=>{
        if (t != null) $f6b55a2021b78f0d$exports.assert(t.dtype !== 'complex64', ()=>`${opName} does not support complex64 tensors ` + 'in the WebGL backend.'
        );
    });
}


function $beca3d55ef0e83d5$export$5ca2cb6073dd12df(gpgpu, program, inputs, output) {
    const inputInfos = inputs.map((input, i)=>{
        const shapeInfo = {
            logicalShape: input.shape,
            texShape: input.isUniform ? null : input.texData.texShape,
            isUniform: input.isUniform,
            isPacked: input.isUniform ? false : input.texData.isPacked,
            flatOffset: null
        };
        if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) shapeInfo.flatOffset = input.texData.slice.flatOffset;
        return {
            name: program.variableNames[i],
            shapeInfo: shapeInfo
        };
    });
    const inShapeInfos = inputInfos.map((x)=>x.shapeInfo
    );
    const outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.texData.texShape,
        isUniform: false,
        isPacked: output.texData.isPacked,
        flatOffset: null
    };
    const source = $fbbfeeecbf2420a1$export$37f33ba844563dd2(inputInfos, outShapeInfo, program);
    const fragmentShader = $7428f53c4d4be222$export$a8ab0e04b20572c0(gpgpu.gl, source);
    const webGLProgram = gpgpu.createProgram(fragmentShader);
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('ENGINE_COMPILE_ONLY')) return Object.assign({
        program: program,
        fragmentShader: fragmentShader,
        source: source,
        webGLProgram: webGLProgram,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    }, $beca3d55ef0e83d5$export$d421ceceafba9cc0(gpgpu, program, webGLProgram));
    else return {
        program: program,
        fragmentShader: fragmentShader,
        source: source,
        webGLProgram: webGLProgram,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo,
        uniformLocations: null,
        customUniformLocations: null,
        infLoc: null,
        nanLoc: null,
        inShapesLocations: null,
        inTexShapesLocations: null,
        outShapeLocation: null,
        outShapeStridesLocation: null,
        outTexShapeLocation: null
    };
}
function $beca3d55ef0e83d5$export$d421ceceafba9cc0(gpgpu, program, webGLProgram) {
    const uniformLocations = {};
    const inShapesLocations = {};
    const inTexShapesLocations = {};
    const customUniformLocations = [];
    let outShapeLocation;
    let outTexShapeLocation;
    let outShapeStridesLocation;
    let infLoc = null;
    let nanLoc = null;
    // Add special uniforms (NAN, INFINITY)
    nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 1) infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);
    // Add user-defined uniforms
    const shouldThrow = false;
    for(let i1 = 0; i1 < program.variableNames.length; i1++){
        const varName = program.variableNames[i1];
        uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
        uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
        if (program.enableShapeUniforms) {
            inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
            inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
        }
    }
    if (program.enableShapeUniforms) {
        outShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);
        outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);
        outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);
    }
    if (program.customUniforms) program.customUniforms.forEach((d, i)=>{
        customUniformLocations[i] = gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);
    });
    return {
        uniformLocations: uniformLocations,
        customUniformLocations: customUniformLocations,
        infLoc: infLoc,
        nanLoc: nanLoc,
        inShapesLocations: inShapesLocations,
        inTexShapesLocations: inTexShapesLocations,
        outShapeLocation: outShapeLocation,
        outShapeStridesLocation: outShapeStridesLocation,
        outTexShapeLocation: outTexShapeLocation
    };
}
function $beca3d55ef0e83d5$var$validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` + `was executed with ${inputs.length} inputs`);
    shapeInfos.forEach((s, i)=>{
        const shapeA = s.logicalShape;
        const input = inputs[i];
        const shapeB = input.shape;
        if (!$f6b55a2021b78f0d$exports.arraysEqual(shapeA, shapeB)) throw Error(`Binary was compiled with different shapes than ` + `the current args. Shapes ${shapeA} and ${shapeB} must match`);
        // The input is uploaded as uniform.
        if (s.isUniform && input.isUniform) return;
        const texShapeA = s.texShape;
        const texShapeB = input.isUniform ? null : input.texData.texShape;
        if (!$f6b55a2021b78f0d$exports.arraysEqual(texShapeA, texShapeB)) throw Error(`Binary was compiled with different texture shapes than the` + ` current args. Shape ${texShapeA} and ${texShapeB} must match`);
    });
}
function $beca3d55ef0e83d5$export$4e01d2c5eea12ae3(gpgpu, binary, inputs, output, customUniformValues) {
    if (!binary.program.enableShapeUniforms) {
        $beca3d55ef0e83d5$var$validateBinaryAndProgram(binary.inShapeInfos, inputs);
        $beca3d55ef0e83d5$var$validateBinaryAndProgram([
            binary.outShapeInfo
        ], [
            output
        ]);
    }
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    else gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    // Set special uniforms (NAN, INFINITY)
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 1) {
        if (binary.infLoc !== null) gpgpu.gl.uniform1f(binary.infLoc, Infinity);
    }
    if (binary.nanLoc !== null) gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    // Set user-defined inputs
    inputs.forEach((input, i)=>{
        const varName = binary.program.variableNames[i];
        const varLoc = binary.uniformLocations[varName];
        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
        const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];
        const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];
        if (varShapeLoc) {
            const { uniformShape: uniformShape  } = $fbbfeeecbf2420a1$export$19e35a0844e29cf9(binary.program.packedInputs, input.shape, input.texData.texShape);
            switch(uniformShape.length){
                case 1:
                    gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 2:
                    gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 3:
                    gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                case 4:
                    gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
                    break;
                default:
                    break;
            }
        }
        if (varTexShapeLoc) gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);
        if (varLoc == null) // The compiler inferred that this variable is not used in this shader.
        return;
        if (input.isUniform) {
            // Upload the values of the tensor as uniform.
            if ($f6b55a2021b78f0d$exports.sizeFromShape(input.shape) < 2) gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);
            else {
                let vals = input.uniformValues;
                if (!(vals instanceof Float32Array)) vals = new Float32Array(vals);
                gpgpu.gl.uniform1fv(varLoc, vals);
            }
            return;
        }
        // If the input was sliced, upload the flat offset index.
        if (input.texData.slice != null && varOffsetLoc != null) gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);
        gpgpu.setInputMatrixTexture(input.texData.texture.texture, varLoc, i);
    });
    const outShapeLoc = binary.outShapeLocation;
    if (outShapeLoc) switch(output.shape.length){
        case 1:
            gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
            break;
        case 2:
            gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
            break;
        case 3:
            gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
            break;
        case 4:
            gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
            break;
        default:
            break;
    }
    if (binary.outShapeStridesLocation) {
        const strides = $f6b55a2021b78f0d$exports.computeStrides(output.shape);
        switch(output.shape.length){
            case 2:
                gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            case 3:
                gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            case 4:
                gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
                break;
            default:
                break;
        }
    }
    if (binary.outTexShapeLocation) gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
    if (binary.program.customUniforms && customUniformValues) binary.program.customUniforms.forEach((d, i)=>{
        const customLoc = binary.customUniformLocations[i];
        const customValue = customUniformValues[i];
        if (d.type === 'float') gpgpu.gl.uniform1fv(customLoc, customValue);
        else if (d.type === 'vec2') gpgpu.gl.uniform2fv(customLoc, customValue);
        else if (d.type === 'vec3') gpgpu.gl.uniform3fv(customLoc, customValue);
        else if (d.type === 'vec4') gpgpu.gl.uniform4fv(customLoc, customValue);
        else if (d.type === 'int') gpgpu.gl.uniform1iv(customLoc, customValue);
        else if (d.type === 'ivec2') gpgpu.gl.uniform2iv(customLoc, customValue);
        else if (d.type === 'ivec3') gpgpu.gl.uniform3iv(customLoc, customValue);
        else if (d.type === 'ivec4') gpgpu.gl.uniform4iv(customLoc, customValue);
        else throw Error(`uniform type ${d.type} is not supported yet.`);
    });
    gpgpu.executeProgram();
}
function $beca3d55ef0e83d5$export$2a17a6d53fe6f5d9(program, inputs, output) {
    let keyInputs = '';
    inputs.concat(output).forEach((x)=>{
        const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
        // TODO: Remove the condition of !x.isUniform.
        if (program.enableShapeUniforms && !x.isUniform) {
            const xTexShape = x.texData.texShape;
            const { useSqueezeShape: useSqueezeShape , uniformShape: uniformShape , keptDims: keptDims  } = $fbbfeeecbf2420a1$export$19e35a0844e29cf9(program.packedInputs, x.shape, xTexShape);
            let rank1 = '', rank2 = '', rank34 = '';
            if (uniformShape.length === 1 && program.packedInputs) {
                const packedTexShape = [
                    Math.ceil(xTexShape[0] / 2),
                    Math.ceil(xTexShape[1] / 2)
                ];
                rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
            } else if (uniformShape.length === 2 && !program.packedInputs) rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
            else if (uniformShape.length > 2 && !program.packedInputs) {
                const strides = $f6b55a2021b78f0d$exports.computeStrides(uniformShape);
                rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
            }
            const xRank = x.shape.length;
            const isLogicalShapTexShapeEqual = uniformShape.length === 2 && $f6b55a2021b78f0d$exports.arraysEqual(x.shape, xTexShape);
            const isScalar = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape) === 1;
            const broadcastDims = $510a55f99d61727a$exports.getBroadcastDims(x.shape, output.shape);
            const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && $f6b55a2021b78f0d$exports.arraysEqual(xTexShape, output.texData.texShape);
            const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? '' : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
            // These key components are needed due to shader_compiler is embedding
            // them in the shader.
            // |xRank| is used to determine the coords length. See
            // get[Packed]SamplerAtOutputCoords.
            // |isInOutTexShapeEqual| is used to determine whether going to an
            // optimization path in getSamplerAtOutputCoords.
            // |useSqueezeShape| is extracted from squeezeInputInfo of
            // getSampler[2|3|4]D/getPackedSampler3D.
            // |isScalar| is extracted from isInputScalar/isOutputScalar in
            // getPackedSamplerAtOutputCoords.
            // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.
            // |isLogicalShapTexShapeEqual| is used in
            // getOutput[Packed]2DCoords/get[Packed]Sampler2D.
            // |rank1| is used in getOutputPacked1DCoords.
            // |rank2| is used in getOutput2DCoords.
            // |rank34| is used in getSampler3D/getSampler4D.
            // |isTexShapeGreaterThanOne| are used in
            // getSampler[Scalar|1D|2D]/getOutput1DCoords.
            keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ''}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
        } else {
            const texShape = x.isUniform ? 'uniform' : x.texData.texShape;
            keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
        }
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    // Fast string concat. See https://jsperf.com/string-concatenation/14.
    key += '_' + keyInputs + '_' + keyUserCode + `${$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION')}`;
    return key;
}
function $beca3d55ef0e83d5$export$5acc770fc06a0138(rank) {
    // TODO: Remove the limitaion of rank <= 4.
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;
}


const $217996ba39efcc29$export$39f0cca2b63399f6 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
const $217996ba39efcc29$export$1e6d79ff8c3b3c83 = 'return (a - b) * (a - b);';
class $217996ba39efcc29$export$9045e9161086790b {
    constructor(op, aShape, bShape){
        this.variableNames = [
            'A',
            'B'
        ];
        this.outputShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(aShape, bShape);
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        this.userCode = `
      float binaryOperation(float a, float b) {
        ${op}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
}




function $941a295bfee22e2b$export$a7c2113d79df2971(name, rank) {
    return [
        'x',
        'y',
        'z',
        'w',
        'u',
        'v'
    ].slice(0, rank).map((d)=>`${name}.${d}`
    );
}
function $941a295bfee22e2b$export$7a4d1d0d17b69972(name, rank) {
    if (rank === 1) return [
        name
    ];
    return $941a295bfee22e2b$export$a7c2113d79df2971(name, rank);
}
function $941a295bfee22e2b$export$8f96407d418c6727(rank, dims) {
    if (rank === 1) return 'rc';
    let coords = '';
    for(let i = 0; i < rank; i++){
        coords += dims[i];
        if (i < rank - 1) coords += ',';
    }
    return coords;
}



const $ae8429d0c17ef751$export$39f0cca2b63399f6 = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
const $ae8429d0c17ef751$export$54f9164222714c69 = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
const $ae8429d0c17ef751$export$fd75136f014548e = `
  return vec4(notEqual(a, b));
`;
class $ae8429d0c17ef751$export$7ef3bdc75c177be0 {
    constructor(op, aShape, bShape, checkOutOfBounds = false){
        this.variableNames = [
            'A',
            'B'
        ];
        this.supportsBroadcasting = true;
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(aShape, bShape);
        const rank = this.outputShape.length;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(rank);
        let checkOutOfBoundsString = '';
        if (checkOutOfBounds) {
            if (rank === 0 || $f6b55a2021b78f0d$exports.sizeFromShape(this.outputShape) === 1) checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
            else {
                const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
                checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
                if (rank === 1) {
                    if (this.enableShapeUniforms) checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
                    else checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
                } else {
                    const channels = $941a295bfee22e2b$export$7a4d1d0d17b69972('coords', rank);
                    if (this.enableShapeUniforms) checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
                    else checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
                }
            }
        }
        this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
    }
}




function $d25b33604ad0d249$export$f0954fd7d5368655(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    backend.incRef(x.dataId);
    return {
        dataId: x.dataId,
        shape: x.shape,
        dtype: x.dtype
    };
}
const $d25b33604ad0d249$export$c426d3942537ad84 = {
    kernelName: $2b76be1e72a8c1db$export$544bf02140fa9a77,
    backendName: 'webgl',
    kernelFunc: $d25b33604ad0d249$export$f0954fd7d5368655
};


function $1e4941852430620a$export$83a0e34f1302825b(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { real: real , imag: imag  } = inputs;
    const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');
    const $1e4941852430620a$export$83a0e34f1302825b = backend.texData.get(complexInfo.dataId);
    const realTensorInfo = $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: real
        },
        backend: backend
    });
    const imagTensorInfo = $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: imag
        },
        backend: backend
    });
    $1e4941852430620a$export$83a0e34f1302825b.complexTensorInfos = {
        real: realTensorInfo,
        imag: imagTensorInfo
    };
    return complexInfo;
}
const $1e4941852430620a$export$67917f7910d27fd8 = {
    kernelName: $2b76be1e72a8c1db$export$50ceb3fb9926e63e,
    backendName: 'webgl',
    kernelFunc: $1e4941852430620a$export$83a0e34f1302825b
};





const $719293cfecd0830c$export$92ed4431d8daa517 = `return (a < 0.) ? b * a : a;`;
const $719293cfecd0830c$export$e86410c26dcc9bb1 = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function $719293cfecd0830c$export$23a860e40a2c6b61(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { alpha: alpha  } = attrs;
    const $alpha = backend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(alpha, 'float32'));
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new $ae8429d0c17ef751$export$7ef3bdc75c177be0($719293cfecd0830c$export$e86410c26dcc9bb1, x.shape, $alpha.shape) : new $217996ba39efcc29$export$9045e9161086790b($719293cfecd0830c$export$92ed4431d8daa517, x.shape, $alpha.shape);
    const result = backend.runWebGLProgram(program, [
        x,
        $alpha
    ], 'float32');
    backend.disposeIntermediateTensorInfo($alpha);
    return result;
}
const $719293cfecd0830c$export$aa04ab963fdf437f = {
    kernelName: $2b76be1e72a8c1db$export$f0c7162bb7af1a2d,
    backendName: 'webgl',
    kernelFunc: $719293cfecd0830c$export$23a860e40a2c6b61
};





const $d5c8a89e81f67413$export$97f8593018a4b737 = `return (a < 0.) ? b * a : a;`;
const $d5c8a89e81f67413$export$4cc182bd80c9848a = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
function $d5c8a89e81f67413$export$5882f235222e6729(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x , alpha: alpha  } = inputs;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new $ae8429d0c17ef751$export$7ef3bdc75c177be0($d5c8a89e81f67413$export$4cc182bd80c9848a, x.shape, alpha.shape) : new $217996ba39efcc29$export$9045e9161086790b($d5c8a89e81f67413$export$97f8593018a4b737, x.shape, alpha.shape);
    return backend.runWebGLProgram(program, [
        x,
        alpha
    ], 'float32');
}
const $d5c8a89e81f67413$export$a5c4a9b694579636 = {
    kernelName: $2b76be1e72a8c1db$export$a42f35f308fc2fa3,
    backendName: 'webgl',
    kernelFunc: $d5c8a89e81f67413$export$5882f235222e6729
};



class $52fabdba6f2b73bf$export$f93811a5a466fd42 {
    constructor(aShape, opSnippet){
        this.variableNames = [
            'A'
        ];
        this.outputShape = aShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}
const $52fabdba6f2b73bf$export$39f0cca2b63399f6 = `if (isnan(x)) return x;`;
const $52fabdba6f2b73bf$export$8244104593af74a6 = `return x;`;
const $52fabdba6f2b73bf$export$3f020f6dcff67a1b = `return abs(x);`;
function $52fabdba6f2b73bf$export$8a2ed3f7f077984e(alpha = 0.0) {
    return $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
    return x > 0.0 ? 1.0 : float(${alpha});
  `;
}
const $52fabdba6f2b73bf$export$945a5ccf96adb3b2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
const $52fabdba6f2b73bf$export$27041fe53e1ee6da = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return (x < 0.0) ? 0.0 : x;
`;
const $52fabdba6f2b73bf$export$94bf29e9c85fc840 = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
const $52fabdba6f2b73bf$export$c07b68c109124fe2 = 'return x;';
const $52fabdba6f2b73bf$export$f95dbffd98d0457a = `return 1.0 / (1.0 + exp(-1.0 * x));`;




const $c5703c4a891fff88$export$8244104593af74a6 = `return x;`;
const $c5703c4a891fff88$export$945a5ccf96adb3b2 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
const $c5703c4a891fff88$export$27041fe53e1ee6da = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $c5703c4a891fff88$export$94bf29e9c85fc840 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $c5703c4a891fff88$export$f95dbffd98d0457a = `return 1.0 / (1.0 + exp(-1.0 * x));`;
class $c5703c4a891fff88$export$4d8daca4f85ed73d {
    constructor(aShape, opSnippet){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = aShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}



const $f569887d6243ad0e$export$bf39b1cb254b6187 = `if (isnan(x)) return x;`;
const $f569887d6243ad0e$export$b6a0646d16261569 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
const $f569887d6243ad0e$export$2bc6376b63d1db4 = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
function $f569887d6243ad0e$export$ba4daf5748026fba({ opSnippet: opSnippet , packedOpSnippet: packedOpSnippet , cpuKernelImpl: cpuKernelImpl , dtype: dtype  }) {
    return ({ inputs: inputs , backend: backend  })=>{
        const { x: x  } = inputs;
        const webglBackend = backend;
        const $dtype = dtype || x.dtype;
        if (webglBackend.shouldExecuteOnCPU([
            x
        ]) && cpuKernelImpl != null) {
            const xData = webglBackend.texData.get(x.dataId);
            const outValues = cpuKernelImpl(xData.values, $dtype);
            return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
        }
        const shouldUsePackedProgram = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_UNARY_OPERATIONS') && packedOpSnippet != null;
        let program;
        if (shouldUsePackedProgram) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(x.shape, packedOpSnippet);
        else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(x.shape, opSnippet);
        return webglBackend.runWebGLProgram(program, [
            x
        ], $dtype);
    };
}
function $f569887d6243ad0e$export$29353c66e70e3e16({ opSnippet: opSnippet , packedOpSnippet: packedOpSnippet , checkOutOfBounds: checkOutOfBounds = false , supportsComplex: supportsComplex = false , cpuKernelImpl: cpuKernelImpl , dtype: dtype  }) {
    return ({ inputs: inputs , backend: backend  })=>{
        const { a: a , b: b  } = inputs;
        const webglBackend = backend;
        if (supportsComplex && a.dtype === 'complex64') {
            const aData = webglBackend.texData.get(a.dataId);
            const bData = webglBackend.texData.get(b.dataId);
            const [real, imag] = [
                [
                    aData.complexTensorInfos.real,
                    bData.complexTensorInfos.real
                ],
                [
                    aData.complexTensorInfos.imag,
                    bData.complexTensorInfos.imag
                ]
            ].map((complexParts)=>{
                const [aPart, bPart] = complexParts;
                const aHandle = {
                    dataId: aPart.dataId,
                    dtype: aPart.dtype,
                    shape: a.shape
                };
                const bHandle = {
                    dataId: bPart.dataId,
                    dtype: bPart.dtype,
                    shape: b.shape
                };
                const program = new $217996ba39efcc29$export$9045e9161086790b(opSnippet, a.shape, b.shape);
                return webglBackend.runWebGLProgram(program, [
                    aHandle,
                    bHandle
                ], $993b52a5dd76e458$export$7bcca02d1a156bdf(aPart.dtype, bPart.dtype));
            });
            const complexOutput = $1e4941852430620a$export$83a0e34f1302825b({
                inputs: {
                    real: real,
                    imag: imag
                },
                backend: webglBackend
            });
            webglBackend.disposeIntermediateTensorInfo(real);
            webglBackend.disposeIntermediateTensorInfo(imag);
            // TODO(annxingyuan): Implement CPU forwarding for complex inputs.
            return complexOutput;
        }
        const $dtype = dtype || $993b52a5dd76e458$export$7bcca02d1a156bdf(a.dtype, b.dtype);
        if ((a.dtype === 'string' || b.dtype === 'string' || webglBackend.shouldExecuteOnCPU([
            a,
            b
        ])) && cpuKernelImpl != null) {
            const aVals = webglBackend.texData.get(a.dataId).values;
            const bVals = webglBackend.texData.get(b.dataId).values;
            const decodedAVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any
            $510a55f99d61727a$exports.fromUint8ToStringArray(aVals) : aVals;
            const decodedBVals = a.dtype === 'string' ? // tslint:disable-next-line: no-any
            $510a55f99d61727a$exports.fromUint8ToStringArray(bVals) : bVals;
            const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
            const out = webglBackend.makeTensorInfo(outShape, $dtype);
            const outData = webglBackend.texData.get(out.dataId);
            outData.values = outValues;
            return out;
        }
        const shouldUsePackedProgram = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_BINARY_OPERATIONS') && packedOpSnippet != null;
        let program1;
        if (shouldUsePackedProgram) program1 = new $ae8429d0c17ef751$export$7ef3bdc75c177be0(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
        else program1 = new $217996ba39efcc29$export$9045e9161086790b(opSnippet, a.shape, b.shape);
        return webglBackend.runWebGLProgram(program1, [
            a,
            b
        ], $dtype);
    };
}
function $f569887d6243ad0e$export$445d43a4039ec7b7(activation, packed = false) {
    if (activation === 'linear') {
        if (packed) return $c5703c4a891fff88$export$8244104593af74a6;
        return $52fabdba6f2b73bf$export$8244104593af74a6;
    } else if (activation === 'relu') {
        if (packed) return $c5703c4a891fff88$export$27041fe53e1ee6da;
        return $52fabdba6f2b73bf$export$27041fe53e1ee6da;
    } else if (activation === 'elu') {
        if (packed) return $c5703c4a891fff88$export$945a5ccf96adb3b2;
        return $52fabdba6f2b73bf$export$945a5ccf96adb3b2;
    } else if (activation === 'relu6') {
        if (packed) return $c5703c4a891fff88$export$94bf29e9c85fc840;
        return $52fabdba6f2b73bf$export$94bf29e9c85fc840;
    } else if (activation === 'prelu') {
        if (packed) return $d5c8a89e81f67413$export$4cc182bd80c9848a;
        return $d5c8a89e81f67413$export$97f8593018a4b737;
    } else if (activation === 'leakyrelu') {
        if (packed) return $719293cfecd0830c$export$e86410c26dcc9bb1;
        return $719293cfecd0830c$export$92ed4431d8daa517;
    } else if (activation === 'sigmoid') {
        if (packed) return $c5703c4a891fff88$export$f95dbffd98d0457a;
        return $52fabdba6f2b73bf$export$f95dbffd98d0457a;
    }
    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);
}



class $2422aad8b4ea59b8$export$21e5f112101779d8 {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false){
        this.variableNames = [
            'matrixA',
            'matrixB'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        const sharedDim = transposeA ? aShape[1] : aShape[2];
        const sharedDimensionPacked = Math.ceil(sharedDim / 2);
        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';
        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';
        const aSwizzle = transposeA ? [
            'a.xxyy',
            'a.zzww'
        ] : [
            'a.xxzz',
            'a.yyww'
        ];
        const bSwizzle = transposeB ? [
            'b.xzxz',
            'b.ywyw'
        ] : [
            'b.xyxy',
            'b.zwzw'
        ];
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            else if (hasLeakyreluActivation) activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            else activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) this.variableNames.push('bias');
        if (hasPreluActivation) this.variableNames.push('preluActivationWeights');
        if (hasLeakyreluActivation) this.variableNames.push('leakyreluAlpha');
        let batchASnippet = 'rc.x';
        let batchBSnippet = 'rc.x';
        if (aShape[0] < bShape[0]) batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
        else if (bShape[0] < aShape[0]) batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
        this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
    }
}




const $9f433a08ccad4b7a$export$51b2b2579375d8b0 = {
    REAL: 'return areal * breal - aimag * bimag;',
    IMAG: 'return areal * bimag + aimag * breal;'
};
class $9f433a08ccad4b7a$export$d4e4851a08b0c91 {
    constructor(op, aShape, bShape){
        this.variableNames = [
            'AReal',
            'AImag',
            'BReal',
            'BImag'
        ];
        this.outputShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
}






const { addImpl: $31b15458ffa33a6b$export$c7f405723b4a93e7 , bincountImpl: $31b15458ffa33a6b$export$566def819e5d4601 , bincountReduceImpl: $31b15458ffa33a6b$export$447b89266e53682e , ceilImpl: $31b15458ffa33a6b$export$bb3ce81256fe261b , concatImpl: $31b15458ffa33a6b$export$95e7342d25849d64 , equalImpl: $31b15458ffa33a6b$export$13d1298222b29d06 , expImpl: $31b15458ffa33a6b$export$f72e179c9610cb8c , expm1Impl: $31b15458ffa33a6b$export$5903785c29f035f5 , floorImpl: $31b15458ffa33a6b$export$195a28e6add8ab7e , gatherNdImpl: $31b15458ffa33a6b$export$e3196a12dce24214 , gatherV2Impl: $31b15458ffa33a6b$export$cffe0fde89e98de6 , greaterImpl: $31b15458ffa33a6b$export$eabb8927944259dd , greaterEqualImpl: $31b15458ffa33a6b$export$a3d2e203d979d298 , lessImpl: $31b15458ffa33a6b$export$74c893b3c5e74e60 , lessEqualImpl: $31b15458ffa33a6b$export$6d1533a3ea9565f , linSpaceImpl: $31b15458ffa33a6b$export$c86a2be8970d7a7d , logImpl: $31b15458ffa33a6b$export$e88dde64a338f813 , maxImpl: $31b15458ffa33a6b$export$a94164c9f637858e , maximumImpl: $31b15458ffa33a6b$export$b3afdc53a543e175 , minimumImpl: $31b15458ffa33a6b$export$1f01be3f637863fa , multiplyImpl: $31b15458ffa33a6b$export$598d1d66b05a298f , negImpl: $31b15458ffa33a6b$export$1cbcde7624effb15 , notEqualImpl: $31b15458ffa33a6b$export$b91372753635df24 , prodImpl: $31b15458ffa33a6b$export$2d654219115cec80 , rangeImpl: $31b15458ffa33a6b$export$fbee6deed7e76443 , rsqrtImpl: $31b15458ffa33a6b$export$431ccb02913a1aee , sigmoidImpl: $31b15458ffa33a6b$export$9b816377c2ca1f1f , simpleAbsImpl: $31b15458ffa33a6b$export$d7efa3585619eabe , sliceImpl: $31b15458ffa33a6b$export$45812d0d8578899 , sparseFillEmptyRowsImpl: $31b15458ffa33a6b$export$6cee5fb970d08428 , sparseReshapeImpl: $31b15458ffa33a6b$export$d17b3360054ff370 , sparseSegmentReductionImpl: $31b15458ffa33a6b$export$a503222c03b33888 , sqrtImpl: $31b15458ffa33a6b$export$548a22b20eeaf85b , stridedSliceImpl: $31b15458ffa33a6b$export$efd4e188e5de0188 , stringNGramsImpl: $31b15458ffa33a6b$export$bb9e83cb65884ef3 , stringSplitImpl: $31b15458ffa33a6b$export$bb4b4a9a1db97dea , stringToHashBucketFastImpl: $31b15458ffa33a6b$export$d7d8a9bba3df6e63 , subImpl: $31b15458ffa33a6b$export$be7474e96b733333 , tileImpl: $31b15458ffa33a6b$export$349e02a266ab3131 , topKImpl: $31b15458ffa33a6b$export$cc4aa6851cf96e2b , transposeImpl: $31b15458ffa33a6b$export$a0105d4a7143676c , uniqueImpl: $31b15458ffa33a6b$export$c417de669ad2e148 ,  } = $7f515e65fbaac962$exports;



const $5990c68e2ef3564e$var$MUL = 'return a * b;';
function $5990c68e2ef3564e$export$2060d2db72cce88f(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { a: a , b: b  } = inputs;
    const dtype = $510a55f99d61727a$exports.upcastType(a.dtype, b.dtype);
    if (a.dtype === 'complex64') {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const realProgram = new $9f433a08ccad4b7a$export$d4e4851a08b0c91($9f433a08ccad4b7a$export$51b2b2579375d8b0.REAL, a.shape, b.shape);
        const imagProgram = new $9f433a08ccad4b7a$export$d4e4851a08b0c91($9f433a08ccad4b7a$export$51b2b2579375d8b0.IMAG, a.shape, b.shape);
        const inputs = [
            {
                dataId: aData.complexTensorInfos.real.dataId,
                dtype: aData.complexTensorInfos.real.dtype,
                shape: a.shape
            },
            {
                dataId: aData.complexTensorInfos.imag.dataId,
                dtype: aData.complexTensorInfos.imag.dtype,
                shape: a.shape
            },
            {
                dataId: bData.complexTensorInfos.real.dataId,
                dtype: bData.complexTensorInfos.real.dtype,
                shape: b.shape
            },
            {
                dataId: bData.complexTensorInfos.imag.dataId,
                dtype: bData.complexTensorInfos.imag.dtype,
                shape: b.shape
            }
        ];
        const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');
        const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');
        const complexOutput = $1e4941852430620a$export$83a0e34f1302825b({
            inputs: {
                real: realPart,
                imag: imagPart
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(imagPart);
        // TODO(annxingyuan): CPU forwarding for complex inputs.
        return complexOutput;
    }
    if (backend.shouldExecuteOnCPU([
        a,
        b
    ])) {
        const aData = backend.texData.get(a.dataId);
        const bData = backend.texData.get(b.dataId);
        const [outValues, outShape] = $31b15458ffa33a6b$export$598d1d66b05a298f(a.shape, b.shape, aData.values, bData.values, dtype);
        const out = backend.makeTensorInfo(outShape, dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
    }
    let program;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_BINARY_OPERATIONS')) program = new $ae8429d0c17ef751$export$7ef3bdc75c177be0($5990c68e2ef3564e$var$MUL, a.shape, b.shape);
    else program = new $217996ba39efcc29$export$9045e9161086790b($5990c68e2ef3564e$var$MUL, a.shape, b.shape);
    return backend.runWebGLProgram(program, [
        a,
        b
    ], dtype);
}
const $5990c68e2ef3564e$export$745576778aafee88 = {
    kernelName: $2b76be1e72a8c1db$export$f14f83b3b531d498,
    backendName: 'webgl',
    kernelFunc: $5990c68e2ef3564e$export$2060d2db72cce88f
};





class $672fdb17e5392b3b$export$ce249f6fedcc44de {
    constructor(outputShape, inputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'inputShape',
                type: 'ivec3'
            }
        ];
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        let mainLoop = ``;
        for(let i = 0; i < 4; i++){
            let thisRC = `thisRC = rc;`;
            if (i % 2 === 1) thisRC += `thisRC.z += 1;`;
            if (i > 1) thisRC += `thisRC.y += 1;`;
            mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? '}' : ''}
      `;
        }
        this.userCode = `
      ${$672fdb17e5392b3b$var$getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? $ee41ed15b893490d$export$4ec1e3f6361de451() : $ee41ed15b893490d$export$4c68558c71205a01(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? 'outShape[1]' : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? 'outShape[2]' : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
    }
}
function $672fdb17e5392b3b$var$getReshapedInputCoords(shape, enableShapeUniforms) {
    const coordsFromIndexSnippet = enableShapeUniforms ? $ee41ed15b893490d$export$a1b266196cc2d8ea([
        'r',
        'c',
        'd'
    ], 'inputShape') : $ee41ed15b893490d$export$53c37f67510642ce([
        'r',
        'c',
        'd'
    ], shape);
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}



function $b1cc94ca76df2b20$export$2ae2c9dd4c61df98(input, afterShape, backend) {
    const input3DShape = [
        $7428f53c4d4be222$export$4dfd7bc0667970e0(input.shape),
        ...$7428f53c4d4be222$export$e8f6c350b57b8270(input.shape)
    ];
    const input3D = {
        dtype: input.dtype,
        shape: input3DShape,
        dataId: input.dataId
    };
    const afterShapeAs3D = [
        $7428f53c4d4be222$export$4dfd7bc0667970e0(afterShape),
        ...$7428f53c4d4be222$export$e8f6c350b57b8270(afterShape)
    ];
    const program = new $672fdb17e5392b3b$export$ce249f6fedcc44de(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const customValues = [
        input3DShape
    ];
    const output = backend.runWebGLProgram(program, [
        input3D
    ], input.dtype, customValues, preventEagerUnpackingOfOutput);
    return {
        dataId: output.dataId,
        shape: afterShape,
        dtype: output.dtype
    };
}



function $6bcbd3d102cf4841$export$9eaad88cf88cee2b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { shape: shape  } = attrs;
    const webglBackend = backend;
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const $shape = $f6b55a2021b78f0d$exports.inferFromImplicitShape(shape, xSize);
    const $xSize = $f6b55a2021b78f0d$exports.sizeFromShape($shape);
    $f6b55a2021b78f0d$exports.assert(xSize === $xSize, ()=>`The new shape (${$shape}) has ${$xSize} elements and the old ` + `shape (${x.shape}) has ${xSize} elements. The new shape and old ` + `shape must have the same number of elements.`
    );
    const xTexData = webglBackend.texData.get(x.dataId);
    if (xTexData.isPacked && !$7428f53c4d4be222$export$951b388203a0422d(x.shape, $shape) && !(xTexData.texture !== null && $7428f53c4d4be222$export$951b388203a0422d(xTexData.shape, $shape))) return $b1cc94ca76df2b20$export$2ae2c9dd4c61df98(x, $shape, webglBackend);
    webglBackend.incRef(x.dataId);
    return {
        dataId: x.dataId,
        shape: $shape,
        dtype: x.dtype
    };
}
const $6bcbd3d102cf4841$export$cfa02e698602aca2 = {
    kernelName: $2b76be1e72a8c1db$export$755ddd847e5abe03,
    backendName: 'webgl',
    kernelFunc: $6bcbd3d102cf4841$export$9eaad88cf88cee2b
};






class $ba03d722828e3bd3$export$a1460fd06abdca4 {
    constructor(reduceInfo, divisor){
        this.variableNames = [
            'x'
        ];
        const { windowSize: windowSize , batchSize: batchSize , inSize: inSize , outSize: outSize  } = reduceInfo;
        this.outputShape = [
            batchSize,
            outSize
        ];
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `sumValue += dot(values, ones);`;
        if (divisor != null) {
            const denominator = 1 / divisor;
            updateSnippet = `sumValue += dot(values * ${$f6b55a2021b78f0d$exports.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
        }
        let checkOutOfBounds = '';
        if (inSize % windowSize > 0) checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
        this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
    }
}


class $738674254eece202$export$14f07173aed228a5 {
    constructor(reduceInfo, reduceType){
        this.variableNames = [
            'x'
        ];
        const { windowSize: windowSize , batchSize: batchSize , inSize: inSize , outSize: outSize  } = reduceInfo;
        this.outputShape = [
            batchSize,
            outSize
        ];
        let initializationValue = '0.0';
        let compareOp = ``;
        if (reduceType === 'prod') initializationValue = '1.0';
        else if (reduceType === 'min') {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '1.0 / 1e-20';
            compareOp = `min`;
        } else if (reduceType === 'max') {
            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
            initializationValue = '-1.0 / 1e-20';
            compareOp = `max`;
        }
        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') returnValue = `sumValue`;
        else if (reduceType === 'prod') returnValue = `prodValue`;
        else if (reduceType === 'all') returnValue = `allValue`;
        else if (reduceType === 'any') returnValue = `anyValue`;
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        let updateSnippet = `
      if (${reduceType === 'sum'}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === 'prod'}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === 'min'} || ${reduceType === 'max'}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
        let vecType = `vec4`;
        if (reduceType === 'all') {
            initializationValue = '1.0';
            updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
            vecType = `bvec4`;
        } else if (reduceType === 'any') {
            initializationValue = '0.0';
            updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
            vecType = `bvec4`;
        }
        let checkOutOfBounds = '';
        if (inSize % windowSize > 0) checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
}


// Returns an array of configuration objects that describe each stage of the
// reduction.
function $cb671098a409c587$var$getReductionStages(inShape) {
    const stages = [];
    while(stages.length === 0 || stages[stages.length - 1].outSize !== 1){
        const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
        const windowSize = $510a55f99d61727a$exports.computeOptimalWindowSize(outSize);
        stages.push({
            inSize: outSize,
            windowSize: windowSize,
            outSize: Math.ceil(outSize / windowSize)
        });
    }
    return stages;
}
function $cb671098a409c587$export$533b26079ad0b4b(x, dtype, reductionType, backend) {
    const reductionStages = $cb671098a409c587$var$getReductionStages(x.shape);
    let result = x;
    for(let i = 0; i < reductionStages.length; i++){
        const { inSize: inSize , windowSize: windowSize , outSize: outSize  } = reductionStages[i];
        let program;
        let previousResult;
        if (reductionType === 'mean') program = i === 0 ? new $ba03d722828e3bd3$export$a1460fd06abdca4({
            windowSize: windowSize,
            inSize: inSize,
            batchSize: x.shape[0],
            outSize: outSize
        }, inSize) : new $ba03d722828e3bd3$export$a1460fd06abdca4({
            windowSize: windowSize,
            inSize: inSize,
            batchSize: x.shape[0],
            outSize: outSize
        });
        else program = new $738674254eece202$export$14f07173aed228a5({
            windowSize: windowSize,
            inSize: inSize,
            batchSize: x.shape[0],
            outSize: outSize
        }, reductionType);
        previousResult = result;
        result = backend.runWebGLProgram(program, [
            result
        ], dtype);
        if (previousResult.dataId !== x.dataId) backend.disposeIntermediateTensorInfo(previousResult);
    }
    return result;
}






class $4e3100c1c539d2ae$export$e48ac6bd7e0ddfac {
    constructor(aShape, newDim){
        this.variableNames = [
            'A'
        ];
        const outputShape = new Array(aShape.length);
        for(let i = 0; i < outputShape.length; i++)outputShape[i] = aShape[newDim[i]];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        const switched = $4e3100c1c539d2ae$var$getSwitchedCoords(newDim);
        this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
    }
}
function $4e3100c1c539d2ae$var$getSwitchedCoords(newDim) {
    const rank = newDim.length;
    if (rank > 6) throw Error(`Transpose for rank ${rank} is not yet supported`);
    const originalOrder = [
        'resRC.x',
        'resRC.y',
        'resRC.z',
        'resRC.w',
        'resRC.u',
        'resRC.v'
    ];
    const switchedCoords = new Array(rank);
    for(let i = 0; i < newDim.length; i++)switchedCoords[newDim[i]] = originalOrder[i];
    return switchedCoords.join();
}




class $46dd3f52531d9358$export$4daa0c968248fb58 {
    constructor(aShape, newDim){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        const outputShape = new Array(aShape.length);
        for(let i = 0; i < outputShape.length; i++)outputShape[i] = aShape[newDim[i]];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        if (this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        const outputOrder = $941a295bfee22e2b$export$a7c2113d79df2971('rc', this.rank);
        const switchedOrder = new Array(this.rank);
        for(let i1 = 0; i1 < newDim.length; i1++)switchedOrder[newDim[i1]] = outputOrder[i1];
        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
        this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
    }
}


function $e24962390fc7a278$export$986b9e65182e08d(x, perm, backend) {
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new $46dd3f52531d9358$export$4daa0c968248fb58(x.shape, perm) : new $4e3100c1c539d2ae$export$e48ac6bd7e0ddfac(x.shape, perm);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}


function $590d228f859517ac$export$c29f6d05a9b60dfa(x, axis, keepDims, backend) {
    const reductionIndices = axis;
    const xRank = x.shape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    const sumInputIsTransposed = permutedAxes != null;
    let sumInput = x;
    if (sumInputIsTransposed) {
        sumInput = $e24962390fc7a278$export$986b9e65182e08d(x, permutedAxes, backend);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('sum', axes, xRank);
    const [sumOutShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(sumInput.shape, axes);
    let outShape = sumOutShape;
    if (keepDims) // rather than reshape at the end, set the target shape here.
    outShape = $510a55f99d61727a$exports.expandShapeToKeepDim(sumOutShape, origAxes);
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: sumInput
        },
        attrs: {
            shape: [
                batchSize,
                inSize
            ]
        },
        backend: backend
    });
    const outType = $993b52a5dd76e458$export$3479b4fbed3c0d8d(x.dtype);
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(reshapedInput, outType, 'sum', backend);
    const out = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        attrs: {
            shape: outShape
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    if (sumInputIsTransposed) backend.disposeIntermediateTensorInfo(sumInput);
    return out;
}


function $da8ee0e3114a74ea$export$8a63f25cc62965f1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    return $590d228f859517ac$export$c29f6d05a9b60dfa(x, axis, keepDims, backend);
}
const $da8ee0e3114a74ea$export$47edea402251c258 = {
    kernelName: $2b76be1e72a8c1db$export$534760f50726d5,
    backendName: 'webgl',
    kernelFunc: $da8ee0e3114a74ea$export$8a63f25cc62965f1
};





function $fe12dc0e164e619f$export$9cb09a71b7d66923(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { perm: perm  } = attrs;
    const webglBackend = backend;
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for(let i = 0; i < newShape.length; i++)newShape[i] = x.shape[perm[i]];
    let out;
    if (webglBackend.shouldExecuteOnCPU([
        x
    ])) {
        const xTexData = webglBackend.texData.get(x.dataId);
        const values = xTexData.values;
        const outValues = $31b15458ffa33a6b$export$a0105d4a7143676c(values, x.shape, x.dtype, perm, newShape);
        out = webglBackend.makeTensorInfo(newShape, x.dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
    } else out = $e24962390fc7a278$export$986b9e65182e08d(x, perm, webglBackend);
    return out;
}
const $fe12dc0e164e619f$export$895a002a39b774be = {
    kernelName: $2b76be1e72a8c1db$export$7e714455f9a1f8f7,
    backendName: 'webgl',
    kernelFunc: $fe12dc0e164e619f$export$9cb09a71b7d66923
};


const $fd470a4c7883c0f2$export$42c1ddb439199e73 = 1000;
function $fd470a4c7883c0f2$export$d524d65e88e1168b({ a: a , b: b , transposeA: transposeA , transposeB: transposeB , backend: backend , bias: bias = null , preluActivationWeights: preluActivationWeights = null , leakyreluAlpha: leakyreluAlpha = 0 , activation: activation = null  }) {
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsA);
    const batchDimB = $f6b55a2021b78f0d$exports.sizeFromShape(outerDimsB);
    const outShapeOuterDims = $c374f26140f3eb6b$exports.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
    const outShape = outShapeOuterDims.concat([
        outerShapeA,
        outerShapeB
    ]);
    $f6b55a2021b78f0d$exports.assert(innerShapeA === innerShapeB, ()=>`Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`
    );
    const a3dShape = transposeA ? [
        batchDimA,
        innerShapeA,
        outerShapeA
    ] : [
        batchDimA,
        outerShapeA,
        innerShapeA
    ];
    const b3dShape = transposeB ? [
        batchDimB,
        outerShapeB,
        innerShapeB
    ] : [
        batchDimB,
        innerShapeB,
        outerShapeB
    ];
    // The rest of the implementation is designed to operate on rank-3 tensors
    const a3d = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: a
        },
        backend: backend,
        attrs: {
            shape: a3dShape
        }
    });
    const b3d = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: b
        },
        backend: backend,
        attrs: {
            shape: b3dShape
        }
    });
    const intermediates = [
        a3d,
        b3d
    ];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation != null ? $f569887d6243ad0e$export$445d43a4039ec7b7(activation, true) : null;
    const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
    let out;
    // Since the matrices are vectors, it is faster to call mul().sum()
    // because sum() is O(sqrt(N)) due to divide-and-conquer.
    if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > $fd470a4c7883c0f2$export$42c1ddb439199e73 && containsFusedOps === false) {
        let aVec = a3d;
        let bVec = b3d;
        if (transposeA) {
            aVec = $fe12dc0e164e619f$export$9cb09a71b7d66923({
                inputs: {
                    x: a3d
                },
                backend: backend,
                attrs: {
                    perm: [
                        0,
                        2,
                        1
                    ]
                }
            });
            intermediates.push(aVec);
        }
        if (transposeB) {
            bVec = $fe12dc0e164e619f$export$9cb09a71b7d66923({
                inputs: {
                    x: b3d
                },
                backend: backend,
                attrs: {
                    perm: [
                        0,
                        2,
                        1
                    ]
                }
            });
            intermediates.push(bVec);
        }
        const shouldReshapeA = outerShapeB !== 1;
        const shouldReshapeB = outerShapeB === 1;
        let aVec3d = aVec;
        if (shouldReshapeA) {
            aVec3d = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
                inputs: {
                    x: aVec
                },
                backend: backend,
                attrs: {
                    shape: [
                        batchDim,
                        sharedDim,
                        1
                    ]
                }
            });
            intermediates.push(aVec3d);
        }
        const axis = outerShapeB === 1 ? 2 : 1;
        let bVec3d = bVec;
        if (shouldReshapeB) {
            bVec3d = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
                inputs: {
                    x: bVec
                },
                backend: backend,
                attrs: {
                    shape: [
                        batchDim,
                        1,
                        sharedDim
                    ]
                }
            });
            intermediates.push(bVec3d);
        }
        const product = $5990c68e2ef3564e$export$2060d2db72cce88f({
            inputs: {
                a: aVec3d,
                b: bVec3d
            },
            backend: backend
        });
        out = $da8ee0e3114a74ea$export$8a63f25cc62965f1({
            inputs: {
                x: product
            },
            backend: backend,
            attrs: {
                axis: axis,
                keepDims: true
            }
        });
        intermediates.push(product);
    } else {
        const dtype = $993b52a5dd76e458$export$7bcca02d1a156bdf(a.dtype, b.dtype);
        const program = new $2422aad8b4ea59b8$export$21e5f112101779d8(a3dShape, b3dShape, [
            batchDim,
            outerShapeA,
            outerShapeB
        ], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [
            a3d,
            b3d
        ];
        if (bias != null) inputs.push(bias);
        if (hasPreluActivationWeights) inputs.push(preluActivationWeights);
        if (hasLeakyreluAlpha) {
            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(leakyreluAlpha, 'float32'));
            inputs.push($leakyreluAlpha);
            intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: out
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    intermediates.push(out);
    for (const i of intermediates)backend.disposeIntermediateTensorInfo(i);
    return outReshaped;
}


function $296c4f9c0bfe624e$export$d86ca0bbe0236889(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { transposeA: transposeA , transposeB: transposeB , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    return $fd470a4c7883c0f2$export$d524d65e88e1168b({
        a: a,
        b: b,
        transposeA: transposeA,
        transposeB: transposeB,
        backend: backend,
        bias: bias,
        preluActivationWeights: preluActivationWeights,
        leakyreluAlpha: leakyreluAlpha,
        activation: activation
    });
}
const $296c4f9c0bfe624e$export$f70d36da1c218f84 = {
    kernelName: $2b76be1e72a8c1db$export$8d1af0f7c2a4da9e,
    backendName: 'webgl',
    kernelFunc: $296c4f9c0bfe624e$export$d86ca0bbe0236889
};






const $9c167b03090a04e5$var$ABS = `return abs(x);`;
function $9c167b03090a04e5$export$2335f513bbd82c6d(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    // TODO: handle cases when x is complex. Once the cpu implementation
    // can handle complex values, refactor to use unaryKernelFunc.
    if (backend.shouldExecuteOnCPU([
        x
    ]) && x.dtype !== 'complex64') {
        const xData = backend.texData.get(x.dataId);
        const outValues = $31b15458ffa33a6b$export$d7efa3585619eabe(xData.values);
        return backend.makeTensorInfo(x.shape, x.dtype, outValues);
    }
    let program;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_UNARY_OPERATIONS')) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(x.shape, $9c167b03090a04e5$var$ABS);
    else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(x.shape, $9c167b03090a04e5$var$ABS);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}
const $9c167b03090a04e5$export$d66f48648b9d5ec7 = {
    kernelName: $2b76be1e72a8c1db$export$b73c596ee8758a66,
    backendName: 'webgl',
    kernelFunc: $9c167b03090a04e5$export$2335f513bbd82c6d
};





const $f5fcf2cd62bb030e$var$ACOS = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
const $f5fcf2cd62bb030e$export$fd6306be3fde5b04 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $f5fcf2cd62bb030e$var$ACOS
});
const $f5fcf2cd62bb030e$export$255826ca70737275 = {
    kernelName: $2b76be1e72a8c1db$export$3b952c9980dac550,
    backendName: 'webgl',
    kernelFunc: $f5fcf2cd62bb030e$export$fd6306be3fde5b04
};





const $fe7109fdd1b2e239$var$ACOSH = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
const $fe7109fdd1b2e239$export$b26caf0f29211d08 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $fe7109fdd1b2e239$var$ACOSH
});
const $fe7109fdd1b2e239$export$3f520b71a56c9e70 = {
    kernelName: $2b76be1e72a8c1db$export$987da490b7c2e7dd,
    backendName: 'webgl',
    kernelFunc: $fe7109fdd1b2e239$export$b26caf0f29211d08
};





const $01583232811deb0b$var$ADD = 'return a + b;';
const $01583232811deb0b$export$d50bf7e4980f70a9 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $01583232811deb0b$var$ADD,
    packedOpSnippet: $01583232811deb0b$var$ADD,
    supportsComplex: true,
    cpuKernelImpl: $31b15458ffa33a6b$export$c7f405723b4a93e7
});
const $01583232811deb0b$export$b1f3a580afb68e4c = {
    kernelName: $2b76be1e72a8c1db$export$d0265b2c425512d6,
    backendName: 'webgl',
    kernelFunc: $01583232811deb0b$export$d50bf7e4980f70a9
};



class $328da3347e1ffcfb$export$9d269fc8eb4783d5 {
    constructor(outputShape, shapes){
        this.outputShape = [];
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i)=>`T${i}`
        );
        const snippets = [];
        // Get target elements from every input tensor.
        this.variableNames.forEach((variable)=>{
            snippets.push(`float v${variable} = get${variable}AtOutCoords();`);
        });
        // Calculate the sum of all elements.
        const operation = this.variableNames.map((variable)=>{
            return `v${variable}`;
        }).join(' + ');
        this.userCode = `
      void main() {
        ${snippets.join('\n        ')}

        float result = ${operation};
        setOutput(result);
      }
    `;
    }
}


class $4d70538d39b94934$export$156b01c0aab97d90 {
    constructor(outputShape, shapes){
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = outputShape;
        this.variableNames = shapes.map((_, i)=>`T${i}`
        );
        const snippets = [];
        // Get target elements from every input tensor.
        this.variableNames.forEach((variable)=>{
            snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);
        });
        // Calculate the sum of all elements.
        const operation = this.variableNames.map((variable)=>{
            return `v${variable}`;
        }).join(' + ');
        this.userCode = `
      void main() {
        ${snippets.join('\n        ')}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
    }
}



function $a9ba51f7d668b6eb$export$37b75d0026f96b8d(args) {
    const { inputs: inputs , backend: backend  } = args;
    const tensors = inputs;
    if (tensors.length === 1) return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: tensors[0]
        },
        backend: backend
    });
    // Limit the number of uploaded textures for optimization.
    if (tensors.length > $78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_MAX_TEXTURES_IN_SHADER')) {
        const midIndex = Math.floor(tensors.length / 2);
        const leftSide = $a9ba51f7d668b6eb$export$37b75d0026f96b8d({
            inputs: tensors.slice(0, midIndex),
            backend: backend
        });
        const rightSide = $a9ba51f7d668b6eb$export$37b75d0026f96b8d({
            inputs: tensors.slice(midIndex),
            backend: backend
        });
        return $a9ba51f7d668b6eb$export$37b75d0026f96b8d({
            inputs: [
                leftSide,
                rightSide
            ],
            backend: backend
        });
    }
    const dtype = tensors.map((t)=>t.dtype
    ).reduce((d1, d2)=>$993b52a5dd76e458$export$7bcca02d1a156bdf(d1, d2)
    );
    const shapes = tensors.map((t)=>t.shape
    );
    // We can make sure shapes are identical in op level.
    const usePackedOp = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK');
    const program = usePackedOp ? new $4d70538d39b94934$export$156b01c0aab97d90(tensors[0].shape, shapes) : new $328da3347e1ffcfb$export$9d269fc8eb4783d5(tensors[0].shape, shapes);
    return backend.runWebGLProgram(program, tensors, dtype);
}
const $a9ba51f7d668b6eb$export$ff8000bc6f0313e1 = {
    kernelName: $2b76be1e72a8c1db$export$eef235ad06d3226a,
    backendName: 'webgl',
    kernelFunc: $a9ba51f7d668b6eb$export$37b75d0026f96b8d
};






function $fe234f6b5f4e1039$export$84bf76cd7afc7469(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const xRank = x.shape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('all', axes, xRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: permutedX
        },
        backend: backend,
        attrs: {
            shape: [
                -1,
                inSize
            ]
        }
    });
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(a2D, a2D.dtype, 'all', backend);
    let res;
    if (keepDims) {
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: reduced
            },
            backend: backend,
            attrs: {
                shape: newShape
            }
        });
    } else res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo(permutedX);
    return res;
}
const $fe234f6b5f4e1039$export$4e3f081eb1a330fa = {
    kernelName: $2b76be1e72a8c1db$export$5dceb1ab650a1776,
    backendName: 'webgl',
    kernelFunc: $fe234f6b5f4e1039$export$84bf76cd7afc7469
};






function $72f756a354227c31$export$4154a199d7d90455(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const xRank = x.shape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('any', axes, xRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: permutedX
        },
        backend: backend,
        attrs: {
            shape: [
                -1,
                inSize
            ]
        }
    });
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(a2D, a2D.dtype, 'any', backend);
    let res;
    if (keepDims) {
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: reduced
            },
            backend: backend,
            attrs: {
                shape: newShape
            }
        });
    } else res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo(permutedX);
    return res;
}
const $72f756a354227c31$export$1a8ff634f2df3da6 = {
    kernelName: $2b76be1e72a8c1db$export$b24b633b1364b94b,
    backendName: 'webgl',
    kernelFunc: $72f756a354227c31$export$4154a199d7d90455
};




class $7c60485ccd515a71$export$7fa5759722b57eba {
    constructor(reduceInfo, op, firstPass){
        this.variableNames = [
            'A'
        ];
        const { windowSize: windowSize , batchSize: batchSize , outSize: outSize  } = reduceInfo;
        if (!firstPass) this.variableNames.push('bestIndicesA');
        this.outputShape = [
            batchSize,
            outSize
        ];
        const compOp = op === 'max' ? '>' : '<';
        const indexSnippet = firstPass ? 'inOffset + i;' : 'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
}





class $289d8e04c4ebafe7$export$6b02cde2348cc418 {
    constructor(shape, windowSize, op, firstPass){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        $f6b55a2021b78f0d$exports.assert(shape.length > 2, ()=>`Packed arg${op.charAt(0).toUpperCase() + op.slice(1)} supports only inputs with rank above 2.`
        );
        const inSize = shape[shape.length - 1];
        const outSize = Math.ceil(inSize / windowSize);
        this.outputShape = shape.slice(0, -1);
        if (outSize > 1) this.outputShape.push(outSize);
        if (!firstPass) this.variableNames.push('bestIndicesA');
        const outShape = this.outputShape;
        const rank = outShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const coords = $941a295bfee22e2b$export$7a4d1d0d17b69972('coords', rank);
        let sourceLocSetup;
        let sourceRank;
        if (outSize === 1) {
            sourceRank = rank + 1;
            const sourceLocDType = $fbbfeeecbf2420a1$export$859efd105c10c755(sourceRank);
            sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 2]};`;
        } else {
            sourceRank = rank;
            sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords[rank - 2]};`;
        }
        const channels = [
            'x',
            'y',
            'z',
            'w',
            'u',
            'v'
        ].slice(0, sourceRank);
        const inChannel = '.' + channels[sourceRank - 1]; // e.g. ".b" for rank 3.
        const intChannels = channels.map((x)=>'int ' + x
        );
        const srcRCoords = $941a295bfee22e2b$export$7a4d1d0d17b69972('sourceLocR', sourceRank - 1).concat('inIdx.r');
        const srcGCoords = $941a295bfee22e2b$export$7a4d1d0d17b69972('sourceLocG', sourceRank - 1).concat('inIdx.g');
        const srcBCoords = $941a295bfee22e2b$export$7a4d1d0d17b69972('sourceLocB', sourceRank - 1).concat('inIdx.b');
        const srcACoords = $941a295bfee22e2b$export$7a4d1d0d17b69972('sourceLocA', sourceRank - 1).concat('inIdx.a');
        const compOp = op === 'max' ? 'greaterThan' : 'lessThan';
        const fetchCandidateIdx = firstPass ? '' : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
        const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
        const getBestIndicesAChannelSnippet = firstPass ? '' : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
        this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
}



function $73bcebe4e7d53da2$var$argReduce(backend, x, reduceType, bestIndicesA = null) {
    let batchSize = x.shape[0];
    let inSize = x.shape[1];
    if (bestIndicesA != null) {
        batchSize = bestIndicesA.shape[0];
        inSize = bestIndicesA.shape[1];
    }
    const windowSize = $510a55f99d61727a$exports.computeOptimalWindowSize(inSize);
    const reduceInfo = {
        windowSize: windowSize,
        inSize: inSize,
        batchSize: batchSize,
        outSize: Math.ceil(inSize / windowSize)
    };
    const program = new $7c60485ccd515a71$export$7fa5759722b57eba(reduceInfo, reduceType, bestIndicesA == null);
    const inputs = [
        x
    ];
    if (bestIndicesA != null) inputs.push(bestIndicesA);
    const output = backend.runWebGLProgram(program, inputs, 'int32');
    // No need to run another GPGPU program.
    if (output.shape[1] === 1) return output;
    const result = $73bcebe4e7d53da2$var$argReduce(backend, x, reduceType, output);
    backend.disposeIntermediateTensorInfo(output);
    return result;
}
function $73bcebe4e7d53da2$var$argReducePacked(backend, x, reduceType, bestIndicesA = null) {
    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
    const inSize = inShape[inShape.length - 1];
    const windowSize = $510a55f99d61727a$exports.computeOptimalWindowSize(inSize);
    const program = new $289d8e04c4ebafe7$export$6b02cde2348cc418(inShape, windowSize, reduceType, bestIndicesA == null);
    const inputs = bestIndicesA == null ? [
        x
    ] : [
        x,
        bestIndicesA
    ];
    const output = backend.runWebGLProgram(program, inputs, 'int32');
    if (output.shape.length === x.shape.length) {
        const result = $73bcebe4e7d53da2$var$argReducePacked(backend, x, reduceType, output);
        backend.disposeIntermediateTensorInfo(output);
        return result;
    }
    return output;
}
function $73bcebe4e7d53da2$export$63dee7a356b9210b(backend, x, axis, reduceType) {
    const axes = [
        axis
    ];
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
    if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_REDUCE') || x.shape.length <= 2) {
        const intermediateTensorInfos = [];
        // Eagerly unpack x input since it is passed in to all the shaders which
        // require unpacked inputs.
        const xtexData = backend.texData.get(x.dataId);
        const xIsPacked = xtexData !== null && xtexData.isPacked;
        let xUnPacked = x;
        if (xIsPacked) {
            xUnPacked = backend.unpackTensor(x);
            intermediateTensorInfos.push(xUnPacked);
        }
        const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(xUnPacked.shape, axes);
        const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
        const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: xUnPacked
            },
            backend: backend,
            attrs: {
                shape: [
                    -1,
                    inSize
                ]
            }
        });
        intermediateTensorInfos.push(a2D);
        const reduced = $73bcebe4e7d53da2$var$argReduce(backend, a2D, reduceType);
        intermediateTensorInfos.push(reduced);
        const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: reduced
            },
            backend: backend,
            attrs: {
                shape: outShape
            }
        });
        intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
        );
        return reshaped;
    }
    return $73bcebe4e7d53da2$var$argReducePacked(backend, x, reduceType);
}



function $c8fafbe0797fc3bd$export$7980a683c1b852b4(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis  } = attrs;
    let axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        intermediateTensorInfos.push($x);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('argMax', [
        axes[0]
    ], $x.shape.length);
    const out = $73bcebe4e7d53da2$export$63dee7a356b9210b(backend, $x, axes[0], 'max');
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return out;
}
const $c8fafbe0797fc3bd$export$ec7419fc9ad0069e = {
    kernelName: $2b76be1e72a8c1db$export$17612294a1503e1c,
    backendName: 'webgl',
    kernelFunc: $c8fafbe0797fc3bd$export$7980a683c1b852b4
};





function $334a90ed8d2393f0$export$ec99a91cddfb29a2(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis  } = attrs;
    let axes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
        $x = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        intermediateTensorInfos.push($x);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('argMin', [
        axes[0]
    ], $x.shape.length);
    const out = $73bcebe4e7d53da2$export$63dee7a356b9210b(backend, $x, axes[0], 'min');
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return out;
}
const $334a90ed8d2393f0$export$21836a5e5fa09eb4 = {
    kernelName: $2b76be1e72a8c1db$export$baabd09270cbbd94,
    backendName: 'webgl',
    kernelFunc: $334a90ed8d2393f0$export$ec99a91cddfb29a2
};





const $fad0cd8fd4877c29$var$ASIN = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
const $fad0cd8fd4877c29$export$41726bdb1fc63f = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $fad0cd8fd4877c29$var$ASIN
});
const $fad0cd8fd4877c29$export$de5cb0ef95dd6700 = {
    kernelName: $2b76be1e72a8c1db$export$664c8ca7e7e5c126,
    backendName: 'webgl',
    kernelFunc: $fad0cd8fd4877c29$export$41726bdb1fc63f
};





const $b45af35a7034ee4b$var$ASINH = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `return log(x + sqrt(x * x + 1.0));`;
const $b45af35a7034ee4b$export$839d8a01b6af4fc0 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $b45af35a7034ee4b$var$ASINH
});
const $b45af35a7034ee4b$export$20d424616c76166 = {
    kernelName: $2b76be1e72a8c1db$export$847c88940cb7dcb5,
    backendName: 'webgl',
    kernelFunc: $b45af35a7034ee4b$export$839d8a01b6af4fc0
};





const $d33763e81cd7530f$var$ATAN = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return atan(x);
`;
const $d33763e81cd7530f$export$628dc4eed22b0fbd = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $d33763e81cd7530f$var$ATAN
});
const $d33763e81cd7530f$export$159d632e3ff13624 = {
    kernelName: $2b76be1e72a8c1db$export$bac667d46ac043ae,
    backendName: 'webgl',
    kernelFunc: $d33763e81cd7530f$export$628dc4eed22b0fbd
};




const $916236386106e37e$var$ATAN2 = $f569887d6243ad0e$export$b6a0646d16261569 + `
  return atan(a, b);
`;
const $916236386106e37e$var$ATAN2_PACKED = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + $f569887d6243ad0e$export$2bc6376b63d1db4 + `
  return result;
`;
const $916236386106e37e$export$b8b770ee6a0d9760 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $916236386106e37e$var$ATAN2,
    packedOpSnippet: $916236386106e37e$var$ATAN2_PACKED
});
const $916236386106e37e$export$c53c7ab019edb8a0 = {
    kernelName: $2b76be1e72a8c1db$export$3bf4c619ce589f4b,
    backendName: 'webgl',
    kernelFunc: $916236386106e37e$export$b8b770ee6a0d9760
};





const $338268dd8a086033$var$ATANH = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
const $338268dd8a086033$export$21ea955025ceb08b = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $338268dd8a086033$var$ATANH
});
const $338268dd8a086033$export$e9ce1ba75fc9b746 = {
    kernelName: $2b76be1e72a8c1db$export$98981a86fa2b1366,
    backendName: 'webgl',
    kernelFunc: $338268dd8a086033$export$21ea955025ceb08b
};



class $82f93a60bd9656d8$export$ddaa65439647a5ac {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false){
        this.variableNames = [
            'x'
        ];
        if (poolType === 'avg' && computePositions) throw new Error('Cannot compute positions for average pool.');
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === 'avg';
        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
        let initializationValue = '0.0';
        if (!isAvgPool) // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
        initializationValue = '-1.0 / 1e-20';
        if (computePositions) {
            const compareOp = '>=';
            this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
            return;
        }
        const compareOp = 'max';
        let returnValue = `${poolType}(${poolType}(${poolType}(` + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') returnValue = `avgValue / count`;
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
}
class $82f93a60bd9656d8$export$a835a97097fdbb0f {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false){
        this.variableNames = [
            'x'
        ];
        if (poolType === 'avg' && computePositions) throw new Error('Cannot compute positions for average pool.');
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        const isAvgPool = poolType === 'avg';
        let initializationValue = '0.0';
        if (!isAvgPool) // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.
        initializationValue = '-1.0 / 1e-20';
        if (computePositions) {
            const compareOp = '>=';
            this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
            return;
        }
        const compareOp = 'max';
        let returnValue = `${poolType}(${poolType}(${poolType}(` + 'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') returnValue = `avgValue / count`;
        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        const filterWidthVec4Remainder = filterWidth % 4;
        const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `;
    }
}




function $b5758d4576e7c495$export$d5c65a2abd3d97dc(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    $7428f53c4d4be222$export$1412c17b2531581a(x, 'avgPool');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = 1;
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, dilations), ()=>'Error in avgPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && $f6b55a2021b78f0d$exports.arraysEqual(convInfo.inShape, convInfo.outShape)) return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const avgPoolProgram = new $82f93a60bd9656d8$export$ddaa65439647a5ac(convInfo, 'avg', false);
    return backend.runWebGLProgram(avgPoolProgram, [
        x
    ], 'float32');
}
const $b5758d4576e7c495$export$6c901824a23e6150 = {
    kernelName: $2b76be1e72a8c1db$export$37f2cc7be1add88c,
    backendName: 'webgl',
    kernelFunc: $b5758d4576e7c495$export$d5c65a2abd3d97dc
};




function $b85df75914a86171$export$8e92f7d23b27f144(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode , dataFormat: dataFormat  } = attrs;
    const dilations = [
        1,
        1,
        1
    ];
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
    const avgPoolProgram = new $82f93a60bd9656d8$export$a835a97097fdbb0f(convInfo, 'avg', false);
    return backend.runWebGLProgram(avgPoolProgram, [
        x
    ], 'float32');
}
const $b85df75914a86171$export$5a9c81d240244392 = {
    kernelName: $2b76be1e72a8c1db$export$390ecb697af103f6,
    backendName: 'webgl',
    kernelFunc: $b85df75914a86171$export$8e92f7d23b27f144
};



class $785c494a30475655$export$5dc4ec478e6759de {
    constructor(convInfo){
        this.variableNames = [
            'dy'
        ];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $785c494a30475655$export$f166702869bc274f {
    constructor(convInfo){
        this.variableNames = [
            'dy'
        ];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}


function $43e4241a68b604ef$export$798cb4034e996ff4(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const x = input;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = [
        1,
        1,
        1
    ];
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    const avgPoolBackpropProgram = new $785c494a30475655$export$f166702869bc274f(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [
        dy
    ], x.dtype);
}
const $43e4241a68b604ef$export$1eeb8780807d0508 = {
    kernelName: $2b76be1e72a8c1db$export$7163112adf28c062,
    backendName: 'webgl',
    kernelFunc: $43e4241a68b604ef$export$798cb4034e996ff4
};





function $b7ac760d8b319767$export$2f098171d1c79aea(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const x = input;
    $7428f53c4d4be222$export$1412c17b2531581a([
        dy,
        input
    ], 'avgPoolGrad');
    const { filterSize: filterSize , strides: strides , pad: pad  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad);
    const avgPoolBackpropProgram = new $785c494a30475655$export$5dc4ec478e6759de(convInfo);
    return backend.runWebGLProgram(avgPoolBackpropProgram, [
        dy
    ], x.dtype);
}
const $b7ac760d8b319767$export$ac3f8709351ab225 = {
    kernelName: $2b76be1e72a8c1db$export$9873fd6046cd6951,
    backendName: 'webgl',
    kernelFunc: $b7ac760d8b319767$export$2f098171d1c79aea
};




function $83f662a9779214e2$export$8f97894b482227f0(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { a: a , b: b  } = inputs;
    const { transposeA: transposeA , transposeB: transposeB  } = attrs;
    return $fd470a4c7883c0f2$export$d524d65e88e1168b({
        a: a,
        b: b,
        transposeA: transposeA,
        transposeB: transposeB,
        backend: backend
    });
}
const $83f662a9779214e2$export$d0dd993198185538 = {
    kernelName: $2b76be1e72a8c1db$export$9a3bf60b23f63c8,
    backendName: 'webgl',
    kernelFunc: $83f662a9779214e2$export$8f97894b482227f0
};




class $0740800ec558b7c9$export$bd15a4172044baef {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon){
        this.outputShape = [];
        this.variableNames = [
            'x',
            'mean',
            'variance'
        ];
        $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, meanShape);
        $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = '0.0';
        if (offsetShape != null) {
            $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        let scaleSnippet = '1.0';
        if (scaleShape != null) {
            $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
}



class $7526c7affa169404$export$cfdd4076f282cff6 {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon){
        this.packedInputs = true;
        this.packedOutput = true;
        this.variableNames = [
            'x',
            'mean',
            'variance'
        ];
        $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, meanShape);
        $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, varianceShape);
        let offsetSnippet = 'vec4(0.0)';
        if (offsetShape != null) {
            $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        let scaleSnippet = 'vec4(1.0)';
        if (scaleShape != null) {
            $510a55f99d61727a$exports.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
}


const $115071e6729f0ebb$export$8ea8088e6d0cdd02 = ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
    const { x: x , mean: mean , variance: variance , offset: offset , scale: scale  } = inputs;
    $f6b55a2021b78f0d$exports.assert(mean.shape.length === variance.shape.length, ()=>"Batch normalization gradient requires mean and variance to have equal ranks."
    );
    $f6b55a2021b78f0d$exports.assert(offset == null || mean.shape.length === offset.shape.length, ()=>"Batch normalization gradient requires mean and offset to have equal ranks."
    );
    $f6b55a2021b78f0d$exports.assert(scale == null || mean.shape.length === scale.shape.length, ()=>"Batch normalization gradient requires mean and scale to have equal ranks."
    );
    let { varianceEpsilon: varianceEpsilon  } = attrs;
    if (varianceEpsilon == null) varianceEpsilon = 0.001;
    const finalInputs = [
        x,
        mean,
        variance
    ];
    let offsetShape = null;
    if (offset != null) {
        offsetShape = offset.shape;
        finalInputs.push(offset);
    }
    let scaleShape = null;
    if (scale != null) {
        scaleShape = scale.shape;
        finalInputs.push(scale);
    }
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_NORMALIZATION') ? new $7526c7affa169404$export$cfdd4076f282cff6(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new $0740800ec558b7c9$export$bd15a4172044baef(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
    const output = backend.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
    return output;
};
const $115071e6729f0ebb$export$df2dc5c7a755e418 = {
    kernelName: $2b76be1e72a8c1db$export$3821a0416660aaa2,
    backendName: 'webgl',
    kernelFunc: $115071e6729f0ebb$export$8ea8088e6d0cdd02
};







class $c53926968f2d1d1e$export$ef8bf52bc4951c85 {
    constructor(destSize){
        this.variableNames = [
            'source'
        ];
        this.outputShape = destSize;
        this.rank = destSize.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        this.customUniforms = [
            {
                name: 'start',
                arrayIndex: this.rank,
                type: 'int'
            }
        ];
        const sourceCoords = $c53926968f2d1d1e$var$getCoords(this.rank);
        let body;
        const coordSum = destSize.map((_, i)=>{
            return `sourceLoc.${$c53926968f2d1d1e$var$coords[i]} = start[${i}] + coords.${$c53926968f2d1d1e$var$coords[i]};`;
        });
        body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join('\n')}
      `;
        this.userCode = `
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
    }
}
const $c53926968f2d1d1e$var$coords = [
    'x',
    'y',
    'z',
    'w',
    'u',
    'v'
];
function $c53926968f2d1d1e$var$getCoords(rank) {
    if (rank === 1) return 'sourceLoc';
    else if (rank <= 6) return $c53926968f2d1d1e$var$coords.slice(0, rank).map((x)=>'sourceLoc.' + x
    ).join(',');
    else throw Error(`Slicing for rank ${rank} is not yet supported`);
}




class $9489385f0f465ad1$export$a6c6101de259f77 {
    constructor(destSize){
        this.variableNames = [
            'source'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = destSize;
        this.rank = destSize.length;
        this.customUniforms = [
            {
                name: 'start',
                arrayIndex: this.rank,
                type: 'int'
            }
        ];
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        const coords = $941a295bfee22e2b$export$7a4d1d0d17b69972('coords', this.rank);
        const sourceLoc = $941a295bfee22e2b$export$7a4d1d0d17b69972('sourceLoc', this.rank);
        const innerDims = this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;
        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
        const upperRow = `
      result.x = ${getChannel};
      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
        const lowerRow = this.rank === 1 ? '' : `
      --${coords[this.rank - 1]};
      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
        const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_, i)=>`start[${i}]`
        ).join()});` : destSize.map((_, i)=>`${sourceLoc[i]} = ${coords[i]} + start[${i}];`
        ).join('\n');
        this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
    }
}


function $230f88c53743d502$var$shallowSlice(x, begin, size, backend) {
    const xTexData = backend.texData.get(x.dataId);
    const t = backend.makeTensorInfo(size, x.dtype);
    const newTexData = backend.texData.get(t.dataId);
    // Copy texture data from the original tensor.
    Object.assign(newTexData, xTexData);
    newTexData.refCount = 1;
    newTexData.shape = size;
    newTexData.dtype = x.dtype;
    let flatOffset = $1a8ddf4b5d32c90c$exports.computeFlatOffset(begin, $f6b55a2021b78f0d$exports.computeStrides(x.shape));
    if (xTexData.slice) // We are slicing an already sliced tensor, so we have to accumulate
    // the offset.
    flatOffset += xTexData.slice.flatOffset;
    newTexData.slice = {
        flatOffset: flatOffset,
        // Point to the original dataId, which is used to do ref counting.
        origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
    };
    // Increase the ref count for that data bucket.
    const refCount = backend.dataRefCount.get(newTexData.slice.origDataId) || 1;
    backend.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
    return t;
}
function $230f88c53743d502$export$58adb3bec8346d0f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { begin: begin , size: size  } = attrs;
    const [$begin, $size] = $1a8ddf4b5d32c90c$exports.parseSliceParams(x, begin, size);
    $1a8ddf4b5d32c90c$exports.assertParamsValid(x, $begin, $size);
    if ($f6b55a2021b78f0d$exports.sizeFromShape($size) === 0) return backend.makeTensorInfo($size, x.dtype, []);
    // Run on cpu if dtype is string. For string, the backend represents it
    // as Uint8Array[], where each Uint8Array is a character. Given that the
    // computation is only on the outer array, uploading the whole data onto
    // gpu is wasteful. Also, currently webgl doesn't have a design to
    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we
    // just run the kernel on cpu if dtype is string.
    if (backend.shouldExecuteOnCPU([
        x
    ]) || x.dtype === 'string') {
        const xTexData = backend.texData.get(x.dataId);
        const outValues = $31b15458ffa33a6b$export$45812d0d8578899(xTexData.values, $begin, $size, x.shape, x.dtype);
        return backend.makeTensorInfo($size, x.dtype, outValues);
    }
    const { isPacked: isPacked  } = backend.texData.get(x.dataId);
    const isContinous = $1a8ddf4b5d32c90c$exports.isSliceContinous(x.shape, $begin, $size);
    if (isPacked || !isContinous) {
        const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new $9489385f0f465ad1$export$a6c6101de259f77($size) : new $c53926968f2d1d1e$export$ef8bf52bc4951c85($size);
        const customValues = [
            $begin
        ];
        return backend.runWebGLProgram(program, [
            x
        ], x.dtype, customValues);
    }
    backend.uploadToGPU(x.dataId);
    return $230f88c53743d502$var$shallowSlice(x, $begin, $size, backend);
}
const $230f88c53743d502$export$8d8a1e11dd2cc6c4 = {
    kernelName: $2b76be1e72a8c1db$export$b3f2e2de3a8baa1e,
    backendName: 'webgl',
    kernelFunc: $230f88c53743d502$export$58adb3bec8346d0f
};



const $08ffee06d455e0ab$export$ea37d960c1808536 = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , crops: crops  } = attrs;
    $f6b55a2021b78f0d$exports.assert(x.shape.length <= 4, ()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
    );
    const prod = blockShape.reduce((a, b)=>a * b
    );
    const reshaped = $510a55f99d61727a$exports.getReshaped(x.shape, blockShape, prod);
    const permuted = $510a55f99d61727a$exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = $510a55f99d61727a$exports.getReshapedPermuted(x.shape, blockShape, prod);
    const sliceBeginCoords = $510a55f99d61727a$exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = $510a55f99d61727a$exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const toDispose = [];
    const reshapedIntermediate = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: reshaped
        }
    });
    const transposedIntermediate = $fe12dc0e164e619f$export$9cb09a71b7d66923({
        inputs: {
            x: reshapedIntermediate
        },
        backend: backend,
        attrs: {
            perm: permuted
        }
    });
    const reshapedIntermediate2 = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: transposedIntermediate
        },
        backend: backend,
        attrs: {
            shape: reshapedPermuted
        }
    });
    const sliced = $230f88c53743d502$export$58adb3bec8346d0f({
        inputs: {
            x: reshapedIntermediate2
        },
        backend: backend,
        attrs: {
            begin: sliceBeginCoords,
            size: sliceSize
        }
    });
    toDispose.push(reshapedIntermediate);
    toDispose.push(transposedIntermediate);
    toDispose.push(reshapedIntermediate2);
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return sliced;
};
const $08ffee06d455e0ab$export$44e08e19f97e5513 = {
    kernelName: $2b76be1e72a8c1db$export$e2743f47f61cca1f,
    backendName: 'webgl',
    kernelFunc: $08ffee06d455e0ab$export$ea37d960c1808536
};




function $85bf44907cbde46e$export$7e474bab088ed182(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , weights: weights  } = inputs;
    const { size: size  } = attrs;
    const xVals = backend.readSync(x.dataId);
    const weightsVals = backend.readSync(weights.dataId);
    const outVals = $31b15458ffa33a6b$export$566def819e5d4601(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend.makeTensorInfo([
        size
    ], weights.dtype, outVals);
}
const $85bf44907cbde46e$export$af9f0093738840fb = {
    kernelName: $2b76be1e72a8c1db$export$45dfbbff595c32aa,
    backendName: 'webgl',
    kernelFunc: $85bf44907cbde46e$export$7e474bab088ed182
};



function $4065ad6ff6ba7894$export$d226d344aedce941(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { s0: s0 , s1: s1  } = inputs;
    const s0Vals = backend.readSync(s0.dataId);
    const s1Vals = backend.readSync(s1.dataId);
    const broadcastShape = $510a55f99d61727a$exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend.makeTensorInfo([
        broadcastShape.length
    ], 'int32', Int32Array.from(broadcastShape));
}
const $4065ad6ff6ba7894$export$8f7b2ec0c6f08fb2 = {
    kernelName: $2b76be1e72a8c1db$export$32877b1d6d497805,
    backendName: 'webgl',
    kernelFunc: $4065ad6ff6ba7894$export$d226d344aedce941
};









const $857eef99e73b204e$var$NOT_EQUAL = `return float(a != b);`;
const $857eef99e73b204e$export$53a6892c50694894 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $857eef99e73b204e$var$NOT_EQUAL,
    cpuKernelImpl: $31b15458ffa33a6b$export$b91372753635df24,
    dtype: 'bool'
});
const $857eef99e73b204e$export$d003d4d7e1500775 = {
    kernelName: $2b76be1e72a8c1db$export$385ebe9945cae0c5,
    backendName: 'webgl',
    kernelFunc: $857eef99e73b204e$export$53a6892c50694894
};




function $73eb9a248eb31689$export$9fc57fb453bdbd67(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const inputData = backend.texData.get(input.dataId);
    return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: inputData.complexTensorInfos.real
        },
        backend: backend
    });
}
const $73eb9a248eb31689$export$4b7bce57557ae68b = {
    kernelName: $2b76be1e72a8c1db$export$f41305719b94e675,
    backendName: 'webgl',
    kernelFunc: $73eb9a248eb31689$export$9fc57fb453bdbd67
};



const $1f0d18dc7ccce53b$var$TO_INT = `return float(int(x));`;
function $1f0d18dc7ccce53b$export$7d260a2a5f8bc19e(input, backend) {
    const program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(input.shape, $1f0d18dc7ccce53b$var$TO_INT);
    const output = backend.runWebGLProgram(program, [
        input
    ], 'int32');
    return {
        dataId: output.dataId,
        shape: output.shape,
        dtype: output.dtype
    };
}


function $c980e53a0e50d07c$export$f2db7d5238e1d23f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { dtype: dtype  } = attrs;
    // Casting to complex64.
    if (dtype === 'complex64') {
        if (x.dtype === 'complex64') return $d25b33604ad0d249$export$f0954fd7d5368655({
            inputs: {
                x: x
            },
            backend: backend
        });
        // TODO(annxingyuan): Import kernel function once zeros is modularized.
        const zerosTensor = $1b84f1678bdd9c2a$export$4445a00dafa2633b(x.shape);
        const floatX = $c980e53a0e50d07c$export$f2db7d5238e1d23f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                dtype: 'float32'
            }
        });
        const result = $1e4941852430620a$export$83a0e34f1302825b({
            inputs: {
                real: floatX,
                imag: zerosTensor
            },
            backend: backend
        });
        zerosTensor.dispose();
        backend.disposeIntermediateTensorInfo(floatX);
        return result;
    }
    // Casting from complex64
    if (x.dtype === 'complex64') {
        const realPart = $73eb9a248eb31689$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const result = $c980e53a0e50d07c$export$f2db7d5238e1d23f({
            inputs: {
                x: realPart
            },
            backend: backend,
            attrs: {
                dtype: dtype
            }
        });
        backend.disposeIntermediateTensorInfo(realPart);
        return result;
    }
    if (!$f6b55a2021b78f0d$exports.hasEncodingLoss(x.dtype, dtype)) {
        // We don't change the underlying data, since we cast to higher
        // precision.
        const result = $d25b33604ad0d249$export$f0954fd7d5368655({
            inputs: {
                x: x
            },
            backend: backend
        });
        return {
            dataId: result.dataId,
            shape: result.shape,
            dtype: dtype
        };
    }
    if (dtype === 'int32') return $1f0d18dc7ccce53b$export$7d260a2a5f8bc19e(x, backend);
    if (dtype === 'bool') {
        const zerosTensorInfo = backend.makeTensorInfo([], 'bool', $f6b55a2021b78f0d$exports.getTypedArrayFromDType('bool', 1));
        const binaryInputs = {
            a: x,
            b: zerosTensorInfo
        };
        const result = $857eef99e73b204e$export$53a6892c50694894({
            inputs: binaryInputs,
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(zerosTensorInfo);
        return result;
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
const $c980e53a0e50d07c$export$ac4d0f0f3927a8f3 = {
    kernelName: $2b76be1e72a8c1db$export$107ecfb3d1ccbd77,
    backendName: 'webgl',
    kernelFunc: $c980e53a0e50d07c$export$f2db7d5238e1d23f
};





const $54019c3ff6c0b749$var$CEIL = `return ceil(x);`;
const $54019c3ff6c0b749$export$803ce6b71a0a94b2 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $54019c3ff6c0b749$var$CEIL,
    packedOpSnippet: $54019c3ff6c0b749$var$CEIL,
    cpuKernelImpl: $31b15458ffa33a6b$export$bb3ce81256fe261b
});
const $54019c3ff6c0b749$export$df387212b1898306 = {
    kernelName: $2b76be1e72a8c1db$export$d4a1bccfd52ebd3,
    backendName: 'webgl',
    kernelFunc: $54019c3ff6c0b749$export$803ce6b71a0a94b2
};



class $6b7507b6d61c76ae$export$ce48b7c79e7985d1 {
    constructor(aShape){
        this.variableNames = [
            'A'
        ];
        this.customUniforms = [
            {
                name: 'minVal',
                type: 'float'
            },
            {
                name: 'maxVal',
                type: 'float'
            }
        ];
        this.outputShape = aShape;
        this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
}


class $df4dc576846d9694$export$812909708a626d33 {
    constructor(aShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'minVal',
                type: 'float'
            },
            {
                name: 'maxVal',
                type: 'float'
            }
        ];
        this.outputShape = aShape;
        this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
}


function $ae540261f363c96d$export$fa97baf70ad024c0(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { clipValueMin: clipValueMin , clipValueMax: clipValueMax  } = attrs;
    let program;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_CLIP')) program = new $df4dc576846d9694$export$812909708a626d33(x.shape);
    else program = new $6b7507b6d61c76ae$export$ce48b7c79e7985d1(x.shape);
    const customValues = [
        [
            clipValueMin
        ],
        [
            clipValueMax
        ]
    ];
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype, customValues);
}
const $ae540261f363c96d$export$f7ee8f07ce0ff4e1 = {
    kernelName: $2b76be1e72a8c1db$export$611c0e357ac37f7d,
    backendName: 'webgl',
    kernelFunc: $ae540261f363c96d$export$fa97baf70ad024c0
};




class $b8cc8a5ef86559f4$export$d03dbc86862098f5 {
    constructor(shape){
        this.variableNames = [
            'real',
            'imag'
        ];
        this.outputShape = shape;
        this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
}


// Returns a TensorInfo with the complex shape and the dataId of the
// underlying part. We need to do this because a reshaped complex tensor is
// not reflected in its parts.
function $16a6b074ee46ef20$var$makeComplexComponentTensorInfo(complexTensor, complexPart) {
    return {
        dataId: complexPart.dataId,
        dtype: complexPart.dtype,
        shape: complexTensor.shape
    };
}
function $16a6b074ee46ef20$export$2837bc62566f8808(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    const xData = backend.texData.get(x.dataId);
    const program = new $b8cc8a5ef86559f4$export$d03dbc86862098f5(x.shape);
    const programInputs = [
        $16a6b074ee46ef20$var$makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
        $16a6b074ee46ef20$var$makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag), 
    ];
    return backend.runWebGLProgram(program, programInputs, programInputs[0].dtype);
}
const $16a6b074ee46ef20$export$a4817d2978acc054 = {
    kernelName: $2b76be1e72a8c1db$export$32902e58f1b48f4b,
    backendName: 'webgl',
    kernelFunc: $16a6b074ee46ef20$export$2837bc62566f8808
};





class $19c71eac6c71e6f9$export$9059cb52ee2cb142 {
    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().
    constructor(shapes){
        this.outputShape = [];
        this.outputShape = $510a55f99d61727a$exports.computeOutShape(shapes, 1 /* axis */ );
        this.variableNames = shapes.map((_, i)=>`T${i}`
        );
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][1];
        for(let i2 = 1; i2 < offsets.length; i2++)offsets[i2] = offsets[i2 - 1] + shapes[i2][1];
        const snippets = [
            `if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`
        ];
        for(let i1 = 1; i1 < offsets.length; i1++){
            const shift = offsets[i1 - 1];
            snippets.push(`else if (yC < ${offsets[i1]}) ` + `setOutput(getT${i1}(yR, yC-${shift}));`);
        }
        const lastIndex = offsets.length;
        const lastShift = offsets[offsets.length - 1];
        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join('\n        ')}
      }
    `;
    }
}





class $bfcccd5ba2a82c7e$export$e91e551248cfdb97 {
    constructor(shapes, axis){
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        this.outputShape = $510a55f99d61727a$exports.computeOutShape(shapes, axis);
        const shape = this.outputShape;
        const rank = shape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const coords = $941a295bfee22e2b$export$7a4d1d0d17b69972('coords', rank);
        const channels = [
            'x',
            'y',
            'z',
            'w',
            'u',
            'v'
        ].slice(0, rank);
        this.variableNames = shapes.map((_, i)=>`T${i}`
        );
        const offsets = new Array(shapes.length - 1);
        offsets[0] = shapes[0][axis];
        for(let i2 = 1; i2 < offsets.length; i2++)offsets[i2] = offsets[i2 - 1] + shapes[i2][axis];
        const channel = channels[axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
        for(let i1 = 1; i1 < offsets.length; i1++){
            const shift = offsets[i1 - 1];
            // Note: the >= comparison below may seem unnecessary given the check
            // above but is needed to workaround branch execution issues on some
            // devices. It makes all the conditions exclusive without relying on
            // execution order.
            getValueSnippet += `
        if (${channel} < ${offsets[i1]}  && ${channel} >= ${offsets[i1 - 1]}) {
          return getChannel(
            getT${i1}(${$bfcccd5ba2a82c7e$var$shiftedChannels(channels, channel, shift)}),
            vec2(${$bfcccd5ba2a82c7e$var$shiftedChannels(lastChannels, channel, shift)}));
        }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${$bfcccd5ba2a82c7e$var$shiftedChannels(channels, channel, shift)}),
          vec2(${$bfcccd5ba2a82c7e$var$shiftedChannels(lastChannels, channel, shift)}));`;
        this.userCode = `
      float getValue(${channels.map((x)=>'int ' + x
        )}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
        if (${coords[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords});
        }

        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
        if (${coords[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords});
        }

        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
        if (${coords[rank - 2]} < ${shape[rank - 2]} &&
            ${coords[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords});
        }
        setOutput(result);
      }
    `;
    }
}
/**
 * Return an expression for coordinates into a vector where a given channel
 * will be offset by [shift].
 *
 * @param channels the channels to consider
 * @param channel the channel we want shifted
 * @param shift  the amount to subtract from the channel.
 *
 * @returns a string of the form 'x, y-[shift], z' where any one channel can
 * have the shift applied.
 */ function $bfcccd5ba2a82c7e$var$shiftedChannels(channels, channel, shift) {
    const channelIdx = channels.indexOf(channel);
    const res = channels.map((c, idx)=>{
        if (idx === channelIdx) return `${c} - ${shift}`;
        else return c;
    });
    return res.join();
}






function $a716805606e403d7$export$d78fab5778ab392b(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    const inputData = backend.texData.get(input.dataId);
    return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: inputData.complexTensorInfos.imag
        },
        backend: backend
    });
}
const $a716805606e403d7$export$ddfc128c2801add7 = {
    kernelName: $2b76be1e72a8c1db$export$303b4473993a24f,
    backendName: 'webgl',
    kernelFunc: $a716805606e403d7$export$d78fab5778ab392b
};




function $de1856a12ff1bca8$export$777da59f594f497d(inputs, axis, backend) {
    const dtype = inputs[0].dtype;
    if (dtype === 'complex64') {
        const reals = inputs.map((t)=>$73eb9a248eb31689$export$9fc57fb453bdbd67({
                inputs: {
                    input: t
                },
                backend: backend
            })
        );
        const imags = inputs.map((t)=>$a716805606e403d7$export$d78fab5778ab392b({
                inputs: {
                    input: t
                },
                backend: backend
            })
        );
        const realConcated = $de1856a12ff1bca8$export$777da59f594f497d(reals, axis, backend);
        const imagConcated = $de1856a12ff1bca8$export$777da59f594f497d(imags, axis, backend);
        const result = $1e4941852430620a$export$83a0e34f1302825b({
            inputs: {
                real: realConcated,
                imag: imagConcated
            },
            backend: backend
        });
        reals.forEach((r)=>backend.disposeIntermediateTensorInfo(r)
        );
        imags.forEach((i)=>backend.disposeIntermediateTensorInfo(i)
        );
        backend.disposeIntermediateTensorInfo(realConcated);
        backend.disposeIntermediateTensorInfo(imagConcated);
        return result;
    }
    let runOnCpu = backend.shouldExecuteOnCPU(inputs);
    // Run on cpu if dtype is string. For string, the backend represents it
    // as Uint8Array[], where each Uint8Array is a character. Given that the
    // computation is only on the outer array, uploading the whole data onto
    // gpu is wasteful. Also, currently webgl doesn't have a design to
    // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we
    // just run the kernel on cpu if dtype is string.
    if (dtype === 'string') runOnCpu = true;
    if (runOnCpu) {
        // Any concat of n-dimensional tensors across any axis can be reduced to
        // a concatenation of two-dimensional tensors across the axis 1 by first
        // partitioning the axes of the original tensors into those less than the
        // axis to be concatenated and the rest. Then reshape the tensors
        // into a two-dimensional tensor by collapsing these two sets of axes and
        // concatenate the resulting matrices across the axis 1, finally reshaping
        // the result to have the proper shape.
        const tensors2D = inputs.map((t)=>{
            const innerSize = $f6b55a2021b78f0d$exports.sizeFromShape(t.shape.slice(axis));
            const shape = [
                -1,
                innerSize
            ];
            return $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
                inputs: {
                    x: t
                },
                backend: backend,
                attrs: {
                    shape: shape
                }
            });
        });
        const inputsValShapes = tensors2D.map((t)=>{
            return {
                vals: backend.readSync(t.dataId),
                shape: t.shape
            };
        });
        // Concats 2d tensors along axis=1.
        const outShape = $510a55f99d61727a$exports.computeOutShape(tensors2D.map((t)=>t.shape
        ), 1 /* axis */ );
        const simplyConcat = tensors2D[0].shape[0] === 1;
        const outVals = $31b15458ffa33a6b$export$95e7342d25849d64(inputsValShapes, outShape, dtype, simplyConcat);
        const finalOutShape = $510a55f99d61727a$exports.computeOutShape(inputs.map((t)=>t.shape
        ), axis);
        const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);
        tensors2D.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
        );
        return outInfo;
    }
    if (inputs.length > $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_MAX_TEXTURES_IN_SHADER')) {
        const midIndex = Math.floor(inputs.length / 2);
        const leftSide = $de1856a12ff1bca8$export$777da59f594f497d(inputs.slice(0, midIndex), axis, backend);
        const rightSide = $de1856a12ff1bca8$export$777da59f594f497d(inputs.slice(midIndex), axis, backend);
        const result = $de1856a12ff1bca8$export$777da59f594f497d([
            leftSide,
            rightSide
        ], axis, backend);
        backend.disposeIntermediateTensorInfo(leftSide);
        backend.disposeIntermediateTensorInfo(rightSide);
        return result;
    }
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') && inputs[0].shape.length > 1) {
        const program = new $bfcccd5ba2a82c7e$export$e91e551248cfdb97(inputs.map((t)=>t.shape
        ), axis);
        return backend.runWebGLProgram(program, inputs, dtype);
    }
    const { tensors2D: tensors2D , outShape: outShape  } = $de1856a12ff1bca8$var$computeTensors2D(inputs, axis, backend);
    const program = new $19c71eac6c71e6f9$export$9059cb52ee2cb142(tensors2D.map((t)=>t.shape
    ));
    const result = backend.runWebGLProgram(program, tensors2D, dtype);
    tensors2D.forEach((r)=>backend.disposeIntermediateTensorInfo(r)
    );
    const reshapedResult = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: result
        },
        attrs: {
            shape: outShape
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(result);
    return reshapedResult;
}
function $de1856a12ff1bca8$var$computeTensors2D(inputs, axis, backend) {
    // Any concat of n-dimensional tensors across any axis can be reduced to
    // a concatenation of two-dimensional tensors across the axis 1 by first
    // partitioning the axes of the original tensors into those less than the
    // axis to be concatenated and the rest. Then reshape the tensors
    // into a two-dimensional tensor by collapsing these two sets of axes and
    // concatenate the resulting matrices across the axis 1, finally reshaping
    // the result to have the proper shape.
    const outShape = $510a55f99d61727a$exports.computeOutShape(inputs.map((t)=>t.shape
    ), axis);
    const tensors2D = inputs.map((x)=>$6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: x
            },
            attrs: {
                shape: [
                    -1,
                    $f6b55a2021b78f0d$exports.sizeFromShape(x.shape.slice(axis))
                ]
            },
            backend: backend
        })
    );
    return {
        tensors2D: tensors2D,
        outShape: outShape
    };
}



function $5ce0b60e52bb4a58$export$ee1b3e54f0441b22(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, inputs[0].shape)[0];
    const outShape = $510a55f99d61727a$exports.computeOutShape(inputs.map((t)=>t.shape
    ), $axis);
    if ($f6b55a2021b78f0d$exports.sizeFromShape(outShape) === 0) return backend.makeTensorInfo(outShape, inputs[0].dtype, []);
    // Keep only non-empty tensors (ignore tensors with 0 in their shape).
    const $inputs = inputs.filter((t)=>$f6b55a2021b78f0d$exports.sizeFromShape(t.shape) > 0
    );
    if ($inputs.length === 1) return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: $inputs[0]
        },
        backend: backend
    });
    const shapes = $inputs.map((t)=>t.shape
    );
    $510a55f99d61727a$exports.assertParamsConsistent(shapes, $axis);
    return $de1856a12ff1bca8$export$777da59f594f497d($inputs, $axis, backend);
}
const $5ce0b60e52bb4a58$export$c8cf96dae25282e5 = {
    kernelName: $2b76be1e72a8c1db$export$936bbfc007425eea,
    backendName: 'webgl',
    kernelFunc: $5ce0b60e52bb4a58$export$ee1b3e54f0441b22
};



class $2fec09c59342cab5$export$8dc36706147178e9 {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false){
        this.variableNames = [
            'x',
            'W'
        ];
        this.outputShape = convInfo.outShape;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivationWeights) activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            else if (hasLeakyreluAlpha) activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            else activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) this.variableNames.push('bias');
        if (hasPreluActivationWeights) this.variableNames.push('preluActivationWeights');
        if (hasLeakyreluAlpha) this.variableNames.push('leakyreluAlpha');
        this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}
class $2fec09c59342cab5$export$67aff94cf1ececaf {
    constructor(convInfo){
        this.variableNames = [
            'x',
            'W'
        ];
        this.outputShape = convInfo.outShape;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        const inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}





class $e4ac852dd27e4bb2$export$d76a638e68b7f211 {
    constructor(outputShape, convInfo){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'inputShape',
                type: 'ivec3'
            },
            {
                name: 'pad',
                type: 'ivec2'
            },
            {
                name: 'stride',
                type: 'ivec2'
            },
            {
                name: 'dilation',
                type: 'ivec2'
            },
            {
                name: 'inChannels',
                type: 'int'
            },
            {
                name: 'itemsPerBlockRow',
                type: 'int'
            },
            {
                name: 'outWidth',
                type: 'int'
            }, 
        ];
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        const { dataFormat: dataFormat  } = convInfo;
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        const isChannelsLast = dataFormat === 'channelsLast';
        const rowDim = isChannelsLast ? 0 : 1;
        const colDim = isChannelsLast ? 1 : 2;
        const boundsCheckingSnippet = this.enableShapeUniforms ? 'if(blockIndex < outShape[1] && pos < outShape[0]) {' : `if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {`;
        let unrolled = ``;
        for(let row = 0; row <= 1; row++)for(let col = 0; col <= 1; col++)unrolled += `
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
        this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
    }
}








function $a83ace48abb59807$export$fe56ce0f8b4bfd45({ x: x , filter: filter , convInfo: convInfo , backend: backend , bias: bias = null , preluActivationWeights: preluActivationWeights = null , leakyreluAlpha: leakyreluAlpha = 0 , activation: activation = null  }) {
    // Reshapes conv2D input to 2D tensors, uses matMul and then reshape the
    // result from 2D to 4D.
    const xShape = x.shape;
    const xTexData = backend.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === 'channelsLast';
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    // TODO: Once reduction ops are packed, batchMatMul will always be packed
    // and we can remove this condition.
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > $fd470a4c7883c0f2$export$42c1ddb439199e73;
    // The algorithm in the if condition assumes (1) the output will be packed,
    // (2) x is packed, (3) x isChannelsLast, (4)  x's packed texture is already
    // on GPU, (5) col is odd, (6) the width, height and inChannels are the same
    // for xTexData.shape and xShape.
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && $f6b55a2021b78f0d$exports.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
        // We avoid expensive packed 2x2 reshape by padding col count to next,
        // even number. When col is odd, the result of packed batchMatMul is
        // the same (has the same texture layout and and values in the texture) as
        // it is for next even col. We make the odd-cols tensor to look like
        // even-cols tensor before the operation and, after the batchMatMul,
        // fix the even-cols result to have odd number of cols.
        const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
        const xReshaped = {
            dataId: x.dataId,
            shape: [
                1,
                targetShape,
                convInfo.inChannels
            ],
            dtype: x.dtype
        };
        // xTexData.shape gets referenced from GPGPUBinary.inShapeInfos.
        // Decrementing col count, after batchMatMul->...->compileProgram leads to
        // invalid col count within the reference in GPGPUBinary.inShapeInfos.
        // Alternative fix would be to provide a copy to GPGPUBinary.inShapeInfos
        // in compileProgram method, but that would affect compilation of all
        // programs - instead, provide a copy here, with even col count, before
        // calling batchMatMul->...->compileProgram and after that, the original
        // xTexData.shape is restored.
        const originalXTexDataShape = xTexData.shape;
        xTexData.shape = xTexData.shape.slice();
        xTexData.shape[xTexData.shape.length - 2]++;
        $f6b55a2021b78f0d$exports.assert($7428f53c4d4be222$export$951b388203a0422d(xTexData.shape, xReshaped.shape), ()=>`packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`
        );
        const filterReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: filter
            },
            backend: backend,
            attrs: {
                shape: [
                    1,
                    convInfo.inChannels,
                    convInfo.outChannels
                ]
            }
        });
        intermediates.push(filterReshaped);
        const pointwiseConv = $fd470a4c7883c0f2$export$d524d65e88e1168b({
            a: xReshaped,
            b: filterReshaped,
            backend: backend,
            transposeA: transposeA,
            transposeB: transposeB,
            bias: bias,
            activation: activation,
            preluActivationWeights: preluActivationWeights,
            leakyreluAlpha: leakyreluAlpha
        });
        const pointwiseConvTexData = backend.texData.get(pointwiseConv.dataId);
        $f6b55a2021b78f0d$exports.assert(pointwiseConvTexData.isPacked, ()=>'batchMatMul result is expected to be packed'
        );
        // Restore the input shape to original.
        xTexData.shape = originalXTexDataShape;
        // Set the output shape - there is no need for expensive reshape as data
        // layout is already correct.
        pointwiseConvTexData.shape = convInfo.outShape;
        out = $d25b33604ad0d249$export$f0954fd7d5368655({
            inputs: {
                x: pointwiseConv
            },
            backend: backend
        });
        out.shape = convInfo.outShape;
        intermediates.push(pointwiseConv);
    } else {
        const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
        const xReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                shape: [
                    1,
                    targetShape,
                    convInfo.inChannels
                ]
            }
        });
        const filterReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: filter
            },
            backend: backend,
            attrs: {
                shape: [
                    1,
                    convInfo.inChannels,
                    convInfo.outChannels
                ]
            }
        });
        const result = $fd470a4c7883c0f2$export$d524d65e88e1168b({
            a: xReshaped,
            b: filterReshaped,
            transposeA: transposeA,
            transposeB: transposeB,
            backend: backend,
            bias: bias,
            activation: activation,
            preluActivationWeights: preluActivationWeights,
            leakyreluAlpha: leakyreluAlpha
        });
        out = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                shape: convInfo.outShape
            }
        });
        intermediates.push(xReshaped);
        intermediates.push(filterReshaped);
        intermediates.push(result);
    }
    for (const i of intermediates)backend.disposeIntermediateTensorInfo(i);
    return out;
}
function $a83ace48abb59807$export$65b699e5c77381b8({ x: x , filter: filter , convInfo: convInfo , backend: backend , bias: bias = null , preluActivationWeights: preluActivationWeights = null , leakyreluAlpha: leakyreluAlpha = 0 , activation: activation = null  }) {
    // Rearranges conv2d input so each block to be convolved over forms the
    // column of a new matrix with shape [filterWidth * filterHeight *
    // inChannels, outHeight * outWidth]. The filter is also rearranged so each
    // output channel forms a row of a new matrix with shape [outChannels,
    // filterWidth * filterHeight * inChannels]. The convolution is then
    // computed by multiplying these matrices and reshaping the result.
    const { filterWidth: filterWidth , filterHeight: filterHeight , inChannels: inChannels , outWidth: outWidth , outHeight: outHeight , dataFormat: dataFormat  } = convInfo;
    const isChannelsLast = dataFormat === 'channelsLast';
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [
        sharedDim,
        numCols
    ];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    const xSqueezed = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: x.shape.slice(1)
        }
    });
    const w2Row = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: filter
        },
        backend: backend,
        attrs: {
            shape: [
                1,
                sharedDim,
                $f6b55a2021b78f0d$exports.sizeFromShape(filter.shape) / sharedDim
            ]
        }
    });
    intermediates.push(xSqueezed);
    intermediates.push(w2Row);
    const im2ColProgram = new $e4ac852dd27e4bb2$export$d76a638e68b7f211(x2ColShape, convInfo);
    const customValues = [
        xSqueezed.shape,
        [
            convInfo.padInfo.top,
            convInfo.padInfo.left
        ],
        [
            convInfo.strideHeight,
            convInfo.strideWidth
        ],
        [
            convInfo.dilationHeight,
            convInfo.dilationWidth
        ],
        [
            convInfo.inChannels
        ],
        [
            convInfo.filterWidth * convInfo.inChannels
        ],
        [
            convInfo.outWidth
        ]
    ];
    const im2Col = backend.runWebGLProgram(im2ColProgram, [
        xSqueezed
    ], 'float32', customValues);
    const im2ColReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: im2Col
        },
        backend: backend,
        attrs: {
            shape: [
                1,
                x2ColShape[0],
                x2ColShape[1]
            ]
        }
    });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    const fusedActivation = activation ? $f569887d6243ad0e$export$445d43a4039ec7b7(activation, true) : null;
    const matmulProgram = new $2422aad8b4ea59b8$export$21e5f112101779d8(im2ColReshaped.shape, w2Row.shape, [
        1,
        numCols,
        convInfo.outChannels
    ], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [
        im2ColReshaped,
        w2Row
    ];
    if (bias) inputs.push(bias);
    if (hasPreluActivationWeights) inputs.push(preluActivationWeights);
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(leakyreluAlpha, 'float32'));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    const product = backend.runWebGLProgram(matmulProgram, inputs, 'float32');
    const outShape = isChannelsLast ? [
        1,
        outHeight,
        outWidth,
        convInfo.outChannels
    ] : [
        1,
        convInfo.outChannels,
        outHeight,
        outWidth
    ];
    const out = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: product
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    intermediates.push(product);
    for (const i of intermediates)backend.disposeIntermediateTensorInfo(i);
    return out;
}



function $562cbe282c117d66$export$188f9215482e3db8(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dilations: dilations , dimRoundingMode: dimRoundingMode  } = attrs;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
    let out;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) out = $a83ace48abb59807$export$fe56ce0f8b4bfd45({
        x: x,
        filter: filter,
        convInfo: convInfo,
        backend: backend
    });
    else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) out = $a83ace48abb59807$export$65b699e5c77381b8({
        x: x,
        filter: filter,
        convInfo: convInfo,
        backend: backend
    });
    else {
        const program = new $2fec09c59342cab5$export$8dc36706147178e9(convInfo);
        out = backend.runWebGLProgram(program, [
            x,
            filter
        ], 'float32');
    }
    const outReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: out
        },
        backend: backend,
        attrs: {
            shape: convInfo.outShape
        }
    });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
}
const $562cbe282c117d66$export$4a39bf13b4378042 = {
    kernelName: $2b76be1e72a8c1db$export$57742e605d475795,
    backendName: 'webgl',
    kernelFunc: $562cbe282c117d66$export$188f9215482e3db8
};



class $cce6ffe79fbd848d$export$1223560f67be2f2d {
    constructor(convInfo){
        this.variableNames = [
            'x',
            'dy'
        ];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $cce6ffe79fbd848d$export$5dc650171c0f6623 {
    constructor(convInfo){
        this.variableNames = [
            'dy',
            'W'
        ];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const isChannelsLast = convInfo.dataFormat === 'channelsLast';
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $cce6ffe79fbd848d$export$932d18866f409cf3 {
    constructor(convInfo){
        this.variableNames = [
            'x',
            'dy'
        ];
        this.outputShape = convInfo.filterShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = convInfo.padInfo.front;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $cce6ffe79fbd848d$export$acda329ff653a25 {
    constructor(convInfo){
        this.variableNames = [
            'dy',
            'W'
        ];
        this.outputShape = convInfo.inShape;
        const filterDepth = convInfo.filterDepth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padFront = filterDepth - 1 - convInfo.padInfo.front;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}


function $5f8b0663342bf4ca$export$652a30c9379f3de7(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode , filterShape: filterShape  } = attrs;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filterShape, strides, 1 /* dilations */ , pad, dimRoundingMode, false, $dataFormat);
    const program = new $cce6ffe79fbd848d$export$1223560f67be2f2d(convInfo);
    return backend.runWebGLProgram(program, [
        x,
        dy
    ], 'float32');
}
const $5f8b0663342bf4ca$export$7a95f55d2d2e7d24 = {
    kernelName: $2b76be1e72a8c1db$export$32a8943c0f1ca5a7,
    backendName: 'webgl',
    kernelFunc: $5f8b0663342bf4ca$export$652a30c9379f3de7
};




function $4411adccfb9b01bb$export$633310eed0c26e72(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { inputShape: inputShape , strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode  } = attrs;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(inputShape, filter.shape, strides, 1 /* dilations */ , pad, dimRoundingMode, false, $dataFormat);
    const program = new $cce6ffe79fbd848d$export$5dc650171c0f6623(convInfo);
    return backend.runWebGLProgram(program, [
        dy,
        filter
    ], 'float32');
}
const $4411adccfb9b01bb$export$19bbc19fff1ed26f = {
    kernelName: $2b76be1e72a8c1db$export$e26961e8ed0eb404,
    backendName: 'webgl',
    kernelFunc: $4411adccfb9b01bb$export$633310eed0c26e72
};




function $7619d588bc0f4c75$export$1929932f31d07956(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad);
    const program = new $2fec09c59342cab5$export$67aff94cf1ececaf(convInfo);
    return backend.runWebGLProgram(program, [
        x,
        filter
    ], 'float32');
}
const $7619d588bc0f4c75$export$1fe590fda0829040 = {
    kernelName: $2b76be1e72a8c1db$export$9d3874201dd21933,
    backendName: 'webgl',
    kernelFunc: $7619d588bc0f4c75$export$1929932f31d07956
};




function $8d4ba464631fb110$export$b57760dc3101cea7(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , pad: pad , filterShape: filterShape  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(x.shape, filterShape, strides, 1 /* dilations */ , pad);
    const program = new $cce6ffe79fbd848d$export$932d18866f409cf3(convInfo);
    return backend.runWebGLProgram(program, [
        x,
        dy
    ], 'float32');
}
const $8d4ba464631fb110$export$6dce9169640850fa = {
    kernelName: $2b76be1e72a8c1db$export$dd2885efe6043eee,
    backendName: 'webgl',
    kernelFunc: $8d4ba464631fb110$export$b57760dc3101cea7
};




function $3e0f65ac92a9d0bd$export$deb6d1ca1fa2977b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { pad: pad , strides: strides , inputShape: inputShape  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv3DInfo(inputShape, filter.shape, strides, 1 /* dilations */ , pad);
    const program = new $cce6ffe79fbd848d$export$acda329ff653a25(convInfo);
    return backend.runWebGLProgram(program, [
        dy,
        filter
    ], 'float32');
}
const $3e0f65ac92a9d0bd$export$cdcac766a3ef1744 = {
    kernelName: $2b76be1e72a8c1db$export$a54f552d6d7d521f,
    backendName: 'webgl',
    kernelFunc: $3e0f65ac92a9d0bd$export$deb6d1ca1fa2977b
};




const $0425cdfb53c4e9fd$var$COS = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return cos(x);
`;
const $0425cdfb53c4e9fd$export$50d414a77b60d802 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $0425cdfb53c4e9fd$var$COS
});
const $0425cdfb53c4e9fd$export$ff099a1da5235a7e = {
    kernelName: $2b76be1e72a8c1db$export$ddfd0a983d257666,
    backendName: 'webgl',
    kernelFunc: $0425cdfb53c4e9fd$export$50d414a77b60d802
};




const $4da9ed2410b2e306$var$COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
const $4da9ed2410b2e306$export$2e2fd1ad24e4d350 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $4da9ed2410b2e306$var$COSH
});
const $4da9ed2410b2e306$export$c5824052b09ba0ed = {
    kernelName: $2b76be1e72a8c1db$export$5e311a1c57b0d27c,
    backendName: 'webgl',
    kernelFunc: $4da9ed2410b2e306$export$2e2fd1ad24e4d350
};



class $8aaec3f9f58a994a$export$c889a58f7ea63106 {
    constructor(imageShape, boxShape, cropSize, method, extrapolationValue){
        this.variableNames = [
            'Image',
            'Boxes',
            'BoxInd'
        ];
        this.outputShape = [];
        const [batch, imageHeight, imageWidth, depth] = imageShape;
        const [numBoxes, ] = boxShape;
        const [cropHeight, cropWidth] = cropSize;
        this.outputShape = [
            numBoxes,
            cropHeight,
            cropWidth,
            depth
        ];
        const methodId = method === 'bilinear' ? 1 : 0;
        const [inputHeightFloat, inputWidthFloat] = [
            `${imageHeight - 1}.0`,
            `${imageWidth - 1}.0`
        ];
        const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
            `${(imageHeight - 1) / (cropHeight - 1)}`,
            '(y2-y1) * height_ratio',
            `y1*${inputHeightFloat} + float(y)*(height_scale)`, 
        ] : [
            '0.0',
            '0.0',
            `0.5 * (y1+y2) * ${inputHeightFloat}`, 
        ];
        const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
            `${(imageWidth - 1) / (cropWidth - 1)}`,
            '(x2-x1) * width_ratio',
            `x1*${inputWidthFloat} + float(x)*(width_scale)`, 
        ] : [
            '0.0',
            '0.0',
            `0.5 * (x1+x2) * ${inputWidthFloat}`, 
        ];
        // Reference implementation
        // tslint:disable-next-line:max-line-length
        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc
        this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
}


const $8d9eb13860ae195e$export$6f0f0090e1f6cd3c = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { image: image , boxes: boxes , boxInd: boxInd  } = inputs;
    const { cropSize: cropSize , method: method , extrapolationValue: extrapolationValue  } = attrs;
    const program = new $8aaec3f9f58a994a$export$c889a58f7ea63106(image.shape, boxes.shape, cropSize, method, extrapolationValue);
    return backend.runWebGLProgram(program, [
        image,
        boxes,
        boxInd
    ], 'float32');
};
const $8d9eb13860ae195e$export$f7086edcf0050c7f = {
    kernelName: $2b76be1e72a8c1db$export$50bc9557793c2e04,
    backendName: 'webgl',
    kernelFunc: $8d9eb13860ae195e$export$6f0f0090e1f6cd3c
};




class $350c9cc737b343ee$export$fbdcedadd00dd392 {
    constructor(shape, exclusive, reverse){
        this.variableNames = [
            'x'
        ];
        this.customUniforms = [
            {
                name: 'index',
                type: 'float'
            }
        ];
        this.outputShape = shape;
        const rank = shape.length;
        const val = exclusive ? '1.0' : `getX(${$350c9cc737b343ee$var$getCoords(rank, 'coords')})`;
        const length = shape[shape.length - 1];
        let condition = '';
        let idxString = '';
        // When exclusive is set, the cumprod op becomes roll op that copies the
        // value from the previous index based on the direction specified by the
        // reverse flag.
        if (exclusive) {
            condition = reverse ? `end != ${length - 1}` : 'end != 0';
            idxString = reverse ? 'end + 1' : 'end - 1';
        } else {
            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';
            idxString = reverse ? 'end + pow2' : 'end - pow2';
        }
        this.userCode = `
      void main() {
        ${$fbbfeeecbf2420a1$export$859efd105c10c755(rank)} coords = getOutputCoords();
        int end = ${$350c9cc737b343ee$var$getFinalCoord(rank, 'coords')};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${$350c9cc737b343ee$var$getFinalCoord(rank, 'coords')} = idx;
          val *= getX(${$350c9cc737b343ee$var$getCoords(rank, 'coords')});
        }
        setOutput(val);
      }
    `;
    }
}
function $350c9cc737b343ee$var$getCoords(rank, name) {
    if (rank === 1) return `${name}`;
    else if (rank === 2) return `${name}.x, ${name}.y`;
    else if (rank === 3) return `${name}.x, ${name}.y, ${name}.z`;
    else if (rank === 4) return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    else throw Error(`Cumulative product for rank ${rank} is not yet supported`);
}
function $350c9cc737b343ee$var$getFinalCoord(rank, name) {
    if (rank === 1) return `${name}`;
    else if (rank === 2) return `${name}.y`;
    else if (rank === 3) return `${name}.z`;
    else if (rank === 4) return `${name}.w`;
    else throw Error(`Cumulative product for rank ${rank} is not yet supported`);
}




function $7eabab793ed2a4ca$export$dc7513e907e94b8d(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    const xRank = x.shape.length;
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], xRank);
    let permutedX = x;
    if (permutation != null) permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            perm: permutation
        }
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${x.shape.length - 1} ` + `but got axis=${axis}`);
    const size = permutedX.shape[permutedAxis];
    let result = $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: permutedX
        },
        backend: backend
    });
    // Use cumprod parallel algorithm, inspired by:
    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
    // Note: although the algorithm is called sum, it works for any associtative
    // operator with an identity.
    for(let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++){
        const program = new $350c9cc737b343ee$export$fbdcedadd00dd392(permutedX.shape, false, reverse);
        const customValues = [
            [
                i
            ]
        ];
        const prevResult = result;
        result = backend.runWebGLProgram(program, [
            result
        ], result.dtype, customValues);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    // For exclusive cumprod, shift the end result in the direction of product
    // and add 1 to the front index.
    if (exclusive) {
        const program = new $350c9cc737b343ee$export$fbdcedadd00dd392(permutedX.shape, exclusive, reverse);
        const prevResult = result;
        result = backend.runWebGLProgram(program, [
            result
        ], result.dtype);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
        const reversePermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                perm: reversePermutation
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        backend.disposeIntermediateTensorInfo(permutedX);
        return reverseTransposedResult;
    }
    return result;
}
const $7eabab793ed2a4ca$export$db50d81ed60c5a35 = {
    kernelName: $2b76be1e72a8c1db$export$e581acc6014c47a,
    backendName: 'webgl',
    kernelFunc: $7eabab793ed2a4ca$export$dc7513e907e94b8d
};




class $6acacc4f655006e2$export$1633a8add7a7cc3e {
    constructor(shape, exclusive, reverse){
        this.variableNames = [
            'x'
        ];
        this.customUniforms = [
            {
                name: 'index',
                type: 'float'
            }
        ];
        this.outputShape = shape;
        const rank = shape.length;
        const val = exclusive ? '0.0' : `getX(${$6acacc4f655006e2$var$getCoords(rank, 'coords')})`;
        const length = shape[shape.length - 1];
        let condition = '';
        let idxString = '';
        // When exclusive is set, the cumsum op becomes roll op that copies the
        // value from the previous index based on the direction specified by the
        // reverse flag.
        if (exclusive) {
            condition = reverse ? `end != ${length - 1}` : 'end != 0';
            idxString = reverse ? 'end + 1' : 'end - 1';
        } else {
            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';
            idxString = reverse ? 'end + pow2' : 'end - pow2';
        }
        this.userCode = `
      void main() {
        ${$fbbfeeecbf2420a1$export$859efd105c10c755(rank)} coords = getOutputCoords();
        int end = ${$6acacc4f655006e2$var$getFinalCoord(rank, 'coords')};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${$6acacc4f655006e2$var$getFinalCoord(rank, 'coords')} = idx;
          val += getX(${$6acacc4f655006e2$var$getCoords(rank, 'coords')});
        }
        setOutput(val);
      }
    `;
    }
}
function $6acacc4f655006e2$var$getCoords(rank, name) {
    if (rank === 1) return `${name}`;
    else if (rank === 2) return `${name}.x, ${name}.y`;
    else if (rank === 3) return `${name}.x, ${name}.y, ${name}.z`;
    else if (rank === 4) return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    else throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
}
function $6acacc4f655006e2$var$getFinalCoord(rank, name) {
    if (rank === 1) return `${name}`;
    else if (rank === 2) return `${name}.y`;
    else if (rank === 3) return `${name}.z`;
    else if (rank === 4) return `${name}.w`;
    else throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
}




function $a229ab31e5763400$export$71990b1e1c4912fe(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , exclusive: exclusive , reverse: reverse  } = attrs;
    const xRank = x.shape.length;
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], xRank);
    let permutedX = x;
    if (permutation != null) permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            perm: permutation
        }
    });
    const permutedAxis = $510a55f99d61727a$exports.getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.shape.length - 1} ` + `but got axis=${axis}`);
    const size = permutedX.shape[permutedAxis];
    let result = $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: permutedX
        },
        backend: backend
    });
    // Use cumsum parallel algorithm, ref:
    // https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
    for(let i = 0; i <= Math.ceil(Math.log2(size)) - 1; i++){
        const program = new $6acacc4f655006e2$export$1633a8add7a7cc3e(permutedX.shape, false, reverse);
        const customValues = [
            [
                i
            ]
        ];
        const prevResult = result;
        result = backend.runWebGLProgram(program, [
            result
        ], result.dtype, customValues);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    // For exclusive cumsum, shift the end result in the direction of sum
    // and add 0 to the front index.
    if (exclusive) {
        const program = new $6acacc4f655006e2$export$1633a8add7a7cc3e(permutedX.shape, exclusive, reverse);
        const prevResult = result;
        result = backend.runWebGLProgram(program, [
            result
        ], result.dtype);
        backend.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
        const reversePermutation = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        const reverseTransposedResult = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: result
            },
            backend: backend,
            attrs: {
                perm: reversePermutation
            }
        });
        backend.disposeIntermediateTensorInfo(result);
        backend.disposeIntermediateTensorInfo(permutedX);
        return reverseTransposedResult;
    }
    return result;
}
const $a229ab31e5763400$export$2f6196f3316e7ed2 = {
    kernelName: $2b76be1e72a8c1db$export$706617d894ad63da,
    backendName: 'webgl',
    kernelFunc: $a229ab31e5763400$export$71990b1e1c4912fe
};




function $09e2e77d1329ce74$export$436934e6cf1946f1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , weights: weights  } = inputs;
    const { size: size , binaryOutput: binaryOutput  } = attrs;
    if (x.shape.length === 1) {
        const xVals = backend.readSync(x.dataId);
        const weightsVals = backend.readSync(weights.dataId);
        const outVals = $31b15458ffa33a6b$export$566def819e5d4601(xVals, weightsVals, weights.dtype, weights.shape, size);
        return backend.makeTensorInfo([
            size
        ], weights.dtype, outVals);
    } else if (x.shape.length === 2) {
        const xBuf = backend.bufferSync(x);
        const weightsBuf = backend.bufferSync(weights);
        const outBuf = $31b15458ffa33a6b$export$447b89266e53682e(xBuf, weightsBuf, size, binaryOutput);
        return backend.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` + `${x.shape.length}.`);
}
const $09e2e77d1329ce74$export$88ba267b84334692 = {
    kernelName: $2b76be1e72a8c1db$export$5bab6834954299c5,
    backendName: 'webgl',
    kernelFunc: $09e2e77d1329ce74$export$436934e6cf1946f1
};



class $2849ef1dc2568c16$export$eb07f17369165f28 {
    constructor(outputShape, blockSize, dataFormat){
        this.variableNames = [
            'x'
        ];
        this.outputShape = [];
        this.outputShape = outputShape;
        this.blockSize = blockSize;
        this.dataFormat = dataFormat;
        this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
        if (this.dataFormat === 'NHWC') return `coords[1]`;
        else return `coords[2]`;
    }
    getWidthCoordString() {
        if (this.dataFormat === 'NHWC') return `coords[2]`;
        else return `coords[3]`;
    }
    getDepthCoordString() {
        if (this.dataFormat === 'NHWC') return `coords[3]`;
        else return `coords[1]`;
    }
    getOutputDepthSize() {
        if (this.dataFormat === 'NHWC') return this.outputShape[3];
        else return this.outputShape[1];
    }
    getInputSamplingString() {
        if (this.dataFormat === 'NHWC') return `getX(b, in_h, in_w, in_d)`;
        else return `getX(b, in_d, in_h, in_w)`;
    }
}


function $42400bf20b37bc81$export$3b50daec0f185f12(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockSize: blockSize , dataFormat: dataFormat  } = attrs;
    const batchSize = x.shape[0];
    const inputHeight = dataFormat === 'NHWC' ? x.shape[1] : x.shape[2];
    const inputWidth = dataFormat === 'NHWC' ? x.shape[2] : x.shape[3];
    const inputDepth = dataFormat === 'NHWC' ? x.shape[3] : x.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = dataFormat === 'NHWC' ? [
        batchSize,
        outputHeight,
        outputWidth,
        outputDepth
    ] : [
        batchSize,
        outputDepth,
        outputHeight,
        outputWidth
    ];
    const program = new $2849ef1dc2568c16$export$eb07f17369165f28(outputShape, blockSize, dataFormat);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}
const $42400bf20b37bc81$export$9c5b88dcb1d2008b = {
    kernelName: $2b76be1e72a8c1db$export$fb0ee52d0cd6f233,
    backendName: 'webgl',
    kernelFunc: $42400bf20b37bc81$export$3b50daec0f185f12
};




class $44523a22f808d266$export$4ead5a4ba22ede40 {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false){
        this.variableNames = [
            'x',
            'W'
        ];
        this.customUniforms = [
            {
                name: 'pads',
                type: 'ivec2'
            },
            {
                name: 'strides',
                type: 'ivec2'
            },
            {
                name: 'dilations',
                type: 'ivec2'
            },
            {
                name: 'inDims',
                type: 'ivec2'
            }, 
        ];
        this.outputShape = convInfo.outShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            else if (hasLeakyReluAlpha) activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            else activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) this.variableNames.push('bias');
        if (hasPreluActivation) this.variableNames.push('preluActivationWeights');
        if (hasLeakyReluAlpha) this.variableNames.push('leakyreluAlpha');
        this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}




class $6b0494a9da79ad6a$export$acb9287627a2b170 {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false){
        this.variableNames = [
            'x',
            'W'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'pads',
                type: 'ivec2'
            },
            {
                name: 'strides',
                type: 'ivec2'
            },
            {
                name: 'dilations',
                type: 'ivec2'
            },
            {
                name: 'inDims',
                type: 'ivec2'
            }, 
        ];
        this.outputShape = convInfo.outShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        const padLeft = convInfo.padInfo.left;
        const strideWidth = convInfo.strideWidth;
        const dilationWidth = convInfo.dilationWidth;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const texelsAcross = filterWidth;
        let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
        for(let c = 0; c < filterWidth; c++)mainLoop += `
          vec4 xTexelC${c * 2};
          int xTexelC${c * 2}Ready;
          vec4 xTexelC${c * 2 + 1};
          int xTexelC${c * 2 + 1}Ready;
          vec4 xC${c};`;
        /**
         * This vectorized implementation works by gathering the values needed for
         * each output channel's dot product into vec4's and then multiplying them
         * all together (this happens in the final double for-loop below). Most of
         * the main loop consists of constructing these vec4's with the minimum
         * number of texture2D calls, which means making use of all four returned
         * values from a texture2D call at once.
         */ mainLoop += `
    for (int r = 0; r < ${filterHeight}; r++) {
      `;
        for(let c1 = 0; c1 < filterWidth; c1++)mainLoop += `
          xTexelC${c1 * 2} = vec4(0.0);
          xTexelC${c1 * 2}Ready = 0;
          xTexelC${c1 * 2 + 1} = vec4(0.0);
          xTexelC${c1 * 2 + 1}Ready = 0;
          xC${c1} = vec4(0.0);`;
        mainLoop += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
        for(let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++){
            const colIndex = texelC * 2;
            mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
            if (strideWidth === 1) {
                if (colIndex < filterWidth) {
                    // If padding is odd, the outer texels have to be composed.
                    if (padLeft % 2 === 1) {
                        // TODO: Ensure vec4 previous does not result in redundant sample,
                        // and avoid setting xTexelRC's that exceed the boundary in the
                        // first place rather than resetting them to vec4(0)).
                        // To compute xCOffset:
                        // - If padding is odd, we must add 1 to ensure we ask for an
                        // even-numbered row.
                        // - We subtract 2 to access the previous texel.
                        mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
                        // This texel has been read in previous iteration if the dilation
                        // is 1.
                        if (dilationWidth === 1 && colIndex > 0) mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
                        else mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
                    } else // Padding is even, so xRC corresponds to a single texel.
                    mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
                    if (colIndex + 1 < filterWidth) {
                        // If dilation is even, the second entry should match the first
                        // (either both are composed or both are single samples). But if
                        // dilation is odd, then the second entry should be the opposite
                        // of the first (if the first is composed, the second is a single
                        // sample, and vice versa.)
                        const nextTexelOffset = padLeft % 2 === 0 ? $f6b55a2021b78f0d$exports.nearestLargerEven(dilationWidth) : dilationWidth;
                        if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                            mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
                            // If dilation > 1 then the xRC's will not be able to share any
                            // values, so each xRC will require two unique calls to getX.
                            if (dilationWidth > 1) mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                      xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                      xTexelC${colIndex}Ready = 1;
                    }
                    `;
                            mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                  `;
                        } else // If dilation is 1 and padding is odd, we have already read the
                        // texel when constructing the previous x value. Here we can
                        // simply skip the texture read.
                        if (nextTexelOffset === 1) mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
                        else mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
                    }
                }
            } else if (colIndex < filterWidth) {
                // Depending on whether padLeft is even or odd, we want either the
                // xy or zw channels from X texels for xC${colIndex}. If padLeft is
                // even, xC${colIndex +1} is simply the zw channels of texels we've
                // already sampled. But if padLeft is odd, xC{$c + 1}.zw will
                // need to come from the xy channels of a new texel, hence the `
                // vec4
                // final` initialized below.
                if (padLeft % 2 === 1) {
                    mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
                    if (colIndex + 1 < filterWidth) mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
                } else {
                    mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
                    if (colIndex + 1 < filterWidth) mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
                }
            }
            // localize the dotProd accumulation within the loop, the theory is for
            // GPU with limited cache, accumulate sum across large amount of
            // veriables will cause lots of cache misses. (i.e. 5x5 filter will have
            // 50 variables)
            if (colIndex < filterWidth) {
                mainLoop += `
            wTexel = getW(r, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
                if (colIndex + 1 < filterWidth) mainLoop += `
              wTexel = getW(r, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
            }
        }
        mainLoop += `
    }
  `;
        mainLoop += `
      }
    `;
        let activationSnippet = '', applyActivationSnippet = '';
        if (activation) {
            if (hasPreluActivation) activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
            else if (hasLeakyReluAlpha) activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
            else activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
            applyActivationSnippet = `result = activation(result);`;
        }
        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';
        if (addBias) this.variableNames.push('bias');
        if (hasPreluActivation) this.variableNames.push('preluActivationWeights');
        if (hasLeakyReluAlpha) this.variableNames.push('leakyreluAlpha');
        this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
}


function $4bd891ab18ed24a2$export$14e793fe8822afd1(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations , dimRoundingMode: dimRoundingMode  } = attrs;
    let $dilations = dilations;
    if ($dilations == null) $dilations = [
        1,
        1
    ];
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, $dilations), ()=>'Error in depthwiseConv2d: Either strides or dilations must be ' + `1. Got strides ${strides} and dilations '${$dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
    let program;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) program = new $6b0494a9da79ad6a$export$acb9287627a2b170(convInfo);
    else program = new $44523a22f808d266$export$4ead5a4ba22ede40(convInfo);
    const customValues = [
        [
            convInfo.padInfo.top,
            convInfo.padInfo.left
        ],
        [
            convInfo.strideHeight,
            convInfo.strideWidth
        ],
        [
            convInfo.dilationHeight,
            convInfo.dilationWidth
        ],
        [
            convInfo.inHeight,
            convInfo.inWidth
        ]
    ];
    return backend.runWebGLProgram(program, [
        x,
        filter
    ], 'float32', customValues);
}
const $4bd891ab18ed24a2$export$240667804b7c390e = {
    kernelName: $2b76be1e72a8c1db$export$7c0fc590ff9e156f,
    backendName: 'webgl',
    kernelFunc: $4bd891ab18ed24a2$export$14e793fe8822afd1
};



class $8513d962bb52e8f5$export$9f5b7866589daeae {
    constructor(convInfo){
        this.variableNames = [
            'x',
            'dy'
        ];
        this.outputShape = convInfo.filterShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = convInfo.padInfo.top;
        const padLeft = convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $8513d962bb52e8f5$export$9b7e054f73b1374b {
    constructor(convInfo){
        this.variableNames = [
            'dy',
            'W'
        ];
        this.outputShape = convInfo.inShape;
        const filterHeight = convInfo.filterHeight;
        const filterWidth = convInfo.filterWidth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const padTop = filterHeight - 1 - convInfo.padInfo.top;
        const padLeft = filterWidth - 1 - convInfo.padInfo.left;
        const channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}


function $2e3c52dbd327acba$export$cc0ae65e9edc7e1a(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , dy: dy  } = inputs;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode , filterShape: filterShape  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad, dimRoundingMode, true);
    const program = new $8513d962bb52e8f5$export$9f5b7866589daeae(convInfo);
    return backend.runWebGLProgram(program, [
        x,
        dy
    ], 'float32');
}
const $2e3c52dbd327acba$export$30bc0ac3775583fc = {
    kernelName: $2b76be1e72a8c1db$export$c99f139e0d4d1833,
    backendName: 'webgl',
    kernelFunc: $2e3c52dbd327acba$export$cc0ae65e9edc7e1a
};




function $a57c258ea915c992$export$37e2ab95a4a4c24b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , filter: filter  } = inputs;
    const { strides: strides , dilations: dilations , pad: pad , dimRoundingMode: dimRoundingMode , inputShape: inputShape  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
    const program = new $8513d962bb52e8f5$export$9b7e054f73b1374b(convInfo);
    return backend.runWebGLProgram(program, [
        dy,
        filter
    ], 'float32');
}
const $a57c258ea915c992$export$55d12409e744bebe = {
    kernelName: $2b76be1e72a8c1db$export$8649ca3b17033a24,
    backendName: 'webgl',
    kernelFunc: $a57c258ea915c992$export$37e2ab95a4a4c24b
};



class $aad8e25e69540282$export$d3d3824ae4245092 {
    constructor(size){
        this.variableNames = [
            'X'
        ];
        this.outputShape = [
            size,
            size
        ];
        this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
}



function $091e55739e5ee000$export$c042e7c2f59bc046(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    const outShape = [
        ...x.shape,
        ...x.shape
    ];
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const flat = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: [
                xSize
            ]
        }
    });
    const program = new $aad8e25e69540282$export$d3d3824ae4245092(xSize);
    const res = backend.runWebGLProgram(program, [
        flat
    ], flat.dtype);
    const out = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    backend.disposeIntermediateTensorInfo(flat);
    backend.disposeIntermediateTensorInfo(res);
    return out;
}
const $091e55739e5ee000$export$56dc5d812a22748f = {
    kernelName: $2b76be1e72a8c1db$export$ca73a25315ddeb7f,
    backendName: 'webgl',
    kernelFunc: $091e55739e5ee000$export$c042e7c2f59bc046
};



class $972dfad3d70c73d5$export$b3acfd0493b4c03e {
    constructor(convInfo){
        this.variableNames = [
            'x',
            'W'
        ];
        this.outputShape = convInfo.outShape;
        const { inHeight: inHeight , inWidth: inWidth , padInfo: padInfo , strideHeight: strideHeight , strideWidth: strideWidth , filterHeight: filterHeight , filterWidth: filterWidth , dilationHeight: dilationHeight , dilationWidth: dilationWidth  } = convInfo;
        const { top: padTop , left: padLeft  } = padInfo;
        this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
}



function $2edff178331161bc$export$544ec6096a7ab30(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computeDilation2DInfo(x.shape, filter.shape, strides, pad, 'NHWC' /* dataFormat */ , dilations);
    let out;
    const program = new $972dfad3d70c73d5$export$b3acfd0493b4c03e(convInfo);
    out = backend.runWebGLProgram(program, [
        x,
        filter
    ], 'float32');
    const outReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: out
        },
        backend: backend,
        attrs: {
            shape: convInfo.outShape
        }
    });
    backend.disposeIntermediateTensorInfo(out);
    return outReshaped;
}
const $2edff178331161bc$export$36d3c11f61a8891a = {
    kernelName: $2b76be1e72a8c1db$export$dbbb7830c6497701,
    backendName: 'webgl',
    kernelFunc: $2edff178331161bc$export$544ec6096a7ab30
};







function $fed02f0f05b3debc$export$27265e7daac5c403(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { equation: equation  } = attrs;
    const tensors = inputs;
    const { allDims: allDims , summedDims: summedDims , idDims: idDims  } = $510a55f99d61727a$exports.decodeEinsumEquation(equation, tensors.length);
    $510a55f99d61727a$exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path: path , steps: steps  } = $510a55f99d61727a$exports.getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for(let i = 0; i < nSteps; ++i){
        for (const idTerm of steps[i]){
            const { permutationIndices: perm , expandDims: dimsToExpand  } = $510a55f99d61727a$exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
            let x;
            if ($510a55f99d61727a$exports.isIdentityPermutation(perm)) x = tensors[idTerm];
            else {
                x = $fe12dc0e164e619f$export$9cb09a71b7d66923({
                    inputs: {
                        x: tensors[idTerm]
                    },
                    backend: backend,
                    attrs: {
                        perm: perm
                    }
                });
                tensorsToDispose.push(x);
            }
            const targetShape = x.shape.slice();
            for(let k = 0; k < dimsToExpand.length; ++k)targetShape.splice(dimsToExpand[k], 0, 1);
            if (!$f6b55a2021b78f0d$exports.arraysEqual(x.shape, targetShape)) {
                x = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
                    inputs: {
                        x: x
                    },
                    backend: backend,
                    attrs: {
                        shape: targetShape
                    }
                });
                tensorsToDispose.push(x);
            }
            if (out === null) out = x;
            else {
                // tslint:disable-next-line: no-unnecessary-type-assertion
                out = $5990c68e2ef3564e$export$2060d2db72cce88f({
                    inputs: {
                        a: x,
                        b: out
                    },
                    backend: backend
                });
                tensorsToDispose.push(out);
            }
        }
        if (i < nSteps - 1) {
            if (path[i] >= 0) {
                out = $da8ee0e3114a74ea$export$8a63f25cc62965f1({
                    inputs: {
                        x: out
                    },
                    backend: backend,
                    attrs: {
                        axis: path[i] - (allDims.length - numDimsRemaining),
                        keepDims: false
                    }
                });
                tensorsToDispose.push(out);
            }
            numDimsRemaining--;
        }
    }
    // Clean up intermediate tensors.
    for (const tensorInfo of tensorsToDispose){
        if (tensorInfo === out) continue;
        backend.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
}
const $fed02f0f05b3debc$export$40bbf341885a23b7 = {
    kernelName: $2b76be1e72a8c1db$export$2541d8be32f3c641,
    backendName: 'webgl',
    kernelFunc: $fed02f0f05b3debc$export$27265e7daac5c403
};




const $69fd5438d450bf2e$var$ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
const $69fd5438d450bf2e$var$ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
const $69fd5438d450bf2e$var$elu = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $69fd5438d450bf2e$var$ELU,
    packedOpSnippet: $69fd5438d450bf2e$var$ELU_PACKED
});
const $69fd5438d450bf2e$export$b990686634ee3cce = {
    kernelName: $2b76be1e72a8c1db$export$64636e173424d83d,
    backendName: 'webgl',
    kernelFunc: $69fd5438d450bf2e$var$elu
};





const $5b4b6916b6294c87$var$ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
const $5b4b6916b6294c87$var$ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
const $5b4b6916b6294c87$export$a346244024505ff9 = (args)=>{
    const { inputs: inputs , backend: backend  } = args;
    const { dy: dy , y: y  } = inputs;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_BINARY_OPERATIONS') ? new $ae8429d0c17ef751$export$7ef3bdc75c177be0($5b4b6916b6294c87$var$ELU_DER_PACKED, dy.shape, y.shape) : new $217996ba39efcc29$export$9045e9161086790b($5b4b6916b6294c87$var$ELU_DER, dy.shape, y.shape);
    return backend.runWebGLProgram(program, [
        dy,
        y
    ], dy.dtype);
};
const $5b4b6916b6294c87$export$59bb07dd04647a1d = {
    kernelName: $2b76be1e72a8c1db$export$9906be4699a73c53,
    backendName: 'webgl',
    kernelFunc: $5b4b6916b6294c87$export$a346244024505ff9
};





const $bed0499ce686b622$var$PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
const $bed0499ce686b622$var$EQUAL = `return float(a == b);`;
const $bed0499ce686b622$export$411ce8e5a71e3069 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $bed0499ce686b622$var$EQUAL,
    packedOpSnippet: $bed0499ce686b622$var$PACKED_EQUAL,
    dtype: 'bool',
    cpuKernelImpl: $31b15458ffa33a6b$export$13d1298222b29d06
});
const $bed0499ce686b622$export$3c8bc3d8ee318217 = {
    kernelName: $2b76be1e72a8c1db$export$8dcf9f58ce5cdfc,
    backendName: 'webgl',
    kernelFunc: $bed0499ce686b622$export$411ce8e5a71e3069
};




const $812b41e295715b9e$var$ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${$510a55f99d61727a$exports.ERF_P};
  float a1 = ${$510a55f99d61727a$exports.ERF_A1};
  float a2 = ${$510a55f99d61727a$exports.ERF_A2};
  float a3 = ${$510a55f99d61727a$exports.ERF_A3};
  float a4 = ${$510a55f99d61727a$exports.ERF_A4};
  float a5 = ${$510a55f99d61727a$exports.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
const $812b41e295715b9e$export$d3896f355fc09423 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $812b41e295715b9e$var$ERF
});
const $812b41e295715b9e$export$d044ffef16079bd = {
    kernelName: $2b76be1e72a8c1db$export$c2ee2551ce71f1d0,
    backendName: 'webgl',
    kernelFunc: $812b41e295715b9e$export$d3896f355fc09423
};





const $7a9db68544dd1ea9$export$e17bfbab9ca97165 = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return exp(x);
`;
const $7a9db68544dd1ea9$var$EXP_PACKED = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $7a9db68544dd1ea9$export$b310ec824aaee37f = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $7a9db68544dd1ea9$export$e17bfbab9ca97165,
    packedOpSnippet: $7a9db68544dd1ea9$var$EXP_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$f72e179c9610cb8c,
    dtype: 'float32'
});
const $7a9db68544dd1ea9$export$2fd7ea0fcf021f34 = {
    kernelName: $2b76be1e72a8c1db$export$f908be7a96fb3363,
    backendName: 'webgl',
    kernelFunc: $7a9db68544dd1ea9$export$b310ec824aaee37f
};




function $8abb1069efe45ee9$export$d660d8ed21f46635(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { dim: dim  } = attrs;
    const { input: input  } = inputs;
    const inputRank = input.shape.length;
    const newShape = input.shape.slice();
    let $dim = dim;
    if (dim < 0) {
        // Negative value is counted from the tail of rank.
        $f6b55a2021b78f0d$exports.assert(-(inputRank + 1) <= dim, ()=>`Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`
        );
        $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: input
        },
        backend: backend,
        attrs: {
            shape: newShape
        }
    });
}
const $8abb1069efe45ee9$export$86341ba0ce5d8e60 = {
    kernelName: $2b76be1e72a8c1db$export$2391750b1d901146,
    backendName: 'webgl',
    kernelFunc: $8abb1069efe45ee9$export$d660d8ed21f46635
};





const $fd543a585a6c8fd3$var$EXPM1 = `return exp(x) - 1.0;`;
const $fd543a585a6c8fd3$export$b6c0a80d46d3391d = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $fd543a585a6c8fd3$var$EXPM1,
    packedOpSnippet: $fd543a585a6c8fd3$var$EXPM1,
    cpuKernelImpl: $31b15458ffa33a6b$export$5903785c29f035f5
});
const $fd543a585a6c8fd3$export$16db8a08b36f938 = {
    kernelName: $2b76be1e72a8c1db$export$261f26143a1ff3,
    backendName: 'webgl',
    kernelFunc: $fd543a585a6c8fd3$export$b6c0a80d46d3391d
};




class $a207b5c1e5a882cf$export$234ba885e3a114f6 {
    constructor(component, inputShape, inverse){
        this.variableNames = [
            'real',
            'imag'
        ];
        const innerDim = inputShape[1];
        this.outputShape = inputShape;
        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
        const resultDenominator = inverse ? `${innerDim}.0` : '1.0';
        let opString;
        if (component === 'real') opString = 'return real * expR - imag * expI;';
        else if (component === 'imag') opString = 'return real * expI + imag * expR;';
        else throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
        this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
}




function $d65fc7c08f98d914$export$75d3742a7578721e(x, inverse, backend) {
    const xData = backend.texData.get(x.dataId);
    const inputSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    // Collapse all outer dimensions to a single batch dimension.
    const innerDimensionSize = x.shape[x.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: [
                batch,
                innerDimensionSize
            ]
        }
    });
    const xShape = input2D.shape;
    const realProgram = new $a207b5c1e5a882cf$export$234ba885e3a114f6('real', xShape, inverse);
    const imagProgram = new $a207b5c1e5a882cf$export$234ba885e3a114f6('imag', xShape, inverse);
    const inputs = [
        {
            dataId: xData.complexTensorInfos.real.dataId,
            dtype: xData.complexTensorInfos.real.dtype,
            shape: xShape
        },
        {
            dataId: xData.complexTensorInfos.imag.dataId,
            dtype: xData.complexTensorInfos.imag.dtype,
            shape: xShape
        }
    ];
    const realPart = backend.runWebGLProgram(realProgram, inputs, 'float32');
    const imagPart = backend.runWebGLProgram(imagProgram, inputs, 'float32');
    const complexOutput = $1e4941852430620a$export$83a0e34f1302825b({
        inputs: {
            real: realPart,
            imag: imagPart
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(realPart);
    backend.disposeIntermediateTensorInfo(imagPart);
    const complexOutputReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: complexOutput
        },
        backend: backend,
        attrs: {
            shape: x.shape
        }
    });
    backend.disposeIntermediateTensorInfo(input2D);
    backend.disposeIntermediateTensorInfo(complexOutput);
    return complexOutputReshaped;
}


function $d2d80b8778ce7f72$export$a535ef183b6128fa(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    return $d65fc7c08f98d914$export$75d3742a7578721e(input, false, backend);
}
const $d2d80b8778ce7f72$export$a4d564e380763c78 = {
    kernelName: $2b76be1e72a8c1db$export$677347237c014ba,
    backendName: 'webgl',
    kernelFunc: $d2d80b8778ce7f72$export$a535ef183b6128fa
};



class $66fd954f06bc9a5c$export$758181b12323e997 {
    constructor(shape, value){
        this.outputShape = [];
        this.customUniforms = [
            {
                name: 'value',
                type: 'float'
            }
        ];
        this.variableNames = [
            'x'
        ];
        this.outputShape = shape;
        this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
}


function $7b5b8f61a189e939$export$9563e054e6f787fb(args) {
    const { backend: backend , attrs: attrs  } = args;
    const { shape: shape , value: value  } = attrs;
    let { dtype: dtype  } = attrs;
    dtype = dtype || $f6b55a2021b78f0d$exports.inferDtype(value);
    if (dtype === 'string') {
        // String type should be handled in CPU memory.
        const values = $f6b55a2021b78f0d$exports.getArrayFromDType(dtype, $f6b55a2021b78f0d$exports.sizeFromShape(shape));
        values.fill(value);
        return backend.makeTensorInfo(shape, dtype, values);
    } else {
        const program = new $66fd954f06bc9a5c$export$758181b12323e997(shape, value);
        const customValues = [
            [
                value
            ]
        ];
        return backend.runWebGLProgram(program, [], dtype, customValues);
    }
}
const $7b5b8f61a189e939$export$c953bf474b2bde62 = {
    kernelName: $2b76be1e72a8c1db$export$ffffe40bfa0649a3,
    backendName: 'webgl',
    kernelFunc: $7b5b8f61a189e939$export$9563e054e6f787fb
};



class $f7b2102f372017f1$export$872622c1de722f28 {
    constructor(imageShape){
        this.variableNames = [
            'Image'
        ];
        this.outputShape = [];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}


const $d177adedca2b684b$export$c9ec83cb23304466 = {
    kernelName: $2b76be1e72a8c1db$export$34e7296fc8558df5,
    backendName: 'webgl',
    kernelFunc: ({ inputs: inputs , backend: backend  })=>{
        const { image: image  } = inputs;
        const webglBackend = backend;
        const program = new $f7b2102f372017f1$export$872622c1de722f28(image.shape);
        const output = webglBackend.runWebGLProgram(program, [
            image
        ], image.dtype);
        return output;
    }
};





const $d36f43f784cd7595$var$FLOOR = `return floor(x);`;
const $d36f43f784cd7595$export$a3fe094919f356fd = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $d36f43f784cd7595$var$FLOOR,
    packedOpSnippet: $d36f43f784cd7595$var$FLOOR,
    cpuKernelImpl: $31b15458ffa33a6b$export$195a28e6add8ab7e
});
const $d36f43f784cd7595$export$7e9a0f96fa6bd01c = {
    kernelName: $2b76be1e72a8c1db$export$4880b0ae5643c62b,
    backendName: 'webgl',
    kernelFunc: $d36f43f784cd7595$export$a3fe094919f356fd
};




// We use native integer division to deal with floating point imprecision. Since
// we implement floor division and glsl implements truncated division, we
// correct for this by subtracting 1 from result when the result is negative and
// there is a remainder.
const $09a1d39c327224ad$var$INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
const $09a1d39c327224ad$var$INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
const $09a1d39c327224ad$export$112397bc52715a8 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $09a1d39c327224ad$var$INT_DIV,
    packedOpSnippet: $09a1d39c327224ad$var$INT_DIV_PACKED,
    dtype: 'int32'
});
const $09a1d39c327224ad$export$7eac933a0c7fd37f = {
    kernelName: $2b76be1e72a8c1db$export$d79b5692ede26c2f,
    backendName: 'webgl',
    kernelFunc: $09a1d39c327224ad$export$112397bc52715a8
};






class $2a778d51eca6568e$export$7ffba7be7a218615 {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        const [height, width, ] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
}



class $daa41bff38818e40$export$5f4cf05de268f9cf {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = false;
        this.packedOutput = true;
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        const [height, width, ] = outputShape;
        this.outputShape = outputShape;
        this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
    }
}


const $4a02d804f2d95551$export$b22e14d614fc7178 = {
    kernelName: $2b76be1e72a8c1db$export$d0eb4e7054966c48,
    backendName: 'webgl',
    kernelFunc: $4a02d804f2d95551$var$fromPixels
};
let $4a02d804f2d95551$var$fromPixels2DContext;
function $4a02d804f2d95551$var$fromPixels(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    let { pixels: pixels  } = inputs;
    const { numChannels: numChannels  } = attrs;
    const isVideo = typeof HTMLVideoElement !== 'undefined' && pixels instanceof HTMLVideoElement;
    const isImage = typeof HTMLImageElement !== 'undefined' && pixels instanceof HTMLImageElement;
    const [width, height] = isVideo ? [
        pixels.videoWidth,
        pixels.videoHeight
    ] : [
        pixels.width,
        pixels.height
    ];
    const texShape = [
        height,
        width
    ];
    const outShape = [
        height,
        width,
        numChannels
    ];
    if (isImage || isVideo) {
        if ($4a02d804f2d95551$var$fromPixels2DContext == null) $4a02d804f2d95551$var$fromPixels2DContext = document.createElement('canvas').getContext('2d');
        $4a02d804f2d95551$var$fromPixels2DContext.canvas.width = width;
        $4a02d804f2d95551$var$fromPixels2DContext.canvas.height = height;
        $4a02d804f2d95551$var$fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
        pixels = $4a02d804f2d95551$var$fromPixels2DContext.canvas;
    }
    const tempPixelHandle = backend.makeTensorInfo(texShape, 'int32');
    // This is a byte texture with pixels.
    backend.texData.get(tempPixelHandle.dataId).usage = $7ea242d526563f56$export$6bf4bd1b6beb0bfd.PIXELS;
    backend.gpgpu.uploadPixelDataToTexture(backend.getTexture(tempPixelHandle.dataId), pixels);
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK') ? new $daa41bff38818e40$export$5f4cf05de268f9cf(outShape) : new $2a778d51eca6568e$export$7ffba7be7a218615(outShape);
    const res = backend.runWebGLProgram(program, [
        tempPixelHandle
    ], 'int32');
    backend.disposeData(tempPixelHandle.dataId);
    return res;
}







function $f0c6f5d4ca6a2b90$export$b4f4a900a93010a(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dataFormat: dataFormat , dilations: dilations , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    const $dataFormat = $510a55f99d61727a$exports.convertConv2DDataFormat(dataFormat);
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad, dimRoundingMode, false, $dataFormat);
    let out;
    const intermediates = [];
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) out = $a83ace48abb59807$export$fe56ce0f8b4bfd45({
        x: x,
        filter: filter,
        convInfo: convInfo,
        backend: backend,
        bias: bias,
        activation: activation,
        preluActivationWeights: preluActivationWeights,
        leakyreluAlpha: leakyreluAlpha
    });
    else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_CONV_IM2COL') && x.shape[0] === 1) out = $a83ace48abb59807$export$65b699e5c77381b8({
        x: x,
        filter: filter,
        convInfo: convInfo,
        backend: backend,
        bias: bias,
        activation: activation,
        preluActivationWeights: preluActivationWeights,
        leakyreluAlpha: leakyreluAlpha
    });
    else {
        const hasBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        const hasLeakyreluAlpha = activation === 'leakyrelu';
        const fusedActivation = activation ? $f569887d6243ad0e$export$445d43a4039ec7b7(activation, false) : null;
        const program = new $2fec09c59342cab5$export$8dc36706147178e9(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
        const inputs = [
            x,
            filter
        ];
        if (bias) inputs.push(bias);
        if (preluActivationWeights) inputs.push(preluActivationWeights);
        if (hasLeakyreluAlpha) {
            const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(leakyreluAlpha, 'float32'));
            inputs.push($leakyreluAlpha);
            intermediates.push($leakyreluAlpha);
        }
        out = backend.runWebGLProgram(program, inputs, 'float32');
    }
    const outReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: out
        },
        backend: backend,
        attrs: {
            shape: convInfo.outShape
        }
    });
    intermediates.push(out);
    intermediates.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return outReshaped;
}
const $f0c6f5d4ca6a2b90$export$5b64efa829ddf94e = {
    kernelName: $2b76be1e72a8c1db$export$86f8a8e3a8f2a8f2,
    backendName: 'webgl',
    kernelFunc: $f0c6f5d4ca6a2b90$export$b4f4a900a93010a
};






function $b3757af6f1833cb0$export$d61de7729228094b(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , filter: filter , bias: bias , preluActivationWeights: preluActivationWeights  } = inputs;
    const { strides: strides , pad: pad , dilations: dilations , dimRoundingMode: dimRoundingMode , activation: activation , leakyreluAlpha: leakyreluAlpha  } = attrs;
    const intermediates = [];
    let $dilations = dilations;
    if ($dilations == null) $dilations = [
        1,
        1
    ];
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, $dilations), ()=>'Error in depthwiseConv2d: Either strides or dilations must be ' + `1. Got strides ${strides} and dilations '${$dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad, dimRoundingMode, true);
    const shouldPackDepthwiseConv = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_DEPTHWISECONV') && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
    const fusedActivation = activation ? $f569887d6243ad0e$export$445d43a4039ec7b7(activation, shouldPackDepthwiseConv) : null;
    const programInputs = [
        x,
        filter
    ];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === 'leakyrelu';
    if (hasBias) programInputs.push(bias);
    if (hasPreluActivationWeights) programInputs.push(preluActivationWeights);
    if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend.makeTensorInfo([], 'float32', $f6b55a2021b78f0d$exports.createScalarValue(leakyreluAlpha, 'float32'));
        programInputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
    }
    let program;
    if (shouldPackDepthwiseConv) program = new $6b0494a9da79ad6a$export$acb9287627a2b170(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    else program = new $44523a22f808d266$export$4ead5a4ba22ede40(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const customValues = [
        [
            convInfo.padInfo.top,
            convInfo.padInfo.left
        ],
        [
            convInfo.strideHeight,
            convInfo.strideWidth
        ],
        [
            convInfo.dilationHeight,
            convInfo.dilationWidth
        ],
        [
            convInfo.inHeight,
            convInfo.inWidth
        ]
    ];
    const result = backend.runWebGLProgram(program, programInputs, 'float32', customValues);
    intermediates.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
}
const $b3757af6f1833cb0$export$58481cc3409b412c = {
    kernelName: $2b76be1e72a8c1db$export$5a249e8f498c02c1,
    backendName: 'webgl',
    kernelFunc: $b3757af6f1833cb0$export$d61de7729228094b
};




class $12844d0ff44bb0c3$export$ffd508d535a7dba1 {
    constructor(sliceDim, strides, shape){
        this.sliceDim = sliceDim;
        this.strides = strides;
        this.variableNames = [
            'x',
            'indices'
        ];
        this.outputShape = shape;
        const stridesType = $fbbfeeecbf2420a1$export$859efd105c10c755(strides.length);
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(shape.length);
        const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
    }
}




function $8dce7e04a22e9508$export$3c586830e482d2b9(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { params: params , indices: indices  } = inputs;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const paramsSize = $f6b55a2021b78f0d$exports.sizeFromShape(params.shape);
    const [resultShape, numSlices, sliceSize, strides] = $510a55f99d61727a$exports.prepareAndValidate(params, indices);
    const flattenIndices = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            shape: [
                numSlices,
                sliceRank
            ]
        }
    });
    const flattenX = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: params
        },
        backend: backend,
        attrs: {
            shape: [
                $f6b55a2021b78f0d$exports.sizeFromShape(params.shape) / sliceSize,
                sliceSize
            ]
        }
    });
    if (backend.shouldExecuteOnCPU([
        params,
        indices
    ]) || params.dtype === 'string') {
        const indicesData = backend.readSync(indices.dataId);
        const paramsBuf = backend.bufferSync(params);
        const outValue = $31b15458ffa33a6b$export$e3196a12dce24214(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
        return backend.makeTensorInfo(resultShape, params.dtype, outValue.values);
    }
    const program = new $12844d0ff44bb0c3$export$ffd508d535a7dba1(sliceRank, strides, [
        numSlices,
        sliceSize
    ]);
    const res = backend.runWebGLProgram(program, [
        flattenX,
        flattenIndices
    ], flattenX.dtype);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            shape: resultShape
        }
    });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
}
const $8dce7e04a22e9508$export$d9700eb1c7f5c969 = {
    kernelName: $2b76be1e72a8c1db$export$4ef6e37a23721703,
    backendName: 'webgl',
    kernelFunc: $8dce7e04a22e9508$export$3c586830e482d2b9
};




class $45c3e0b92a699014$export$e8921930334c8ed5 {
    constructor(aShape, outputShape){
        this.variableNames = [
            'A',
            'indices'
        ];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        const sourceCoords = $45c3e0b92a699014$var$getSourceCoords(aShape, 2);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${aShape[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${sourceCoords}));
      }
    `;
    }
}
// The input and output are always flattened into rank 4 tensors.
function $45c3e0b92a699014$var$getSourceCoords(aShape, axis) {
    const currentCoords = [
        'resRC.x',
        'resRC.y',
        'resRC.z',
        'resRC.w'
    ];
    const sourceCoords = [];
    for(let i = 0; i < aShape.length; i++)if (i === 2) sourceCoords.push('index');
    else sourceCoords.push(`${currentCoords[i]}`);
    return sourceCoords.join();
}




function $d6a8183309191047$export$3d75b4295ded9925(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , indices: indices  } = inputs;
    const { axis: axis , batchDims: batchDims  } = attrs;
    const parsedAxis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('DEBUG')) {
        // In debug mode, throw error when any index is out of bound.
        // Otherwise, just fill out of bounds with zeroes.
        const indicesVals = backend.readSync(indices.dataId);
        const axisDim = x.shape[parsedAxis];
        for(let i = 0; i < indicesVals.length; ++i){
            const index = indicesVals[i];
            $f6b55a2021b78f0d$exports.assert(index <= axisDim - 1 && index >= 0, ()=>`GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`
            );
        }
    }
    const shapeInfo = $510a55f99d61727a$exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const indicesSize = $f6b55a2021b78f0d$exports.sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: [
                shapeInfo.batchSize,
                shapeInfo.outerSize,
                shapeInfo.dimSize,
                shapeInfo.sliceSize
            ]
        }
    });
    const flattenIndex = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            shape: [
                shapeInfo.batchSize,
                indicesSize / shapeInfo.batchSize
            ]
        }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        indicesSize / shapeInfo.batchSize,
        shapeInfo.sliceSize
    ];
    if (backend.shouldExecuteOnCPU([
        x,
        indices
    ]) || x.dtype === 'string') {
        const indicesBuf = backend.bufferSync(flattenIndex);
        const xBuf = backend.bufferSync(flattenX);
        const outBuf = $31b15458ffa33a6b$export$cffe0fde89e98de6(xBuf, indicesBuf, flattenOutputShape);
        toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
        );
        return backend.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new $45c3e0b92a699014$export$e8921930334c8ed5(flattenX.shape, flattenOutputShape);
    const res = backend.runWebGLProgram(program, [
        flattenX,
        flattenIndex
    ], flattenX.dtype);
    toDispose.push(res);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            shape: shapeInfo.outputShape
        }
    });
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return reshaped;
}
const $d6a8183309191047$export$b1bd3139c91d8765 = {
    kernelName: $2b76be1e72a8c1db$export$ccd988942e5c0181,
    backendName: 'webgl',
    kernelFunc: $d6a8183309191047$export$3d75b4295ded9925
};





const $18c4147b9607e4cf$var$GREATER = `return float(a > b);`;
const $18c4147b9607e4cf$var$GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
const $18c4147b9607e4cf$export$9dca161faaf6308b = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $18c4147b9607e4cf$var$GREATER,
    packedOpSnippet: $18c4147b9607e4cf$var$GREATER_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$eabb8927944259dd,
    dtype: 'bool'
});
const $18c4147b9607e4cf$export$8c4f7e92d92310f8 = {
    kernelName: $2b76be1e72a8c1db$export$d0a25eac5ee3f515,
    backendName: 'webgl',
    kernelFunc: $18c4147b9607e4cf$export$9dca161faaf6308b
};





const $4dca33563fa942df$var$GREATER_EQUAL = `return float(a >= b);`;
const $4dca33563fa942df$var$GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
const $4dca33563fa942df$export$c2fd4164cadc1fa2 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $4dca33563fa942df$var$GREATER_EQUAL,
    packedOpSnippet: $4dca33563fa942df$var$GREATER_EQUAL_PACKED,
    dtype: 'bool',
    cpuKernelImpl: $31b15458ffa33a6b$export$a3d2e203d979d298
});
const $4dca33563fa942df$export$7a6926f9fcac24ca = {
    kernelName: $2b76be1e72a8c1db$export$3b7d21bc9aee0851,
    backendName: 'webgl',
    kernelFunc: $4dca33563fa942df$export$c2fd4164cadc1fa2
};





function $38d01a36ce3f8dd5$export$776649b0bf8ce1fd(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { input: input  } = inputs;
    return $d65fc7c08f98d914$export$75d3742a7578721e(input, true, backend);
}
const $38d01a36ce3f8dd5$export$dc267425bf21b465 = {
    kernelName: $2b76be1e72a8c1db$export$21c6f576ae8100e8,
    backendName: 'webgl',
    kernelFunc: $38d01a36ce3f8dd5$export$776649b0bf8ce1fd
};





const $c969c8588a456fcd$var$IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
const $c969c8588a456fcd$export$65f0b13f2f82375a = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $c969c8588a456fcd$var$IS_FINITE,
    dtype: 'bool'
});
const $c969c8588a456fcd$export$4d45c8f7b9ffdaf1 = {
    kernelName: $2b76be1e72a8c1db$export$b9fcc0946d7d485e,
    backendName: 'webgl',
    kernelFunc: $c969c8588a456fcd$export$65f0b13f2f82375a
};




const $2b51ad6a2f594a3b$var$IS_INF = `return float(isinf(x));`;
const $2b51ad6a2f594a3b$export$e5d3415c656f7096 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $2b51ad6a2f594a3b$var$IS_INF,
    dtype: 'bool'
});
const $2b51ad6a2f594a3b$export$bc383b82282e9b5a = {
    kernelName: $2b76be1e72a8c1db$export$74b5a3bc735b152,
    backendName: 'webgl',
    kernelFunc: $2b51ad6a2f594a3b$export$e5d3415c656f7096
};




const $7d141e221d55c17d$var$IS_NAN = `return float(isnan(x));`;
const $7d141e221d55c17d$export$c9f5652083b8129d = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $7d141e221d55c17d$var$IS_NAN,
    dtype: 'bool'
});
const $7d141e221d55c17d$export$d58ff790c765c1f0 = {
    kernelName: $2b76be1e72a8c1db$export$9912dc4fc649dbec,
    backendName: 'webgl',
    kernelFunc: $7d141e221d55c17d$export$c9f5652083b8129d
};






const $5ab8be00f0fecb22$var$LESS = `return float(a < b);`;
const $5ab8be00f0fecb22$var$LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
const $5ab8be00f0fecb22$export$bb1a638da8ad190f = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $5ab8be00f0fecb22$var$LESS,
    packedOpSnippet: $5ab8be00f0fecb22$var$LESS_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$74c893b3c5e74e60,
    dtype: 'bool'
});
const $5ab8be00f0fecb22$export$8d4530ce8b6ffc3c = {
    kernelName: $2b76be1e72a8c1db$export$728c50f1c88ac779,
    backendName: 'webgl',
    kernelFunc: $5ab8be00f0fecb22$export$bb1a638da8ad190f
};





const $07ea39d8180241c0$export$8342242c3b80421d = `return float(a <= b);`;
const $07ea39d8180241c0$export$b12559c17f42d056 = `
  return vec4(lessThanEqual(a, b));
`;
const $07ea39d8180241c0$export$c24ad19a692bb92 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $07ea39d8180241c0$export$8342242c3b80421d,
    packedOpSnippet: $07ea39d8180241c0$export$b12559c17f42d056,
    cpuKernelImpl: $31b15458ffa33a6b$export$6d1533a3ea9565f,
    dtype: 'bool'
});
const $07ea39d8180241c0$export$9f26bd257393dd8 = {
    kernelName: $2b76be1e72a8c1db$export$84afd0d8f7fb8c5d,
    backendName: 'webgl',
    kernelFunc: $07ea39d8180241c0$export$c24ad19a692bb92
};




function $7672231b0fc85b4d$export$865a19adce4d7a46(args) {
    const { backend: backend , attrs: attrs  } = args;
    const { start: start , stop: stop , num: num  } = attrs;
    // TODO: Use CPU implementation due to the precision problem in Safari.
    const outVals = $31b15458ffa33a6b$export$c86a2be8970d7a7d(start, stop, num);
    return backend.makeTensorInfo([
        outVals.length
    ], 'float32', outVals);
}
const $7672231b0fc85b4d$export$46b96f742c70959b = {
    kernelName: $2b76be1e72a8c1db$export$34f0ab8eba543ee6,
    backendName: 'webgl',
    kernelFunc: $7672231b0fc85b4d$export$865a19adce4d7a46
};





// Windows chrome return 0 if the input is negative value. We will specifically
// return NaN if the input is 0 to solve compatiblity issue.
const $050a0cb48ea72936$var$LOG = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return x < 0.0 ? 0./0. : log(x);
`;
const $050a0cb48ea72936$var$LOG_PACKED = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`;
const $050a0cb48ea72936$export$bef1f36f5486a6a3 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $050a0cb48ea72936$var$LOG,
    packedOpSnippet: $050a0cb48ea72936$var$LOG_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$e88dde64a338f813
});
const $050a0cb48ea72936$export$a4ae1f00643ddd14 = {
    kernelName: $2b76be1e72a8c1db$export$ce30dbb46644d06c,
    backendName: 'webgl',
    kernelFunc: $050a0cb48ea72936$export$bef1f36f5486a6a3
};




const $cbe0b9adb007fc5b$var$LOG1P = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return log(1.0 + x);
`;
const $cbe0b9adb007fc5b$export$144dcf16adfb9698 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $cbe0b9adb007fc5b$var$LOG1P
});
const $cbe0b9adb007fc5b$export$c458b9e5ba980198 = {
    kernelName: $2b76be1e72a8c1db$export$70f05bf9ddcfca68,
    backendName: 'webgl',
    kernelFunc: $cbe0b9adb007fc5b$export$144dcf16adfb9698
};




const $c3ec187d6ff1e6c3$var$LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
const $c3ec187d6ff1e6c3$var$LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
const $c3ec187d6ff1e6c3$export$db5dd0ef9d505f = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $c3ec187d6ff1e6c3$var$LOGICAL_AND,
    packedOpSnippet: $c3ec187d6ff1e6c3$var$LOGICAL_AND_PACKED,
    dtype: 'bool'
});
const $c3ec187d6ff1e6c3$export$257f1e82e69113fb = {
    kernelName: $2b76be1e72a8c1db$export$8a27ff10dff4d6e5,
    backendName: 'webgl',
    kernelFunc: $c3ec187d6ff1e6c3$export$db5dd0ef9d505f
};




const $bf19cf2393aade9c$var$LOGICAL_NOT = `return float(!(x >= 1.0));`;
const $bf19cf2393aade9c$export$c836ff7b605b1617 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $bf19cf2393aade9c$var$LOGICAL_NOT
});
const $bf19cf2393aade9c$export$68e2dd0840056271 = {
    kernelName: $2b76be1e72a8c1db$export$4393bee5596c68c2,
    backendName: 'webgl',
    kernelFunc: $bf19cf2393aade9c$export$c836ff7b605b1617
};




const $fe6c1844a32dc31c$var$LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
const $fe6c1844a32dc31c$var$LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
const $fe6c1844a32dc31c$export$e2a73975983cadd8 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $fe6c1844a32dc31c$var$LOGICAL_OR,
    packedOpSnippet: $fe6c1844a32dc31c$var$LOGICAL_OR_PACKED,
    dtype: 'bool'
});
const $fe6c1844a32dc31c$export$ce04b6546987ef43 = {
    kernelName: $2b76be1e72a8c1db$export$c49f9f5ffc6f678c,
    backendName: 'webgl',
    kernelFunc: $fe6c1844a32dc31c$export$e2a73975983cadd8
};



class $449cc3bf67d152ba$export$2214c2ca22968528 {
    constructor(xShape, radius, bias, alpha, beta){
        this.variableNames = [
            'x'
        ];
        this.outputShape = [];
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        // optimize pow(bias + alpha * sum, -beta)
        // src: https://github.com/tensorflow/tensorflow/..
        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..
        // tensorflow/core/kernels/mkl_lrn_op.cc#L320
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) powOperator = `inversesqrt(${basis})`;
        else if (beta === 1.0) powOperator = `1.0/(${basis})`;
        else powOperator = `exp(log(${basis}) * float(-${beta}));`;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
    }
}


class $e1c378a87219b2fb$export$3942340f6b6d7fe9 {
    constructor(xShape, radius, bias, alpha, beta){
        this.variableNames = [
            'x'
        ];
        this.outputShape = [];
        this.packedInputs = true;
        this.packedOutput = true;
        const rad = radius;
        const maxD = xShape[3] - 1;
        this.outputShape = xShape;
        // optimize pow(bias + alpha * sum, -beta)
        // src: https://github.com/tensorflow/tensorflow/..
        // blob/26033a1644a9c4a5fbe3170ab2e864b6a4ccd4ca/..
        // tensorflow/core/kernels/mkl_lrn_op.cc#L320
        let powOperator;
        const basis = `float(${bias}) + float(${alpha}) * sum`;
        if (beta === 0.5) powOperator = `inversesqrt(${basis})`;
        else if (beta === 1.0) powOperator = `1.0/(${basis})`;
        else powOperator = `exp(log(${basis}) * float(-${beta}));`;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
    }
}


const $8a83a68a2150f887$export$4e4a7896ae51c2f1 = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { depthRadius: depthRadius , bias: bias , alpha: alpha , beta: beta  } = attrs;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_NORMALIZATION') ? new $e1c378a87219b2fb$export$3942340f6b6d7fe9(x.shape, depthRadius, bias, alpha, beta) : new $449cc3bf67d152ba$export$2214c2ca22968528(x.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
};
const $8a83a68a2150f887$export$6fb124d5a6994734 = {
    kernelName: $2b76be1e72a8c1db$export$eb2f713fc3e1ca9a,
    backendName: 'webgl',
    kernelFunc: $8a83a68a2150f887$export$4e4a7896ae51c2f1
};



class $b7231706266b1426$export$f121c71e68d75e {
    constructor(inputShape, depthRadius, bias, alpha, beta){
        this.variableNames = [
            'inputImage',
            'outputImage',
            'dy'
        ];
        this.outputShape = [];
        this.outputShape = inputShape;
        this.depth = inputShape[3];
        this.depthRadius = depthRadius;
        this.bias = bias;
        this.alpha = alpha;
        this.beta = beta;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
}


const $c96891b383299f08$export$c1529e4348811bb5 = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x , y: y , dy: dy  } = inputs;
    const { depthRadius: depthRadius , bias: bias , alpha: alpha , beta: beta  } = attrs;
    const program = new $b7231706266b1426$export$f121c71e68d75e(x.shape, depthRadius, bias, alpha, beta);
    return backend.runWebGLProgram(program, [
        x,
        y,
        dy
    ], x.dtype);
};
const $c96891b383299f08$export$99a62fc039d7aca0 = {
    kernelName: $2b76be1e72a8c1db$export$73ba43cd0ce95b10,
    backendName: 'webgl',
    kernelFunc: $c96891b383299f08$export$c1529e4348811bb5
};








function $2c1590166f336a99$export$23c9b99bdac85be0(x, reduceShape, outShape, backend) {
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        attrs: {
            shape: [
                batchSize,
                inSize
            ]
        },
        backend: backend
    });
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(reshapedInput, x.dtype, 'max', backend);
    const reshapedOutput = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        attrs: {
            shape: outShape
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
}



function $3c688ad0168df0af$export$8960430cfd85939f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { reductionIndices: reductionIndices , keepDims: keepDims  } = attrs;
    const xRank = x.shape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    const maxInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([
        x
    ]);
    let maxInput = x;
    if (maxInputIsTransposed) {
        if (shouldExecuteOnCPU) {
            const xTexData = backend.texData.get(maxInput.dataId);
            const values = xTexData.values;
            const newShape = new Array(xRank);
            for(let i = 0; i < newShape.length; i++)newShape[i] = x.shape[permutedAxes[i]];
            const maxInputValues = $31b15458ffa33a6b$export$a0105d4a7143676c(values, x.shape, x.dtype, permutedAxes, newShape);
            maxInput = backend.makeTensorInfo(newShape, x.dtype);
            const maxInputData = backend.texData.get(maxInput.dataId);
            maxInputData.values = maxInputValues;
        } else maxInput = $e24962390fc7a278$export$986b9e65182e08d(x, permutedAxes, backend);
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('max', axes, xRank);
    const [maxOutShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(maxInput.shape, axes);
    let outShape = maxOutShape;
    if (keepDims) // rather than reshape at the end, set the target shape here.
    outShape = $510a55f99d61727a$exports.expandShapeToKeepDim(maxOutShape, origAxes);
    let out;
    if (shouldExecuteOnCPU) {
        const xTexData = backend.texData.get(maxInput.dataId);
        const values = xTexData.values;
        const outValues = $31b15458ffa33a6b$export$a94164c9f637858e(values, $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape), outShape, x.dtype);
        out = backend.makeTensorInfo(outShape, x.dtype);
        const outData = backend.texData.get(out.dataId);
        outData.values = outValues;
    } else out = $2c1590166f336a99$export$23c9b99bdac85be0(maxInput, reduceShape, outShape, backend);
    if (maxInputIsTransposed) backend.disposeIntermediateTensorInfo(maxInput);
    return out;
}
const $3c688ad0168df0af$export$7d79147246e312bb = {
    kernelName: $2b76be1e72a8c1db$export$d36c09e5d02927e7,
    backendName: 'webgl',
    kernelFunc: $3c688ad0168df0af$export$8960430cfd85939f
};







const $d4a33a7f7298909d$var$MAXIMUM = $217996ba39efcc29$export$39f0cca2b63399f6 + `
  return max(a, b);
`;
const $d4a33a7f7298909d$var$MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + $ae8429d0c17ef751$export$39f0cca2b63399f6 + `
  return result;
`;
const $d4a33a7f7298909d$export$b25e0be55f42c9a = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $d4a33a7f7298909d$var$MAXIMUM,
    packedOpSnippet: $d4a33a7f7298909d$var$MAXIMUM_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$b3afdc53a543e175
});
const $d4a33a7f7298909d$export$45b97bdc342e72a2 = {
    kernelName: $2b76be1e72a8c1db$export$d8d02ac92d161004,
    backendName: 'webgl',
    kernelFunc: $d4a33a7f7298909d$export$b25e0be55f42c9a
};






function $21e3b30464ed62a3$export$e4aadcf115842782(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    $7428f53c4d4be222$export$1412c17b2531581a(x, 'maxPool');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = 1;
    $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, dilations), ()=>'Error in maxPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`
    );
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && $f6b55a2021b78f0d$exports.arraysEqual(convInfo.inShape, convInfo.outShape)) return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const maxPoolProgram = new $82f93a60bd9656d8$export$ddaa65439647a5ac(convInfo, 'max', false);
    return backend.runWebGLProgram(maxPoolProgram, [
        x
    ], x.dtype);
}
const $21e3b30464ed62a3$export$45c8263b38f19e33 = {
    kernelName: $2b76be1e72a8c1db$export$39ea33024ddd5cf,
    backendName: 'webgl',
    kernelFunc: $21e3b30464ed62a3$export$e4aadcf115842782
};




function $5dac58a5d53e0f25$export$822a6e53be1125f9(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { filterSize: filterSize , strides: strides , pad: pad , dataFormat: dataFormat , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = [
        1,
        1,
        1
    ];
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode, dataFormat);
    const maxPoolProgram = new $82f93a60bd9656d8$export$a835a97097fdbb0f(convInfo, 'max', false);
    return backend.runWebGLProgram(maxPoolProgram, [
        x
    ], x.dtype);
}
const $5dac58a5d53e0f25$export$91a8fc5da39ec855 = {
    kernelName: $2b76be1e72a8c1db$export$88fdc64af890fc53,
    backendName: 'webgl',
    kernelFunc: $5dac58a5d53e0f25$export$822a6e53be1125f9
};



class $8b35aa59d9d97533$export$ab6144ed51884dd {
    constructor(convInfo){
        this.variableNames = [
            'dy',
            'maxPos'
        ];
        this.outputShape = convInfo.inShape;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationHeight = convInfo.dilationHeight;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}
class $8b35aa59d9d97533$export$ae61ae287bf9d719 {
    constructor(convInfo){
        this.variableNames = [
            'dy',
            'maxPos'
        ];
        this.outputShape = convInfo.inShape;
        const strideDepth = convInfo.strideDepth;
        const strideHeight = convInfo.strideHeight;
        const strideWidth = convInfo.strideWidth;
        const dilationDepth = convInfo.dilationDepth;
        const dilationHeight = convInfo.dilationHeight;
        const dilationWidth = convInfo.dilationWidth;
        const effectiveFilterDepth = convInfo.effectiveFilterDepth;
        const effectiveFilterHeight = convInfo.effectiveFilterHeight;
        const effectiveFilterWidth = convInfo.effectiveFilterWidth;
        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
        const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
        this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}



function $3143d996ffc4399b$export$e68b9bef571dd4ea(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input  } = inputs;
    const x = input;
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const dilations = [
        1,
        1,
        1
    ];
    const convInfo = $510a55f99d61727a$exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad, dimRoundingMode);
    const maxPool3dPositionsProgram = new $82f93a60bd9656d8$export$a835a97097fdbb0f(convInfo, 'max', true);
    const maxPool3dPositions = backend.runWebGLProgram(maxPool3dPositionsProgram, [
        x
    ], x.dtype);
    const maxPoolBackpropProgram = new $8b35aa59d9d97533$export$ae61ae287bf9d719(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackpropProgram, [
        dy,
        maxPool3dPositions
    ], x.dtype);
    backend.disposeIntermediateTensorInfo(maxPool3dPositions);
    return result;
}
const $3143d996ffc4399b$export$5201426bb10bd5eb = {
    kernelName: $2b76be1e72a8c1db$export$52be2c00371a1350,
    backendName: 'webgl',
    kernelFunc: $3143d996ffc4399b$export$e68b9bef571dd4ea
};






function $ffe095f87be7ea61$export$85dfd1121f049514(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { dy: dy , input: input , output: output  } = inputs;
    const x = input;
    $7428f53c4d4be222$export$1412c17b2531581a([
        input,
        output
    ], 'maxPoolGrad');
    const { filterSize: filterSize , strides: strides , pad: pad , dimRoundingMode: dimRoundingMode  } = attrs;
    const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, 1 /* dilations */ , pad, dimRoundingMode);
    const getPositions = true;
    const maxPoolPositionsProgram = new $82f93a60bd9656d8$export$ddaa65439647a5ac(convInfo, 'max', getPositions);
    const maxPoolPositions = backend.runWebGLProgram(maxPoolPositionsProgram, [
        x
    ], x.dtype);
    const maxPoolBackPropProgram = new $8b35aa59d9d97533$export$ab6144ed51884dd(convInfo);
    const result = backend.runWebGLProgram(maxPoolBackPropProgram, [
        dy,
        maxPoolPositions
    ], x.dtype);
    backend.disposeIntermediateTensorInfo(maxPoolPositions);
    return result;
}
const $ffe095f87be7ea61$export$e01a7f8dbee29127 = {
    kernelName: $2b76be1e72a8c1db$export$f0f010b1d1db8a46,
    backendName: 'webgl',
    kernelFunc: $ffe095f87be7ea61$export$85dfd1121f049514
};





function $846c923cf71bc7ec$export$3cc34964a47e7a3f(x, includeBatchInIndex, convInfo, backend) {
    let program = new $82f93a60bd9656d8$export$ddaa65439647a5ac(convInfo, 'max', false);
    const poolOutput = backend.runWebGLProgram(program, [
        x
    ], 'float32');
    program = new $82f93a60bd9656d8$export$ddaa65439647a5ac(convInfo, 'max', true, true, includeBatchInIndex);
    const indexOutput = backend.runWebGLProgram(program, [
        x
    ], 'float32');
    return [
        poolOutput,
        indexOutput
    ];
}


const $95a6635bd22a1730$export$a069ee2247a7d1ce = {
    kernelName: $2b76be1e72a8c1db$export$deac4b7497b4047f,
    backendName: 'webgl',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { x: x  } = inputs;
        const { filterSize: filterSize , strides: strides , pad: pad , includeBatchInIndex: includeBatchInIndex  } = attrs;
        const webglBackend = backend;
        $f6b55a2021b78f0d$exports.assert(x.shape.length === 4, ()=>`Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`
        );
        const dilations = [
            1,
            1
        ];
        $f6b55a2021b78f0d$exports.assert($510a55f99d61727a$exports.eitherStridesOrDilationsAreOne(strides, dilations), ()=>'Error in maxPool: Either strides or dilations must be 1. ' + `Got strides ${strides} and dilations '${dilations}'`
        );
        const convInfo = $510a55f99d61727a$exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad);
        const [result, indexes] = $846c923cf71bc7ec$export$3cc34964a47e7a3f(x, includeBatchInIndex, convInfo, webglBackend);
        return [
            result,
            indexes
        ];
    }
};






function $5da6a1396c3ba849$export$320c6ab5e6e7bcef(x, reduceShape, outShape, backend) {
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        attrs: {
            shape: [
                batchSize,
                inSize
            ]
        },
        backend: backend
    });
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(reshapedInput, 'float32', 'mean', backend);
    const reshapedOutput = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        attrs: {
            shape: outShape
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(reshapedInput);
    backend.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
}



const $e30cfecff2a5f0c6$export$b934af0ccd0cdbe1 = {
    kernelName: $2b76be1e72a8c1db$export$1c2d59c4b681fbd8,
    backendName: 'webgl',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { x: x  } = inputs;
        const { keepDims: keepDims , axis: axis  } = attrs;
        const webglBackend = backend;
        const xRank = x.shape.length;
        const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
        let axes = origAxes;
        const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
        const meanInputIsTransposed = permutedAxes != null;
        const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([
            x
        ]);
        const intermediates = [];
        let meanInput = x;
        if (meanInputIsTransposed) {
            if (shouldExecuteOnCPU) {
                const xTexData = webglBackend.texData.get(meanInput.dataId);
                const values = xTexData.values;
                const newShape = new Array(xRank);
                for(let i = 0; i < newShape.length; i++)newShape[i] = x.shape[permutedAxes[i]];
                const meanInputValues = $31b15458ffa33a6b$export$a0105d4a7143676c(values, x.shape, x.dtype, permutedAxes, newShape);
                meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
                const meanInputData = webglBackend.texData.get(meanInput.dataId);
                meanInputData.values = meanInputValues;
            } else meanInput = $e24962390fc7a278$export$986b9e65182e08d(x, permutedAxes, webglBackend);
            intermediates.push(meanInput);
            axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
        }
        $510a55f99d61727a$exports.assertAxesAreInnerMostDims('sum', axes, xRank);
        const [meanOutShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(meanInput.shape, axes);
        let outShape = meanOutShape;
        if (keepDims) // rather than reshape at the end, set the target shape here.
        outShape = $510a55f99d61727a$exports.expandShapeToKeepDim(meanOutShape, origAxes);
        const out = $5da6a1396c3ba849$export$320c6ab5e6e7bcef(meanInput, reduceShape, outShape, webglBackend);
        for (const i of intermediates)webglBackend.disposeIntermediateTensorInfo(i);
        return out;
    }
};






function $fcf9b85161161677$export$96ec731ed4dcb222(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const xRank = x.shape.length;
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('min', axes, xRank);
    const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
    const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: permutedX
        },
        backend: backend,
        attrs: {
            shape: [
                -1,
                inSize
            ]
        }
    });
    const reduced = $cb671098a409c587$export$533b26079ad0b4b(a2D, a2D.dtype, 'min', backend);
    let res;
    if (keepDims) {
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(outShape, origAxes);
        res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: reduced
            },
            backend: backend,
            attrs: {
                shape: newShape
            }
        });
    } else res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: reduced
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    backend.disposeIntermediateTensorInfo(a2D);
    backend.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) backend.disposeIntermediateTensorInfo(permutedX);
    return res;
}
const $fcf9b85161161677$export$3cd9f9a31b38cf18 = {
    kernelName: $2b76be1e72a8c1db$export$dfed19fabc75a31d,
    backendName: 'webgl',
    kernelFunc: $fcf9b85161161677$export$96ec731ed4dcb222
};







const $ccb379ff1a1361a4$var$MINIMUM = $217996ba39efcc29$export$39f0cca2b63399f6 + `
  return min(a, b);
`;
const $ccb379ff1a1361a4$var$MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + $ae8429d0c17ef751$export$39f0cca2b63399f6 + `
  return result;
`;
const $ccb379ff1a1361a4$export$916782c1f0ddb132 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $ccb379ff1a1361a4$var$MINIMUM,
    packedOpSnippet: $ccb379ff1a1361a4$var$MINIMUM_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$1f01be3f637863fa
});
const $ccb379ff1a1361a4$export$ea24ffbbbce8d546 = {
    kernelName: $2b76be1e72a8c1db$export$23cb308301e89d6b,
    backendName: 'webgl',
    kernelFunc: $ccb379ff1a1361a4$export$916782c1f0ddb132
};




class $6cd0f0660f23dc74$export$284b676bb83fc2a7 {
    constructor(xShape, paddings, mode){
        this.variableNames = [
            'x'
        ];
        this.outputShape = paddings.map((p, i)=>p[0] + xShape[i] + p[1]
        );
        const rank = xShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const start = paddings.map((p)=>p[0]
        ).join(',');
        const end = paddings.map((p, i)=>p[0] + xShape[i]
        ).join(',');
        const unpackedCoords = [
            'coords[0]',
            'coords[1]',
            'coords[2]',
            'coords[3]'
        ].slice(0, rank);
        const offset = mode === 'reflect' ? 0 : 1;
        if (rank === 1) {
            this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
            return;
        }
        this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
    }
}




class $34d49ab038dbb663$export$8b179cde16652b52 {
    constructor(xShape, paddings, mode){
        this.variableNames = [
            'x'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = paddings.map((p, i)=>p[0] + xShape[i] + p[1]
        );
        const rank = xShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const start = paddings.map((p)=>p[0]
        ).join(',');
        const end = paddings.map((p, i)=>p[0] + xShape[i]
        ).join(',');
        const coords = $941a295bfee22e2b$export$7a4d1d0d17b69972('rc', rank);
        const source = $941a295bfee22e2b$export$7a4d1d0d17b69972('source', rank);
        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;
        const offset = mode === 'reflect' ? 0 : 1;
        let mainLoop = '';
        if (rank === 1) {
            const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
            mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        } else {
            const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
            mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords[rank - 2]} += 1;
        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
        }
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
}


const $acb590d87bf12a71$export$cd4ff5cd9b95abe8 = ({ inputs: inputs , backend: backend , attrs: attrs  })=>{
    const { x: x  } = inputs;
    const { paddings: paddings , mode: mode  } = attrs;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new $34d49ab038dbb663$export$8b179cde16652b52(x.shape, paddings, mode) : new $6cd0f0660f23dc74$export$284b676bb83fc2a7(x.shape, paddings, mode);
    const output = backend.runWebGLProgram(program, [
        x
    ], x.dtype);
    return output;
};
const $acb590d87bf12a71$export$2cfd6c6c7daeb5fc = {
    kernelName: $2b76be1e72a8c1db$export$f4c0e95fd7fd31e5,
    backendName: 'webgl',
    kernelFunc: $acb590d87bf12a71$export$cd4ff5cd9b95abe8
};





const $4ac6b77757ba37c2$var$MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
const $4ac6b77757ba37c2$var$MOD_PACKED = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` + $ae8429d0c17ef751$export$39f0cca2b63399f6 + `
  return result;
`;
const $4ac6b77757ba37c2$export$842a2cf37af977e1 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $4ac6b77757ba37c2$var$MOD,
    packedOpSnippet: $4ac6b77757ba37c2$var$MOD_PACKED
});
const $4ac6b77757ba37c2$export$9037685a81180a9c = {
    kernelName: $2b76be1e72a8c1db$export$e4835a5e3f3674d5,
    backendName: 'webgl',
    kernelFunc: $4ac6b77757ba37c2$export$842a2cf37af977e1
};



class $7b19249f8bfe7616$export$f8cda6c8ea4f2110 {
    constructor(batchSize, numOutcomes, numSamples){
        this.variableNames = [
            'probs'
        ];
        this.customUniforms = [
            {
                name: 'seed',
                type: 'float'
            }
        ];
        this.outputShape = [
            batchSize,
            numSamples
        ];
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
    }
}







// Without the equality check div produces 0.9999 for a = b, which when
// floored can cause errors.
const $86dd7324f9362d49$var$DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
// We do the same as in ./binaryop_gpu, with vec4 and ivec4.
// On Linux, the vectorized implementation produces NaNs when a and b are 0.
const $86dd7324f9362d49$var$DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
const $86dd7324f9362d49$export$f76766520aabd67 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $86dd7324f9362d49$var$DIV,
    packedOpSnippet: $86dd7324f9362d49$var$DIV_PACKED,
    checkOutOfBounds: true
});
const $86dd7324f9362d49$export$15c5d6176b30b9a6 = {
    kernelName: $2b76be1e72a8c1db$export$b9880b86e1014bb8,
    backendName: 'webgl',
    kernelFunc: $86dd7324f9362d49$export$f76766520aabd67
};






const $e59e1f5cc1f80c8f$var$SUB = 'return a - b;';
const $e59e1f5cc1f80c8f$export$f93b5905241a7cca = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $e59e1f5cc1f80c8f$var$SUB,
    packedOpSnippet: $e59e1f5cc1f80c8f$var$SUB,
    supportsComplex: true,
    cpuKernelImpl: $31b15458ffa33a6b$export$be7474e96b733333
});
const $e59e1f5cc1f80c8f$export$5d068476dad60c4d = {
    kernelName: $2b76be1e72a8c1db$export$d7a01e11500dfb6f,
    backendName: 'webgl',
    kernelFunc: $e59e1f5cc1f80c8f$export$f93b5905241a7cca
};



function $a909eb8eb92742a2$export$e008137e76238601(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { logits: logits  } = inputs;
    const { dim: dim  } = attrs;
    const axes = $f6b55a2021b78f0d$exports.parseAxisParam([
        dim
    ], logits.shape);
    const maxLogit = $3c688ad0168df0af$export$8960430cfd85939f({
        inputs: {
            x: logits
        },
        backend: backend,
        attrs: {
            reductionIndices: axes,
            keepDims: false
        }
    });
    const expandedShape = $510a55f99d61727a$exports.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitsReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: maxLogit
        },
        backend: backend,
        attrs: {
            shape: expandedShape
        }
    });
    const a = $e59e1f5cc1f80c8f$export$f93b5905241a7cca({
        inputs: {
            a: logits,
            b: maxLogitsReshaped
        },
        backend: backend
    });
    const b = $7a9db68544dd1ea9$export$b310ec824aaee37f({
        inputs: {
            x: a
        },
        backend: backend
    });
    const sumExp = $da8ee0e3114a74ea$export$8a63f25cc62965f1({
        inputs: {
            x: b
        },
        backend: backend,
        attrs: {
            axis: axes,
            keepDims: false
        }
    });
    const sumExpReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: sumExp
        },
        backend: backend,
        attrs: {
            shape: expandedShape
        }
    });
    const res = $86dd7324f9362d49$export$f76766520aabd67({
        inputs: {
            a: b,
            b: sumExpReshaped
        },
        backend: backend
    });
    backend.disposeIntermediateTensorInfo(maxLogit);
    backend.disposeIntermediateTensorInfo(maxLogitsReshaped);
    backend.disposeIntermediateTensorInfo(a);
    backend.disposeIntermediateTensorInfo(b);
    backend.disposeIntermediateTensorInfo(sumExp);
    backend.disposeIntermediateTensorInfo(sumExpReshaped);
    return res;
}
const $a909eb8eb92742a2$export$c022691f23e2ee69 = {
    kernelName: $2b76be1e72a8c1db$export$350a526055d3ca6e,
    backendName: 'webgl',
    kernelFunc: $a909eb8eb92742a2$export$e008137e76238601
};


function $67705f4f13e4a922$export$f4d580f3101a1c7e(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { logits: logits  } = inputs;
    const { numSamples: numSamples , seed: seed , normalized: normalized  } = attrs;
    const probs = normalized ? logits : $a909eb8eb92742a2$export$e008137e76238601({
        inputs: {
            logits: logits
        },
        backend: backend,
        attrs: {
            dim: logits.shape.length - 1
        }
    });
    const batchSize = probs.shape[0];
    const numOutcomes = probs.shape[1];
    const program = new $7b19249f8bfe7616$export$f8cda6c8ea4f2110(batchSize, numOutcomes, numSamples);
    const customValues = [
        [
            seed
        ]
    ];
    const res = backend.runWebGLProgram(program, [
        probs
    ], 'int32', customValues);
    if (!normalized) backend.disposeIntermediateTensorInfo(probs);
    return res;
}
const $67705f4f13e4a922$export$ad960e364767f0e2 = {
    kernelName: $2b76be1e72a8c1db$export$ee0a8cfb693e0e3f,
    backendName: 'webgl',
    kernelFunc: $67705f4f13e4a922$export$f4d580f3101a1c7e
};







const $fa9897dc57ad46ae$var$NEG = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return -x;
`;
const $fa9897dc57ad46ae$var$NEG_PACKED = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
function $fa9897dc57ad46ae$export$d9493ff0dfa0fdd5(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    if (backend.shouldExecuteOnCPU([
        x
    ])) {
        const xData = backend.texData.get(x.dataId);
        const [outValues, newShape] = $31b15458ffa33a6b$export$1cbcde7624effb15(xData.values, x.shape, x.dtype);
        return backend.makeTensorInfo(newShape, x.dtype, outValues);
    }
    let program;
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_UNARY_OPERATIONS')) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(x.shape, $fa9897dc57ad46ae$var$NEG_PACKED);
    else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(x.shape, $fa9897dc57ad46ae$var$NEG);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}
const $fa9897dc57ad46ae$export$cc7b18b8229c3db = {
    kernelName: $2b76be1e72a8c1db$export$c07c549000872073,
    backendName: 'webgl',
    kernelFunc: $fa9897dc57ad46ae$export$d9493ff0dfa0fdd5
};



const $f5f7a77f93d79100$var$nonMaxSuppressionV3Impl = $c0ded10581046f08$exports.nonMaxSuppressionV3Impl;
function $f5f7a77f93d79100$export$8917e4bf7f7f5d42(args) {
    $510a55f99d61727a$exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold  } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices: selectedIndices  } = $f5f7a77f93d79100$var$nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend.makeTensorInfo([
        selectedIndices.length
    ], 'int32', new Int32Array(selectedIndices));
}
const $f5f7a77f93d79100$export$549561cd158f260a = {
    kernelName: $2b76be1e72a8c1db$export$5e11788439c2f04,
    backendName: 'webgl',
    kernelFunc: $f5f7a77f93d79100$export$8917e4bf7f7f5d42
};



const $5b4ef8a16a378d74$var$nonMaxSuppressionV4Impl = $c0ded10581046f08$exports.nonMaxSuppressionV4Impl;
function $5b4ef8a16a378d74$export$ad519bdebe8f4dcf(args) {
    $510a55f99d61727a$exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold , padToMaxOutputSize: padToMaxOutputSize  } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const { selectedIndices: selectedIndices , validOutputs: validOutputs  } = $5b4ef8a16a378d74$var$nonMaxSuppressionV4Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
        backend.makeTensorInfo([
            selectedIndices.length
        ], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([], 'int32', new Int32Array([
            validOutputs
        ]))
    ];
}
const $5b4ef8a16a378d74$export$906b8fb32c570e9d = {
    kernelName: $2b76be1e72a8c1db$export$7df908154366fe7f,
    backendName: 'webgl',
    kernelFunc: $5b4ef8a16a378d74$export$ad519bdebe8f4dcf
};



const $10120e3db89632ca$var$nonMaxSuppressionV5Impl = $c0ded10581046f08$exports.nonMaxSuppressionV5Impl;
function $10120e3db89632ca$export$49e389fdbe01a534(args) {
    $510a55f99d61727a$exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { boxes: boxes , scores: scores  } = inputs;
    const { maxOutputSize: maxOutputSize , iouThreshold: iouThreshold , scoreThreshold: scoreThreshold , softNmsSigma: softNmsSigma  } = attrs;
    const boxesVals = backend.readSync(boxes.dataId);
    const scoresVals = backend.readSync(scores.dataId);
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices: selectedIndices , selectedScores: selectedScores  } = $10120e3db89632ca$var$nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
        backend.makeTensorInfo([
            selectedIndices.length
        ], 'int32', new Int32Array(selectedIndices)),
        backend.makeTensorInfo([
            selectedScores.length
        ], 'float32', new Float32Array(selectedScores))
    ];
}
const $10120e3db89632ca$export$4c00b682f309701d = {
    kernelName: $2b76be1e72a8c1db$export$cb45d3fcefce2ef0,
    backendName: 'webgl',
    kernelFunc: $10120e3db89632ca$export$49e389fdbe01a534
};




class $b991076d774dbe14$export$314e506cf5800fc5 {
    constructor(numIndices, depth, onValue, offValue){
        this.variableNames = [
            'indices'
        ];
        this.outputShape = [
            numIndices,
            depth
        ];
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
    }
}



const $35697f7ce28eec31$export$341b5490a776d041 = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { indices: indices  } = inputs;
    const { depth: depth , onValue: onValue , offValue: offValue  } = attrs;
    const indicesSize = $f6b55a2021b78f0d$exports.sizeFromShape(indices.shape);
    const program = new $b991076d774dbe14$export$314e506cf5800fc5(indicesSize, depth, onValue, offValue);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            shape: [
                indicesSize
            ]
        }
    });
    const result = backend.runWebGLProgram(program, [
        reshaped
    ], indices.dtype);
    backend.disposeIntermediateTensorInfo(reshaped);
    const outShape = [
        ...indices.shape,
        depth
    ];
    const out = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: result
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    backend.disposeIntermediateTensorInfo(result);
    return out;
};
const $35697f7ce28eec31$export$dde5645b472b80b2 = {
    kernelName: $2b76be1e72a8c1db$export$18982b43ba8c02e9,
    backendName: 'webgl',
    kernelFunc: $35697f7ce28eec31$export$341b5490a776d041
};












function $fd1448403917bac4$export$cb1f824e7733584d(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    if (x.dtype === 'complex64') {
        const realPart = $73eb9a248eb31689$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const r = $fd1448403917bac4$export$cb1f824e7733584d({
            inputs: {
                x: realPart
            },
            backend: backend
        });
        const imagPart = $a716805606e403d7$export$d78fab5778ab392b({
            inputs: {
                input: x
            },
            backend: backend
        });
        const i = $fd1448403917bac4$export$cb1f824e7733584d({
            inputs: {
                x: imagPart
            },
            backend: backend
        });
        const result = $1e4941852430620a$export$83a0e34f1302825b({
            inputs: {
                real: r,
                imag: i
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    } else return $7b5b8f61a189e939$export$9563e054e6f787fb({
        attrs: {
            shape: x.shape,
            dtype: x.dtype,
            value: x.dtype === 'string' ? '' : 0
        },
        backend: backend
    });
}
const $fd1448403917bac4$export$15368df05c479e41 = {
    kernelName: $2b76be1e72a8c1db$export$430969a37eda1e88,
    backendName: 'webgl',
    kernelFunc: $fd1448403917bac4$export$cb1f824e7733584d
};


function $8c91cdbc6158ee40$export$fb6afd6214fee9e9(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { x: x  } = inputs;
    if (x.dtype === 'string') throw new Error('onesLike is not supported under string dtype');
    else if (x.dtype === 'complex64') {
        const realPart = $73eb9a248eb31689$export$9fc57fb453bdbd67({
            inputs: {
                input: x
            },
            backend: backend
        });
        const r = $8c91cdbc6158ee40$export$fb6afd6214fee9e9({
            inputs: {
                x: realPart
            },
            backend: backend
        });
        const imagPart = $a716805606e403d7$export$d78fab5778ab392b({
            inputs: {
                input: x
            },
            backend: backend
        });
        const i = $fd1448403917bac4$export$cb1f824e7733584d({
            inputs: {
                x: imagPart
            },
            backend: backend
        });
        const result = $1e4941852430620a$export$83a0e34f1302825b({
            inputs: {
                real: r,
                imag: i
            },
            backend: backend
        });
        backend.disposeIntermediateTensorInfo(realPart);
        backend.disposeIntermediateTensorInfo(r);
        backend.disposeIntermediateTensorInfo(imagPart);
        backend.disposeIntermediateTensorInfo(i);
        return result;
    } else // TODO(cais, smilkov): Add WebGL shader for onesLike:
    //   https://github.com/tensorflow/tfjs/issues/1293
    return $7b5b8f61a189e939$export$9563e054e6f787fb({
        attrs: {
            shape: x.shape,
            dtype: x.dtype,
            value: 1
        },
        backend: backend
    });
}
const $8c91cdbc6158ee40$export$d8d7015eb6ab37d0 = {
    kernelName: $2b76be1e72a8c1db$export$a2962e735c809d91,
    backendName: 'webgl',
    kernelFunc: $8c91cdbc6158ee40$export$fb6afd6214fee9e9
};





function $6db40906cff564f8$export$2a703dbb0cb35339(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { axis: axis  } = attrs;
    if (inputs.length === 1) return $8abb1069efe45ee9$export$d660d8ed21f46635({
        inputs: {
            input: inputs[0]
        },
        backend: backend,
        attrs: {
            dim: axis
        }
    });
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t)=>{
        $f6b55a2021b78f0d$exports.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        $f6b55a2021b78f0d$exports.assert(dtype === t.dtype, ()=>'All tensors passed to stack must have matching dtypes'
        );
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t)=>{
        const expandedT = $8abb1069efe45ee9$export$d660d8ed21f46635({
            inputs: {
                input: t
            },
            backend: backend,
            attrs: {
                dim: axis
            }
        });
        intermediateTensorInfos.push(expandedT);
        return expandedT;
    });
    const result = $5ce0b60e52bb4a58$export$ee1b3e54f0441b22({
        inputs: expandedTensors,
        backend: backend,
        attrs: {
            axis: axis
        }
    });
    intermediateTensorInfos.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
}
const $6db40906cff564f8$export$1645fa8803aa1f86 = {
    kernelName: $2b76be1e72a8c1db$export$c26f40b29201e5b7,
    backendName: 'webgl',
    kernelFunc: $6db40906cff564f8$export$2a703dbb0cb35339
};




class $ce2ed79a8cfc11bc$export$15f19b307ce21f0a {
    constructor(xShape, paddings, constantValue){
        this.variableNames = [
            'x'
        ];
        this.customUniforms = [
            {
                name: 'value',
                type: 'float'
            }
        ];
        this.outputShape = paddings.map((p, i)=>p[0] + xShape[i] + p[1]
        );
        const rank = xShape.length;
        const type = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const start = paddings.map((p)=>p[0]
        ).join(',');
        const end = paddings.map((p, i)=>p[0] + xShape[i]
        ).join(',');
        const unpackedCoords = [
            'coords[0]',
            'coords[1]',
            'coords[2]',
            'coords[3]'
        ].slice(0, rank);
        if (rank === 1) {
            this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
            return;
        }
        this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
    }
}




class $6749f817d25dd65e$export$ed21e062cfba77c5 {
    constructor(xShape, paddings, constantValue){
        this.variableNames = [
            'x'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'value',
                type: 'float'
            }
        ];
        this.outputShape = paddings.map((p, i)=>p[0] + xShape[i] + p[1]
        );
        const rank = xShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const start = paddings.map((p)=>p[0]
        ).join(',');
        const end = paddings.map((p, i)=>p[0] + xShape[i]
        ).join(',');
        const coords = $941a295bfee22e2b$export$7a4d1d0d17b69972('rc', rank);
        const source = $941a295bfee22e2b$export$7a4d1d0d17b69972('source', rank);
        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;
        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;
        const componentSetup = [
            `${dtype} rc = outputLoc;`,
            `${coords[rank - 1]} += 1;
       if(${cLimit}) {
      `,
            rank === 1 ? '' : `}
       rc = outputLoc;
       ${coords[rank - 2]} += 1;
       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;
         if(${cLimit}) {`
        ];
        const paddingArea = rank === 1 ? 'rc < start || rc >= end' : 'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';
        let mainLoop = '';
        for(let i1 = 0, j = rank === 1 ? 2 : 4; i1 < j; i1++)mainLoop += `
        ${componentSetup[i1]}
        if (${paddingArea}) {
          result[${i1}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i1}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
        mainLoop += rank === 1 ? `} ` : `}}`;
        this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
}



const $b61f1b9690890c45$export$f676d6ad4f38bb89 = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { paddings: paddings , constantValue: constantValue  } = attrs;
    if ($f6b55a2021b78f0d$exports.sizeFromShape(x.shape) === 0) {
        // Short-circuit the computation, since x doesn't have value, only
        // the shape is used to compute output shape to pad.
        const outputShape = paddings.map((p, i)=>p[0] + x.shape[i] + p[1]
        );
        return $7b5b8f61a189e939$export$9563e054e6f787fb({
            backend: backend,
            attrs: {
                shape: outputShape,
                value: constantValue,
                dtype: x.dtype
            }
        });
    }
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new $6749f817d25dd65e$export$ed21e062cfba77c5(x.shape, paddings, constantValue) : new $ce2ed79a8cfc11bc$export$15f19b307ce21f0a(x.shape, paddings, constantValue);
    const customValues = [
        [
            constantValue
        ]
    ];
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype, customValues);
};
const $b61f1b9690890c45$export$b0317e720bfd61fc = {
    kernelName: $2b76be1e72a8c1db$export$5d47ba206577f0f2,
    backendName: 'webgl',
    kernelFunc: $b61f1b9690890c45$export$f676d6ad4f38bb89
};





const $784cf101917be3c7$var$POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
const $784cf101917be3c7$var$POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` + $ae8429d0c17ef751$export$39f0cca2b63399f6 + `
  return result;
`;
const $784cf101917be3c7$export$9c297f60e22e3389 = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $784cf101917be3c7$var$POW,
    packedOpSnippet: $784cf101917be3c7$var$POW_PACKED
});
const $784cf101917be3c7$export$b823d49786719761 = {
    kernelName: $2b76be1e72a8c1db$export$ce28d653ec559ee,
    backendName: 'webgl',
    kernelFunc: $784cf101917be3c7$export$9c297f60e22e3389
};








function $6dd2e459e33de7b2$export$5e143010dea16c85(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { axis: axis , keepDims: keepDims  } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = $510a55f99d61727a$exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
        permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                perm: permutedAxes
            }
        });
        axes = $510a55f99d61727a$exports.getInnerMostAxes(axes.length, xRank);
        toDispose.push(permutedX);
    }
    $510a55f99d61727a$exports.assertAxesAreInnerMostDims('prod', axes, xRank);
    let res;
    if (backend.shouldExecuteOnCPU([
        permutedX
    ])) {
        const xVals = backend.texData.get(permutedX.dataId).values;
        const { outVals: outVals , outShape: outShape , outDtype: outDtype  } = $31b15458ffa33a6b$export$2d654219115cec80(permutedX.shape, permutedX.dtype, xVals, axes);
        res = backend.makeTensorInfo(outShape, outDtype, outVals);
    } else {
        const [outShape, reduceShape] = $510a55f99d61727a$exports.computeOutAndReduceShapes(permutedX.shape, axes);
        const inSize = $f6b55a2021b78f0d$exports.sizeFromShape(reduceShape);
        const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: permutedX
            },
            backend: backend,
            attrs: {
                shape: [
                    -1,
                    inSize
                ]
            }
        });
        const outputDType = $993b52a5dd76e458$export$3479b4fbed3c0d8d(x.dtype);
        const reduced = $cb671098a409c587$export$533b26079ad0b4b(a2D, outputDType, 'prod', backend);
        res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: reduced
            },
            backend: backend,
            attrs: {
                shape: outShape
            }
        });
        toDispose.push(a2D);
        toDispose.push(reduced);
    }
    if (keepDims) {
        toDispose.push(res);
        const newShape = $510a55f99d61727a$exports.expandShapeToKeepDim(res.shape, origAxes);
        res = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: res
            },
            backend: backend,
            attrs: {
                shape: newShape
            }
        });
    }
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return res;
}
const $6dd2e459e33de7b2$export$d556aa935cef5c0c = {
    kernelName: $2b76be1e72a8c1db$export$b8a16d526a791fb0,
    backendName: 'webgl',
    kernelFunc: $6dd2e459e33de7b2$export$5e143010dea16c85
};




const $8875c72c90407dcb$export$d02631cccf789723 = (args)=>{
    const { backend: backend , attrs: attrs  } = args;
    const { start: start , stop: stop , step: step , dtype: dtype  } = attrs;
    const values = $31b15458ffa33a6b$export$fbee6deed7e76443(start, stop, step, dtype);
    return backend.makeTensorInfo([
        values.length
    ], dtype, values);
};
const $8875c72c90407dcb$export$361c4075706e31c2 = {
    kernelName: $2b76be1e72a8c1db$export$9a58ef0d7ad3278c,
    backendName: 'webgl',
    kernelFunc: $8875c72c90407dcb$export$d02631cccf789723
};






const $6e6decab85223d86$var$RECIPROCAL = `return 1.0 / x;`;
const $6e6decab85223d86$export$163bc8c839a1ac04 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $6e6decab85223d86$var$RECIPROCAL
});
const $6e6decab85223d86$export$412a6b66203fdf72 = {
    kernelName: $2b76be1e72a8c1db$export$c6e4a23ed5e0415b,
    backendName: 'webgl',
    kernelFunc: $6e6decab85223d86$export$163bc8c839a1ac04
};





const $3f17a31fea670b57$var$RELU = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return (x < 0.0) ? 0.0 : x;
`;
const $3f17a31fea670b57$var$RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $3f17a31fea670b57$export$16d1e4612cc0139f = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $3f17a31fea670b57$var$RELU,
    packedOpSnippet: $3f17a31fea670b57$var$RELU_PACKED
});
const $3f17a31fea670b57$export$731f9199bde068eb = {
    kernelName: $2b76be1e72a8c1db$export$9a6ff968bf961432,
    backendName: 'webgl',
    kernelFunc: $3f17a31fea670b57$export$16d1e4612cc0139f
};





const $d41f9543de4062a4$var$RELU6 = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
const $d41f9543de4062a4$var$RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $d41f9543de4062a4$export$4a62bcb95e9c44c4 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $d41f9543de4062a4$var$RELU6,
    packedOpSnippet: $d41f9543de4062a4$var$RELU6_PACKED
});
const $d41f9543de4062a4$export$92c30890ad649d53 = {
    kernelName: $2b76be1e72a8c1db$export$3be9e924f629054e,
    backendName: 'webgl',
    kernelFunc: $d41f9543de4062a4$export$4a62bcb95e9c44c4
};




class $fbc175e2175b0f87$export$52b2ccd78b972549 {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters){
        this.variableNames = [
            'A'
        ];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [
            batch,
            newHeight,
            newWidth,
            depth
        ];
        const effectiveInSize = [
            alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
            alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
            alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` + ` - vec2(0.5)`;
        else sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
}


class $4016bd8c5fb3156a$export$b334a0f2524628a {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [
            batch,
            newHeight,
            newWidth,
            depth
        ];
        const effectiveInSize = [
            alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
            alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
            alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        let sourceFracIndexRC;
        if (halfPixelCenters) sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` + `effectiveInputOverOutputRatioRC - vec3(0.5)`;
        else sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
}


function $3ca9a7d03c380047$export$1f1cbc7da93d06a0(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images  } = inputs;
    const { alignCorners: alignCorners , halfPixelCenters: halfPixelCenters , size: size  } = attrs;
    const [newHeight, newWidth] = size;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ? new $4016bd8c5fb3156a$export$b334a0f2524628a(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new $fbc175e2175b0f87$export$52b2ccd78b972549(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [
        images
    ], 'float32');
}
const $3ca9a7d03c380047$export$a37a56137abc1357 = {
    kernelName: $2b76be1e72a8c1db$export$24f2f15d869e0fd,
    backendName: 'webgl',
    kernelFunc: $3ca9a7d03c380047$export$1f1cbc7da93d06a0
};



class $697b2a83b7919845$export$dd552814323a3592 {
    constructor(dyShape, inputShape, alignCorners){
        this.variableNames = [
            'dy'
        ];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth, ] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        // In the backwards pass, we want to find the pixels that were generated for
        // each pixel in the input image the forward pass and add the corresponding
        // coefficient from dy to the gradient (with some interpolation).
        const effectiveXSize = [
            alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
            alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
            alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
            alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        // This defines the size of the window of values around a particular
        // index in dy that we want to search for contributions to dx.
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}


function $4c155922869031af$export$8899506794ec394(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images , dy: dy  } = inputs;
    const { alignCorners: alignCorners  } = attrs;
    const program = new $697b2a83b7919845$export$dd552814323a3592(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [
        dy
    ], dy.dtype);
}
const $4c155922869031af$export$51f84ca614e84763 = {
    kernelName: $2b76be1e72a8c1db$export$2d3cf759f1538c13,
    backendName: 'webgl',
    kernelFunc: $4c155922869031af$export$8899506794ec394
};



class $46ba3afba782dc03$export$2218952be90fb74a {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters){
        this.variableNames = [
            'A'
        ];
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [
            batch,
            newHeight,
            newWidth,
            depth
        ];
        const effectiveInSize = [
            alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
            alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
            alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        // When align corners is false, we rounds the value with floor.
        const roundBase = alignCorners ? '0.5' : '0.0';
        let sourceFracIndexRC;
        if (halfPixelCenters) sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` + `, vec2(0.0))`;
        else sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
}


class $9583d4a50d0c9352$export$a616f6d9a33abf84 {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outputShape = [];
        const [batch, oldHeight, oldWidth, depth] = inputShape;
        this.outputShape = [
            batch,
            newHeight,
            newWidth,
            depth
        ];
        const effectiveInSize = [
            alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
            alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
        ];
        const effectiveOutSize = [
            alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
            alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
        ];
        // When align corners is false, we rounds the value with floor.
        const roundBase = alignCorners ? '0.5' : '0.0';
        let sourceFracIndexRC;
        if (halfPixelCenters) sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * ` + `effectiveInputOverOutputRatioRC, vec3(0.0))`;
        else sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
}


function $7f6cffaa0055f9e6$export$74a902ae74ac2560(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images  } = inputs;
    const { alignCorners: alignCorners , halfPixelCenters: halfPixelCenters , size: size  } = attrs;
    const [newHeight, newWidth] = size;
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_IMAGE_OPERATIONS') ? new $9583d4a50d0c9352$export$a616f6d9a33abf84(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new $46ba3afba782dc03$export$2218952be90fb74a(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend.runWebGLProgram(program, [
        images
    ], images.dtype);
}
const $7f6cffaa0055f9e6$export$2b6a92caba113b89 = {
    kernelName: $2b76be1e72a8c1db$export$6c8d8ec26192bb18,
    backendName: 'webgl',
    kernelFunc: $7f6cffaa0055f9e6$export$74a902ae74ac2560
};



class $a32de45823acb609$export$b6671a84abe827c4 {
    constructor(dyShape, inputShape, alignCorners){
        this.variableNames = [
            'dy'
        ];
        this.outputShape = [];
        this.outputShape = inputShape;
        const [, xHeight, xWidth, ] = inputShape;
        const [, yHeight, yWidth] = dyShape;
        // In the backwards pass, we want to find the pixels that were generated for
        // each pixel in the input image the forward pass and add the corresponding
        // coefficient from dy to the gradient (with some interpolation).
        const effectiveXSize = [
            alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
            alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
        ];
        const effectiveYSize = [
            alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
            alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
        ];
        const heightScale = effectiveXSize[0] / effectiveYSize[0];
        const widthScale = effectiveXSize[1] / effectiveYSize[1];
        const invHeightScale = 1 / heightScale;
        const invWidthScale = 1 / widthScale;
        // This defines the size of the window of values around a particular
        // index in dy that we want to search for contributions to dx.
        const winHeight = Math.ceil(invHeightScale) * 2 + 2;
        const winWidth = Math.ceil(invWidthScale) * 2 + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}


function $d0eeaa9e9236582e$export$2b75795f158f1b18(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { images: images , dy: dy  } = inputs;
    const { alignCorners: alignCorners  } = attrs;
    const program = new $a32de45823acb609$export$b6671a84abe827c4(dy.shape, images.shape, alignCorners);
    return backend.runWebGLProgram(program, [
        dy
    ], dy.dtype);
}
const $d0eeaa9e9236582e$export$2b08d810b5090fe1 = {
    kernelName: $2b76be1e72a8c1db$export$b84ac31c55aa023b,
    backendName: 'webgl',
    kernelFunc: $d0eeaa9e9236582e$export$2b75795f158f1b18
};




class $05c45618bc70e52b$export$abc2effa29e77e92 {
    constructor(xShape, axis){
        this.variableNames = [
            'x'
        ];
        const rank = xShape.length;
        if (rank > 4) throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
            return;
        }
        const getInCoord = (i)=>{
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) return `${xShape[i]} - coords[${i}] - 1`;
            return `coords[${i}]`;
        };
        const inCoords = xShape.map((_, i)=>getInCoord(i)
        ).join(',');
        const type = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
    }
}




class $a425c7e90ee4f7cf$export$e427e51a4a356956 {
    constructor(xShape, axis){
        this.variableNames = [
            'x'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        const rank = xShape.length;
        if (rank > 4) throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
        this.outputShape = xShape;
        const channels1 = $941a295bfee22e2b$export$7a4d1d0d17b69972('rc', rank);
        const nextColumn = `${channels1[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
        const nextRow = `${channels1[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
        const type = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        if (rank === 1) this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
        else this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels1.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels1.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels1.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels1.slice())};
            }
          }
          setOutput(result);
        }
    `;
        function getR(channels) {
            return getChannel(channels);
        }
        function getG(channels) {
            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;
            return getChannel(channels);
        }
        function getB(channels) {
            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;
            return getChannel(channels);
        }
        function getA(channels) {
            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;
            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;
            return getChannel(channels);
        }
        function getChannel(channels) {
            const inCoordsArray = xShape.map((_, i)=>getInCoord(i, channels)
            );
            const inCoords = inCoordsArray.join(',');
            const innerDims = inCoordsArray.slice(-2).join(',');
            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
        }
        function getInCoord(i, channels1) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) return `${xShape[i]} - ${channels1[i]} - 1`;
            else return `${channels1[i]}`;
        }
    }
}



function $60c11b6eef7dfa81$export$66c1ae025e96b4bc(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { dims: dims  } = attrs;
    const xRank = x.shape.length;
    const $dims = $f6b55a2021b78f0d$exports.parseAxisParam(dims, x.shape);
    if (xRank === 0) return $d25b33604ad0d249$export$f0954fd7d5368655({
        inputs: {
            x: x
        },
        backend: backend
    });
    const program = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_ARRAY_OPERATIONS') ? new $a425c7e90ee4f7cf$export$e427e51a4a356956(x.shape, $dims) : new $05c45618bc70e52b$export$abc2effa29e77e92(x.shape, $dims);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}
const $60c11b6eef7dfa81$export$cab6a4e8d2ed8e8d = {
    kernelName: $2b76be1e72a8c1db$export$53c81f36b32e1bba,
    backendName: 'webgl',
    kernelFunc: $60c11b6eef7dfa81$export$66c1ae025e96b4bc
};




class $c4e006004eba1202$export$a37df1d4e69844e7 {
    constructor(imageShape, fillValue){
        this.variableNames = [
            'Image'
        ];
        this.outputShape = [];
        this.customUniforms = [
            {
                name: 'params',
                type: 'vec4'
            }
        ];
        const imageHeight = imageShape[1];
        const imageWidth = imageShape[2];
        this.outputShape = imageShape;
        let fillSnippet = '';
        if (typeof fillValue === 'number') fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
        else fillSnippet = `
        vec3 fill = vec3(${fillValue.join(',')});
        float outputValue = fill[coords[3]];`;
        this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}


const $24a900ade3367b78$export$44ba8c83417ab668 = {
    kernelName: $2b76be1e72a8c1db$export$c5a44649815d1c3,
    backendName: 'webgl',
    kernelFunc: ({ inputs: inputs , attrs: attrs , backend: backend  })=>{
        const { image: image  } = inputs;
        const { radians: radians , fillValue: fillValue , center: center  } = attrs;
        const webglBackend = backend;
        const program = new $c4e006004eba1202$export$a37df1d4e69844e7(image.shape, fillValue);
        const [centerX, centerY] = $510a55f99d61727a$exports.getImageCenter(center, image.shape[1], image.shape[2]);
        const customValues = [
            [
                centerX,
                centerY,
                Math.sin(radians),
                Math.cos(radians)
            ]
        ];
        const output = webglBackend.runWebGLProgram(program, [
            image
        ], image.dtype, customValues);
        return output;
    }
};




const $8f6224b4b6e4abab$var$ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
const $8f6224b4b6e4abab$export$2077e0241d6afd3c = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $8f6224b4b6e4abab$var$ROUND
});
const $8f6224b4b6e4abab$export$6c09e3291f636503 = {
    kernelName: $2b76be1e72a8c1db$export$c5ed3eef16c0612f,
    backendName: 'webgl',
    kernelFunc: $8f6224b4b6e4abab$export$2077e0241d6afd3c
};





const $b1ba2b65877c5c17$var$RSQRT = `return inversesqrt(x);`;
const $b1ba2b65877c5c17$export$1cc01d192953037e = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $b1ba2b65877c5c17$var$RSQRT,
    cpuKernelImpl: $31b15458ffa33a6b$export$431ccb02913a1aee
});
const $b1ba2b65877c5c17$export$941104b789956ef6 = {
    kernelName: $2b76be1e72a8c1db$export$7cc53aa09f5f3a2d,
    backendName: 'webgl',
    kernelFunc: $b1ba2b65877c5c17$export$1cc01d192953037e
};




class $7c39ce649bff3682$export$8d0317f5c5cbc1ac {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true){
        this.variableNames = [
            'updates',
            'indices',
            'defaultValue'
        ];
        this.outputShape = shape;
        const stridesType = $fbbfeeecbf2420a1$export$859efd105c10c755(strides.length);
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(shape.length);
        let indicesString = '';
        if (indicesRank === 1) indicesString = 'i';
        else if (indicesRank === 2) indicesString = 'i, j';
        const indicesSnippet = `getIndices(${indicesString})`;
        let updatesString = '';
        if (updatesRank === 1) updatesString = 'i';
        else if (updatesRank === 2) updatesString = 'i, coords[1]';
        const updatesSnippet = `getUpdates(${updatesString})`;
        const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';
        this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
    }
}



function $7bb9c8ec7ed63e3e$export$b6f42038a536d877(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { indices: indices , updates: updates  } = inputs;
    const { shape: shape  } = attrs;
    const { sliceRank: sliceRank , numUpdates: numUpdates , sliceSize: sliceSize , strides: strides , outputSize: outputSize  } = $510a55f99d61727a$exports.calculateShapes(updates, indices, shape);
    const flattenShape = [
        outputSize / sliceSize,
        sliceSize
    ];
    if (outputSize === 0) return backend.makeTensorInfo(shape, indices.dtype);
    const flattenIndices = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            shape: [
                numUpdates,
                sliceRank
            ]
        }
    });
    const flattenX = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: updates
        },
        backend: backend,
        attrs: {
            shape: [
                numUpdates,
                sliceSize
            ]
        }
    });
    const defaultValue = backend.makeTensorInfo([], 'float32', new Float32Array([
        0
    ])); // scalar(0)
    const program = new $7c39ce649bff3682$export$8d0317f5c5cbc1ac(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    const res = backend.runWebGLProgram(program, [
        flattenX,
        flattenIndices,
        defaultValue
    ], flattenX.dtype);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            shape: shape
        }
    });
    backend.disposeIntermediateTensorInfo(flattenIndices);
    backend.disposeIntermediateTensorInfo(flattenX);
    backend.disposeIntermediateTensorInfo(res);
    backend.disposeIntermediateTensorInfo(defaultValue);
    return reshaped;
}
const $7bb9c8ec7ed63e3e$export$573371744f044f5 = {
    kernelName: $2b76be1e72a8c1db$export$28eef6f0168af686,
    backendName: 'webgl',
    kernelFunc: $7bb9c8ec7ed63e3e$export$b6f42038a536d877
};




class $2b4ac06f4d2a12ed$export$845ed2d1f74ef297 {
    constructor(cRank, shape, rank){
        this.variableNames = [
            'c',
            'a',
            'b'
        ];
        this.outputShape = shape;
        let cCoords;
        let abCoords;
        if (rank > 4) throw Error(`Where for rank ${rank} is not yet supported`);
        if (rank === 1) {
            abCoords = `resRC`;
            cCoords = `resRC`;
        } else {
            const currentCoords = [
                'resRC.x',
                'resRC.y',
                'resRC.z',
                'resRC.w'
            ];
            const cCoordVars = [];
            const abCoordVars = [];
            for(let i = 0; i < shape.length; i++){
                abCoordVars.push(`${currentCoords[i]}`);
                if (i < cRank) cCoordVars.push(`${currentCoords[i]}`);
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
    }
}


function $a5456b88c4f1014e$export$2e6c959c16ff56b8(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { condition: condition , t: t , e: e  } = inputs;
    const program = new $2b4ac06f4d2a12ed$export$845ed2d1f74ef297(condition.shape.length, t.shape, t.shape.length);
    return backend.runWebGLProgram(program, [
        condition,
        t,
        e
    ], $993b52a5dd76e458$export$7bcca02d1a156bdf(t.dtype, e.dtype));
}
const $a5456b88c4f1014e$export$7ff911e710ee72fc = {
    kernelName: $2b76be1e72a8c1db$export$ef9b1a59e592288f,
    backendName: 'webgl',
    kernelFunc: $a5456b88c4f1014e$export$2e6c959c16ff56b8
};




const $44d2e3bfcf9989b5$var$SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${$510a55f99d61727a$exports.SELU_SCALEALPHA};
  float scale = ${$510a55f99d61727a$exports.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
const $44d2e3bfcf9989b5$export$a5f8240d9e99b438 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $44d2e3bfcf9989b5$var$SELU
});
const $44d2e3bfcf9989b5$export$8afc8558705c1a39 = {
    kernelName: $2b76be1e72a8c1db$export$6760d858e6f2594a,
    backendName: 'webgl',
    kernelFunc: $44d2e3bfcf9989b5$export$a5f8240d9e99b438
};





const $9f7ab51834752a66$var$SIGMOID = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
const $9f7ab51834752a66$var$SIGMOID_PACKED = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
const $9f7ab51834752a66$export$3b295495ca3cad7c = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $9f7ab51834752a66$var$SIGMOID,
    packedOpSnippet: $9f7ab51834752a66$var$SIGMOID_PACKED,
    cpuKernelImpl: $31b15458ffa33a6b$export$9b816377c2ca1f1f
});
const $9f7ab51834752a66$export$195d1cf7c59f3ef = {
    kernelName: $2b76be1e72a8c1db$export$fde18c826dda6b1b,
    backendName: 'webgl',
    kernelFunc: $9f7ab51834752a66$export$3b295495ca3cad7c
};




// Sign does not propagate NANs.
const $252199f6f7e45ee6$var$SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
const $252199f6f7e45ee6$export$c5552dfdbc7cec71 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $252199f6f7e45ee6$var$SIGN
});
const $252199f6f7e45ee6$export$9c0fb3eb2124ceb7 = {
    kernelName: $2b76be1e72a8c1db$export$1db683ad541682f6,
    backendName: 'webgl',
    kernelFunc: $252199f6f7e45ee6$export$c5552dfdbc7cec71
};




const $ca5ac725b0f62c2e$var$SIN = $f569887d6243ad0e$export$bf39b1cb254b6187 + `
  return sin(x);
`;
const $ca5ac725b0f62c2e$export$5de3937cb4b592ed = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $ca5ac725b0f62c2e$var$SIN
});
const $ca5ac725b0f62c2e$export$d993ec4e5c253b66 = {
    kernelName: $2b76be1e72a8c1db$export$75be1b631f7687,
    backendName: 'webgl',
    kernelFunc: $ca5ac725b0f62c2e$export$5de3937cb4b592ed
};




const $4e7254a6cee31204$var$SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
const $4e7254a6cee31204$export$545004b505d7c555 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $4e7254a6cee31204$var$SINH
});
const $4e7254a6cee31204$export$b92766b47f18ac85 = {
    kernelName: $2b76be1e72a8c1db$export$b8c187376329d79b,
    backendName: 'webgl',
    kernelFunc: $4e7254a6cee31204$export$545004b505d7c555
};






const $9d2e8bad92f865e5$var$SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
const $9d2e8bad92f865e5$export$76aa560a8c2b0055 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $9d2e8bad92f865e5$var$SOFTPLUS
});
const $9d2e8bad92f865e5$export$d9bcfe553d12d9e3 = {
    kernelName: $2b76be1e72a8c1db$export$c5af433747f1fd0a,
    backendName: 'webgl',
    kernelFunc: $9d2e8bad92f865e5$export$76aa560a8c2b0055
};






const $d1c95f41eea285c2$export$effb9d7cae92012f = (args)=>{
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { blockShape: blockShape , paddings: paddings  } = attrs;
    $f6b55a2021b78f0d$exports.assert(x.shape.length <= 4, ()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
    );
    const prod = blockShape.reduce((a, b)=>a * b
    );
    const completePaddings = [
        [
            0,
            0
        ]
    ];
    completePaddings.push(...paddings);
    for(let i = 1 + blockShape.length; i < x.shape.length; ++i)completePaddings.push([
        0,
        0
    ]);
    const toDispose = [];
    const paddedX = $b61f1b9690890c45$export$f676d6ad4f38bb89({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            paddings: completePaddings,
            constantValue: 0
        }
    });
    const reshapedPaddedShape = $510a55f99d61727a$exports.getReshaped(paddedX.shape, blockShape, prod, false);
    const permutedReshapedPaddedPermutation = $510a55f99d61727a$exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = $510a55f99d61727a$exports.getReshapedPermuted(paddedX.shape, blockShape, prod, false);
    const reshapedPaddedX = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: paddedX
        },
        backend: backend,
        attrs: {
            shape: reshapedPaddedShape
        }
    });
    const paddedXT = $fe12dc0e164e619f$export$9cb09a71b7d66923({
        inputs: {
            x: reshapedPaddedX
        },
        backend: backend,
        attrs: {
            perm: permutedReshapedPaddedPermutation
        }
    });
    const result = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: paddedXT
        },
        backend: backend,
        attrs: {
            shape: flattenShape
        }
    });
    toDispose.push(paddedX);
    toDispose.push(reshapedPaddedX);
    toDispose.push(paddedXT);
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result;
};
const $d1c95f41eea285c2$export$2f85417863d2050b = {
    kernelName: $2b76be1e72a8c1db$export$f63ac5409312707c,
    backendName: 'webgl',
    kernelFunc: $d1c95f41eea285c2$export$effb9d7cae92012f
};




function $44b09c54ae7d8045$export$c82a1904a15b5028(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { indices: indices , values: values , denseShape: denseShape , defaultValue: defaultValue  } = inputs;
    if (denseShape.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
    if (indices.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
    if (values.shape.length !== 1) throw new Error(`Values must be a vector, saw:
         ${values.shape}`);
    if (defaultValue.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    const $indices = backend.readSync(indices.dataId);
    const $values = backend.readSync(values.dataId);
    const $denseShape = backend.readSync(denseShape.dataId);
    const $defaultValue = backend.readSync(defaultValue.dataId)[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = $31b15458ffa33a6b$export$6cee5fb970d08428($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
    return [
        backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
        backend.makeTensorInfo([
            outputIndicesShape[0]
        ], values.dtype, outputValues),
        backend.makeTensorInfo([
            emptyRowIndicator.length
        ], 'bool', new Uint8Array(emptyRowIndicator.map((value)=>Number(value)
        ))),
        backend.makeTensorInfo([
            reverseIndexMap.length
        ], indices.dtype, new Int32Array(reverseIndexMap)), 
    ];
}
const $44b09c54ae7d8045$export$818286c593224d1a = {
    kernelName: $2b76be1e72a8c1db$export$8f1933853a5c8cca,
    backendName: 'webgl',
    kernelFunc: $44b09c54ae7d8045$export$c82a1904a15b5028
};




function $72026153e4a739a6$export$1408c45865e11fc6(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { inputIndices: inputIndices , inputShape: inputShape , newShape: newShape  } = inputs;
    if (inputIndices.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
    if (inputShape.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
    if (newShape.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    const $inputShape = Array.from(backend.readSync(inputShape.dataId));
    const $inputIndices = backend.readSync(inputIndices.dataId);
    const targetShape = Array.from(backend.readSync(newShape.dataId));
    const [newIndices, indicesShape, outputShape] = $31b15458ffa33a6b$export$d17b3360054ff370($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
        backend.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
        backend.makeTensorInfo([
            outputShape.length
        ], newShape.dtype, new Int32Array(outputShape)), 
    ];
}
const $72026153e4a739a6$export$eb106efc10374803 = {
    kernelName: $2b76be1e72a8c1db$export$f08f0dca44fa542,
    backendName: 'webgl',
    kernelFunc: $72026153e4a739a6$export$1408c45865e11fc6
};




function $e2da4fb417fd831a$export$dbc0c9096869d04e(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { data: data , indices: indices , segmentIds: segmentIds  } = inputs;
    if (data.shape.length < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if (indices.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
    if (segmentIds.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
    const $data = backend.readSync(data.dataId);
    const $indices = backend.readSync(indices.dataId);
    const $segmentIds = backend.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = $31b15458ffa33a6b$export$a503222c03b33888($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
const $e2da4fb417fd831a$export$51e7224ae14d7f78 = {
    kernelName: $2b76be1e72a8c1db$export$610b077aecc2447b,
    backendName: 'webgl',
    kernelFunc: $e2da4fb417fd831a$export$dbc0c9096869d04e
};




function $bac0420164a6e512$export$2255ce53fc777865(args) {
    const { inputs: inputs , backend: backend  } = args;
    const { data: data , indices: indices , segmentIds: segmentIds  } = inputs;
    if (data.shape.length < 1) throw new Error(`Data should be at least 1 dimensional but received scalar`);
    if (indices.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
    if (segmentIds.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
    const $data = backend.readSync(data.dataId);
    const $indices = backend.readSync(indices.dataId);
    const $segmentIds = backend.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = $31b15458ffa33a6b$export$a503222c03b33888($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
const $bac0420164a6e512$export$73fa0270f28b9555 = {
    kernelName: $2b76be1e72a8c1db$export$68351c28d7116b56,
    backendName: 'webgl',
    kernelFunc: $bac0420164a6e512$export$2255ce53fc777865
};





function $f5670097b375670e$export$1be4b823dd1a3080(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { sparseIndices: sparseIndices , sparseValues: sparseValues , defaultValue: defaultValue  } = inputs;
    const { outputShape: outputShape  } = attrs;
    const { sliceRank: sliceRank , numUpdates: numUpdates , strides: strides , outputSize: outputSize  } = $510a55f99d61727a$exports.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    const program = new $7c39ce649bff3682$export$8d0317f5c5cbc1ac(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [
        outputSize,
        1
    ], sumDupeIndices);
    const res = backend.runWebGLProgram(program, [
        sparseValues,
        sparseIndices,
        defaultValue
    ], sparseValues.dtype);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: res
        },
        backend: backend,
        attrs: {
            shape: outputShape
        }
    });
    backend.disposeIntermediateTensorInfo(res);
    return reshaped;
}
const $f5670097b375670e$export$7bc088f8ad44ef99 = {
    kernelName: $2b76be1e72a8c1db$export$2c426709a9332421,
    backendName: 'webgl',
    kernelFunc: $f5670097b375670e$export$1be4b823dd1a3080
};




function $dd6f489928e3c9df$export$c0085d48b0a75d8f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { numOrSizeSplits: numOrSizeSplits , axis: axis  } = attrs;
    const $axis = $f6b55a2021b78f0d$exports.parseAxisParam(axis, x.shape)[0];
    const splitSizes = $510a55f99d61727a$exports.prepareSplitSize(x, numOrSizeSplits, $axis);
    const xRank = x.shape.length;
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    return splitSizes.map((s)=>{
        const sliceSize = [
            ...size
        ];
        sliceSize[$axis] = s;
        const sliceT = $230f88c53743d502$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: begin,
                size: sliceSize
            }
        });
        begin[$axis] += s;
        return sliceT;
    });
}
const $dd6f489928e3c9df$export$317be24be3af9ea0 = {
    kernelName: $2b76be1e72a8c1db$export$8dffabb4071f05aa,
    backendName: 'webgl',
    kernelFunc: $dd6f489928e3c9df$export$c0085d48b0a75d8f
};





const $e49b11e56bbc06d9$var$SQRT = `return sqrt(x);`;
const $e49b11e56bbc06d9$export$eba8049fb5020b81 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $e49b11e56bbc06d9$var$SQRT,
    packedOpSnippet: $e49b11e56bbc06d9$var$SQRT,
    cpuKernelImpl: $31b15458ffa33a6b$export$548a22b20eeaf85b
});
const $e49b11e56bbc06d9$export$a592ba9268f10eeb = {
    kernelName: $2b76be1e72a8c1db$export$21ab404ab9d512a6,
    backendName: 'webgl',
    kernelFunc: $e49b11e56bbc06d9$export$eba8049fb5020b81
};




const $b2fd760a707171d5$var$SQUARE = `return x * x;`;
const $b2fd760a707171d5$export$dd4f28cef696bc7d = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $b2fd760a707171d5$var$SQUARE
});
const $b2fd760a707171d5$export$7c77bece4d51efc4 = {
    kernelName: $2b76be1e72a8c1db$export$b09fb900337259de,
    backendName: 'webgl',
    kernelFunc: $b2fd760a707171d5$export$dd4f28cef696bc7d
};




const $ad86dda305f851c2$var$SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';
const $ad86dda305f851c2$export$b178697fb6d0b37f = $f569887d6243ad0e$export$29353c66e70e3e16({
    opSnippet: $ad86dda305f851c2$var$SQUARED_DIFFERENCE,
    packedOpSnippet: $ad86dda305f851c2$var$SQUARED_DIFFERENCE
});
const $ad86dda305f851c2$export$9ed4691d69db8a43 = {
    kernelName: $2b76be1e72a8c1db$export$2f922d20d66089c6,
    backendName: 'webgl',
    kernelFunc: $ad86dda305f851c2$export$b178697fb6d0b37f
};




function $36c860301d2cd8a5$export$35d34bc0ed591a92({ inputs: inputs , attrs: attrs , backend: backend  }) {
    const { x: x  } = inputs;
    const opSnippet = $52fabdba6f2b73bf$export$39f0cca2b63399f6 + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
    const program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(x.shape, opSnippet);
    return backend.runWebGLProgram(program, [
        x
    ], x.dtype);
}
const $36c860301d2cd8a5$export$c42ffaf52eb2647 = {
    kernelName: $2b76be1e72a8c1db$export$fd55ce593607084a,
    backendName: 'webgl',
    kernelFunc: $36c860301d2cd8a5$export$35d34bc0ed591a92
};





class $82981caab25f551a$export$335c52ce94f359f6 {
    constructor(begin, strides, size){
        this.variableNames = [
            'x'
        ];
        this.outputShape = size;
        const rank = size.length;
        const inputDtype = $fbbfeeecbf2420a1$export$859efd105c10c755(size.length);
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(size.length);
        let newCoords = '';
        if (rank === 1) newCoords = 'coords * strides + begin';
        else {
            let outputAxis = 0;
            newCoords = size.map((_, i)=>{
                outputAxis++;
                return size.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
            }).join(',');
        }
        this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
    }
}




function $9e327212b1591a99$export$4ae57224f3b0605c(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs;
    const { begin: begin , end: end , strides: strides , beginMask: beginMask , endMask: endMask , ellipsisMask: ellipsisMask , newAxisMask: newAxisMask , shrinkAxisMask: shrinkAxisMask  } = attrs;
    const { finalShapeSparse: finalShapeSparse , finalShape: finalShape , isIdentity: isIdentity , sliceDim0: sliceDim0 , isSimpleSlice: isSimpleSlice , begin: $begin , end: $end , strides: $strides  } = $1a8ddf4b5d32c90c$exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) // Optimization #1, slice is a no-op plus reshape
    result = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: x
        },
        backend: backend,
        attrs: {
            shape: finalShape
        }
    });
    else if (sliceDim0 || isSimpleSlice) {
        // Optimization #2, slice is memory contiguous (only occurs in dim 0)
        $f6b55a2021b78f0d$exports.assert(x.shape.length >= 1, ()=>`Input must have rank at least 1, got: ${x.shape.length}`
        );
        const size = $1a8ddf4b5d32c90c$exports.computeOutShape($begin, $end, $strides);
        // To tolerate begin[0] > end[0] (a 0-output slice), we min(begin, end).
        const sliced = $230f88c53743d502$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: $begin,
                size: size
            }
        });
        result = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: sliced
            },
            backend: backend,
            attrs: {
                shape: finalShape
            }
        });
        backend.disposeIntermediateTensorInfo(sliced);
    } else {
        const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([
            x
        ]);
        if (shouldExecuteOnCPU) {
            // tslint:disable-next-line: no-unnecessary-type-assertion
            const values = backend.readSync(x.dataId);
            // tslint:disable-next-line: no-unnecessary-type-assertion
            const xBuf = $034bc04874ecb003$export$ab1029bcae9ddb4a(x.shape, x.dtype, values);
            const resultValues = $31b15458ffa33a6b$export$efd4e188e5de0188(finalShapeSparse, xBuf, $strides, $begin);
            result = backend.makeTensorInfo(finalShape, x.dtype, resultValues.values);
        } else {
            const program = new $82981caab25f551a$export$335c52ce94f359f6($begin, $strides, finalShapeSparse);
            result = backend.runWebGLProgram(program, [
                x
            ], x.dtype);
        }
    }
    const resultReshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: result
        },
        backend: backend,
        attrs: {
            shape: finalShape
        }
    });
    backend.disposeIntermediateTensorInfo(result);
    return resultReshaped;
}
const $9e327212b1591a99$export$81773633114187bd = {
    kernelName: $2b76be1e72a8c1db$export$60c7f9ac271417a9,
    backendName: 'webgl',
    kernelFunc: $9e327212b1591a99$export$4ae57224f3b0605c
};




function $f614ef32cc78b356$export$3490514dcc63b044(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { separator: separator , nGramWidths: nGramWidths , leftPad: leftPad , rightPad: rightPad , padWidth: padWidth , preserveShortSequences: preserveShortSequences  } = attrs;
    const { data: data , dataSplits: dataSplits  } = inputs;
    const $data = backend.readSync(data.dataId);
    const $dataSplits = backend.readSync(dataSplits.dataId);
    const [nGrams, nGramsSplits] = $31b15458ffa33a6b$export$bb9e83cb65884ef3($data, $dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences);
    return [
        backend.makeTensorInfo([
            nGrams.length
        ], 'string', nGrams),
        backend.makeTensorInfo(dataSplits.shape, 'int32', nGramsSplits), 
    ];
}
const $f614ef32cc78b356$export$35e13284eed34c22 = {
    kernelName: $2b76be1e72a8c1db$export$11a7f4af7d96ad41,
    backendName: 'webgl',
    kernelFunc: $f614ef32cc78b356$export$3490514dcc63b044
};




function $1b1a4ee6218d3c50$export$aa7f8babb17e7672(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { skipEmpty: skipEmpty  } = attrs;
    const { input: input , delimiter: delimiter  } = inputs;
    if (input.dtype !== 'string') throw new Error('Input must be of datatype string');
    if (input.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${input.shape}`);
    if (delimiter.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    const $input = backend.readSync(input.dataId);
    const $delimiter = backend.readSync(delimiter.dataId)[0];
    const [indices, values, shape] = $31b15458ffa33a6b$export$bb4b4a9a1db97dea($input, $delimiter, skipEmpty);
    const outputSize = values.length;
    return [
        backend.makeTensorInfo([
            outputSize,
            2
        ], 'int32', indices),
        backend.makeTensorInfo([
            outputSize
        ], 'string', values),
        backend.makeTensorInfo([
            2
        ], 'int32', new Int32Array(shape))
    ];
}
const $1b1a4ee6218d3c50$export$c51cbbd627a96532 = {
    kernelName: $2b76be1e72a8c1db$export$7e266f7223b9d396,
    backendName: 'webgl',
    kernelFunc: $1b1a4ee6218d3c50$export$aa7f8babb17e7672
};




function $831c8c71c9bb25e1$export$6195616d6fd0c848(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { numBuckets: numBuckets  } = attrs;
    const { input: input  } = inputs;
    if (input.dtype !== 'string') throw new Error('Input must be of datatype string');
    if (numBuckets <= 0) throw new Error(`Number of buckets must be at least 1`);
    const $input = backend.readSync(input.dataId);
    const output = $31b15458ffa33a6b$export$d7d8a9bba3df6e63($input, numBuckets);
    return backend.makeTensorInfo(input.shape, 'int32', output);
}
const $831c8c71c9bb25e1$export$a88a78b2b233f507 = {
    kernelName: $2b76be1e72a8c1db$export$a5639899909bc8ae,
    backendName: 'webgl',
    kernelFunc: $831c8c71c9bb25e1$export$6195616d6fd0c848
};






const $420986fdb90b2e6a$var$TAN = `return tan(x);`;
const $420986fdb90b2e6a$export$fcdd3b0b3246a325 = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $420986fdb90b2e6a$var$TAN
});
const $420986fdb90b2e6a$export$97648844df7611f3 = {
    kernelName: $2b76be1e72a8c1db$export$115b2d5263ba5985,
    backendName: 'webgl',
    kernelFunc: $420986fdb90b2e6a$export$fcdd3b0b3246a325
};




const $cd15947c0ecdfafe$var$TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
const $cd15947c0ecdfafe$export$7128670e45beef9a = $f569887d6243ad0e$export$ba4daf5748026fba({
    opSnippet: $cd15947c0ecdfafe$var$TANH
});
const $cd15947c0ecdfafe$export$a2fc7de1a1e4eee0 = {
    kernelName: $2b76be1e72a8c1db$export$893b6e865e352c83,
    backendName: 'webgl',
    kernelFunc: $cd15947c0ecdfafe$export$7128670e45beef9a
};





class $76157b857c194a2c$export$215140f0ab19f420 {
    constructor(aShape, reps){
        this.variableNames = [
            'A'
        ];
        const outputShape = new Array(aShape.length);
        for(let i = 0; i < outputShape.length; i++)outputShape[i] = aShape[i] * reps[i];
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
        const sourceCoords = $76157b857c194a2c$var$getSourceCoords(aShape);
        this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
}
function $76157b857c194a2c$var$getSourceCoords(aShape) {
    const rank = aShape.length;
    if (rank > 5) throw Error(`Tile for rank ${rank} is not yet supported`);
    if (rank === 1) return `imod(resRC, ${aShape[0]})`;
    const currentCoords = [
        'resRC.x',
        'resRC.y',
        'resRC.z',
        'resRC.w',
        'resRC.u'
    ];
    const sourceCoords = [];
    for(let i = 0; i < aShape.length; i++)sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
    return sourceCoords.join();
}


function $0b1b90217cabcc5d$export$3c17558da18e4d75(params) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = params;
    const { x: x  } = inputs;
    const { reps: reps  } = attrs;
    // tile gpu program cannot handle rank > 5 case.
    if (x.dtype === 'string' || x.shape.length > 5) {
        // Even thought string tensor is always on CPU, just to be consistent on how
        // to access tensor data.
        const data = backend.readSync(x.dataId);
        const value = x.dtype === 'string' ? data.map((d)=>$f6b55a2021b78f0d$exports.decodeString(d)
        ) : data;
        const buf = $034bc04874ecb003$export$ab1029bcae9ddb4a(x.shape, x.dtype, value);
        const outBuf = $31b15458ffa33a6b$export$349e02a266ab3131(buf, reps);
        return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
    }
    const program = new $76157b857c194a2c$export$215140f0ab19f420(x.shape, reps);
    const output = backend.runWebGLProgram(program, [
        x
    ], x.dtype);
    return output;
}
const $0b1b90217cabcc5d$export$a5a9f8050ba7f41e = {
    kernelName: $2b76be1e72a8c1db$export$235cb65c20ad2b7,
    backendName: 'webgl',
    kernelFunc: $0b1b90217cabcc5d$export$3c17558da18e4d75
};




class $16a2384ef3b20eff$export$5ee54e3c81d6f6e7 {
    /**
     * @param shape desired output shape (can be larger than input shape, output
     *                                    will be padded with -Infinity)
     */ constructor(shape){
        this.variableNames = [
            'x',
            'indices'
        ];
        // |n| Size of the original input of TopK.
        // |firstPass|indicates if this is the first time swap is being used which
        // means no indices input containing the top K is present yet.
        // |inc| Swaps pairs of indices (0, inc), (1, inc + 1), (2, inc + 2) ...
        this.customUniforms = [
            {
                name: 'n',
                type: 'int'
            },
            {
                name: 'firstPass',
                type: 'int'
            },
            {
                name: 'negativeInf',
                type: 'float'
            },
            {
                name: 'dir',
                type: 'int'
            },
            {
                name: 'inc',
                type: 'int'
            }
        ];
        this.outputShape = shape;
        this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
}
class $16a2384ef3b20eff$export$c3fbf8b38d821ac9 {
    /**
     * @param shape desired output shape (must be half of the input size)
     */ constructor(shape){
        this.variableNames = [
            'x',
            'indices'
        ];
        // |n| Size of the original input of TopK
        // |firstPass| indicates if this is the first time swap is being used which
        // means no indices input containing the top K is present yet.
        // |k| Top k elements desired
        this.customUniforms = [
            {
                name: 'n',
                type: 'int'
            },
            {
                name: 'firstPass',
                type: 'int'
            },
            {
                name: 'k',
                type: 'int'
            }
        ];
        this.outputShape = shape;
        this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
}






function $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {
    if (tensorInfo !== null) backend.disposeIntermediateTensorInfo(tensorInfo);
}
function $ec334b59eba01091$var$roundUpToPow2(num) {
    let pow2 = 1;
    while(pow2 < num)pow2 *= 2;
    return pow2;
}
function $ec334b59eba01091$export$7e641efc73a2d81(args) {
    const { inputs: inputs1 , backend: backend , attrs: attrs  } = args;
    const { x: x  } = inputs1;
    const { k: k , sorted: sorted  } = attrs;
    // Empirically determined constant used to determine last dim threshold for
    // handing off execution to the CPU.
    const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD');
    // Empirically determined constant used to determine k threshold for handing
    // off execution to the CPU.
    const TOPK_K_CPU_HANDOFF_THRESHOLD = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');
    const xShape = x.shape;
    const lastDim = xShape[xShape.length - 1];
    if (backend.shouldExecuteOnCPU([
        x
    ]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {
        const xVals = backend.readSync(x.dataId);
        const [allTopKVals, allTopKIndices] = $31b15458ffa33a6b$export$cc4aa6851cf96e2b(xVals, xShape, x.dtype, k, sorted);
        return [
            backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
            backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
        ];
    }
    if (k === 0) {
        xShape[xShape.length - 1] = 0;
        return [
            backend.makeTensorInfo(xShape, x.dtype, []),
            backend.makeTensorInfo(xShape, 'int32', [])
        ];
    }
    if (lastDim === 1 /* firstPass */ ) return [
        x,
        $7b5b8f61a189e939$export$9563e054e6f787fb({
            attrs: {
                shape: xShape,
                dtype: 'int32',
                value: 0
            },
            backend: backend
        })
    ];
    // Eagerly unpack x input since it is passed in to all the shaders which
    // require unpacked inputs.
    const xtexData = backend.texData.get(x.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    const xUnPacked = xIsPacked ? backend.unpackTensor(x) : x;
    // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.
    const xSize = $f6b55a2021b78f0d$exports.sizeFromShape(xShape);
    const batch = xSize / lastDim;
    const x2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: xUnPacked
        },
        attrs: {
            shape: [
                batch,
                lastDim
            ]
        },
        backend: backend
    });
    if (xIsPacked) $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, xUnPacked);
    const kPow2 = $ec334b59eba01091$var$roundUpToPow2(k);
    const lastDimPow2 = $ec334b59eba01091$var$roundUpToPow2(lastDim);
    // Only the indices containing the top K are kept at every step to reduce
    // number of outputs in the GPU algorithms, so once the final set of indices
    // is computed then gather is used to grab the corresponding values
    // from the original input.
    let indices = null;
    // GPU algorithm always takes in an indices input but this input is not used
    // on the first run of a GPU algorithm, therefore if indices is null we simply
    // pass in x2D instead of it but the value will not actually be used
    const getInputs = ()=>indices === null ? [
            x2D,
            x2D
        ] : [
            x2D,
            indices
        ]
    ;
    const runSwap = (dir, inc, shape)=>{
        const inputs = getInputs();
        const program = new $16a2384ef3b20eff$export$5ee54e3c81d6f6e7(shape);
        const fistPass = indices === null ? 1 : 0;
        const customValues = [
            [
                lastDim
            ],
            [
                fistPass
            ],
            [
                Number.NEGATIVE_INFINITY
            ],
            [
                dir
            ],
            [
                inc
            ]
        ];
        const prevIndices = indices;
        indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);
        $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, prevIndices);
    };
    // Step 1: local sort
    for(let len = 1; len < kPow2; len *= 2){
        const dir = len * 2;
        for(let inc = len; inc >= 1; inc /= 2)runSwap(dir, inc, [
            batch,
            lastDimPow2
        ]);
    }
    // Step 2: merge
    for(let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2){
        const inputs = getInputs();
        const mergeProgram = new $16a2384ef3b20eff$export$c3fbf8b38d821ac9([
            batch,
            indicesSize / 2
        ]);
        const firstPass = indices === null ? 1 : 0;
        const customValues = [
            [
                lastDim
            ],
            [
                firstPass
            ],
            [
                kPow2
            ]
        ];
        const prevIndices = indices;
        indices = backend.runWebGLProgram(mergeProgram, inputs, 'int32', customValues);
        $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, prevIndices);
        // Step 3: rebuild
        const len = kPow2 / 2;
        const dir = len * 2;
        for(let inc = len; inc >= 1; inc /= 2)runSwap(dir, inc, indices.shape);
    }
    // Keep only the requested top K results instead of kPow2
    let prevIndices1 = indices;
    indices = $230f88c53743d502$export$58adb3bec8346d0f({
        inputs: {
            x: indices
        },
        backend: backend,
        attrs: {
            begin: 0,
            size: [
                batch,
                k
            ]
        }
    });
    $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, prevIndices1);
    // Gather values on last dimension
    let values = $d6a8183309191047$export$3d75b4295ded9925({
        inputs: {
            x: x2D,
            indices: indices
        },
        backend: backend,
        attrs: {
            axis: 1,
            batchDims: 1
        }
    });
    $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, x2D);
    // Reshape back to the original input shape, except that the last
    // dimension is k.
    const newShape = xShape.slice(0, -1);
    newShape.push(k);
    prevIndices1 = indices;
    indices = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: indices
        },
        attrs: {
            shape: newShape
        },
        backend: backend
    });
    $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, prevIndices1);
    const prevValues = values;
    values = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: values
        },
        attrs: {
            shape: newShape
        },
        backend: backend
    });
    $ec334b59eba01091$var$disposeIntermediateTensorInfoOrNull(backend, prevValues);
    return [
        values,
        indices
    ];
}
const $ec334b59eba01091$export$cffaee31213314ce = {
    kernelName: $2b76be1e72a8c1db$export$c593cd1ea0d02ebd,
    backendName: 'webgl',
    kernelFunc: $ec334b59eba01091$export$7e641efc73a2d81
};



class $213d713e17a2d2d6$export$c83a293baf8f269d {
    constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape){
        this.variableNames = [
            'Image',
            'Transforms'
        ];
        this.outputShape = outShape;
        const interpolationModeId = interpolation === 'nearest' ? 1 : 2;
        let fillModeId;
        switch(fillMode){
            case 'constant':
                fillModeId = 1;
                break;
            case 'reflect':
                fillModeId = 2;
                break;
            case 'wrap':
                fillModeId = 3;
                break;
            case 'nearest':
                fillModeId = 4;
                break;
            default:
                fillModeId = 1;
                break;
        }
        this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
}


function $ad7656e5cf1d8171$export$51186ad6e864892a(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { image: image , transforms: transforms  } = inputs;
    const { interpolation: interpolation , fillMode: fillMode , fillValue: fillValue , outputShape: outputShape  } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [
        imageHeight,
        imageWidth
    ];
    const outShape = [
        batch,
        outHeight,
        outWidth,
        numChannels
    ];
    const program = new $213d713e17a2d2d6$export$c83a293baf8f269d(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
    return backend.runWebGLProgram(program, [
        image,
        transforms
    ], 'float32');
}
const $ad7656e5cf1d8171$export$1c7a3de6335954ed = {
    kernelName: $2b76be1e72a8c1db$export$563a914cafbdc389,
    backendName: 'webgl',
    kernelFunc: $ad7656e5cf1d8171$export$51186ad6e864892a
};






function $07c62242fef4144e$export$7a5d5c156e7dc406(args) {
    const { inputs: inputs , attrs: attrs , backend: backend  } = args;
    const { axis: axis  } = attrs;
    const { x: x  } = inputs;
    $7428f53c4d4be222$export$1412c17b2531581a(x, 'unique');
    // For now, always forward calculation to the CPU backend.
    console.warn('WARNING: ', 'UI might be locked temporarily as data is being downloaded');
    const values = backend.readSync(x.dataId);
    const { outputValues: outputValues , outputShape: outputShape , indices: indices  } = $31b15458ffa33a6b$export$c417de669ad2e148(values, axis, x.shape, x.dtype);
    return [
        backend.makeTensorInfo(outputShape, x.dtype, outputValues),
        backend.makeTensorInfo([
            indices.length
        ], 'int32', indices), 
    ];
}
const $07c62242fef4144e$export$78cd70dcd092910e = {
    kernelName: $2b76be1e72a8c1db$export$8e3adf126971a183,
    backendName: 'webgl',
    kernelFunc: $07c62242fef4144e$export$7a5d5c156e7dc406
};





function $a7c6e51ab3258a96$export$417857010dc9287f(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { value: value  } = inputs;
    let { axis: axis  } = attrs;
    if (axis < 0) axis += value.shape.length;
    const x = value;
    const xRank = x.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(xRank - 1);
    let outIndex = 0;
    for(let i = 0; i < xRank; i++)if (i !== axis) outShape[outIndex++] = x.shape[i];
    const toDispose = [];
    const begin = new Array(xRank).fill(0);
    const size = x.shape.slice();
    size[axis] = 1;
    const res = new Array(num);
    for(let i1 = 0; i1 < res.length; i1++){
        begin[axis] = i1;
        const sliced = $230f88c53743d502$export$58adb3bec8346d0f({
            inputs: {
                x: x
            },
            backend: backend,
            attrs: {
                begin: begin,
                size: size
            }
        });
        const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
            inputs: {
                x: sliced
            },
            backend: backend,
            attrs: {
                shape: outShape
            }
        });
        res[i1] = reshaped;
        toDispose.push(sliced);
    }
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return res;
}
const $a7c6e51ab3258a96$export$d06292128cae50d6 = {
    kernelName: $2b76be1e72a8c1db$export$441ad6bfc5db8ab4,
    backendName: 'webgl',
    kernelFunc: $a7c6e51ab3258a96$export$417857010dc9287f
};



class $3036f7a7f0af57d4$export$543f739d986d05c3 {
    constructor(segOpInfo, segOpType){
        this.variableNames = [
            'x',
            'segmentIds'
        ];
        const windowSize = segOpInfo.windowSize;
        const batchSize = segOpInfo.batchSize;
        const inSize = segOpInfo.inSize;
        const numSegments = segOpInfo.numSegments;
        const outSize = numSegments * Math.ceil(inSize / windowSize);
        this.outputShape = [
            batchSize,
            outSize
        ];
        const initializationValue = '0.0';
        const returnValue = `sumValue`;
        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        const windowSizeVec4Remainder = windowSize % 4;
        const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
        let checkValueOutOfBounds = '';
        if (inSize % windowSize > 0) checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
        let checkSegmentIdOutOfBounds = '';
        if (inSize % windowSize > 0) checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
        this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
}






function $9622cf3464eda844$export$ba7c4d144d85a309(args) {
    const { inputs: inputs , backend: backend , attrs: attrs  } = args;
    const { x: x1 , segmentIds: segmentIds1  } = inputs;
    const { numSegments: numSegments1  } = attrs;
    const xRank = x1.shape.length;
    const toDispose = [];
    let axis = 0;
    const permutation = $510a55f99d61727a$exports.getAxesPermutation([
        axis
    ], xRank);
    let permutedX = x1;
    if (permutation != null) {
        permutedX = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: x1
            },
            backend: backend,
            attrs: {
                perm: permutation
            }
        });
        toDispose.push(permutedX);
        axis = $510a55f99d61727a$exports.getInnerMostAxes(1, xRank)[0];
    }
    const outShape = $510a55f99d61727a$exports.segment_util.computeOutShape(permutedX.shape, axis, numSegments1);
    const inSize1 = $f6b55a2021b78f0d$exports.sizeFromShape([
        permutedX.shape[axis]
    ]);
    const a2D = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: permutedX
        },
        backend: backend,
        attrs: {
            shape: [
                -1,
                inSize1
            ]
        }
    });
    toDispose.push(a2D);
    const outputDType = $993b52a5dd76e458$export$3479b4fbed3c0d8d(x1.dtype);
    const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments)=>{
        const batchSize = x.shape[0];
        const inSize = x.shape[1];
        const windowSize = $510a55f99d61727a$exports.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);
        const segOpInfo = {
            windowSize: windowSize,
            inSize: inSize,
            batchSize: batchSize,
            numSegments: numSegments
        };
        const program = new $3036f7a7f0af57d4$export$543f739d986d05c3(segOpInfo, segOpType);
        const output = backend.compileAndRun(program, [
            x,
            segmentIds
        ], dtype);
        toDispose.push(output);
        // No need to run another GPGPU program.
        if (output.shape[1] === numSegments) return output;
        const rangeInfo = $8875c72c90407dcb$export$d02631cccf789723({
            backend: backend,
            attrs: {
                start: 0,
                stop: numSegments,
                step: 1,
                dtype: 'float32'
            }
        });
        const tileInfo = $0b1b90217cabcc5d$export$3c17558da18e4d75({
            inputs: {
                x: rangeInfo
            },
            backend: backend,
            attrs: {
                reps: [
                    inSize / windowSize
                ]
            }
        });
        toDispose.push(rangeInfo);
        toDispose.push(tileInfo);
        const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);
        return result;
    };
    const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds1, outputDType, numSegments1);
    const reshaped = $6bcbd3d102cf4841$export$9eaad88cf88cee2b({
        inputs: {
            x: segOpResult
        },
        backend: backend,
        attrs: {
            shape: outShape
        }
    });
    let result1 = reshaped;
    if (permutation != null) {
        toDispose.push(reshaped);
        const perm = $510a55f99d61727a$exports.getUndoAxesPermutation(permutation);
        result1 = $fe12dc0e164e619f$export$9cb09a71b7d66923({
            inputs: {
                x: result1
            },
            backend: backend,
            attrs: {
                perm: perm
            }
        });
    }
    toDispose.forEach((t)=>backend.disposeIntermediateTensorInfo(t)
    );
    return result1;
}
const $9622cf3464eda844$export$71e3626a4ca29968 = {
    kernelName: $2b76be1e72a8c1db$export$af810663cded5fe2,
    backendName: 'webgl',
    kernelFunc: $9622cf3464eda844$export$ba7c4d144d85a309
};



// List all kernel configs here
const $184feb6e52aec4c9$var$kernelConfigs = [
    $296c4f9c0bfe624e$export$f70d36da1c218f84,
    $9c167b03090a04e5$export$d66f48648b9d5ec7,
    $f5fcf2cd62bb030e$export$255826ca70737275,
    $fe7109fdd1b2e239$export$3f520b71a56c9e70,
    $01583232811deb0b$export$b1f3a580afb68e4c,
    $a9ba51f7d668b6eb$export$ff8000bc6f0313e1,
    $fe234f6b5f4e1039$export$4e3f081eb1a330fa,
    $72f756a354227c31$export$1a8ff634f2df3da6,
    $c8fafbe0797fc3bd$export$ec7419fc9ad0069e,
    $334a90ed8d2393f0$export$21836a5e5fa09eb4,
    $fad0cd8fd4877c29$export$de5cb0ef95dd6700,
    $b45af35a7034ee4b$export$20d424616c76166,
    $d33763e81cd7530f$export$159d632e3ff13624,
    $916236386106e37e$export$c53c7ab019edb8a0,
    $338268dd8a086033$export$e9ce1ba75fc9b746,
    $b5758d4576e7c495$export$6c901824a23e6150,
    $b85df75914a86171$export$5a9c81d240244392,
    $43e4241a68b604ef$export$1eeb8780807d0508,
    $b7ac760d8b319767$export$ac3f8709351ab225,
    $83f662a9779214e2$export$d0dd993198185538,
    $115071e6729f0ebb$export$df2dc5c7a755e418,
    $08ffee06d455e0ab$export$44e08e19f97e5513,
    $85bf44907cbde46e$export$af9f0093738840fb,
    $4065ad6ff6ba7894$export$8f7b2ec0c6f08fb2,
    $c980e53a0e50d07c$export$ac4d0f0f3927a8f3,
    $54019c3ff6c0b749$export$df387212b1898306,
    $ae540261f363c96d$export$f7ee8f07ce0ff4e1,
    $1e4941852430620a$export$67917f7910d27fd8,
    $16a6b074ee46ef20$export$a4817d2978acc054,
    $5ce0b60e52bb4a58$export$c8cf96dae25282e5,
    $562cbe282c117d66$export$4a39bf13b4378042,
    $5f8b0663342bf4ca$export$7a95f55d2d2e7d24,
    $4411adccfb9b01bb$export$19bbc19fff1ed26f,
    $7619d588bc0f4c75$export$1fe590fda0829040,
    $8d4ba464631fb110$export$6dce9169640850fa,
    $3e0f65ac92a9d0bd$export$cdcac766a3ef1744,
    $0425cdfb53c4e9fd$export$ff099a1da5235a7e,
    $4da9ed2410b2e306$export$c5824052b09ba0ed,
    $8d9eb13860ae195e$export$f7086edcf0050c7f,
    $7eabab793ed2a4ca$export$db50d81ed60c5a35,
    $a229ab31e5763400$export$2f6196f3316e7ed2,
    $09e2e77d1329ce74$export$88ba267b84334692,
    $42400bf20b37bc81$export$9c5b88dcb1d2008b,
    $4bd891ab18ed24a2$export$240667804b7c390e,
    $2e3c52dbd327acba$export$30bc0ac3775583fc,
    $a57c258ea915c992$export$55d12409e744bebe,
    $091e55739e5ee000$export$56dc5d812a22748f,
    $2edff178331161bc$export$36d3c11f61a8891a,
    $fed02f0f05b3debc$export$40bbf341885a23b7,
    $69fd5438d450bf2e$export$b990686634ee3cce,
    $5b4b6916b6294c87$export$59bb07dd04647a1d,
    $bed0499ce686b622$export$3c8bc3d8ee318217,
    $812b41e295715b9e$export$d044ffef16079bd,
    $7a9db68544dd1ea9$export$2fd7ea0fcf021f34,
    $8abb1069efe45ee9$export$86341ba0ce5d8e60,
    $fd543a585a6c8fd3$export$16db8a08b36f938,
    $d2d80b8778ce7f72$export$a4d564e380763c78,
    $7b5b8f61a189e939$export$c953bf474b2bde62,
    $d177adedca2b684b$export$c9ec83cb23304466,
    $d36f43f784cd7595$export$7e9a0f96fa6bd01c,
    $09a1d39c327224ad$export$7eac933a0c7fd37f,
    $4a02d804f2d95551$export$b22e14d614fc7178,
    $f0c6f5d4ca6a2b90$export$5b64efa829ddf94e,
    $b3757af6f1833cb0$export$58481cc3409b412c,
    $8dce7e04a22e9508$export$d9700eb1c7f5c969,
    $d6a8183309191047$export$b1bd3139c91d8765,
    $18c4147b9607e4cf$export$8c4f7e92d92310f8,
    $4dca33563fa942df$export$7a6926f9fcac24ca,
    $d25b33604ad0d249$export$c426d3942537ad84,
    $38d01a36ce3f8dd5$export$dc267425bf21b465,
    $a716805606e403d7$export$ddfc128c2801add7,
    $c969c8588a456fcd$export$4d45c8f7b9ffdaf1,
    $2b51ad6a2f594a3b$export$bc383b82282e9b5a,
    $7d141e221d55c17d$export$d58ff790c765c1f0,
    $719293cfecd0830c$export$aa04ab963fdf437f,
    $5ab8be00f0fecb22$export$8d4530ce8b6ffc3c,
    $07ea39d8180241c0$export$9f26bd257393dd8,
    $7672231b0fc85b4d$export$46b96f742c70959b,
    $050a0cb48ea72936$export$a4ae1f00643ddd14,
    $cbe0b9adb007fc5b$export$c458b9e5ba980198,
    $c3ec187d6ff1e6c3$export$257f1e82e69113fb,
    $bf19cf2393aade9c$export$68e2dd0840056271,
    $fe6c1844a32dc31c$export$ce04b6546987ef43,
    $8a83a68a2150f887$export$6fb124d5a6994734,
    $c96891b383299f08$export$99a62fc039d7aca0,
    $3c688ad0168df0af$export$7d79147246e312bb,
    $d4a33a7f7298909d$export$45b97bdc342e72a2,
    $21e3b30464ed62a3$export$45c8263b38f19e33,
    $5dac58a5d53e0f25$export$91a8fc5da39ec855,
    $3143d996ffc4399b$export$5201426bb10bd5eb,
    $ffe095f87be7ea61$export$e01a7f8dbee29127,
    $95a6635bd22a1730$export$a069ee2247a7d1ce,
    $e30cfecff2a5f0c6$export$b934af0ccd0cdbe1,
    $fcf9b85161161677$export$3cd9f9a31b38cf18,
    $ccb379ff1a1361a4$export$ea24ffbbbce8d546,
    $acb590d87bf12a71$export$2cfd6c6c7daeb5fc,
    $4ac6b77757ba37c2$export$9037685a81180a9c,
    $67705f4f13e4a922$export$ad960e364767f0e2,
    $5990c68e2ef3564e$export$745576778aafee88,
    $fa9897dc57ad46ae$export$cc7b18b8229c3db,
    $f5f7a77f93d79100$export$549561cd158f260a,
    $5b4ef8a16a378d74$export$906b8fb32c570e9d,
    $10120e3db89632ca$export$4c00b682f309701d,
    $857eef99e73b204e$export$d003d4d7e1500775,
    $35697f7ce28eec31$export$dde5645b472b80b2,
    $8c91cdbc6158ee40$export$d8d7015eb6ab37d0,
    $6db40906cff564f8$export$1645fa8803aa1f86,
    $b61f1b9690890c45$export$b0317e720bfd61fc,
    $784cf101917be3c7$export$b823d49786719761,
    $d5c8a89e81f67413$export$a5c4a9b694579636,
    $6dd2e459e33de7b2$export$d556aa935cef5c0c,
    $8875c72c90407dcb$export$361c4075706e31c2,
    $73eb9a248eb31689$export$4b7bce57557ae68b,
    $86dd7324f9362d49$export$15c5d6176b30b9a6,
    $6e6decab85223d86$export$412a6b66203fdf72,
    $3f17a31fea670b57$export$731f9199bde068eb,
    $d41f9543de4062a4$export$92c30890ad649d53,
    $6bcbd3d102cf4841$export$cfa02e698602aca2,
    $3ca9a7d03c380047$export$a37a56137abc1357,
    $4c155922869031af$export$51f84ca614e84763,
    $7f6cffaa0055f9e6$export$2b6a92caba113b89,
    $d0eeaa9e9236582e$export$2b08d810b5090fe1,
    $60c11b6eef7dfa81$export$cab6a4e8d2ed8e8d,
    $24a900ade3367b78$export$44ba8c83417ab668,
    $8f6224b4b6e4abab$export$6c09e3291f636503,
    $b1ba2b65877c5c17$export$941104b789956ef6,
    $7bb9c8ec7ed63e3e$export$573371744f044f5,
    $a5456b88c4f1014e$export$7ff911e710ee72fc,
    $44d2e3bfcf9989b5$export$8afc8558705c1a39,
    $9f7ab51834752a66$export$195d1cf7c59f3ef,
    $252199f6f7e45ee6$export$9c0fb3eb2124ceb7,
    $ca5ac725b0f62c2e$export$d993ec4e5c253b66,
    $4e7254a6cee31204$export$b92766b47f18ac85,
    $230f88c53743d502$export$8d8a1e11dd2cc6c4,
    $a909eb8eb92742a2$export$c022691f23e2ee69,
    $9d2e8bad92f865e5$export$d9bcfe553d12d9e3,
    $d1c95f41eea285c2$export$2f85417863d2050b,
    $44b09c54ae7d8045$export$818286c593224d1a,
    $72026153e4a739a6$export$eb106efc10374803,
    $e2da4fb417fd831a$export$51e7224ae14d7f78,
    $bac0420164a6e512$export$73fa0270f28b9555,
    $f5670097b375670e$export$7bc088f8ad44ef99,
    $dd6f489928e3c9df$export$317be24be3af9ea0,
    $e49b11e56bbc06d9$export$a592ba9268f10eeb,
    $b2fd760a707171d5$export$7c77bece4d51efc4,
    $ad86dda305f851c2$export$9ed4691d69db8a43,
    $36c860301d2cd8a5$export$c42ffaf52eb2647,
    $9e327212b1591a99$export$81773633114187bd,
    $f614ef32cc78b356$export$35e13284eed34c22,
    $1b1a4ee6218d3c50$export$c51cbbd627a96532,
    $831c8c71c9bb25e1$export$a88a78b2b233f507,
    $e59e1f5cc1f80c8f$export$5d068476dad60c4d,
    $da8ee0e3114a74ea$export$47edea402251c258,
    $420986fdb90b2e6a$export$97648844df7611f3,
    $cd15947c0ecdfafe$export$a2fc7de1a1e4eee0,
    $0b1b90217cabcc5d$export$a5a9f8050ba7f41e,
    $ec334b59eba01091$export$cffaee31213314ce,
    $ad7656e5cf1d8171$export$1c7a3de6335954ed,
    $fe12dc0e164e619f$export$895a002a39b774be,
    $07c62242fef4144e$export$78cd70dcd092910e,
    $a7c6e51ab3258a96$export$d06292128cae50d6,
    $9622cf3464eda844$export$71e3626a4ca29968,
    $fd1448403917bac4$export$15368df05c479e41
];
for (const kernelConfig of $184feb6e52aec4c9$var$kernelConfigs)$18a84b897e201316$export$f3f7c443f3a606e6(kernelConfig);





const $e8526f3e53138c84$var$ENV = $78e7329b437d1e00$export$a7b6bc01c63cdfc3();
/**
 * This file contains WebGL-specific flag registrations.
 */ /**
 * True if WebGL is supported.
 */ $e8526f3e53138c84$var$ENV.registerFlag('HAS_WEBGL', ()=>$e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION') > 0
);
/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_VERSION', ()=>{
    if ($7428f53c4d4be222$export$9232c111e2230c00(2)) return 2;
    else if ($7428f53c4d4be222$export$9232c111e2230c00(1)) return 1;
    return 0;
});
/** Whether to check for numerical representation problems. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', ()=>false
);
$e8526f3e53138c84$var$ENV.registerFlag('WEBGL_BUFFER_SUPPORTED', ()=>$e8526f3e53138c84$var$ENV.get('WEBGL_VERSION') === 2
);
/** Whether the WebGL backend will sometimes forward ops to the CPU. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_CPU_FORWARD', ()=>true
);
/** Whether the WebGL backend will always use f16 textures for rendering. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', ()=>false
);
/** Whether to turn all packing related flags on. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK', ()=>$e8526f3e53138c84$var$ENV.getBool('HAS_WEBGL')
);
/** Whether we will pack the batchnormalization op. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_NORMALIZATION', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack the clip op. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_CLIP', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack the depthwise conv op. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack binary ops. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack unary ops. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack array ops. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack image ops. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will pack reduce ops. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_PACK_REDUCE', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether packed WebGL kernels lazily unpack their outputs. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_LAZILY_UNPACK', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** Whether we will use the im2col algorithm to speed up convolutions. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_CONV_IM2COL', ()=>$e8526f3e53138c84$var$ENV.getBool('WEBGL_PACK')
);
/** The maximum texture dimension. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', ()=>$7428f53c4d4be222$export$9dbf32263e41ec5($e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION'))
);
/** The maximum texture dimension. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', ()=>$7428f53c4d4be222$export$ce91baf6aebded89($e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION'))
);
/**
 * The disjoint_query_timer extension version.
 * 0: disabled, 1: EXT_disjoint_timer_query, 2:
 * EXT_disjoint_timer_query_webgl2.
 * In Firefox with WebGL 2.0,
 * EXT_disjoint_timer_query_webgl2 is not available, so we must use the
 * WebGL 1.0 extension.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', ()=>{
    const webGLVersion = $e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION');
    if (webGLVersion === 0) return 0;
    return $7428f53c4d4be222$export$8a49d28f4bb7b8a0(webGLVersion);
});
/**
 * Whether the timer object from the disjoint_query_timer extension gives
 * timing information that is reliable.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', ()=>$e8526f3e53138c84$var$ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 && !$20e2f2a589b22510$exports.isMobile()
);
/**
 * Whether the device is physically capable of rendering to float32 textures.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', ()=>$7428f53c4d4be222$export$d571cb60e9b5ec74($e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION'))
);
/**
 * Whether rendering to float32 textures is enabled. If disabled, renders to
 * float16 textures.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', ()=>{
    return $e8526f3e53138c84$var$ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ? false : $e8526f3e53138c84$var$ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');
});
/**
 * Whether downloading float textures is enabled (16 or 32 bit). If disabled,
 * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', ()=>$7428f53c4d4be222$export$9cd61c8662dbbc66($e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION'))
);
/** Whether the fence API is available. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_FENCE_API_ENABLED', ()=>$7428f53c4d4be222$export$77efcdc20b17e5f2($e8526f3e53138c84$var$ENV.getNumber('WEBGL_VERSION'))
);
/**
 * Tensors with size <= than this will be uploaded as uniforms, not textures.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', ()=>{
    // Use uniform uploads only when 32bit floats are supported. In
    // 16bit
    // environments there are problems with comparing a 16bit texture value
    // with a 32bit uniform value.
    const useUniforms = $e8526f3e53138c84$var$ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');
    return useUniforms ? 4 : 0;
});
/**
 * If the total number of bytes allocated on the GPU is greater than this
 * number, we will aggressively delete textures upon disposal with
 * gl.deleteMatrixTexture, rather than making them available for reuse.
 *
 * Default value -1 indicates that we will never aggressively delete textures.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', ()=>{
    return -1;
}, (threshold)=>{
    if (threshold < 0 && threshold !== -1) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` + `delete) or at least 0, but got ${threshold}.`);
});
/**
 * Trigger a manual GL command flush if the threshold of time has passed since
 * previous Kernel execution. This can be useful for Andorid device where GL
 * command flush are delayed un til the end of javascript task. This value is
 * measured in millisecond. Typically you want to set this value to close to 1.
 *
 * Default value 1 for mobile chrome, and -1 for rest cases. -1 indicates that
 * we will not enforce manual flush and depend on system default flush schedule.
 */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_FLUSH_THRESHOLD', ()=>{
    return $20e2f2a589b22510$exports.isMobile() ? 1 : -1;
}, (threshold)=>{
    if (threshold < 0 && threshold !== -1) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never ` + `manual flush) or at least 0, but got ${threshold}.`);
});
/**
 * Threshold for input tensor size that determines whether WebGL backend will
 * delegate computation to CPU.
 *
 * Default value is 128.
 */ $e8526f3e53138c84$var$ENV.registerFlag('CPU_HANDOFF_SIZE_THRESHOLD', ()=>128
);
/** Whether we will use shapes uniforms. */ $e8526f3e53138c84$var$ENV.registerFlag('WEBGL_USE_SHAPES_UNIFORMS', ()=>false
);
/**
 * Threshold for last dimension of input tensor that determines whether
 * WebGL backend for the Top K op will delegate computation to CPU. If input
 * is smaller than threshold then CPU will be used
 *
 * Default value is 100000.
 */ $e8526f3e53138c84$var$ENV.registerFlag('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD', ()=>100000
);
/**
 * Threshold for K that determines whether
 * WebGL backend for the Top K op will delegate computation to CPU. If k
 * is larger than threshold then CPU will be used
 *
 * Default value is 128.
 */ $e8526f3e53138c84$var$ENV.registerFlag('TOPK_K_CPU_HANDOFF_THRESHOLD', ()=>128
);








class $2f735e5046cb23b0$export$f6ee51c6efbee026 {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = false;
        this.packedOutput = true;
        this.outPackingScheme = $7ea242d526563f56$export$81d5c79efa1086f2.DENSE;
        this.customUniforms = [
            {
                name: 'texShape',
                type: 'ivec2'
            }
        ];
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? $ee41ed15b893490d$export$ae684ebb20c3e80c([
            'r',
            'c',
            'd'
        ], outputShape) : $ee41ed15b893490d$export$53c37f67510642ce([
            'r',
            'c',
            'd'
        ], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
    }
}






class $f9bb4b31b50bb598$export$4434db41c70879cb {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = true;
        this.outPackingScheme = $7ea242d526563f56$export$81d5c79efa1086f2.DENSE;
        this.customUniforms = [
            {
                name: 'texShape',
                type: 'ivec2'
            }
        ];
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? $ee41ed15b893490d$export$ae684ebb20c3e80c([
            'r',
            'c',
            'd'
        ], outputShape) : $ee41ed15b893490d$export$53c37f67510642ce([
            'r',
            'c',
            'd'
        ], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
    }
}





class $cb915a894a6d67d1$export$dae4f112167b5aac {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.outTexUsage = $7ea242d526563f56$export$6bf4bd1b6beb0bfd.DOWNLOAD;
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.userCode = `
      ${$ee41ed15b893490d$export$2ac12a308a563905}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
    }
}





class $92788da84234e5c7$export$97e262e8a4818e2e {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outTexUsage = $7ea242d526563f56$export$6bf4bd1b6beb0bfd.DOWNLOAD;
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.userCode = `
      ${$ee41ed15b893490d$export$2ac12a308a563905}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
    }
}





class $61a84908d4955ec2$export$b2e063313033aeab {
    constructor(outputShape, inputIsUnsignedByte = false){
        this.variableNames = [
            'A'
        ];
        this.customUniforms = [
            {
                name: 'texShape',
                type: 'ivec2'
            }
        ];
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        let output = `result`;
        if (inputIsUnsignedByte) output = `floor(result * 255. + 0.5)`;
        this.userCode = `
      ${this.enableShapeUniforms ? $ee41ed15b893490d$export$4ec1e3f6361de451() : $ee41ed15b893490d$export$4c68558c71205a01(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
    }
}





class $b6fd1c9c8aea7f9a$export$3b3e6b1f67c8c4d5 {
    constructor(outputShape, inputIsUnsignedByte = false){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = false;
        this.packedOutput = true;
        this.customUniforms = [
            {
                name: 'texShape',
                type: 'ivec2'
            }
        ];
        const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        let mainLoop = '';
        let output = 'result';
        if (inputIsUnsignedByte) output = 'floor(result * 255. + 0.5)';
        for(let row = 0; row <= 1; row++)for(let col = 0; col <= 1; col++){
            const channel = row * 2 + col;
            mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? 'outShape[2]' : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? 'outShape[1]' : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
        }
        this.userCode = `
        ${this.enableShapeUniforms ? $ee41ed15b893490d$export$4ec1e3f6361de451() : $ee41ed15b893490d$export$4c68558c71205a01(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
    }
}








function $e764bfbdb52c6abd$export$4ca6704ce1875929(gl) {
    const glsl = $3fd32f5baad8d391$export$3ebf4a18d6319f7a();
    const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return $7428f53c4d4be222$export$4ca6704ce1875929(gl, vertexShaderSource);
}
function $e764bfbdb52c6abd$export$8ddd35f9c5bd5634(gl) {
    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]
    const vertexArray = new Float32Array([
        -1,
        1,
        0,
        0,
        1,
        -1,
        -1,
        0,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        1,
        -1,
        0,
        1,
        0
    ]);
    return $7428f53c4d4be222$export$3871e1d1e28ac6cb(gl, vertexArray);
}
function $e764bfbdb52c6abd$export$2be7df49658092d0(gl) {
    // OpenGL (and WebGL) have "CCW == front" winding
    const triangleVertexIndices = new Uint16Array([
        0,
        1,
        2,
        2,
        1,
        3
    ]);
    return $7428f53c4d4be222$export$f9b26b97ca2b25e9(gl, triangleVertexIndices);
}
function $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
    $7428f53c4d4be222$export$3543950a45505554(width, height);
    const texture = $7428f53c4d4be222$export$37b981a8c575f415(gl);
    const tex2d = gl.TEXTURE_2D;
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(tex2d, texture)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    );
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 1) $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null)
    );
    else $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texStorage2D(tex2d, 1, internalFormat, width, height)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, null)
    );
    return {
        texture: texture,
        texShape: [
            height,
            width
        ]
    };
}
function $e764bfbdb52c6abd$export$46e83db9ed4a55ec(textureConfig) {
    return textureConfig.internalFormatFloat;
}
function $e764bfbdb52c6abd$export$b6545ebc87bceaba(gl, rows, columns, textureConfig) {
    const [width, height] = $7ea242d526563f56$export$95fb8493b25f77a4(rows, columns);
    return $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, $e764bfbdb52c6abd$export$46e83db9ed4a55ec(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
}
function $e764bfbdb52c6abd$export$c3c5df7eccaed480(textureConfig) {
    return textureConfig.internalFormatHalfFloat;
}
function $e764bfbdb52c6abd$export$3e231b7a052616c2(gl, rows, columns, textureConfig) {
    const [width, height] = $7ea242d526563f56$export$95fb8493b25f77a4(rows, columns);
    return $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, $e764bfbdb52c6abd$export$c3c5df7eccaed480(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
}
function $e764bfbdb52c6abd$export$ed62004e3546feef(textureConfig) {
    return textureConfig.downloadTextureFormat;
}
function $e764bfbdb52c6abd$export$23456bef7917c292(gl, rows, columns, textureConfig) {
    const [width, height] = $7ea242d526563f56$export$95fb8493b25f77a4(rows, columns);
    return $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, $e764bfbdb52c6abd$export$ed62004e3546feef(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
}
function $e764bfbdb52c6abd$export$dcae4a9709a9d6(textureConfig) {
    return textureConfig.internalFormatPackedFloat;
}
function $e764bfbdb52c6abd$export$9edab265a05c8d3a(gl, rows, columns, textureConfig) {
    const [width, height] = $7ea242d526563f56$export$2754e02fa98f5582(rows, columns);
    return $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, $e764bfbdb52c6abd$export$dcae4a9709a9d6(textureConfig), gl.RGBA, gl.FLOAT);
}
function $e764bfbdb52c6abd$export$9b8d6c2b6b2037b0(textureConfig) {
    return textureConfig.internalFormatPackedHalfFloat;
}
function $e764bfbdb52c6abd$export$9c51ae7c3160b50c(gl, rows, columns, textureConfig) {
    const [width, height] = $7ea242d526563f56$export$2754e02fa98f5582(rows, columns);
    return $e764bfbdb52c6abd$var$createAndConfigureTexture(gl, width, height, $e764bfbdb52c6abd$export$9b8d6c2b6b2037b0(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
}
function $e764bfbdb52c6abd$export$9080d84e4e2d38c9(gl, program, vertexBuffer) {
    const posOffset = 0; // x is the first buffer element
    const uvOffset = 12; // uv comes after [x y z]
    const stride = 20; // xyz + uv, each entry is 4-byte float.
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
    );
    const success = $7428f53c4d4be222$export$4c858b3c953a013f(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    return success && $7428f53c4d4be222$export$4c858b3c953a013f(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
function $e764bfbdb52c6abd$export$fe948dd2858cae63(gl, texture, width, height, data, textureConfig) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, texture)
    );
    let dataForUpload, texelDataType, internalFormat;
    if (data instanceof Uint8Array) {
        dataForUpload = new Uint8Array(width * height * 4);
        texelDataType = gl.UNSIGNED_BYTE;
        internalFormat = gl.RGBA;
    } else {
        dataForUpload = new Float32Array(width * height * 4);
        texelDataType = gl.FLOAT;
        internalFormat = textureConfig.internalFormatPackedFloat;
    }
    dataForUpload.set(data);
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, texelDataType, dataForUpload)
    );
    else $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, null)
    );
}
function $e764bfbdb52c6abd$export$2d42c33b8625a8d7(gl, texture, pixels) {
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, texture)
    );
    if (pixels.data instanceof Uint8Array) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixels.width, pixels.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data)
        );
        else $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data)
        );
    } else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
    );
    else $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindTexture(gl.TEXTURE_2D, null)
    );
}
function $e764bfbdb52c6abd$export$2983fc3c819070e9(gl2, rows, columns, textureConfig) {
    // Create and bind the buffer.
    const buffer = gl2.createBuffer();
    $7428f53c4d4be222$export$7642ac97981532b8(gl2, ()=>gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer)
    );
    // Initialize the buffer to the size of the texture in bytes.
    const bytesPerFloat = 4;
    const valuesPerTexel = 4;
    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
    $7428f53c4d4be222$export$7642ac97981532b8(gl2, ()=>gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ)
    );
    // Enqueue a command on the GPU command queue to copy of texture into the
    // buffer.
    $7428f53c4d4be222$export$7642ac97981532b8(gl2, ()=>gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0)
    );
    $7428f53c4d4be222$export$7642ac97981532b8(gl2, ()=>gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null)
    );
    return buffer;
}
function $e764bfbdb52c6abd$export$3d2780ea6b3027ca(gl, buffer, size) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(size);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
}
function $e764bfbdb52c6abd$export$6bc5a1ce24b8dc6c(gl, rows, columns, textureConfig) {
    const [w, h] = $7ea242d526563f56$export$95fb8493b25f77a4(rows, columns);
    const numChannels = 4;
    const downloadTarget = new Uint8Array($7ea242d526563f56$export$9427543edb6e188a(rows * columns, numChannels));
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget)
    );
    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754
    // decoding of the 4 bytes that back each 32 bit float.
    return new Float32Array(downloadTarget.buffer);
}
function $e764bfbdb52c6abd$export$4fe1bc4caaf85c22(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
    const gl2 = gl;
    const downloadTarget = new Float32Array($7ea242d526563f56$export$12d4e412f879b1d4(physicalRows, physicalCols));
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
}
function $e764bfbdb52c6abd$export$7287c6a301610ce2(gl, physicalRows, physicalCols) {
    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
    $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA)
    );
    return packedRGBA;
}




class $86249af5c6a57cc9$export$fa7a74a0ce382ac5 {
    constructor(gl){
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.vertexAttrsAreBound = false;
        this.itemsToPoll = [];
        const glVersion = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION');
        if (gl != null) {
            this.gl = gl;
            $9ee1746afacd745d$export$4b8d5e1525955c68(glVersion, gl);
        } else this.gl = $9ee1746afacd745d$export$c7a808a518b9a146(glVersion);
        // WebGL 2.0 enables texture floats without an extension.
        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';
        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';
        this.parallelCompilationExtension = this.gl.getExtension('KHR_parallel_shader_compile');
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 1) {
            const TEXTURE_FLOAT = 'OES_texture_float';
            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';
            this.textureFloatExtension = $7428f53c4d4be222$export$3a5e7a891790a26c(this.gl, TEXTURE_FLOAT);
            if ($7428f53c4d4be222$export$4f402f57c05c9ec3(this.gl, TEXTURE_HALF_FLOAT)) this.textureHalfFloatExtension = $7428f53c4d4be222$export$3a5e7a891790a26c(this.gl, TEXTURE_HALF_FLOAT);
            else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_FORCE_F16_TEXTURES')) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
            if ($7428f53c4d4be222$export$4f402f57c05c9ec3(this.gl, COLOR_BUFFER_HALF_FLOAT)) this.colorBufferHalfFloatExtension = $7428f53c4d4be222$export$3a5e7a891790a26c(this.gl, COLOR_BUFFER_HALF_FLOAT);
            else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_FORCE_F16_TEXTURES')) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        } else {
            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';
            if ($7428f53c4d4be222$export$4f402f57c05c9ec3(this.gl, COLOR_BUFFER_FLOAT)) this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
            else if ($7428f53c4d4be222$export$4f402f57c05c9ec3(this.gl, COLOR_BUFFER_HALF_FLOAT)) this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
            else throw new Error('GL context does not support color renderable floats');
        }
        this.vertexBuffer = $e764bfbdb52c6abd$export$8ddd35f9c5bd5634(this.gl);
        this.indexBuffer = $e764bfbdb52c6abd$export$2be7df49658092d0(this.gl);
        this.framebuffer = $7428f53c4d4be222$export$366d1e3e32f5a700(this.gl);
        this.textureConfig = $7ea242d526563f56$export$129d92ae6e74c416(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
        return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG');
    }
    dispose() {
        if (this.disposed) return;
        if (this.program != null) console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
        if (this.outputTexture != null) console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
        const gl = this.gl;
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.finish()
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindFramebuffer(gl.FRAMEBUFFER, null)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.deleteFramebuffer(this.framebuffer)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ARRAY_BUFFER, null)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.deleteBuffer(this.indexBuffer)
        );
        this.disposed = true;
    }
    createFloat32MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return $e764bfbdb52c6abd$export$b6545ebc87bceaba(this.gl, rows, columns, this.textureConfig);
    }
    createFloat16MatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return $e764bfbdb52c6abd$export$3e231b7a052616c2(this.gl, rows, columns, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return $e764bfbdb52c6abd$export$23456bef7917c292(this.gl, rows, columns, this.textureConfig);
    }
    uploadPixelDataToTexture(texture, pixels) {
        this.throwIfDisposed();
        $e764bfbdb52c6abd$export$2d42c33b8625a8d7(this.gl, texture, pixels);
    }
    uploadDenseMatrixToTexture(texture, width, height, data) {
        this.throwIfDisposed();
        $e764bfbdb52c6abd$export$fe948dd2858cae63(this.gl, texture, width, height, data, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return $e764bfbdb52c6abd$export$9c51ae7c3160b50c(this.gl, rows, columns, this.textureConfig);
    }
    createPackedMatrixTexture(rows, columns) {
        this.throwIfDisposed();
        return $e764bfbdb52c6abd$export$9edab265a05c8d3a(this.gl, rows, columns, this.textureConfig);
    }
    deleteMatrixTexture(texture) {
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            $7428f53c4d4be222$export$d3c809959a3c24fa(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.deleteTexture(texture)
        );
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
        return this.downloadMatrixDriver(texture, ()=>$e764bfbdb52c6abd$export$6bc5a1ce24b8dc6c(this.gl, rows, columns, this.textureConfig)
        );
    }
    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {
        return $e764bfbdb52c6abd$export$4fe1bc4caaf85c22(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(buffer, size) {
        return $e764bfbdb52c6abd$export$3d2780ea6b3027ca(this.gl, buffer, size);
    }
    createBufferFromTexture(texture, rows, columns) {
        this.bindTextureToFrameBuffer(texture);
        const result = $e764bfbdb52c6abd$export$2983fc3c819070e9(this.gl, rows, columns, this.textureConfig);
        this.unbindTextureToFrameBuffer();
        return result;
    }
    createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
    }
    createFence(gl) {
        let query;
        let isFencePassed;
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_FENCE_API_ENABLED')) {
            const gl2 = gl;
            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            gl.flush();
            isFencePassed = ()=>{
                const status = gl2.clientWaitSync(sync, 0, 0);
                return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
            };
            query = sync;
        } else if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            query = this.beginQuery();
            this.endQuery();
            isFencePassed = ()=>this.isQueryAvailable(query, $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))
            ;
        } else // If we have no way to fence, return true immediately. This will fire in
        // WebGL 1.0 when there is no disjoint query timer. In this case, because
        // the fence passes immediately, we'll immediately ask for a download of
        // the texture, which will cause the UI thread to hang.
        isFencePassed = ()=>true
        ;
        return {
            query: query,
            isFencePassed: isFencePassed
        };
    }
    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
        return this.downloadMatrixDriver(texture, ()=>$e764bfbdb52c6abd$export$7287c6a301610ce2(this.gl, physicalRows, physicalCols)
        );
    }
    createProgram(fragmentShader) {
        this.throwIfDisposed();
        const gl = this.gl;
        if (this.vertexShader == null) this.vertexShader = $e764bfbdb52c6abd$export$4ca6704ce1875929(gl);
        const program = $7428f53c4d4be222$export$327d24a04cd0dc17(gl);
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.attachShader(program, this.vertexShader)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.attachShader(program, fragmentShader)
        );
        $7428f53c4d4be222$export$d879afae78b531a5(gl, program);
        if (this.debug) $7428f53c4d4be222$export$e2dfaf93681cde16(gl, program);
        if (!this.vertexAttrsAreBound) {
            this.setProgram(program);
            this.vertexAttrsAreBound = $e764bfbdb52c6abd$export$9080d84e4e2d38c9(gl, this.program, this.vertexBuffer);
        }
        return program;
    }
    deleteProgram(program) {
        this.throwIfDisposed();
        if (program === this.program) this.program = null;
        if (program != null) $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.deleteProgram(program)
        );
    }
    setProgram(program) {
        this.throwIfDisposed();
        this.program = program;
        if (this.program != null && this.debug) $7428f53c4d4be222$export$e2dfaf93681cde16(this.gl, this.program);
        $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.useProgram(program)
        );
    }
    getUniformLocation(program, uniformName, shouldThrow = true) {
        this.throwIfDisposed();
        if (shouldThrow) return $7428f53c4d4be222$export$748cafa2cdf50d8(this.gl, program, uniformName);
        else return $7428f53c4d4be222$export$d27256445dd7e8dd(this.gl, program, uniformName);
    }
    getAttributeLocation(program, attribute) {
        this.throwIfDisposed();
        return $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.getAttribLocation(program, attribute)
        );
    }
    getUniformLocationNoThrow(program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    }
    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        $7428f53c4d4be222$export$f9ffd997f3c8b98f(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
    }
    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    }
    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        const [width, height] = $7ea242d526563f56$export$2754e02fa98f5582(rows, columns);
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    }
    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    }
    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    }
    debugValidate() {
        if (this.program != null) $7428f53c4d4be222$export$e2dfaf93681cde16(this.gl, this.program);
        $7428f53c4d4be222$export$ca09b577525e6519(this.gl);
    }
    executeProgram() {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        const gl = this.gl;
        if (this.debug) this.debugValidate();
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)
        );
    }
    blockUntilAllProgramsCompleted() {
        this.throwIfDisposed();
        $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.finish()
        );
    }
    getQueryTimerExtension() {
        if (this.disjointQueryTimerExtension == null) this.disjointQueryTimerExtension = $7428f53c4d4be222$export$3a5e7a891790a26c(this.gl, $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');
        return this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
        return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
        return this.getQueryTimerExtension();
    }
    beginQuery() {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            const query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        const query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    }
    endQuery() {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
        }
        const ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(query) {
        await $f6b55a2021b78f0d$exports.repeatedTry(()=>this.disposed || // in rapid succession, so without this check we
            // may poll for the query timer indefinitely
            this.isQueryAvailable(query, $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'))
        );
        return this.getQueryTime(query, $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));
    }
    getQueryTime(query, queryTimerVersion) {
        if (queryTimerVersion === 0) return null;
        if (queryTimerVersion === 2) {
            const gl2 = this.gl;
            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            // Return milliseconds.
            return timeElapsedNanos / 1000000;
        } else {
            const ext = this.getQueryTimerExtensionWebGL1();
            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            // Return milliseconds.
            return timeElapsedNanos / 1000000;
        }
    }
    isQueryAvailable(query, queryTimerVersion) {
        if (queryTimerVersion === 0) return true;
        if (queryTimerVersion === 2) {
            const gl2 = this.gl;
            const ext = this.getQueryTimerExtensionWebGL2();
            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            if (this.disjoint == null) this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            return available && !this.disjoint;
        } else {
            const ext = this.getQueryTimerExtensionWebGL1();
            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            if (this.disjoint == null) this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            return available && !this.disjoint;
        }
    }
    pollFence(fenceContext) {
        return new Promise((resolve)=>{
            this.addItemToPoll(()=>fenceContext.isFencePassed()
            , ()=>resolve()
            );
        });
    }
    pollItems() {
        // Find the last query that has finished.
        const index = $86249af5c6a57cc9$export$4a09b41294052731(this.itemsToPoll.map((x)=>x.isDoneFn
        ));
        for(let i = 0; i <= index; ++i){
            const { resolveFn: resolveFn  } = this.itemsToPoll[i];
            resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    }
    addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({
            isDoneFn: isDoneFn,
            resolveFn: resolveFn
        });
        if (this.itemsToPoll.length > 1) // We already have a running loop that polls.
        return;
        // Start a new loop that polls.
        $f6b55a2021b78f0d$exports.repeatedTry(()=>{
            this.pollItems();
            // End the loop if no more items to poll.
            return this.itemsToPoll.length === 0;
        });
    }
    bindTextureToFrameBuffer(texture) {
        this.throwIfDisposed();
        $7428f53c4d4be222$export$4e154f0d71f19013(this.gl, texture, this.framebuffer);
        if (this.debug) $7428f53c4d4be222$export$ca09b577525e6519(this.gl);
    }
    unbindTextureToFrameBuffer() {
        if (this.outputTexture != null) {
            $7428f53c4d4be222$export$4e154f0d71f19013(this.gl, this.outputTexture, this.framebuffer);
            if (this.debug) $7428f53c4d4be222$export$ca09b577525e6519(this.gl);
        } else $7428f53c4d4be222$export$d3c809959a3c24fa(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(texture, downloadAndDecode) {
        this.bindTextureToFrameBuffer(texture);
        const result = downloadAndDecode();
        this.unbindTextureToFrameBuffer();
        return result;
    }
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        const gl = this.gl;
        $7428f53c4d4be222$export$4e154f0d71f19013(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.debug) $7428f53c4d4be222$export$ca09b577525e6519(gl);
        this.outputTexture = outputMatrixTextureMaybePacked;
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.viewport(0, 0, width, height)
        );
        $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.scissor(0, 0, width, height)
        );
    }
    setOutputMatrixWriteRegionDriver(x, y, width, height) {
        this.throwIfDisposed();
        $7428f53c4d4be222$export$7642ac97981532b8(this.gl, ()=>this.gl.scissor(x, y, width, height)
        );
    }
    throwIfDisposed() {
        if (this.disposed) throw new Error('Attempted to use disposed GPGPUContext.');
    }
    throwIfNoProgram() {
        if (this.program == null) throw new Error('No GPU program is currently set.');
    }
}
function $86249af5c6a57cc9$export$4a09b41294052731(arr) {
    let i = 0;
    for(; i < arr.length; ++i){
        const isDone = arr[i]();
        if (!isDone) break;
    }
    return i - 1;
}








class $5004c86a694ef749$export$5ebf74a9a135ce1d {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = false;
        this.packedOutput = true;
        // Only input / output 3D tensors.
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        if (this.rank === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
        else {
            const channels = $941a295bfee22e2b$export$7a4d1d0d17b69972('rc', this.rank);
            const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(this.rank);
            const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);
            const setup = this.getSetup(channels);
            const output = this.getOutput(channels);
            this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
        }
    }
    getSourceCoordsArr(dims) {
        const coords = [];
        for(let row = 0; row <= 1; row++)for(let col = 0; col <= 1; col++){
            let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;
            for(let d = 2; d < this.rank; d++)coord = `${dims[dims.length - 1 - d]},` + coord;
            coords.push(coord);
        }
        return coords;
    }
    getOutOfBoundsCondition(dims) {
        if (this.rank === 1) return `rc > ${this.enableShapeUniforms ? 'outShape' : this.outputShape[0]}`;
        let cond = '';
        for(let i = this.rank - 2; i < this.rank; i++){
            cond += `${dims[i]} >= ${this.enableShapeUniforms ? `outShape[${i}]` : this.outputShape[i]}`;
            if (i < this.rank - 1) cond += '||';
        }
        return cond;
    }
    getSetup(dims) {
        if (this.rank === 1) return '';
        const innerDims = dims.slice(-2);
        const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1];
        const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
        return `
      int r = ${innerDims[0]};
      int c = ${innerDims[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${col};
      bool rEdge = rp1 >= ${row};
    `;
    }
    getOutput(dims) {
        const sourceCoords = this.getSourceCoordsArr(dims);
        if (this.rank === 1) {
            const outShape = this.enableShapeUniforms ? 'outShape' : this.outputShape[0];
            return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;
        }
        return `getA(${sourceCoords[0]}),
            cEdge ? 0. : getA(${sourceCoords[1]}),
            rEdge ? 0. : getA(${sourceCoords[2]}),
            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
    }
}








class $b7620dd3ee4a56cd$export$337f59f8fd79d24f {
    constructor(gpgpu){
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0; // How many bytes that have been allocated
        // are available for reuse.
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextures = {};
    }
    acquireTexture(shapeRC, usage, isPacked) {
        const physicalTexType = $b7620dd3ee4a56cd$var$getPhysicalFromLogicalTextureType(usage, isPacked);
        const shapeKey = $b7620dd3ee4a56cd$var$getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) this.freeTextures[shapeKey] = [];
        if (!(shapeKey in this.usedTextures)) this.usedTextures[shapeKey] = [];
        const texBytes = $b7620dd3ee4a56cd$export$66c19e55ce03e099(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this._numBytesFree -= texBytes;
            this.log();
            const newTexture = this.freeTextures[shapeKey].shift();
            this.usedTextures[shapeKey].push(newTexture);
            return newTexture;
        }
        let newTexture;
        if (physicalTexType === $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT32) newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
        else if (physicalTexType === $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT16) newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
        else if (physicalTexType === $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT32) newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
        else if (physicalTexType === $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT16) newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
        else if (physicalTexType === $7ea242d526563f56$export$bde70ab3692e385c.PACKED_4X1_UNSIGNED_BYTE) newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
        this.usedTextures[shapeKey].push(newTexture);
        this.numUsedTextures++;
        this._numBytesAllocated += texBytes;
        this.log();
        return newTexture;
    }
    releaseTexture(texture, shape, logicalTexType, isPacked) {
        if (this.freeTextures == null) // Already disposed.
        return;
        const physicalTexType = $b7620dd3ee4a56cd$var$getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
        const shapeKey = $b7620dd3ee4a56cd$var$getKeyFromTextureShape(shape, physicalTexType, isPacked);
        if (!(shapeKey in this.freeTextures)) this.freeTextures[shapeKey] = [];
        const texBytes = $b7620dd3ee4a56cd$export$66c19e55ce03e099(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
        const deleteTexThreshold = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_DELETE_TEXTURE_THRESHOLD');
        if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
            this.gpgpu.deleteMatrixTexture(texture.texture);
            this._numBytesAllocated -= texBytes;
        } else {
            this.freeTextures[shapeKey].push(texture);
            this.numFreeTextures++;
            this._numBytesFree += texBytes;
        }
        this.numUsedTextures--;
        const texList = this.usedTextures[shapeKey];
        const texIndex = texList.indexOf(texture);
        if (texIndex < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
        texList.splice(texIndex, 1);
        this.log();
    }
    log() {
        if (!this.logEnabled) return;
        const total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
        const freeRatio = this._numBytesFree / this._numBytesAllocated;
        console.log(`Bytes allocated: ${this._numBytesAllocated}`);
        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
    }
    get numBytesAllocated() {
        return this._numBytesAllocated;
    }
    get numBytesFree() {
        return this._numBytesFree;
    }
    getNumUsedTextures() {
        return this.numUsedTextures;
    }
    getNumFreeTextures() {
        return this.numFreeTextures;
    }
    dispose() {
        if (this.freeTextures == null) // Already disposed.
        return;
        for(const texShape in this.freeTextures)this.freeTextures[texShape].forEach((tex)=>{
            this.gpgpu.deleteMatrixTexture(tex.texture);
        });
        for(const texShape1 in this.usedTextures)this.usedTextures[texShape1].forEach((tex)=>{
            this.gpgpu.deleteMatrixTexture(tex.texture);
        });
        this.freeTextures = null;
        this.usedTextures = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this._numBytesAllocated = 0;
        this._numBytesFree = 0;
    }
}
function $b7620dd3ee4a56cd$var$numBytesForInternalFormat(gl, internalFormat) {
    // tslint:disable-next-line:no-any
    const glany = gl;
    if (internalFormat === glany.R32F) return 4;
    else if (internalFormat === glany.R16F) return 2;
    else if (internalFormat === glany.RGBA32F) return 16;
    else if (internalFormat === gl.RGBA) return 16;
    else if (internalFormat === glany.RGBA16F) return 8;
    else if (internalFormat === glany.RGBA8) return 4;
    throw new Error(`Unknown internal format ${internalFormat}`);
}
function $b7620dd3ee4a56cd$export$66c19e55ce03e099(shape, physicalTexType, gl, textureConfig, isPacked) {
    // It is not possible to infer packed status from the texture type because
    // depending on the textureConfig, different  texture types may resolve to the
    // same internal format (e.g. in WebGL1, the internal format for
    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`
    // explicitly.
    const internalFormat = $b7620dd3ee4a56cd$var$internalFormatForPhysicalTexType(physicalTexType, textureConfig);
    let numElements;
    if (isPacked) {
        const [packedWidth, packedHeight] = $7ea242d526563f56$export$2754e02fa98f5582(shape[0], shape[1]);
        numElements = packedWidth * packedHeight;
    } else {
        const [width, height] = $7ea242d526563f56$export$95fb8493b25f77a4(shape[0], shape[1]);
        numElements = width * height;
    }
    const bytesPerElement = $b7620dd3ee4a56cd$var$numBytesForInternalFormat(gl, internalFormat);
    return numElements * bytesPerElement;
}
function $b7620dd3ee4a56cd$var$internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
    switch(physicalTexType){
        case $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT32:
            return $e764bfbdb52c6abd$export$dcae4a9709a9d6(textureConfig);
        case $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT16:
            return $e764bfbdb52c6abd$export$9b8d6c2b6b2037b0(textureConfig);
        case $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT32:
            return $e764bfbdb52c6abd$export$46e83db9ed4a55ec(textureConfig);
        case $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT16:
            return $e764bfbdb52c6abd$export$c3c5df7eccaed480(textureConfig);
        case $7ea242d526563f56$export$bde70ab3692e385c.PACKED_4X1_UNSIGNED_BYTE:
            return $e764bfbdb52c6abd$export$ed62004e3546feef(textureConfig);
        default:
            throw new Error(`Unknown physical texture type ${physicalTexType}`);
    }
}
function $b7620dd3ee4a56cd$var$getPhysicalTextureForRendering(isPacked) {
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {
        if (isPacked) return $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT32;
        return $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT32;
    }
    if (isPacked) return $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT16;
    return $7ea242d526563f56$export$bde70ab3692e385c.UNPACKED_FLOAT16;
}
function $b7620dd3ee4a56cd$var$getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
    if (logicalTexType === $7ea242d526563f56$export$6bf4bd1b6beb0bfd.UPLOAD) return $7ea242d526563f56$export$bde70ab3692e385c.PACKED_2X2_FLOAT32;
    else if (logicalTexType === $7ea242d526563f56$export$6bf4bd1b6beb0bfd.RENDER || logicalTexType == null) return $b7620dd3ee4a56cd$var$getPhysicalTextureForRendering(isPacked);
    else if (logicalTexType === $7ea242d526563f56$export$6bf4bd1b6beb0bfd.DOWNLOAD || logicalTexType === $7ea242d526563f56$export$6bf4bd1b6beb0bfd.PIXELS) return $7ea242d526563f56$export$bde70ab3692e385c.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${logicalTexType}`);
}
function $b7620dd3ee4a56cd$var$getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
}








class $5ea07995c34f25a2$export$c457dd67217cb5eb {
    constructor(outputShape){
        this.variableNames = [
            'A'
        ];
        this.packedInputs = true;
        this.packedOutput = false;
        this.outputShape = outputShape;
        this.enableShapeUniforms = $beca3d55ef0e83d5$export$5acc770fc06a0138(this.outputShape.length);
        const rank = outputShape.length;
        const channels = $941a295bfee22e2b$export$7a4d1d0d17b69972('rc', rank);
        const dtype = $fbbfeeecbf2420a1$export$859efd105c10c755(rank);
        const sourceCoords = $941a295bfee22e2b$export$8f96407d418c6727(rank, channels);
        const innerDims = channels.slice(-2);
        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;
        this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords}));
      }
    `;
    }
}



const $854a222962c89a34$var$whereImpl = $c0ded10581046f08$exports.whereImpl;
const $854a222962c89a34$export$76e53a66c52b6d4d = 1e-7;
const $854a222962c89a34$export$49716d145771e6a2 = 1e-4;
const $854a222962c89a34$var$binaryCaches = {};
function $854a222962c89a34$export$5863a14c5c829662(webGLVersion) {
    if (webGLVersion in $854a222962c89a34$var$binaryCaches) return $854a222962c89a34$var$binaryCaches[webGLVersion];
    $854a222962c89a34$var$binaryCaches[webGLVersion] = {};
    return $854a222962c89a34$var$binaryCaches[webGLVersion];
}
// Empirically determined constant used to determine size threshold for handing
// off execution to the CPU.
const $854a222962c89a34$var$CPU_HANDOFF_SIZE_THRESHOLD = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');
// Empirically determined constant used to decide the number of MB on GPU
// before we warn about high memory use. The MB are this constant * screen area
// * dpi / 1024 / 1024.
const $854a222962c89a34$var$BEFORE_PAGING_CONSTANT = 600;
function $854a222962c89a34$var$numMBBeforeWarning() {
    if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().global.screen == null) return 1024; // 1 GB.
    return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().global.screen.height * $78e7329b437d1e00$export$a7b6bc01c63cdfc3().global.screen.width * window.devicePixelRatio * $854a222962c89a34$var$BEFORE_PAGING_CONSTANT / 1024 / 1024;
}
class $854a222962c89a34$export$33567d88bc7c6249 extends $fc3e518cb31152af$export$543916c62202b50a {
    constructor(gpuResource){
        super();
        // Maps data ids that have a pending read operation, to list of subscribers.
        this.pendingRead = new WeakMap();
        // List of data ids that are scheduled for disposal, but are waiting on a
        // pending read operation.
        this.pendingDisposal = new WeakSet();
        // Used to count the number of 'shallow' sliced tensors that point to the
        // same data id.
        this.dataRefCount = new WeakMap();
        this.numBytesInGPU = 0;
        // Accumulated time spent (including blocking) in uploading data to webgl.
        this.uploadWaitMs = 0;
        // Accumulated time spent (including blocking in downloading data from webgl.
        this.downloadWaitMs = 0;
        // record the last manual GL Flush time.
        this.lastGlFlushTime = 0;
        this.warnedAboutMemory = false;
        this.pendingDeletes = 0;
        this.disposed = false;
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('HAS_WEBGL')) throw new Error('WebGL is not supported on this device');
        let newGPGPU;
        if (gpuResource != null) {
            if (gpuResource instanceof $86249af5c6a57cc9$export$fa7a74a0ce382ac5) newGPGPU = gpuResource;
            else {
                const gl = $9ee1746afacd745d$export$c7a808a518b9a146($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION'), gpuResource);
                newGPGPU = new $86249af5c6a57cc9$export$fa7a74a0ce382ac5(gl);
            }
            this.binaryCache = {};
            this.gpgpuCreatedLocally = false;
        } else {
            const gl = $9ee1746afacd745d$export$c7a808a518b9a146($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION'));
            newGPGPU = new $86249af5c6a57cc9$export$fa7a74a0ce382ac5(gl);
            this.binaryCache = $854a222962c89a34$export$5863a14c5c829662($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION'));
            this.gpgpuCreatedLocally = true;
        }
        this.gpgpu = newGPGPU;
        this.canvas = this.gpgpu.gl.canvas;
        this.textureManager = new $b7620dd3ee4a56cd$export$337f59f8fd79d24f(this.gpgpu);
        this.numMBBeforeWarning = $854a222962c89a34$var$numMBBeforeWarning();
        this.texData = new $fc3e518cb31152af$export$e95767ffe2e60cec(this, $307e90c4876a9d4d$export$d3c662a6136faebb());
    }
    nextDataId() {
        return $854a222962c89a34$export$33567d88bc7c6249.nextDataId++;
    }
    numDataIds() {
        return this.texData.numDataIds() - this.pendingDeletes;
    }
    write(values, shape, dtype) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') || $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) this.checkNumericalProblems(values);
        if (dtype === 'complex64' && values != null) throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
        const dataId = {
            id: this.nextDataId()
        };
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: values,
            usage: $7ea242d526563f56$export$6bf4bd1b6beb0bfd.UPLOAD,
            refCount: 1
        });
        return dataId;
    }
    /** Return refCount of a `TensorData`. */ refCount(dataId) {
        if (this.texData.has(dataId)) {
            const tensorData = this.texData.get(dataId);
            return tensorData.refCount;
        }
        return 0;
    }
    /** Increase refCount of a `TextureData`. */ incRef(dataId) {
        const texData = this.texData.get(dataId);
        texData.refCount++;
    }
    /** Decrease refCount of a `TextureData`. */ decRef(dataId) {
        if (this.texData.has(dataId)) {
            const texData = this.texData.get(dataId);
            texData.refCount--;
        }
    }
    move(dataId, values, shape, dtype, refCount) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) this.checkNumericalProblems(values);
        if (dtype === 'complex64') throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: values,
            usage: $7ea242d526563f56$export$6bf4bd1b6beb0bfd.UPLOAD,
            refCount: refCount
        });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
        this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
        const texData = this.texData.get(dataId);
        const { values: values , dtype: dtype , complexTensorInfos: complexTensorInfos , slice: slice , shape: shape , isPacked: isPacked  } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            const res = this.runWebGLProgram(program, [
                {
                    dataId: dataId,
                    shape: shape,
                    dtype: dtype
                }
            ], dtype);
            const data = this.readSync(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) return this.convertAndCacheOnCPU(dataId);
        if (dtype === 'string') return values;
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) start = $f6b55a2021b78f0d$exports.now();
        let result;
        if (dtype === 'complex64') {
            const realValues = this.readSync(complexTensorInfos.real.dataId);
            const imagValues = this.readSync(complexTensorInfos.imag.dataId);
            result = $510a55f99d61727a$exports.mergeRealAndImagArrays(realValues, imagValues);
        } else result = this.getValuesFromTexture(dataId);
        if (shouldTimeProgram) this.downloadWaitMs += $f6b55a2021b78f0d$exports.now() - start;
        return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
        if (this.pendingRead.has(dataId)) {
            const subscribers = this.pendingRead.get(dataId);
            return new Promise((resolve)=>subscribers.push(resolve)
            );
        }
        const texData = this.texData.get(dataId);
        const { values: values , shape: shape , slice: slice , dtype: dtype , complexTensorInfos: complexTensorInfos , isPacked: isPacked  } = texData;
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            const res = this.runWebGLProgram(program, [
                {
                    dataId: dataId,
                    shape: shape,
                    dtype: dtype
                }
            ], dtype);
            const data = this.read(res.dataId);
            this.disposeIntermediateTensorInfo(res);
            return data;
        }
        if (values != null) return this.convertAndCacheOnCPU(dataId);
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG')) {
            // getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') caused a blocking GPU call.
            // For performance reason, only check it for debugging. In production,
            // it doesn't handle this use case anyway, so behavior is not changed.
            if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') && $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_VERSION') === 2) throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` + `WEBGL_VERSION=2 not yet supported.`);
        }
        let buffer = null;
        let tmpDownloadTarget;
        if (dtype !== 'complex64' && $78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_BUFFER_SUPPORTED')) {
            // Possibly copy the texture into a buffer before inserting a fence.
            tmpDownloadTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpDownloadTarget.dataId);
            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture.texture, ...$7ea242d526563f56$export$2cc7cc972aa2533d(shape));
        }
        this.pendingRead.set(dataId, []);
        if (dtype !== 'complex64') // Create a fence and wait for it to resolve.
        await this.gpgpu.createAndWaitForFence();
        // Download the values from the GPU.
        let vals;
        if (dtype === 'complex64') {
            const ps = await Promise.all([
                this.read(complexTensorInfos.real.dataId),
                this.read(complexTensorInfos.imag.dataId)
            ]);
            const realValues = ps[0];
            const imagValues = ps[1];
            vals = $510a55f99d61727a$exports.mergeRealAndImagArrays(realValues, imagValues);
        } else if (buffer == null) vals = this.getValuesFromTexture(dataId);
        else {
            const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);
        }
        if (tmpDownloadTarget != null) this.disposeIntermediateTensorInfo(tmpDownloadTarget);
        if (buffer != null) {
            const gl = this.gpgpu.gl;
            $7428f53c4d4be222$export$7642ac97981532b8(gl, ()=>gl.deleteBuffer(buffer)
            );
        }
        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
        const subscribers = this.pendingRead.get(dataId);
        this.pendingRead.delete(dataId);
        // Notify all pending reads.
        subscribers.forEach((resolve)=>resolve(dTypeVals)
        );
        if (this.pendingDisposal.has(dataId)) {
            this.pendingDisposal.delete(dataId);
            if (this.disposeData(dataId)) $307e90c4876a9d4d$export$d3c662a6136faebb().removeDataId(dataId, this);
            this.pendingDeletes--;
        }
        return dTypeVals;
    }
    /**
     * Read tensor to a new texture that is densely packed for ease of use.
     * @param dataId The source tensor.
     * @param options
     *     customTexShape: Optional. If set, will use the user defined texture
     *     shape to create the texture.
     */ readToGPU(dataId, options = {}) {
        const texData = this.texData.get(dataId);
        const { values: values , shape: shape , slice: slice , dtype: dtype , isPacked: isPacked , texture: texture  } = texData;
        if (dtype === 'complex64') throw new Error('Does not support reading texture for complex64 dtype.');
        // The presence of `slice` indicates this tensor is a shallow slice of a
        // different tensor, and is using that original tensor's texture. Run
        // `clone` in order to copy that texture and read from it.
        if (slice != null) {
            let program;
            if (isPacked) program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            else program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(shape, $52fabdba6f2b73bf$export$c07b68c109124fe2);
            const res = this.runWebGLProgram(program, [
                {
                    dataId: dataId,
                    shape: shape,
                    dtype: dtype
                }
            ], dtype);
            const gpuResouorce = this.readToGPU(res, options);
            this.disposeIntermediateTensorInfo(res);
            return gpuResouorce;
        }
        if (texture == null) {
            if (values != null) throw new Error('Data is not on GPU but on CPU.');
            else throw new Error('There is no data on GPU or CPU.');
        }
        // Decode the texture so that it is stored densely (using four channels).
        const tmpTarget = this.decode(dataId, options.customTexShape);
        // Make engine track this tensor, so that we can dispose it later.
        const tensorRef = $307e90c4876a9d4d$export$d3c662a6136faebb().makeTensorFromDataId(tmpTarget.dataId, tmpTarget.shape, tmpTarget.dtype);
        const tmpData = this.texData.get(tmpTarget.dataId);
        return Object.assign({
            tensorRef: tensorRef
        }, tmpData.texture);
    }
    bufferSync(t) {
        const data = this.readSync(t.dataId);
        let decodedData = data;
        if (t.dtype === 'string') try {
            // Decode the bytes into string.
            decodedData = data.map((d)=>$f6b55a2021b78f0d$exports.decodeString(d)
            );
        } catch (_a) {
            throw new Error('Failed to decode encoded string bytes into utf-8');
        }
        return $034bc04874ecb003$export$ab1029bcae9ddb4a(t.shape, t.dtype, decodedData);
    }
    checkNumericalProblems(values) {
        if (values == null) return;
        for(let i = 0; i < values.length; i++){
            const num = values[i];
            if (!$7428f53c4d4be222$export$829768a5b7625879(num)) {
                if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) throw Error(`The value ${num} cannot be represented with your ` + `current settings. Consider enabling float32 rendering: ` + `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
                throw Error(`The value ${num} cannot be represented on this device.`);
            }
        }
    }
    getValuesFromTexture(dataId) {
        const { shape: shape , dtype: dtype , isPacked: isPacked  } = this.texData.get(dataId);
        const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {
            const tmpTarget = this.decode(dataId);
            const tmpData = this.texData.get(tmpTarget.dataId);
            const vals = this.gpgpu.downloadMatrixFromPackedTexture(tmpData.texture.texture, ...$7ea242d526563f56$export$2cc7cc972aa2533d(shape)).subarray(0, size);
            this.disposeIntermediateTensorInfo(tmpTarget);
            return vals;
        }
        const shouldUsePackedProgram = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK') && isPacked === true;
        const outputShape = shouldUsePackedProgram ? $7428f53c4d4be222$export$f944c0101b593a79(shape) : shape;
        const program = shouldUsePackedProgram ? new $92788da84234e5c7$export$97e262e8a4818e2e(outputShape) : new $cb915a894a6d67d1$export$dae4f112167b5aac(outputShape);
        const output = this.runWebGLProgram(program, [
            {
                shape: outputShape,
                dtype: dtype,
                dataId: dataId
            }
        ], 'float32');
        const tmpData = this.texData.get(output.dataId);
        const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
        this.disposeIntermediateTensorInfo(output);
        return vals;
    }
    timerAvailable() {
        return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;
    }
    time(f) {
        const oldActiveTimers = this.activeTimers;
        const newActiveTimers = [];
        let outerMostTime = false;
        if (this.programTimersStack == null) {
            this.programTimersStack = newActiveTimers;
            outerMostTime = true;
        } else this.activeTimers.push(newActiveTimers);
        this.activeTimers = newActiveTimers;
        f();
        // needing to split these up because util.flatten only accepts certain types
        const flattenedActiveTimerQueries = $f6b55a2021b78f0d$exports.flatten(this.activeTimers.map((d)=>d.query
        )).filter((d)=>d != null
        );
        const flattenedActiveTimerNames = $f6b55a2021b78f0d$exports.flatten(this.activeTimers.map((d)=>d.name
        )).filter((d)=>d != null
        );
        this.activeTimers = oldActiveTimers;
        if (outerMostTime) this.programTimersStack = null;
        const res = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null // will be filled by the engine
        };
        return (async ()=>{
            if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
                const kernelMs = await Promise.all(flattenedActiveTimerQueries);
                res['kernelMs'] = $f6b55a2021b78f0d$exports.sum(kernelMs);
                res['getExtraProfileInfo'] = ()=>kernelMs.map((d, i)=>({
                            name: flattenedActiveTimerNames[i],
                            ms: d
                        })
                    ).map((d)=>`${d.name}: ${d.ms}`
                    ).join(', ')
                ;
            } else res['kernelMs'] = {
                error: 'WebGL query timers are not supported in this environment.'
            };
            this.uploadWaitMs = 0;
            this.downloadWaitMs = 0;
            return res;
        })();
    }
    memory() {
        return {
            unreliable: false,
            numBytesInGPU: this.numBytesInGPU,
            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
            numBytesInGPUFree: this.textureManager.numBytesFree
        };
    }
    startTimer() {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) return this.gpgpu.beginQuery();
        return {
            startMs: $f6b55a2021b78f0d$exports.now(),
            endMs: null
        };
    }
    endTimer(query) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = $f6b55a2021b78f0d$exports.now();
        return query;
    }
    async getQueryTime(query) {
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) return this.gpgpu.waitForQueryAndGetTime(query);
        const timerQuery = query;
        return timerQuery.endMs - timerQuery.startMs;
    }
    /**
     * Decrease the RefCount on the dataId and dispose the memory if the dataId
     * has 0 refCount. If there are pending read on the data, the disposal would
     * added to the pending delete queue. Return true if the dataId is removed
     * from backend or the backend does not contain the dataId, false if the
     * dataId is not removed. Memory may or may not be released even when dataId
     * is removed, which also depends on dataRefCount, see `releaseGPU`.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */ disposeData(dataId, force = false) {
        if (this.pendingDisposal.has(dataId)) return false;
        // No-op if already disposed.
        if (!this.texData.has(dataId)) return true;
        // if force flag is set, change refCount to 0, this would ensure disposal
        // when added to the pendingDisposal queue. Memory may or may not be
        // released, which also depends on dataRefCount, see `releaseGPU`.
        if (force) this.texData.get(dataId).refCount = 0;
        else this.texData.get(dataId).refCount--;
        if (!force && this.texData.get(dataId).refCount > 0) return false;
        if (this.pendingRead.has(dataId)) {
            this.pendingDisposal.add(dataId);
            this.pendingDeletes++;
            return false;
        }
        this.releaseGPUData(dataId);
        const { complexTensorInfos: complexTensorInfos  } = this.texData.get(dataId);
        if (complexTensorInfos != null) {
            this.disposeData(complexTensorInfos.real.dataId, force);
            this.disposeData(complexTensorInfos.imag.dataId, force);
        }
        this.texData.delete(dataId);
        return true;
    }
    releaseGPUData(dataId) {
        const { texture: texture , dtype: dtype , texShape: texShape , usage: usage , isPacked: isPacked , slice: slice  } = this.texData.get(dataId);
        const key = slice && slice.origDataId || dataId;
        const refCount = this.dataRefCount.get(key);
        if (refCount > 1) this.dataRefCount.set(key, refCount - 1);
        else {
            this.dataRefCount.delete(key);
            if (texture != null) {
                this.numBytesInGPU -= this.computeBytes(texShape, dtype);
                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
            }
        }
        const texData = this.texData.get(dataId);
        texData.texture = null;
        texData.texShape = null;
        texData.isPacked = false;
        texData.slice = null;
    }
    getTexture(dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture.texture;
    }
    /**
     * Returns internal information for the specific data bucket. Used in unit
     * tests.
     */ getDataInfo(dataId) {
        return this.texData.get(dataId);
    }
    /*
    Tests whether all the inputs to an op are small and on the CPU. This heuristic
    determines when it would be faster to execute a kernel on the CPU. WebGL
    kernels opt into running this check and forwarding when appropriate.
    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more
    sustainable strategy for optimizing backend execution of ops.
     */ shouldExecuteOnCPU(inputs, sizeThreshold = $854a222962c89a34$var$CPU_HANDOFF_SIZE_THRESHOLD) {
        return $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_CPU_FORWARD') && inputs.every((input)=>this.texData.get(input.dataId).texture == null && $f6b55a2021b78f0d$exports.sizeFromShape(input.shape) < sizeThreshold
        );
    }
    getGPGPUContext() {
        return this.gpgpu;
    }
    where(condition) {
        $510a55f99d61727a$exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        const condVals = condition.dataSync();
        return $854a222962c89a34$var$whereImpl(condition.shape, condVals);
    }
    packedUnaryOp(x, op, dtype) {
        const program = new $c5703c4a891fff88$export$4d8daca4f85ed73d(x.shape, op);
        const outInfo = this.compileAndRun(program, [
            x
        ], dtype);
        return $307e90c4876a9d4d$export$d3c662a6136faebb().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
    }
    // TODO(msoulanille) remove this once the backend has been modularized
    // a copy is needed here to break a circular dependency.
    // Also remove the op from unary_op.
    abs(x) {
        // TODO: handle cases when x is complex.
        if (this.shouldExecuteOnCPU([
            x
        ]) && x.dtype !== 'complex64') {
            const outValues = $31b15458ffa33a6b$export$d7efa3585619eabe(this.texData.get(x.dataId).values);
            return this.makeOutput(x.shape, x.dtype, outValues);
        }
        if ($78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_PACK_UNARY_OPERATIONS')) return this.packedUnaryOp(x, $52fabdba6f2b73bf$export$3f020f6dcff67a1b, x.dtype);
        const program = new $52fabdba6f2b73bf$export$f93811a5a466fd42(x.shape, $52fabdba6f2b73bf$export$3f020f6dcff67a1b);
        const outInfo = this.compileAndRun(program, [
            x
        ]);
        return $307e90c4876a9d4d$export$d3c662a6136faebb().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
    }
    makeTensorInfo(shape, dtype, values) {
        let dataId;
        if (dtype === 'string' && values != null && values.length > 0 && $f6b55a2021b78f0d$exports.isString(values[0])) {
            const encodedValues = values.map((d)=>$f6b55a2021b78f0d$exports.encodeString(d)
            );
            dataId = this.write(encodedValues, shape, dtype);
        } else dataId = this.write(values, shape, dtype);
        this.texData.get(dataId).usage = null;
        return {
            dataId: dataId,
            shape: shape,
            dtype: dtype
        };
    }
    makeOutput(shape, dtype, values) {
        const { dataId: dataId  } = this.makeTensorInfo(shape, dtype, values);
        return $307e90c4876a9d4d$export$d3c662a6136faebb().makeTensorFromDataId(dataId, shape, dtype, this);
    }
    unpackTensor(input) {
        const program = new $5ea07995c34f25a2$export$c457dd67217cb5eb(input.shape);
        return this.runWebGLProgram(program, [
            input
        ], input.dtype);
    }
    packTensor(input) {
        const program = new $5004c86a694ef749$export$5ebf74a9a135ce1d(input.shape);
        const preventEagerUnpackingOutput = true;
        return this.runWebGLProgram(program, [
            input
        ], input.dtype, null, preventEagerUnpackingOutput);
    }
    packedReshape(input, afterShape) {
        const input3DShape = [
            $7428f53c4d4be222$export$4dfd7bc0667970e0(input.shape),
            ...$7428f53c4d4be222$export$e8f6c350b57b8270(input.shape)
        ];
        const input3D = {
            dtype: input.dtype,
            shape: input3DShape,
            dataId: input.dataId
        };
        const afterShapeAs3D = [
            $7428f53c4d4be222$export$4dfd7bc0667970e0(afterShape),
            ...$7428f53c4d4be222$export$e8f6c350b57b8270(afterShape)
        ];
        const program = new $672fdb17e5392b3b$export$ce249f6fedcc44de(afterShapeAs3D, input3DShape);
        const preventEagerUnpackingOfOutput = true;
        const customValues = [
            input3DShape
        ];
        const output = this.runWebGLProgram(program, [
            input3D
        ], input.dtype, customValues, preventEagerUnpackingOfOutput);
        return {
            dataId: output.dataId,
            shape: afterShape,
            dtype: output.dtype
        };
    }
    decode(dataId, customTexShape) {
        const texData = this.texData.get(dataId);
        const { isPacked: isPacked , shape: shape , dtype: dtype  } = texData;
        if (customTexShape != null) {
            const size = $f6b55a2021b78f0d$exports.sizeFromShape(shape);
            const texSize = customTexShape[0] * customTexShape[1] * 4;
            $f6b55a2021b78f0d$exports.assert(size <= texSize, ()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."
            );
        }
        const shapeAs3D = $7428f53c4d4be222$export$f944c0101b593a79(shape);
        let program;
        if (isPacked) program = new $f9bb4b31b50bb598$export$4434db41c70879cb(shapeAs3D);
        else program = new $2f735e5046cb23b0$export$f6ee51c6efbee026(shapeAs3D);
        const preventEagerUnpackingOfOutput = true;
        const customValues = [
            customTexShape != null ? customTexShape : $7ea242d526563f56$export$2cc7cc972aa2533d(shapeAs3D)
        ];
        const out = this.runWebGLProgram(program, [
            {
                shape: shapeAs3D,
                dtype: dtype,
                dataId: dataId
            }
        ], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);
        return {
            dtype: dtype,
            shape: shape,
            dataId: out.dataId
        };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false, customTexShape) {
        const output = this.makeTensorInfo(program.outputShape, outputDtype);
        const outData = this.texData.get(output.dataId);
        if (program.packedOutput) outData.isPacked = true;
        if (program.outPackingScheme === $7ea242d526563f56$export$81d5c79efa1086f2.DENSE) {
            const texelShape = customTexShape != null ? customTexShape : $7ea242d526563f56$export$2cc7cc972aa2533d(program.outputShape);
            // For a densely packed output, we explicitly set texShape
            // so it doesn't get assigned later according to our typical packing
            // scheme wherein a single texel can only contain values from adjacent
            // rows/cols.
            outData.texShape = texelShape.map((d)=>d * 2
            );
        }
        if (program.outTexUsage != null) outData.usage = program.outTexUsage;
        if ($f6b55a2021b78f0d$exports.sizeFromShape(output.shape) === 0) {
            // Short-circuit the computation since the result is empty (has 0 in its
            // shape).
            outData.values = $f6b55a2021b78f0d$exports.getTypedArrayFromDType(output.dtype, 0);
            return output;
        }
        const dataToDispose = [];
        const inputsData = inputs.map((input)=>{
            if (input.dtype === 'complex64') throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` + `dtypes, please separate the program into real and imaginary ` + `parts.`);
            let texData = this.texData.get(input.dataId);
            if (texData.texture == null) {
                if (!program.packedInputs && $f6b55a2021b78f0d$exports.sizeFromShape(input.shape) <= $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) // Upload small tensors that live on the CPU as uniforms, not as
                // textures. Do this only when the environment supports 32bit floats
                // due to problems when comparing 16bit floats with 32bit floats.
                // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it
                // possible for packed shaders to sample from uniforms.
                return {
                    shape: input.shape,
                    texData: null,
                    isUniform: true,
                    uniformValues: texData.values
                };
                // This ensures that if a packed program's inputs have not yet been
                // uploaded to the GPU, they get uploaded as packed right off the bat.
                if (program.packedInputs) {
                    texData.isPacked = true;
                    texData.shape = input.shape;
                }
            }
            this.uploadToGPU(input.dataId);
            if (!!texData.isPacked !== !!program.packedInputs) {
                input = texData.isPacked ? this.unpackTensor(input) : this.packTensor(input);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
            } else if (texData.isPacked && !$7428f53c4d4be222$export$951b388203a0422d(texData.shape, input.shape)) {
                // This is a special case where a texture exists for a tensor
                // but the shapes are incompatible (due to packing constraints) because
                // the tensor did not have a chance to go through the packed reshape
                // shader. This only happens when we reshape the *same* tensor to form
                // *distinct* inputs to an op, e.g. dotting a vector with itself. This
                // case will disappear once packed uploading is the default.
                const savedInput = input;
                const targetShape = input.shape;
                input.shape = texData.shape;
                input = this.packedReshape(input, targetShape);
                dataToDispose.push(input);
                texData = this.texData.get(input.dataId);
                savedInput.shape = targetShape;
            }
            return {
                shape: input.shape,
                texData: texData,
                isUniform: false
            };
        });
        this.uploadToGPU(output.dataId);
        const outputData = {
            shape: output.shape,
            texData: outData,
            isUniform: false
        };
        const key = $beca3d55ef0e83d5$export$2a17a6d53fe6f5d9(program, inputsData, outputData);
        const binary = this.getAndSaveBinary(key, ()=>{
            return $beca3d55ef0e83d5$export$5ca2cb6073dd12df(this.gpgpu, program, inputsData, outputData);
        });
        const shouldTimeProgram = this.activeTimers != null;
        let query;
        if (shouldTimeProgram) query = this.startTimer();
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('ENGINE_COMPILE_ONLY')) $beca3d55ef0e83d5$export$4e01d2c5eea12ae3(this.gpgpu, binary, inputsData, outputData, customUniformValues);
        dataToDispose.forEach((info)=>this.disposeIntermediateTensorInfo(info)
        );
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push({
                name: program.constructor.name,
                query: this.getQueryTime(query)
            });
        }
        const glFlushThreshold = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_FLUSH_THRESHOLD');
        // Manually GL flush requested
        if (glFlushThreshold > 0) {
            const time = $f6b55a2021b78f0d$exports.now();
            if (time - this.lastGlFlushTime > glFlushThreshold) {
                this.gpgpu.gl.flush();
                this.lastGlFlushTime = time;
            }
        }
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked && preventEagerUnpackingOfOutput === false) {
            const unpacked = this.unpackTensor(output);
            this.disposeIntermediateTensorInfo(output);
            return unpacked;
        }
        return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
        outputDtype = outputDtype || inputs[0].dtype;
        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
        return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
        if (!(key in this.binaryCache)) this.binaryCache[key] = getBinary();
        return this.binaryCache[key];
    }
    getTextureManager() {
        return this.textureManager;
    }
    dispose() {
        if (this.disposed) return;
        // Avoid disposing the compiled webgl programs during unit testing because
        // it slows down test execution.
        if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('IS_TEST')) {
            const allKeys = Object.keys(this.binaryCache);
            allKeys.forEach((key)=>{
                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
                delete this.binaryCache[key];
            });
        }
        this.textureManager.dispose();
        if (this.canvas != null && typeof HTMLCanvasElement !== 'undefined' && this.canvas instanceof HTMLCanvasElement) this.canvas.remove();
        else this.canvas = null;
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.program = null;
            this.gpgpu.dispose();
        }
        this.disposed = true;
    }
    floatPrecision() {
        if (this.floatPrecisionValue == null) this.floatPrecisionValue = $307e90c4876a9d4d$export$b841c6a213a653eb(()=>{
            if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('WEBGL_RENDER_FLOAT32_ENABLED')) {
                // Momentarily switching DEBUG flag to false so we don't throw an
                // error trying to upload a small value.
                const debugFlag = $78e7329b437d1e00$export$a7b6bc01c63cdfc3().getBool('DEBUG');
                $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('DEBUG', false);
                const underflowCheckValue = this.abs($3d4d3db2721d0fe6$export$7de3fcd3cdba2a46(1e-8)).dataSync()[0];
                $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('DEBUG', debugFlag);
                if (underflowCheckValue > 0) return 32;
            }
            return 16;
        });
        return this.floatPrecisionValue;
    }
    /** Returns the smallest representable number.  */ epsilon() {
        return this.floatPrecision() === 32 ? $854a222962c89a34$export$76e53a66c52b6d4d : $854a222962c89a34$export$49716d145771e6a2;
    }
    uploadToGPU(dataId) {
        const texData = this.texData.get(dataId);
        const { shape: shape , dtype: dtype , values: values , texture: texture , usage: usage , isPacked: isPacked  } = texData;
        if (texture != null) // Array is already on GPU. No-op.
        return;
        const shouldTimeProgram = this.activeTimers != null;
        let start;
        if (shouldTimeProgram) start = $f6b55a2021b78f0d$exports.now();
        let texShape = texData.texShape;
        if (texShape == null) {
            // This texShape may not be the final texture shape. For packed or dense
            // textures, the texShape will be changed when textures are created.
            texShape = $7428f53c4d4be222$export$80bf57c6927be1d9(shape, isPacked);
            texData.texShape = texShape;
        }
        if (values != null) {
            const shapeAs3D = $7428f53c4d4be222$export$f944c0101b593a79(shape);
            let program;
            let width = texShape[1], height = texShape[0];
            const isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;
            // texture for float array is PhysicalTextureType.PACKED_2X2_FLOAT32, we
            // need to make sure the upload uses the same packed size
            if (isPacked || !isByteArray) [width, height] = $7ea242d526563f56$export$2754e02fa98f5582(texShape[0], texShape[1]);
            if (isPacked) program = new $b6fd1c9c8aea7f9a$export$3b3e6b1f67c8c4d5(shapeAs3D, isByteArray);
            else program = new $61a84908d4955ec2$export$b2e063313033aeab(shapeAs3D, isByteArray);
            // TexShape for float array needs to be the original shape, which byte
            // array needs to be packed size. This allow the data upload shape to be
            // matched with texture creation logic.
            const tempDenseInputTexShape = isByteArray ? [
                height,
                width
            ] : texShape;
            const tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);
            const tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);
            if (isByteArray) tempDenseInputTexData.usage = $7ea242d526563f56$export$6bf4bd1b6beb0bfd.PIXELS;
            else tempDenseInputTexData.usage = $7ea242d526563f56$export$6bf4bd1b6beb0bfd.UPLOAD;
            tempDenseInputTexData.texShape = tempDenseInputTexShape;
            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
            const customValues = [
                [
                    height,
                    width
                ]
            ];
            // We want the output to remain packed regardless of the value of
            // WEBGL_PACK.
            const preventEagerUnpacking = true;
            const encodedOutputTarget = this.runWebGLProgram(program, [
                tempDenseInputHandle
            ], dtype, customValues, preventEagerUnpacking);
            // Have the original texture assume the identity of the encoded output.
            const outputTexData = this.texData.get(encodedOutputTarget.dataId);
            texData.texShape = outputTexData.texShape;
            texData.isPacked = outputTexData.isPacked;
            texData.usage = outputTexData.usage;
            if (!$78e7329b437d1e00$export$a7b6bc01c63cdfc3().get('ENGINE_COMPILE_ONLY')) {
                texData.texture = outputTexData.texture;
                // Once uploaded, don't store the values on cpu.
                texData.values = null;
                this.texData.delete(encodedOutputTarget.dataId);
            } else this.disposeData(encodedOutputTarget.dataId);
            this.disposeIntermediateTensorInfo(tempDenseInputHandle);
            if (shouldTimeProgram) this.uploadWaitMs += $f6b55a2021b78f0d$exports.now() - start;
        } else {
            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
            texData.texture = newTexture;
        }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
        const texData = this.texData.get(dataId);
        const { dtype: dtype  } = texData;
        this.releaseGPUData(dataId);
        if (float32Values != null) texData.values = $854a222962c89a34$var$float32ToTypedArray(float32Values, dtype);
        return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
        this.numBytesInGPU += this.computeBytes(texShape, dtype);
        if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1048576) {
            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
            this.warnedAboutMemory = true;
            console.warn(`High memory usage in GPU: ${mb} MB, ` + `most likely due to a memory leak`);
        }
        return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
        return shape[0] * shape[1] * $f6b55a2021b78f0d$exports.bytesPerElement(dtype);
    }
    checkCompileCompletion() {
        for (const [, binary] of Object.entries(this.binaryCache))this.checkCompletion_(binary);
    }
    async checkCompileCompletionAsync() {
        const ps = [];
        if (this.gpgpu.parallelCompilationExtension) {
            for (const [, binary] of Object.entries(this.binaryCache))ps.push(this.checkCompletionAsync_(binary));
            return Promise.all(ps);
        } else {
            for (const [, binary] of Object.entries(this.binaryCache)){
                const p = new Promise((resolve)=>{
                    try {
                        this.checkCompletion_(binary);
                        resolve(true);
                    } catch (error) {
                        throw error;
                    }
                });
                ps.push(p);
            }
            return Promise.all(ps);
        }
    }
    async checkCompletionAsync_(binary) {
        if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) return this.checkCompletion_(binary);
        else {
            await $6543175c07504abe$export$68d2d147c928d1dd();
            return this.checkCompletionAsync_(binary);
        }
    }
    checkCompletion_(binary) {
        if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
            console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));
            if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
                $7428f53c4d4be222$export$f7b23987b58d218(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));
                throw new Error('Failed to compile fragment shader.');
            }
            throw new Error('Failed to link vertex and fragment shaders.');
        }
        return true;
    }
    getUniformLocations() {
        for (const [, binary] of Object.entries(this.binaryCache)){
            const { uniformLocations: uniformLocations , customUniformLocations: customUniformLocations , infLoc: infLoc , nanLoc: nanLoc , inShapesLocations: inShapesLocations , inTexShapesLocations: inTexShapesLocations , outShapeLocation: outShapeLocation , outShapeStridesLocation: outShapeStridesLocation , outTexShapeLocation: outTexShapeLocation  } = $beca3d55ef0e83d5$export$d421ceceafba9cc0(this.gpgpu, binary.program, binary.webGLProgram);
            binary.uniformLocations = uniformLocations;
            binary.customUniformLocations = customUniformLocations;
            binary.infLoc = infLoc;
            binary.nanLoc = nanLoc;
            binary.inShapesLocations = inShapesLocations;
            binary.inTexShapesLocations = inTexShapesLocations;
            binary.outShapeLocation = outShapeLocation;
            binary.outShapeStridesLocation = outShapeStridesLocation;
            binary.outTexShapeLocation = outTexShapeLocation;
        }
    }
}
$854a222962c89a34$export$33567d88bc7c6249.nextDataId = 0;
function $854a222962c89a34$var$float32ToTypedArray(a, dtype) {
    if (dtype === 'float32' || dtype === 'complex64') return a;
    else if (dtype === 'int32' || dtype === 'bool') {
        const result = dtype === 'int32' ? new Int32Array(a.length) : new Uint8Array(a.length);
        for(let i = 0; i < result.length; ++i)result[i] = Math.round(a[i]);
        return result;
    } else throw new Error(`Unknown dtype ${dtype}`);
}








function $d403861a41d9f07d$export$3f638ed94e6c5baa() {
    $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WEBGL_FORCE_F16_TEXTURES', true);
}




if ($20e2f2a589b22510$exports.isBrowser()) $307e90c4876a9d4d$export$1ac8c3a90eff05d('webgl', ()=>new $854a222962c89a34$export$33567d88bc7c6249()
, 2 /* priority */ );
const $b199afe068b432cf$export$d55298c9efc5ed14 = {
    forceHalfFloat: $d403861a41d9f07d$export$3f638ed94e6c5baa
};




const $0f630917ee0a4348$var$wasm_factory = $307e90c4876a9d4d$export$e4a6d214466a2c7b('wasm');
var $9bd4ee2724450428$exports = {};

$9bd4ee2724450428$exports = new URL((parcelRequire("82BEU")).resolve("cG2dQ"), import.meta.url).toString();


var $ba0daa793586a00e$exports = {};

$ba0daa793586a00e$exports = new URL((parcelRequire("82BEU")).resolve("8uft9"), import.meta.url).toString();


var $e93b49bfac94d5af$exports = {};

$e93b49bfac94d5af$exports = new URL((parcelRequire("82BEU")).resolve("knRc6"), import.meta.url).toString();


$3f9aee83a734b7cf$export$96f76c6576699053({
    // @ts-ignore
    'tfjs-backend-wasm.wasm': new URL($9bd4ee2724450428$exports).toString(),
    // @ts-ignore
    'tfjs-backend-wasm-simd.wasm': new URL($ba0daa793586a00e$exports).toString(),
    // @ts-ignore
    'tfjs-backend-wasm-threaded-simd.wasm': new URL($e93b49bfac94d5af$exports).toString()
});
async function $0f630917ee0a4348$export$111ebbd6ec0d37d6(n, k, m, count, warmup, threads, simd) {
    if (simd && threads > 1) {
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_SIMD_SUPPORT', true);
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_MULTITHREAD_SUPPORT', true);
    } else if (simd) {
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_SIMD_SUPPORT', true);
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_MULTITHREAD_SUPPORT', false);
    } else if (threads > 1) {
        console.log('In TJFS multithreading works only with SIMD.\nEnable SIMD please!');
        return {
            mean: -1,
            confidence_interval: -1
        };
    } else {
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_SIMD_SUPPORT', false);
        $78e7329b437d1e00$export$a7b6bc01c63cdfc3().set('WASM_HAS_MULTITHREAD_SUPPORT', false);
    }
    $307e90c4876a9d4d$export$c299110fbe92c80c('wasm');
    $307e90c4876a9d4d$export$1ac8c3a90eff05d('wasm', $0f630917ee0a4348$var$wasm_factory);
    $3f9aee83a734b7cf$export$b13f278778f0c389(threads);
    await $307e90c4876a9d4d$export$7953970fabc9c2('wasm');
    console.log('TFJS WASM');
    if (threads > $3f9aee83a734b7cf$export$2878a7293fa21941()) console.log(`Max num of threads for TFJS = ${$3f9aee83a734b7cf$export$2878a7293fa21941()}`);
    console.log(`threads = ${$3f9aee83a734b7cf$export$2878a7293fa21941()}`);
    console.log(`simd = ${simd}`);
    console.log(`count = ${count}`);
    console.log(`warmup = ${warmup}`);
    console.log(`N = ${n}`);
    console.log(`K = ${k}`);
    console.log(`M = ${m}`);
    for(let i = 0; i < warmup; i++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    const times = new Array(count);
    for(let i1 = 0; i1 < count; i1++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const start = performance.now();
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        const end = performance.now();
        times[i1] = end - start;
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    return $3021ccad43dbee2d$export$58fde443e4317a86(times);
}
async function $0f630917ee0a4348$export$d70bd4925955bf48(n, k, m, count, warmup) {
    await $307e90c4876a9d4d$export$7953970fabc9c2('webgl');
    console.log('TFJS WEBGL');
    console.log(`count = ${count}`);
    console.log(`warmup = ${warmup}`);
    console.log(`N = ${n}`);
    console.log(`K = ${k}`);
    console.log(`M = ${m}`);
    for(let i = 0; i < warmup; i++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    const times = new Array(count);
    for(let i2 = 0; i2 < count; i2++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const start = performance.now();
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        const end = performance.now();
        times[i2] = end - start;
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    return $3021ccad43dbee2d$export$58fde443e4317a86(times);
}
async function $0f630917ee0a4348$export$44d28064ef62086c(n, k, m, count, warmup) {
    await $307e90c4876a9d4d$export$7953970fabc9c2('cpu');
    console.log('TFJS CPU');
    console.log(`count = ${count}`);
    console.log(`warmup = ${warmup}`);
    console.log(`N = ${n}`);
    console.log(`K = ${k}`);
    console.log(`M = ${m}`);
    for(let i = 0; i < warmup; i++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    const times = new Array(count);
    for(let i3 = 0; i3 < count; i3++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = $b61ddc0946231fbd$export$65df3ad1ad888abb(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = $b61ddc0946231fbd$export$65df3ad1ad888abb(right_array, [
            k,
            m
        ]);
        const start = performance.now();
        const dest = $8e2c3ff1a0ec32ef$export$6706882a873e9a8f(left, right);
        const end = performance.now();
        times[i3] = end - start;
        left.dispose();
        right.dispose();
        dest.dispose();
    }
    return $3021ccad43dbee2d$export$58fde443e4317a86(times);
}
async function $0f630917ee0a4348$export$4c1e078f3ed46cf5() {
    await $307e90c4876a9d4d$export$7953970fabc9c2('wasm');
    return $3f9aee83a734b7cf$export$2878a7293fa21941();
}



var $245vJ = parcelRequire("245vJ");

var $06fe4f517247eec5$exports = {};

$06fe4f517247eec5$exports = new URL((parcelRequire("82BEU")).resolve("8WkUN"), import.meta.url).toString();


var $187447e8bb6c91bf$exports = {};

$187447e8bb6c91bf$exports = new URL((parcelRequire("82BEU")).resolve("7tQQV"), import.meta.url).toString();


var $b023f8ca0fafb37c$exports = {};

$b023f8ca0fafb37c$exports = new URL((parcelRequire("82BEU")).resolve("iFOoy"), import.meta.url).toString();


var $680276cf4be26d13$exports = {};

$680276cf4be26d13$exports = new URL((parcelRequire("82BEU")).resolve("2QKLs"), import.meta.url).toString();


$245vJ.env.wasm.wasmPaths = {
    // @ts-ignore
    'ort-wasm.wasm': new URL($06fe4f517247eec5$exports).toString(),
    // @ts-ignore
    'ort-wasm-simd.wasm': new URL($187447e8bb6c91bf$exports).toString(),
    // @ts-ignore
    'ort-wasm-threaded.wasm': new URL($b023f8ca0fafb37c$exports).toString(),
    // @ts-ignore
    'ort-wasm-simd-threaded.wasm': new URL($680276cf4be26d13$exports).toString()
};
var $6699808a2e729d15$exports = {};

$6699808a2e729d15$exports = new URL((parcelRequire("82BEU")).resolve("jbhSP"), import.meta.url).toString();


// @ts-ignore
const $91a3ddfc118ae180$var$model_path = new URL($6699808a2e729d15$exports).toString();
async function $91a3ddfc118ae180$export$2ced01523e5cbd11(n, k, m, count, warmup) {
    console.log('ORT WEBGL');
    console.log(`count = ${count}`);
    console.log(`warmup = ${warmup}`);
    $245vJ.env.webgl.contextId = 'webgl2';
    $245vJ.env.webgl.pack = true;
    $245vJ.env.webgl.textureCacheMode = 'full';
    console.log(`N = ${n}`);
    console.log(`K = ${k}`);
    console.log(`M = ${m}`);
    const session = await $245vJ.InferenceSession.create($91a3ddfc118ae180$var$model_path, {
        executionProviders: [
            'webgl'
        ]
    });
    for(let i = 0; i < warmup; i++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = new $245vJ.Tensor(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = new $245vJ.Tensor(right_array, [
            k,
            m
        ]);
        const feed = {
            left: left,
            right: right
        };
        // eslint-disable-next-line no-unused-vars
        const output = await session.run(feed);
    }
    const times = new Array(count);
    for(let i1 = 0; i1 < count; i1++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = new $245vJ.Tensor(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = new $245vJ.Tensor(right_array, [
            k,
            m
        ]);
        const feed = {
            left: left,
            right: right
        };
        const start = performance.now();
        // eslint-disable-next-line no-unused-vars
        const output = await session.run(feed);
        const end = performance.now();
        times[i1] = end - start;
    }
    return $3021ccad43dbee2d$export$58fde443e4317a86(times);
}
async function $91a3ddfc118ae180$export$d18f8127d9466c7b(n, k, m, count, warmup, threads, simd) {
    console.log('ORT WASM');
    $245vJ.env.wasm.numThreads = threads;
    $245vJ.env.wasm.simd = simd;
    const session = await $245vJ.InferenceSession.create($91a3ddfc118ae180$var$model_path, {
        executionProviders: [
            'wasm'
        ]
    });
    console.log(`threads = ${$245vJ.env.wasm.numThreads}`);
    console.log(`simd = ${$245vJ.env.wasm.simd}`);
    console.log(`count = ${count}`);
    console.log(`warmup = ${warmup}`);
    console.log(`N = ${n}`);
    console.log(`K = ${k}`);
    console.log(`M = ${m}`);
    for(let i = 0; i < warmup; i++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = new $245vJ.Tensor(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = new $245vJ.Tensor(right_array, [
            k,
            m
        ]);
        const feed = {
            left: left,
            right: right
        };
        // eslint-disable-next-line no-unused-vars
        const output = await session.run(feed);
    }
    const times = new Array(count);
    for(let i2 = 0; i2 < count; i2++){
        const left_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(n * k);
        const left = new $245vJ.Tensor(left_array, [
            n,
            k
        ]);
        const right_array = $3021ccad43dbee2d$export$2a73984e4f41e1c1(k * m);
        const right = new $245vJ.Tensor(right_array, [
            k,
            m
        ]);
        const feed = {
            left: left,
            right: right
        };
        const start = performance.now();
        // eslint-disable-next-line no-unused-vars
        const output = await session.run(feed);
        const end = performance.now();
        times[i2] = end - start;
    }
    return $3021ccad43dbee2d$export$58fde443e4317a86(times);
}


const $0600e615ac71d69e$var$N_field = document.getElementById('N');
const $0600e615ac71d69e$var$K_field = document.getElementById('K');
const $0600e615ac71d69e$var$M_field = document.getElementById('M');
const $0600e615ac71d69e$var$count_field = document.getElementById('count');
const $0600e615ac71d69e$var$warmup_field = document.getElementById('warmup');
const $0600e615ac71d69e$var$tfjs_cpu_count_field = document.getElementById('tfjs-cpu-count');
const $0600e615ac71d69e$var$ort_cpu_count_field = document.getElementById('ort-cpu-count');
const $0600e615ac71d69e$var$benchmark_results = document.getElementById('benchmark-results');
function $0600e615ac71d69e$var$get_parameters() {
    return {
        N: $0600e615ac71d69e$var$N_field.valueAsNumber,
        K: $0600e615ac71d69e$var$K_field.valueAsNumber,
        M: $0600e615ac71d69e$var$M_field.valueAsNumber,
        count: $0600e615ac71d69e$var$count_field.valueAsNumber,
        warmup: $0600e615ac71d69e$var$warmup_field.valueAsNumber
    };
}
function $0600e615ac71d69e$var$block_inputs() {
    const buttons = document.querySelectorAll('button');
    for (const button of buttons)button.disabled = true;
    const inputs = document.querySelectorAll('input');
    for (const input of inputs)input.disabled = true;
}
function $0600e615ac71d69e$var$unblock_inputs() {
    const buttons = document.querySelectorAll('button');
    for (const button of buttons)button.disabled = false;
    const inputs = document.querySelectorAll('input');
    for (const input of inputs)input.disabled = false;
}
function $0600e615ac71d69e$var$main_string_builder(params, mean, interval) {
    return `
  N = ${params.N}<br>
  K = ${params.K}<br>
  M = ${params.M}<br>
  count = ${params.count}<br>
  warmup = ${params.warmup}<br><br>

  Result = ${mean.toFixed(3)}±${interval.toFixed(3)}`;
}
async function $0600e615ac71d69e$var$create_benchmark_paragraph(benchmark_fn, text_builder) {
    $0600e615ac71d69e$var$block_inputs();
    const paragraph = document.createElement('p');
    paragraph.innerHTML = 'Executing benchmark';
    paragraph.setAttribute('style', 'border:1px; border-style:solid; border-color:#FFFFF; padding: 1em; width: fit-content');
    $0600e615ac71d69e$var$benchmark_results.appendChild(paragraph);
    paragraph.scrollIntoView();
    const output = await new Promise((resolve)=>{
        setTimeout(()=>{
            resolve(benchmark_fn());
        }, 0);
    });
    paragraph.innerHTML = text_builder(output.mean, output.confidence_interval);
    paragraph.scrollIntoView();
    $0600e615ac71d69e$var$unblock_inputs();
}
document.getElementById('tfjs-wasm').onclick = async (_)=>{
    const params = $0600e615ac71d69e$var$get_parameters();
    const threads = $0600e615ac71d69e$var$tfjs_cpu_count_field.valueAsNumber;
    const simd_enabled = document.querySelector('input[name="tfjs-simd"]:checked').value === 'yes';
    await $0600e615ac71d69e$var$create_benchmark_paragraph(()=>{
        return $0f630917ee0a4348$export$111ebbd6ec0d37d6(params.N, params.K, params.M, params.count, params.warmup, threads, simd_enabled);
    }, (mean, interval)=>{
        if (mean > 0) return `TFJS WASM<br>threads=${threads}<br>simd=${simd_enabled}<br>` + $0600e615ac71d69e$var$main_string_builder(params, mean, interval);
        else return 'TFJS WASM<br>In TJFS multithreading works only with SIMD.<br>Enable SIMD!';
    });
};
document.getElementById('tfjs-webgl').onclick = async (_)=>{
    const params = $0600e615ac71d69e$var$get_parameters();
    await $0600e615ac71d69e$var$create_benchmark_paragraph(()=>$0f630917ee0a4348$export$d70bd4925955bf48(params.N, params.K, params.M, params.count, params.warmup)
    , (mean, interval)=>'TFJS WEBGL<br>' + $0600e615ac71d69e$var$main_string_builder(params, mean, interval)
    );
};
document.getElementById('tfjs-cpu').onclick = async (_)=>{
    const params = $0600e615ac71d69e$var$get_parameters();
    await $0600e615ac71d69e$var$create_benchmark_paragraph(()=>$0f630917ee0a4348$export$44d28064ef62086c(params.N, params.K, params.M, params.count, params.warmup)
    , (mean, interval)=>'TFJS CPU<br>' + $0600e615ac71d69e$var$main_string_builder(params, mean, interval)
    );
};
document.getElementById('ort-wasm').onclick = async (_)=>{
    const params = $0600e615ac71d69e$var$get_parameters();
    const threads = $0600e615ac71d69e$var$ort_cpu_count_field.valueAsNumber;
    const simd_enabled = document.querySelector('input[name="ort-simd"]:checked').value === 'yes';
    await $0600e615ac71d69e$var$create_benchmark_paragraph(()=>$91a3ddfc118ae180$export$d18f8127d9466c7b(params.N, params.K, params.M, params.count, params.warmup, threads, simd_enabled)
    , (mean, interval)=>`ORT WASM<br>threads=${threads}<br>simd=${simd_enabled}<br>` + $0600e615ac71d69e$var$main_string_builder(params, mean, interval)
    );
};
document.getElementById('ort-webgl').onclick = async (_)=>{
    const params = $0600e615ac71d69e$var$get_parameters();
    await $0600e615ac71d69e$var$create_benchmark_paragraph(()=>$91a3ddfc118ae180$export$2ced01523e5cbd11(params.N, params.K, params.M, params.count, params.warmup)
    , (mean, interval)=>'ORT WEBGL<br>' + $0600e615ac71d69e$var$main_string_builder(params, mean, interval)
    );
};
document.getElementById('clear-benchmarks').onclick = ()=>{
    $0600e615ac71d69e$var$benchmark_results.innerHTML = '';
};
$0f630917ee0a4348$export$4c1e078f3ed46cf5().then((threads)=>{
    $0600e615ac71d69e$var$tfjs_cpu_count_field.valueAsNumber = threads;
    $0600e615ac71d69e$var$ort_cpu_count_field.valueAsNumber = navigator.hardwareConcurrency;
});


//# sourceMappingURL=index.694d99a1.js.map
